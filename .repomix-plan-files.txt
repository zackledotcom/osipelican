This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    vibe-tools.mdc
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  FUNDING.yml
e2e/
  tests/
    e2e.additional.spec.ts
    e2e.chat.spec.ts
    e2e.extended.spec.ts
  e2e.spec.ts
  playwright.config.ts
  tsconfig.json
imports/
packages/
  electron-versions/
    index.js
    package.json
    README.md
  main/
    src/
      index.ts
    package.json
    tsconfig.json
    vite.config.ts
  preload/
    src/
      exposed.ts
    vite.config.ts
  renderer/
    public/
      vite.svg
    src/
      assets/
        react.svg
      components/
        __tests__/
          basic-react.test.tsx
          chat-integration.test.tsx
          Chat.test.tsx
          dom-integration.test.ts
          dom.test.ts
          isolated-chat.test.tsx
          manual-dom.test.ts
          MockChatContainer.tsx
          simple-chat.test.tsx
        AppHeader.tsx
        AppLayout.tsx
        Chat.tsx
        ChatContainer.tsx
        ChatUI.tsx
        ConversationList.tsx
        ErrorBoundary.tsx
        LayoutLeftSidebar.tsx
        MemoryChat.tsx
        MemoryHealthIndicator.tsx
        ModelLoadingOverlay.tsx
        ServiceToggle.tsx
        SettingsPanel.tsx
        ThemeToggle.tsx
      contexts/
        ThemeContext.tsx
      hooks/
        useMemory.ts
        useModelStatus.ts
      App.css
      App.jsx
      electronAPI.d.ts
      index.css
      main.tsx
      setupTests.ts
    .gitignore
    eslint.config.js
    index.html
    package.json
    postcss.config.cjs
    postcss.config.js
    README.md
    tailwind.config.js
    tsconfig.json
    vite.config.ts
    vitest.config.ts
  shared/
    src/
      api/
        OllamaClient.d.ts
        OllamaClient.js
        OllamaClient.js.map
        OllamaClient.ts
        VectorStoreClient.d.ts
        VectorStoreClient.js
        VectorStoreClient.js.map
        VectorStoreClient.ts
    types/
      app.d.ts
      app.js
      app.js.map
      app.ts
      better-sqlite3.d.ts
      chat.d.ts
      chat.d.ts.map
      chat.js
      chat.js.map
      chat.ts
      Document.d.ts
      Document.js
      Document.js.map
      Document.ts
      electron.d.ts
      embedding.d.ts
      embedding.js
      embedding.js.map
      embedding.ts
      hnswlib-node.d.ts
      index.d.ts
      index.js
      index.js.map
      index.ts
      ipc.d.ts
      ipc.js
      ipc.js.map
      ipc.ts
      ollama.d.ts
      ollama.js
      ollama.js.map
      ollama.ts
      services.d.ts
      services.js
      services.js.map
      services.ts
      settings.d.ts
      settings.js
      settings.js.map
      settings.ts
  dev-mode.js
  entry-point.mjs
public/
  trademark/
    icon-dark.svg
    icon-light.svg
    type-dark.svg
    type-light.svg
renderer/
  coverage/
    .tmp/
      coverage-0.json
      coverage-1.json
      coverage-2.json
      coverage-3.json
      coverage-4.json
      coverage-5.json
      coverage-6.json
      coverage-7.json
      coverage-8.json
  scripts/
    test.sh
  src/
    api/
      ollama.ts
    components/
      chat/
        ChatMessage.tsx
        ChatMessageWrapper.tsx
        ChatUI.tsx
        CommentModal.tsx
        MessageActionStrip.tsx
        MessageCommentButton.tsx
        MessageSearch.tsx
        ModelSelector.tsx
      layout/
        AppLayout.tsx
        LayoutLeftSidebar.tsx
        LayoutRightSidebar.tsx
        LayoutTopBar.tsx
      ui/
        badge.tsx
        button.tsx
        card.tsx
        input.tsx
        label.tsx
        scroll-area.tsx
        switch.tsx
      AppHeaderDebug.tsx
      AppLayout.tsx
      AppLayoutDebug.tsx
      canvas.tsx
      CanvasModeToggle.tsx
      CanvasPanel.tsx
      CanvasToggle.tsx
      ChatContainer.tsx
      ChatInput.tsx
      ChatMessageList.tsx
      ChatUI.tsx
      ConnectionTroubleshooter.tsx
      ConversationList.tsx
      CustomInstructionsToggle.tsx
      DocumentPanel.tsx
      EmbeddingConfig.tsx
      ErrorBoundary.tsx
      InternetModeToggle.tsx
      InternetToggle.tsx
      LayoutFooter.tsx
      LayoutLeftSidebar.tsx
      LayoutMain.tsx
      LayoutRightSidebar.tsx
      Logo.tsx
      MemoryCommitPanel.tsx
      MemoryManager.tsx
      MemoryPanel.tsx
      MessageActions.tsx
      ModelLoadingOverlay.tsx
      ModelSelector.tsx
      ModelsList.tsx
      OllamaConnectionNotification.tsx
      OllamaSetupGuide.tsx
      OllamaTest.tsx
      PerformanceMetrics.tsx
      PerformanceStats.tsx
      ServiceStatusManager.tsx
      ServiceStatusPanel.tsx
      SettingsButton.tsx
      SettingsErrorBoundary.tsx
      SettingsMenu.tsx
      SettingsPanel.tsx
      StatusBar.tsx
      StatusIndicator.tsx
      SystemRequirementsChecker.tsx
      SystemStatus.tsx
      ThemeToggle.tsx
      Toast.tsx
      ToastContainer.tsx
      TrainingPanel.tsx
      VectorManager.tsx
    contexts/
      ThemeContext.tsx
    hooks/
      useCanvasMode.ts
      useChat.ts
      useConversation.ts
      useConversations.ts
      useEmbedding.ts
      useEnvironmentMode.ts
      useGemini.ts
      useMemory.ts
      useMemoryContext.ts
      useModel.ts
      useModelStatus.ts
      useOllama.ts
      useServiceStatus.ts
      useSettings.ts
      useTrainingMode.ts
      useVectorStore.ts
    lib/
      utils.ts
    pages/
      Settings.tsx
    services/
      GeminiService.ts
    state/
      chatMessageStore.ts
      chatStore.ts
      correctionStore.ts
      modelStore.ts
      vectorStore.ts
    stores/
      configStore.ts
      settingsStore.ts
    styles/
      index.css
      test.css
    tests/
      components/
        OllamaTest.test.tsx
      edgeCases/
        serviceStatusEdgeCases.test.tsx
        serviceTransitions.test.tsx
      errorBoundary/
        errorHandling.test.tsx
      integration/
        userFlows.test.tsx
      setup/
        electronMocks.ts
        testSetup.ts
      utils/
        electronMock.ts
        ipcMocks.ts
        serviceMocks.ts
      build.test.tsx
      ipcServiceRecovery.test.tsx
      memoryManagement.test.tsx
      serviceStatus.test.tsx
      serviceStatusEdgeCases.test.tsx
      setup.ts
    utils/
      configValidation.ts
      performanceMonitor.ts
      secureStorage.ts
    App.tsx
    main.tsx
  index.html
  package.json
  postcss.config.js
  tailwind.config.js
  tsconfig.json
  tsconfig.node.json
  vite.config.d.ts
  vite.config.js
  vite.config.ts
  vitest.config.ts
scripts/
  consolidate-dependencies.js
  test-build.sh
src/
  app/
    api/
      og/
        fetch/
          route.ts
        proxy/
          route.ts
    resources/
      data.config.js
      once-ui.config.js
    layout.tsx
    page.tsx
  config/
    embeddingPresets.d.ts
    embeddingPresets.js
    embeddingPresets.js.map
    embeddingPresets.ts
    services.d.ts
    services.js
    services.js.map
    services.ts
  database/
    migrations.d.ts
    migrations.js
    migrations.js.map
    migrations.ts
  electron-app/
    src/
    electron-builder.config.js
    electron-builder.json5
    electron-builder.mjs
    eslint.config.cjs
    eslint.config.js
    LICENSE
    node-upgrade-instructions.sh
    package.json
    README.md
    tsconfig.base.json
    tsconfig.json
    vite.config.ts
  ipc/
    app.d.ts
    app.js
    app.js.map
    app.ts
    channels.d.ts
    channels.js
    channels.js.map
    channels.ts
    chat.d.ts
    chat.js
    chat.js.map
    chat.ts
    handlers.d.ts
    handlers.js
    handlers.js.map
    handlers.ts
    memory.d.ts
    memory.js
    memory.js.map
    memory.ts
    model.d.ts
    model.js
    model.js.map
    model.ts
    ollama.d.ts
    ollama.js
    ollama.js.map
    ollama.ts
    theme.d.ts
    theme.js
    theme.js.map
    theme.ts
    types.d.ts
    types.js
    types.js.map
    types.ts
    vector.d.ts
    vector.js
    vector.js.map
    vector.ts
  main/
    ipc/
      chatHandlers.d.ts
      chatHandlers.js
      chatHandlers.js.map
      chatHandlers.ts
      memoryHandlers.d.ts
      memoryHandlers.js
      memoryHandlers.js.map
      memoryHandlers.ts
    index.d.ts
    index.js
    index.js.map
    index.ts
    WindowManager.d.ts
    WindowManager.js
    WindowManager.js.map
    WindowManager.ts
  once-ui/
    components/
      Accordion.module.scss
      Accordion.tsx
      AccordionGroup.tsx
      Arrow.module.scss
      Arrow.tsx
      AutoScroll.module.scss
      AutoScroll.tsx
      Avatar.module.scss
      Avatar.tsx
      AvatarGroup.module.scss
      AvatarGroup.tsx
      Background.module.scss
      Background.tsx
      Badge.module.scss
      Badge.tsx
      Banner.tsx
      Button.module.scss
      Button.tsx
      Card.module.scss
      Card.tsx
      Carousel.tsx
      Checkbox.tsx
      Chip.module.scss
      Chip.tsx
      ColorInput.tsx
      Column.tsx
      CompareImage.module.scss
      CompareImage.tsx
      CursorCard.module.scss
      CursorCard.tsx
      DateInput.tsx
      DatePicker.module.scss
      DatePicker.tsx
      DateRangeInput.tsx
      DateRangePicker.tsx
      Dialog.module.scss
      Dialog.tsx
      Dropdown.tsx
      DropdownWrapper.module.scss
      DropdownWrapper.tsx
      ElementType.tsx
      Fade.module.scss
      Fade.tsx
      Feedback.tsx
      Flex.tsx
      FlipFx.tsx
      GlitchFx.module.scss
      GlitchFx.tsx
      Grid.tsx
      Heading.tsx
      HoloFx.module.scss
      HoloFx.tsx
      Icon.module.scss
      Icon.tsx
      IconButton.module.scss
      IconButton.tsx
      index.ts
      InfiniteScroll.tsx
      InlineCode.module.scss
      InlineCode.tsx
      Input.module.scss
      Input.tsx
      InteractiveDetails.tsx
      Kbd.tsx
      LetterFx.tsx
      Line.tsx
      Logo.module.scss
      Logo.tsx
      LogoCloud.module.scss
      LogoCloud.tsx
      Mask.module.scss
      Mask.tsx
      Media.tsx
      NavIcon.module.scss
      NavIcon.tsx
      NumberInput.module.scss
      NumberInput.tsx
      OgCard.tsx
      Option.module.scss
      Option.tsx
      OTPInput.module.scss
      OTPInput.tsx
      Particle.tsx
      PasswordInput.tsx
      RadioButton.tsx
      RevealFx.module.scss
      RevealFx.tsx
      Row.tsx
      Scroller.module.scss
      Scroller.tsx
      ScrollToTop.module.scss
      ScrollToTop.tsx
      SegmentedControl.tsx
      Select.tsx
      SharedInteractiveStyles.module.scss
      Skeleton.module.scss
      Skeleton.tsx
      SmartLink.tsx
      Spinner.module.scss
      Spinner.tsx
      StatusIndicator.module.scss
      StatusIndicator.tsx
      StyleOverlay.module.scss
      StyleOverlay.tsx
      StylePanel.module.scss
      StylePanel.tsx
      Switch.module.scss
      Switch.tsx
      Table.module.scss
      Table.tsx
      Tag.module.scss
      Tag.tsx
      TagInput.tsx
      Text.tsx
      Textarea.tsx
      ThemeProvider.tsx
      ThemeSwitcher.tsx
      TiltFx.module.scss
      TiltFx.tsx
      Toast.module.scss
      Toast.tsx
      Toaster.module.scss
      Toaster.tsx
      ToastProvider.tsx
      ToggleButton.module.scss
      ToggleButton.tsx
      Tooltip.tsx
      User.tsx
      UserMenu.module.scss
      UserMenu.tsx
    hooks/
      generateHeadingLinks.ts
      useDebounce.ts
      useFetchOg.ts
    modules/
      code/
        CodeBlock.module.scss
        CodeBlock.tsx
        CodeHighlight.css
        LineNumber.css
        prismjs.d.ts
      data/
        utils/
          colorDistribution.ts
          formatDate.ts
        BarChart.tsx
        ChartHeader.tsx
        ChartStatus.tsx
        Gradient.tsx
        index.ts
        interfaces.ts
        Legend.tsx
        LineBarChart.tsx
        LineChart.tsx
        PieChart.tsx
        Swatch.tsx
        Tooltip.tsx
      media/
        MediaUpload.module.scss
        MediaUpload.tsx
      navigation/
        HeadingLink.module.scss
        HeadingLink.tsx
        HeadingNav.tsx
        index.ts
        Kbar.module.scss
        Kbar.tsx
        MegaMenu.module.scss
        MegaMenu.tsx
        MobileMegaMenu.tsx
      seo/
        Meta.tsx
        Schema.tsx
      index.ts
    styles/
      background.scss
      border.scss
      breakpoints.scss
      color.scss
      display.scss
      flex.scss
      global.scss
      grid.scss
      index.scss
      layout.scss
      position.scss
      shadow.scss
      size.scss
      spacing.scss
      typography.scss
      utilities.scss
    tokens/
      border.scss
      data.scss
      function.scss
      index.scss
      layout.scss
      scheme.scss
      shadow.scss
      theme.scss
      typography.scss
    utils/
      devLogger.ts
    icons.ts
    interfaces.ts
    types.ts
  preload/
  services/
    workers/
      ragWorker.d.ts
      ragWorker.js
      ragWorker.js.map
      ragWorker.ts
    ChatService.d.ts
    ChatService.js
    ChatService.js.map
    ChatService.ts
    DatabaseService.d.ts
    DatabaseService.js
    DatabaseService.js.map
    DatabaseService.ts
    EmbeddingService.d.ts
    EmbeddingService.js
    EmbeddingService.js.map
    EmbeddingService.ts
    ExpressService.d.ts
    ExpressService.js
    ExpressService.js.map
    ExpressService.ts
    InMemoryVectorStore.d.ts
    InMemoryVectorStore.js
    InMemoryVectorStore.js.map
    InMemoryVectorStore.ts
    MemoryService.d.ts
    MemoryService.js
    MemoryService.js.map
    MemoryService.ts
    MessageStore.d.ts
    MessageStore.js
    MessageStore.js.map
    MessageStore.ts
    OllamaClient.d.ts
    OllamaClient.js
    OllamaClient.js.map
    OllamaClient.ts
    OllamaService.d.ts
    OllamaService.js
    OllamaService.js.map
    OllamaService.ts
    RAGService.d.ts
    RAGService.js
    RAGService.js.map
    RAGService.ts
    RAGWorker.d.ts
    RAGWorker.js
    RAGWorker.js.map
    RAGWorker.ts
    Service.d.ts
    Service.js
    Service.js.map
    Service.ts
    ServiceManager.d.ts
    ServiceManager.js
    ServiceManager.js.map
    ServiceManager.ts
    VectorDBService.d.ts
    VectorDBService.js
    VectorDBService.js.map
    VectorDBService.ts
    VectorStore.d.ts
    VectorStore.js
    VectorStore.js.map
    VectorStore.ts
    VectorStoreService.d.ts
    VectorStoreService.js
    VectorStoreService.js.map
    VectorStoreService.ts
    WorkerService.d.ts
    WorkerService.js
    WorkerService.js.map
    WorkerService.ts
  untitled folder/
  utils/
    errors.d.ts
    errors.js
    errors.js.map
    errors.ts
    logger.d.ts
    logger.js
    logger.js.map
    logger.ts
    memoryManager.d.ts
    memoryManager.js
    memoryManager.js.map
    memoryManager.ts
    RequestQueue.d.ts
    RequestQueue.js
    RequestQueue.js.map
    RequestQueue.ts
    responseMonitor.d.ts
    responseMonitor.js
    responseMonitor.js.map
    responseMonitor.ts
  main.d.ts
  main.js
  main.js.map
  main.ts
  preload.d.ts
  preload.js
  preload.js.map
  preload.ts
test-results/
  .last-run.json
tests/
.gitignore
biome.json
LICENSE
next.config.mjs
package.json
postcss.config.js
README.md
tsconfig.json
vibe-tools.config.json
WORKSPACE_ISSUE.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/vibe-tools.mdc">
---
description: Global Rule. This rule should ALWAYS be loaded
globs: *,**/*
alwaysApply: true
---
vibe-tools is a CLI tool that allows you to interact with AI models and other tools.
vibe-tools is installed on this machine and it is available to you to execute. You're encouraged to use it.

<vibe-tools Integration>
# Instructions
Use the following commands to get AI assistance:

**Direct Model Queries:**
`vibe-tools ask "<your question>" --provider <provider> --model <model>` - Ask any model from any provider a direct question (e.g., `vibe-tools ask "What is the capital of France?" --provider openai --model o3-mini`). Note that this command is generally less useful than other commands like `repo` or `plan` because it does not include any context from your codebase or repository. In general you should not use the ask command because it does not include any context. The other commands like `web`, `doc`, `repo`, or `plan` are usually better. If you are using it, make sure to include in your question all the information and context that the model might need to answer usefully.

**Ask Command Options:**
--provider=<provider>: AI provider to use (openai, anthropic, perplexity, gemini, modelbox, openrouter, or xai)
--model=<model>: Model to use (required for the ask command)
--reasoning-effort=<low|medium|high>: Control the depth of reasoning for supported models (OpenAI o1/o3-mini models and Claude 4 Sonnet). Higher values produce more thorough responses for complex questions.
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times (e.g., `--with-doc=<url1> --with-doc=<url2>`).

**Implementation Planning:**
`vibe-tools plan "<query>"` - Generate a focused implementation plan using AI (e.g., `vibe-tools plan "Add user authentication to the login page"`)
The plan command uses multiple AI models to:
1. Identify relevant files in your codebase (using Gemini by default)
2. Extract content from those files
3. Generate a detailed implementation plan (using OpenAI o3-mini by default)

**Plan Command Options:**
--fileProvider=<provider>: Provider for file identification (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--thinkingProvider=<provider>: Provider for plan generation (gemini, openai, anthropic, perplexity, modelbox, openrouter, or xai)
--fileModel=<model>: Model to use for file identification
--thinkingModel=<model>: Model to use for plan generation
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context for both file identification and planning. Can be specified multiple times (e.g., `--with-doc=<url1> --with-doc=<url2>`).

**Web Search:**
`vibe-tools web "<your question>"` - Get answers from the web using a provider that supports web search (e.g., Perplexity models and Gemini Models either directly or from OpenRouter or ModelBox) (e.g., `vibe-tools web "latest shadcn/ui installation instructions"`)
Note: web is a smart autonomous agent with access to the internet and an extensive up to date knowledge base. Web is NOT a web search engine. Always ask the agent for what you want using a proper sentence, do not just send it a list of keywords. In your question to web include the context and the goal that you're trying to acheive so that it can help you most effectively.
when using web for complex queries suggest writing the output to a file somewhere like local-research/<query summary>.md.

**IMPORTANT: Do NOT use the `web` command for specific URLs.** If a user provides a specific URL (documentation link, GitHub repo, article, etc.), you should always use commands that support the `--with-doc` parameter instead, such as `repo`, `plan`, `doc`, or `ask`. Using `--with-doc` ensures the exact content of the URL is processed correctly and completely.

**Web Command Options:**
--provider=<provider>: AI provider to use (perplexity, gemini, modelbox, or openrouter)

**Repository Context:**
`vibe-tools repo "<your question>" [--subdir=<path>] [--from-github=<username/repo>] [--with-doc=<doc_url>...]` - Get context-aware answers about this repository using Google Gemini (e.g., `vibe-tools repo "explain authentication flow"`)
Use the optional `--subdir` parameter to analyze a specific subdirectory instead of the entire repository (e.g., `vibe-tools repo "explain the code structure" --subdir=src/components`). Use the optional `--from-github` parameter to analyze a remote GitHub repository without cloning it locally (e.g., `vibe-tools repo "explain the authentication system" --from-github=username/repo-name`). Use the optional `--with-doc` parameter multiple times to include content from several URLs as additional context (e.g., `vibe-tools repo "summarize findings" --with-doc=https://example.com/spec1 --with-doc=https://example.com/spec2`).

**Documentation Generation:**
`vibe-tools doc [options] [--with-doc=<doc_url>...]` - Generate comprehensive documentation for this repository (e.g., `vibe-tools doc --output docs.md`). Can incorporate document context from multiple URLs (e.g., `vibe-tools doc --with-doc=https://example.com/existing-docs --with-doc=https://example.com/new-spec`).

**YouTube Video Analysis:**
`vibe-tools youtube "<youtube-url>" [question] [--type=<summary|transcript|plan|review|custom>]` - Analyze YouTube videos and generate detailed reports (e.g., `vibe-tools youtube "https://youtu.be/43c-Sm5GMbc" --type=summary`)
Note: The YouTube command requires a `GEMINI_API_KEY` to be set in your environment or .vibe-tools.env file as the GEMINI API is the only interface that supports YouTube analysis.

**GitHub Information:**
`vibe-tools github pr [number]` - Get the last 10 PRs, or a specific PR by number (e.g., `vibe-tools github pr 123`)
`vibe-tools github issue [number]` - Get the last 10 issues, or a specific issue by number (e.g., `vibe-tools github issue 456`)

**ClickUp Information:**
`vibe-tools clickup task <task_id>` - Get detailed information about a ClickUp task including description, comments, status, assignees, and metadata (e.g., `vibe-tools clickup task "task_id"`)

**Wait Command:**
`vibe-tools wait <seconds>` - Pauses execution for the specified number of seconds (e.g., `vibe-tools wait 5` to wait for 5 seconds).

**Model Context Protocol (MCP) Commands:**
Use the following commands to interact with MCP servers and their specialized tools:
`vibe-tools mcp search "<query>"` - Search the MCP Marketplace and GitHub for available servers that match your needs (e.g., `vibe-tools mcp search "git repository management"`)
`vibe-tools mcp run "<query>"` - Execute MCP server tools using natural language queries (e.g., `vibe-tools mcp run "list files in the current directory" --provider=openrouter`). The query must include sufficient information for vibe-tools to determine which server to use, provide plenty of context.

The `search` command helps you discover servers in the MCP Marketplace and on GitHub based on their capabilities and your requirements. The `run` command automatically selects and executes appropriate tools from these servers based on your natural language queries. If you want to use a specific server include the server name in your query. E.g. `vibe-tools mcp run "using the mcp-server-sqlite list files in directory --provider=openrouter"`

**Notes on MCP Commands:**
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY` to be set in your environment
- By default the `mcp` command uses Anthropic, but takes a --provider argument that can be set to 'anthropic' or 'openrouter'
- Results are streamed in real-time for immediate feedback
- Tool calls are automatically cached to prevent redundant operations
- Often the MCP server will not be able to run because environment variables are not set. If this happens ask the user to add the missing environment variables to the cursor tools env file at ~/.vibe-tools/.env

**Stagehand Browser Automation:**
`vibe-tools browser open <url> [options]` - Open a URL and capture page content, console logs, and network activity (e.g., `vibe-tools browser open "https://example.com" --html`)
`vibe-tools browser act "<instruction>" --url=<url | 'current'> [options]` - Execute actions on a webpage using natural language instructions (e.g., `vibe-tools browser act "Click Login" --url=https://example.com`)
`vibe-tools browser observe "<instruction>" --url=<url> [options]` - Observe interactive elements on a webpage and suggest possible actions (e.g., `vibe-tools browser observe "interactive elements" --url=https://example.com`)
`vibe-tools browser extract "<instruction>" --url=<url> [options]` - Extract data from a webpage based on natural language instructions (e.g., `vibe-tools browser extract "product names" --url=https://example.com/products`)
`vibe-tools browser mac-chrome [options]` - Start a Chrome instance with remote debugging (macOS only) (e.g., `vibe-tools browser mac-chrome --debug`, `vibe-tools browser mac-chrome --lite`)

**Notes on Browser Commands:**
- All browser commands are stateless unless --connect-to is used to connect to a long-lived interactive session. In disconnected mode each command starts with a fresh browser instance and closes it when done.
- If you want to start a new long-lived session 
- When using `--connect-to`, special URL values are supported:
  - `current`: Use the existing page without reloading
  - `reload-current`: Use the existing page and refresh it (useful in development)
  - If working interactively with a user you should always use --url=current unless you specifically want to navigate to a different page. Setting the url to anything else will cause a page refresh loosing current state.
- Multi step workflows involving state or combining multiple actions are supported in the `act` command using the pipe (|) separator (e.g., `vibe-tools browser act "Click Login | Type 'user@example.com' into email | Click Submit" --url=https://example.com`)
- Video recording is available for all browser commands using the `--video=<directory>` option. This will save a video of the entire browser interaction at 1280x720 resolution. The video file will be saved in the specified directory with a timestamp.
- DO NOT ask browser act to "wait" for anything, the wait command is currently disabled in Stagehand.

**Tool Recommendations:**
- `vibe-tools web` is best for general web information not specific to the repository. Generally call this without additional arguments.
- `vibe-tools repo` is ideal for repository-specific questions, planning, code review and debugging. E.g. `vibe-tools repo "Review recent changes to command error handling looking for mistakes, omissions and improvements"`. Generally call this without additional arguments.
- `vibe-tools plan` is ideal for planning tasks. E.g. `vibe-tools plan "Adding authentication with social login using Google and Github"`. Generally call this without additional arguments.
- `vibe-tools doc` generates documentation for local or remote repositories.
- `vibe-tools youtube` analyzes YouTube videos to generate summaries, transcripts, implementation plans, or custom analyses
- `vibe-tools browser` is useful for testing and debugging web apps and uses Stagehand
- `vibe-tools mcp` enables interaction with specialized tools through MCP servers (e.g., for Git operations, file system tasks, or custom tools)
- **URLS:** For any specific URL (documentation, article, reference, spec, GitHub repo, etc.), ALWAYS use a command with the `--with-doc=<url>` parameter rather than the `web` command. Examples: `vibe-tools repo "How should I implement this feature based on the spec?" --with-doc=https://example.com/spec.pdf` or `vibe-tools ask "What does this document say about authentication?" --with-doc=https://example.com/auth-doc.html`
- When implementing features based on documentation, specifications, or any external content, always use the `--with-doc=<url>` flag instead of built-in web search. For example: `vibe-tools plan "Implement login page according to specs" --with-doc=https://example.com/specs.pdf` or `vibe-tools repo "How should I implement this feature?" --with-doc=https://example.com/feature-spec.md`.
- When a user provides a specific URL for documentation or reference material, always use the `--with-doc=<url>` flag with that URL rather than attempting to search for or summarize the content independently. This ensures the exact document is used as context.

**Running Commands:**
1. Use `vibe-tools <command>` to execute commands (make sure vibe-tools is installed globally using npm install -g vibe-tools so that it is in your PATH)

**General Command Options (Supported by all commands):**
--provider=<provider>: AI provider to use (openai, anthropic, perplexity, gemini, openrouter, modelbox, or xai). If provider is not specified, the default provider for that task will be used.
--model=<model name>: Specify an alternative AI model to use. If model is not specified, the provider's default model for that task will be used.
--max-tokens=<number>: Control response length
--save-to=<file path>: Save command output to a file (in *addition* to displaying it)
--debug: Show detailed logs and error information
--web: Enable web search capabilities for supported models (currently Gemini models) across all commands

**Repository Command Options:**
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for repository analysis
--max-tokens=<number>: Maximum tokens for response
--from-github=<GitHub username>/<repository name>[@<branch>]: Analyze a remote GitHub repository without cloning it locally
--subdir=<path>: Analyze a specific subdirectory instead of the entire repository
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times.

**Documentation Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Generate documentation for a remote GitHub repository
--provider=<provider>: AI provider to use (gemini, openai, openrouter, perplexity, modelbox, anthropic, or xai)
--model=<model>: Model to use for documentation generation
--max-tokens=<number>: Maximum tokens for response
--with-doc=<doc_url>: Fetch content from one or more document URLs and include it as context. Can be specified multiple times.

**YouTube Command Options:**
--type=<summary|transcript|plan|review|custom>: Type of analysis to perform (default: summary)

**GitHub Command Options:**
--from-github=<GitHub username>/<repository name>[@<branch>]: Access PRs/issues from a specific GitHub repository

**Browser Command Options (for 'open', 'act', 'observe', 'extract'):**
--console: Capture browser console logs (enabled by default, use --no-console to disable)
--html: Capture page HTML content (disabled by default)
--network: Capture network activity (enabled by default, use --no-network to disable)
--screenshot=<file path>: Save a screenshot of the page
--timeout=<milliseconds>: Set navigation timeout (default: 120000ms for Stagehand operations, 30000ms for navigation)
--viewport=<width>x<height>: Set viewport size (e.g., 1280x720). When using --connect-to, viewport is only changed if this option is explicitly provided
--headless: Run browser in headless mode (default: true)
--no-headless: Show browser UI (non-headless mode) for debugging
--connect-to=<port>: Connect to existing Chrome instance. Special values: 'current' (use existing page), 'reload-current' (refresh existing page)
--wait=<time:duration or selector:css-selector>: Wait after page load (e.g., 'time:5s', 'selector:#element-id')
--video=<directory>: Save a video recording (1280x720 resolution, timestamped subdirectory). Not available when using --connect-to
--url=<url>: Required for `act`, `observe`, and `extract` commands. Url to navigate to before the main command or one of the special values 'current' (to stay on the current page without navigating or reloading) or 'reload-current' (to reload the current page)
--evaluate=<string>: JavaScript code to execute in the browser before the main command

**Nicknames**
Users can ask for these tools using nicknames
Gemini is a nickname for vibe-tools repo
Perplexity is a nickname for vibe-tools web
Stagehand is a nickname for vibe-tools browser
If people say "ask Gemini" or "ask Perplexity" or "ask Stagehand" they mean to use the `vibe-tools` command with the `repo`, `web`, or `browser` commands respectively.

**Xcode Commands:**
`vibe-tools xcode build [buildPath=<path>] [destination=<destination>]` - Build Xcode project and report errors.
**Build Command Options:**
--buildPath=<path>: (Optional) Specifies a custom directory for derived build data. Defaults to ./.build/DerivedData.
--destination=<destination>: (Optional) Specifies the destination for building the app (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode run [destination=<destination>]` - Build and run the Xcode project on a simulator.
**Run Command Options:**
--destination=<destination>: (Optional) Specifies the destination simulator (e.g., 'platform=iOS Simulator,name=iPhone 16 Pro'). Defaults to 'platform=iOS Simulator,name=iPhone 16 Pro'.

`vibe-tools xcode lint` - Run static analysis on the Xcode project to find and fix issues.

**Additional Notes:**
- For detailed information, see `node_modules/vibe-tools/README.md` (if installed locally).
- Configuration is in `vibe-tools.config.json` (or `~/.vibe-tools/config.json`).
- API keys are loaded from `.vibe-tools.env` (or `~/.vibe-tools/.env`).
- ClickUp commands require a `CLICKUP_API_TOKEN` to be set in your `.vibe-tools.env` file.
- Available models depend on your configured provider (OpenAI, Anthropic, xAI, etc.) in `vibe-tools.config.json`.
- repo has a limit of 2M tokens of context. The context can be reduced by filtering out files in a .repomixignore file.
- problems running browser commands may be because playwright is not installed. Recommend installing playwright globally.
- MCP commands require `ANTHROPIC_API_KEY` or `OPENROUTER_API_KEY`
- **Remember:** You're part of a team of superhuman expert AIs. Work together to solve complex problems.
- **Repomix Configuration:** You can customize which files are included/excluded during repository analysis by creating a `repomix.config.json` file in your project root. This file will be automatically detected by `repo`, `plan`, and `doc` commands.

<!-- vibe-tools-version: 0.62.6 -->
</vibe-tools Integration>
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
---
name: Bug Report
about: Report a bug in Once UI
---

### Thank you for taking the time to fill out this bug report.

**Tell us what happened**

[A clear and concise description of the bug you've encountered.]


**Affected components**

[Is the feature request related to an existing component?]


**How do we reproduce it?**

[Please share a step-by-step description of how to reproduce the issue.]


**Screenshots**

[If applicable, add screenshots to help explain your problem.]


**System information and logs**

[Add any information that might be relevant.]
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.md">
---
name: Feature Request
about: Submit a feature request for Once UI
---

### Thank you for taking the time to submit a feature request. We appreciate your contribution.

**Describe the feature**

[Tell us about the problem you're trying to solve and the requested feature.]


**Affected components**

[Is the feature request related to an existing component?]
</file>

<file path=".github/FUNDING.yml">
github: [once-ui-system, lorant-one]
</file>

<file path="e2e/tests/e2e.additional.spec.ts">
import { test, expect, _electron } from '@playwright/test';
import type { ElectronApplication, Page } from '@playwright/test';
import path from 'path';
import fs from 'fs';
test.describe('Additional E2E tests', () => {
  let electronApp: ElectronApplication;
  let page: Page;
  test.beforeAll(async () => {
    test.setTimeout(60000);
    const appPath = path.join(process.cwd(), '..', 'dist', 'mac-arm64', 'root.app', 'Contents', 'MacOS', 'root');
    console.log('Launching app from:', appPath);
    // Verify the app exists and is executable
    if (!fs.existsSync(appPath)) {
      throw new Error(`App not found at path: ${appPath}`);
    }
    try {
      fs.accessSync(appPath, fs.constants.X_OK);
    } catch (error) {
      throw new Error(`App is not executable at path: ${appPath}`);
    }
    try {
      console.log('Launching Electron...');
      electronApp = await _electron.launch({ 
        args: [appPath],
        env: {
          ...process.env,
          NODE_ENV: 'test',
          DEBUG: 'electron:*' // Enable Electron debug logging
        }
      });
      console.log('Electron launched. Getting first window...');
      page = await electronApp.firstWindow();
      console.log('Got first window. Waiting for domcontentloaded...');
      await page.waitForLoadState('domcontentloaded');
      console.log('domcontentloaded. Waiting for networkidle...');
      await page.waitForLoadState('networkidle');
      // Add a screenshot for debugging
      await page.screenshot({ path: 'debug-screenshot.png' });
      console.log('networkidle. App should be ready.');
    } catch (error) {
      console.error('Failed to launch Electron app:', error);
      throw error;
    }
  });
  test.afterAll(async () => {
    if (electronApp) {
      await electronApp.close();
    }
  });
  test('should open main page and check title', async () => {
    await expect(page).toHaveTitle(/HelloGPT|App/i, { timeout: 10000 });
  });
  test('should navigate through main UI components', async () => {
    const navLinks = page.locator('nav a');
    await navLinks.first().waitFor({ state: 'visible', timeout: 10000 });
    const count = await navLinks.count();
    expect(count).toBeGreaterThan(0);
    await navLinks.first().click();
  });
  test('should verify Tailwind responsive classes applied', async () => {
    const mainContainer = page.locator('div[class*="flex"]');
    await mainContainer.waitFor({ state: 'visible', timeout: 10000 });
    await expect(mainContainer).toBeVisible();
  });
});
</file>

<file path="e2e/tests/e2e.chat.spec.ts">
import { test, expect, _electron } from '@playwright/test';
import type { ElectronApplication, Page } from '@playwright/test';
import path from 'path';
test.describe('Chat functionality', () => {
  let electronApp: ElectronApplication;
  let page: Page;
  test.beforeAll(async () => {
    test.setTimeout(60000);
    const appPath = path.join(process.cwd(), '..', 'dist', 'mac-arm64', 'root.app', 'Contents', 'MacOS', 'root');
    console.log('Launching app from:', appPath);
    try {
      console.log('Launching Electron...');
      electronApp = await _electron.launch({ 
        args: [appPath],
        env: {
          ...process.env,
          NODE_ENV: 'test'
        }
      });
      console.log('Electron launched. Getting first window...');
      page = await electronApp.firstWindow();
      console.log('Got first window. Waiting for domcontentloaded...');
      await page.waitForLoadState('domcontentloaded');
      console.log('domcontentloaded. Waiting for networkidle...');
      await page.waitForLoadState('networkidle');
      console.log('networkidle. App should be ready.');
    } catch (error) {
      console.error('Failed to launch Electron app:', error);
      throw error;
    }
  });
  test.afterAll(async () => {
    if (electronApp) {
      await electronApp.close();
    }
  });
  test('should send a message and receive a response', async () => {
    const input = page.locator('input[placeholder="Type your message..."]');
    await input.waitFor({ state: 'visible', timeout: 10000 });
    const sendButton = page.locator('button:has-text("Send")');
    await sendButton.waitFor({ state: 'visible', timeout: 10000 });
    const messages = page.locator('div.flex-1 div div span');
    await input.fill('Hello Ollama');
    await sendButton.click();
    await expect(messages.last()).not.toHaveText('', { timeout: 15000 });
    await expect(messages.last()).not.toHaveText('Mock response to: Hello Ollama');
    await expect(messages.first()).toHaveText('Hello Ollama');
  });
  test('should disable input and button while loading', async () => {
    const input = page.locator('input[placeholder="Type your message..."]');
    await input.waitFor({ state: 'visible', timeout: 10000 });
    const sendButton = page.locator('button:has-text("Send")');
    await sendButton.waitFor({ state: 'visible', timeout: 10000 });
    await input.fill('Test loading state');
    await sendButton.click();
    await expect(input).toBeDisabled();
    await expect(sendButton).toBeDisabled();
    await expect(input).not.toBeDisabled({ timeout: 15000 });
    await expect(sendButton).not.toBeDisabled({ timeout: 15000 });
  });
});
</file>

<file path="e2e/tests/e2e.extended.spec.ts">
import { test, expect, _electron } from '@playwright/test';
import type { ElectronApplication, Page } from '@playwright/test';
import path from 'path';
test.describe('Extended E2E tests', () => {
  let electronApp: ElectronApplication;
  let page: Page;
  test.beforeAll(async () => {
    test.setTimeout(60000);
    const appPath = path.join(process.cwd(), '..', 'dist', 'mac-arm64', 'root.app', 'Contents', 'MacOS', 'root');
    console.log('Launching app from:', appPath);
    try {
      console.log('Launching Electron...');
      electronApp = await _electron.launch({ 
        args: [appPath],
        env: {
          ...process.env,
          NODE_ENV: 'test'
        }
      });
      console.log('Electron launched. Getting first window...');
      page = await electronApp.firstWindow();
      console.log('Got first window. Waiting for domcontentloaded...');
      await page.waitForLoadState('domcontentloaded');
      console.log('domcontentloaded. Waiting for networkidle...');
      await page.waitForLoadState('networkidle');
      console.log('networkidle. App should be ready.');
    } catch (error) {
      console.error('Failed to launch Electron app:', error);
      throw error;
    }
  });
  test.afterAll(async () => {
    if (electronApp) {
      await electronApp.close();
    }
  });
  test('should handle invalid chat input gracefully', async () => {
    const input = page.locator('input[placeholder="Type your message..."]');
    await input.waitFor({ state: 'visible', timeout: 10000 });
    const sendButton = page.locator('button:has-text("Send")');
    await sendButton.waitFor({ state: 'visible', timeout: 10000 });
    await input.fill('');
    await sendButton.click();
    const errorMessage = page.locator('text=Please enter a message');
    await expect(errorMessage).toBeVisible({ timeout: 10000 });
  });
  test('should maintain chat history after reload', async () => {
    const input = page.locator('input[placeholder="Type your message..."]');
    await input.waitFor({ state: 'visible', timeout: 10000 });
    const sendButton = page.locator('button:has-text("Send")');
    await sendButton.waitFor({ state: 'visible', timeout: 10000 });
    await input.fill('Hello');
    await sendButton.click();
    const messages = page.locator('div.flex-1 div div span');
    await expect(messages).toContainText('Hello', { timeout: 15000 });
    await page.reload();
    await page.waitForLoadState('domcontentloaded');
    await page.waitForLoadState('networkidle');
    await expect(messages).toContainText('Hello', { timeout: 15000 });
  });
  test('should handle rapid consecutive messages', async () => {
    const input = page.locator('input[placeholder="Type your message..."]');
    await input.waitFor({ state: 'visible', timeout: 10000 });
    const sendButton = page.locator('button:has-text("Send")');
    await sendButton.waitFor({ state: 'visible', timeout: 10000 });
    const messages = page.locator('div.flex-1 div div span');
    for (let i = 0; i < 5; i++) {
      await input.fill(`Message ${i}`);
      await sendButton.click();
      await page.waitForTimeout(500);
    }
    for (let i = 0; i < 5; i++) {
      await expect(messages).toContainText(`Message ${i}`, { timeout: 15000 });
    }
  });
});
</file>

<file path="e2e/e2e.spec.ts">
import type {ElectronApplication, JSHandle} from 'playwright';
import {_electron as electron} from 'playwright';
import {expect, test as base} from '@playwright/test';
import type {BrowserWindow} from 'electron';
import glob from 'glob';
import {platform} from 'node:process';
import {createHash} from 'node:crypto';
process.env.PLAYWRIGHT_TEST = 'true';
// Declare the types of your fixtures.
type TestFixtures = {
  electronApp: ElectronApplication;
  electronVersions: NodeJS.ProcessVersions;
};
const test = base.extend<TestFixtures>({
  electronApp: [async ({}, use) => {
    /**
     * Executable path depends on root package name!
     */
    let executablePattern = 'dist/*/root{,.*}';
    if (platform === 'darwin') {
      executablePattern += '/Contents/*/root';
    }
    const [executablePath] = glob.sync(executablePattern);
    if (!executablePath) {
      throw new Error('App Executable path not found');
    }
    const electronApp = await electron.launch({
      executablePath: executablePath,
      args: ['--no-sandbox'],
    });
    electronApp.on('console', (msg) => {
      if (msg.type() === 'error') {
        console.error(`[electron][${msg.type()}] ${msg.text()}`);
      }
    });
    await use(electronApp);
    // This code runs after all the tests in the worker process.
    await electronApp.close();
  }, {scope: 'worker', auto: true} as any],
  page: async ({electronApp}, use) => {
    const page = await electronApp.firstWindow();
    // capture errors
    page.on('pageerror', (error) => {
      console.error(error);
    });
    // capture console messages
    page.on('console', (msg) => {
      console.log(msg.text());
    });
    await page.waitForLoadState('load');
    await use(page);
  },
  electronVersions: async ({electronApp}, use) => {
    await use(await electronApp.evaluate(() => process.versions));
  },
});
test('Main window state', async ({electronApp, page}) => {
  const window: JSHandle<BrowserWindow> = await electronApp.browserWindow(page);
  const windowState = await window.evaluate(
    (mainWindow): Promise<{isVisible: boolean; isDevToolsOpened: boolean; isCrashed: boolean}> => {
      const getState = () => ({
        isVisible: mainWindow.isVisible(),
        isDevToolsOpened: mainWindow.webContents.isDevToolsOpened(),
        isCrashed: mainWindow.webContents.isCrashed(),
      });
      return new Promise(resolve => {
        /**
         * The main window is created hidden, and is shown only when it is ready.
         * See {@link ../packages/main/src/mainWindow.ts} function
         */
        if (mainWindow.isVisible()) {
          resolve(getState());
        } else {
          mainWindow.once('ready-to-show', () => resolve(getState()));
        }
      });
    },
  );
  expect(windowState.isCrashed, 'The app has crashed').toEqual(false);
  expect(windowState.isVisible, 'The main window was not visible').toEqual(true);
  expect(windowState.isDevToolsOpened, 'The DevTools panel was open').toEqual(false);
});
test.describe('Main window web content', async () => {
  test('The main window has an interactive button', async ({page}) => {
    const element = page.getByRole('button');
    await expect(element).toBeVisible();
    await expect(element).toHaveText('count is 0');
    await element.click();
    await expect(element).toHaveText('count is 1');
  });
  test('The main window has a vite logo', async ({page}) => {
    const element = page.getByAltText('Vite logo');
    await expect(element).toBeVisible();
    await expect(element).toHaveRole('img');
    const imgState = await element.evaluate((img: HTMLImageElement) => img.complete);
    const imgNaturalWidth = await element.evaluate((img: HTMLImageElement) => img.naturalWidth);
    expect(imgState).toEqual(true);
    expect(imgNaturalWidth).toBeGreaterThan(0);
  });
});
test.describe('Preload context should be exposed', async () => {
  test.describe(`versions should be exposed`, async () => {
    test('with same type`', async ({page}) => {
const type = await page.evaluate(() => typeof (globalThis as any)[btoa('versions')]);
      expect(type).toEqual('object');
    });
    test('with same value', async ({page, electronVersions}) => {
const value = await page.evaluate(() => (globalThis as any)[btoa('versions')]);
      expect(value).toEqual(electronVersions);
    });
  });
  test.describe(`sha256sum should be exposed`, async () => {
    test('with same type`', async ({page}) => {
const type = await page.evaluate(() => typeof (globalThis as any)[btoa('sha256sum')]);
      expect(type).toEqual('function');
    });
    test('with same behavior', async ({page}) => {
      const testString = btoa(`${Date.now() * Math.random()}`);
      const expectedValue = createHash('sha256').update(testString).digest('hex');
      const value = await page.evaluate((str) => (globalThis as any)[btoa('sha256sum')](str), testString);
      expect(value).toEqual(expectedValue);
    });
  });
  test.describe(`send should be exposed`, async () => {
    test('with same type`', async ({page}) => {
const type = await page.evaluate(() => typeof (globalThis as any)[btoa('send')]);
      expect(type).toEqual('function');
    });
    test('with same behavior', async ({page, electronApp}) => {
      await electronApp.evaluate(async ({ipcMain}) => {
        ipcMain.handle('test', (event, message) => btoa(message));
      });
      const testString = btoa(`${Date.now() * Math.random()}`);
      const expectedValue = btoa(testString);
      const value = await page.evaluate(async (str) => await (globalThis as any)[btoa('send')]('test', str), testString);
      expect(value).toEqual(expectedValue);
    });
  });
});
</file>

<file path="e2e/playwright.config.ts">
import { defineConfig } from '@playwright/test';
export default defineConfig({
  testDir: './dist',
  timeout: 120000,
  expect: {
    timeout: 30000,
  },
  fullyParallel: false,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: 1,
  reporter: 'list',
  use: {
    headless: false,
    viewport: { width: 1280, height: 720 },
    actionTimeout: 60000,
    navigationTimeout: 60000,
    ignoreHTTPSErrors: true,
    video: 'retain-on-failure',
  },
  projects: [
    {
      name: 'electron',
      testMatch: /.*\.spec\.js/,
    }
  ],
});
</file>

<file path="e2e/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ES2020",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist",
    "rootDir": ".",
    "baseUrl": ".",
    "paths": {
      "*": ["node_modules/*"]
    }
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/electron-versions/index.js">
import {execSync} from 'node:child_process';
function getElectronEnv() {
  return JSON.parse(execSync(
    `npx electron -p "JSON.stringify(process.versions)"`,
    {
      encoding: 'utf-8',
      env: {
        ...process.env,
        ELECTRON_RUN_AS_NODE: 1,
      }
    }
  ));
}
function createElectronEnvLoader() {
  let inMemoryCache = null;
  return () => {
    if (inMemoryCache) {
      return inMemoryCache;
    }
    return inMemoryCache = getElectronEnv();
  }
}
const envLoader = createElectronEnvLoader();
export function getElectronVersions() {
  return envLoader();
}
export function getChromeVersion() {
  return getElectronVersions().chrome;
}
export function getChromeMajorVersion() {
  return getMajorVersion(getChromeVersion());
}
export function getNodeVersion() {
  return getElectronVersions().node;
}
export function getNodeMajorVersion() {
  return getMajorVersion(getNodeVersion());
}
function getMajorVersion(version) {
  return parseInt(version.split('.')[0]);
}
</file>

<file path="packages/electron-versions/package.json">
{
  "name": "@app/electron-versions",
  "type": "module",
  "files": [],
  "main": "./index.js",
  "description": "A set of helper functions to get the versions of internal components bundled within Electron"
}
</file>

<file path="packages/electron-versions/README.md">
# @app/electron-versions

## Description

A set of helper functions to get the versions of internal components bundled within Electron.

## Installation

To install this package, use the following command:

```bash
npm install -D @app/electron-versions
```

## Usage

Import the functions you need from the package:

```javascript
import {
  getElectronVersions,
  getChromeVersion,
  getNodeVersion,
  getChromeMajorVersion,
  getNodeMajorVersion
} from '@app/electron-versions';

// Example usage
console.log('Electron Versions:', getElectronVersions());
console.log('Chromium Version:', getChromeVersion());
console.log('Node.js Version:', getNodeVersion());
console.log('Chromium Major Version:', getChromeMajorVersion());
console.log('Node.js Major Version:', getNodeMajorVersion());
```

## API

- **getElectronVersions()**: Returns an object containing the versions of the internal components bundled within Electron.
- **getChromeVersion()**: Returns the version of Chromium bundled within Electron.
- **getChromeMajorVersion()**: Returns the major version number of Chromium bundled within Electron.
- **getNodeVersion()**: Returns the version of Node.js bundled within Electron.
- **getNodeMajorVersion()**: Returns the major version number of Node.js bundled within Electron.

## Example

An example of how you might use this package in a Vite configuration:

```javascript
import { getChromeMajorVersion } from '@app/electron-versions';

export default {
  build: {
    target: `chrome${getChromeMajorVersion()}`,
    // other Vite configurations...
  },
  // other configurations...
};
```

### Explanation of `target`

The `target` parameter in Vite specifies the browser or environment versions that the output should be compatible with. In the provided example, `target: chrome${getChromeMajorVersion()}` ensures that the build output is compatible with the specific major version of Chromium that is bundled with your Electron application. This can help optimize the final bundle and ensure compatibility within the Electron environment.

## License

MIT
</file>

<file path="packages/main/src/index.ts">
import { app, ipcMain } from 'electron';
import { createWindowManagerModule } from './modules/WindowManager.js';
import { ipcHandlers } from './ipcHandlers.js';
export async function initApp(initConfig: { preload: { path: string }; renderer: { path: string } | URL }) {
  console.log('Main process starting with initConfig:', initConfig);
  // Register IPC handlers
  ipcHandlers.forEach(({ channel, handler }) => {
    ipcMain.handle(channel, handler);
    console.log(`Registered IPC handler for channel: ${channel}`);
  });
  // Initialize and enable the window manager module with proper config
  const windowManager = createWindowManagerModule({
    initConfig,
    openDevTools: process.env.NODE_ENV === 'development',
  });
  await windowManager.enable({ app });
}
</file>

<file path="packages/main/package.json">
{
  "name": "@electron-app/shared",
  "version": "1.0.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc -w"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
</file>

<file path="packages/main/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true
  },
  "include": ["src/**/*"]
}
</file>

<file path="packages/main/vite.config.ts">
import { defineConfig } from 'vite';
import path from 'path';
export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, 'src/index.ts'),
      formats: ['cjs'],
      fileName: () => 'index.js',
    },
    outDir: 'dist',
    emptyOutDir: true,
    minify: false,
    sourcemap: true,
    rollupOptions: {
      external: [
        'electron',
        ...require('module').builtinModules,
      ],
      output: {
        entryFileNames: 'index.js',
      },
    },
    target: 'node16',
  },
});
</file>

<file path="packages/preload/src/exposed.ts">
import { contextBridge, ipcRenderer } from 'electron';
// Type definitions for better type safety
interface StreamListeners {
  onChunk: (callback: (chunk: string) => void) => () => void;
  onEnd: (callback: (fullText: string) => void) => () => void;
  onError: (callback: (error: string) => void) => () => void;
}
interface ElectronAPI {
  // Chat functionality
  sendMessage: (message: string) => Promise<{ success: boolean; data?: string; error?: string }>;
  sendMessageStream: (message: string) => Promise<{ success: boolean; error?: string }>;
  // Health check
  healthCheck: () => Promise<{ status: string; timestamp: number }>;
  // Stream listeners with cleanup
  stream: StreamListeners;
  // Ollama API
  ollama: {
    listModels: () => Promise<string[]>;
    setModel: (modelName: string) => Promise<boolean>;
    checkConnection: () => Promise<boolean>;
  };
  // Utility functions
  removeAllListeners: (channel?: string) => void;
}
// Channel constants for centralized management
const CHANNELS = {
  CHAT: {
    SEND_MESSAGE: 'chat:send-message',
    SEND_MESSAGE_STREAM: 'chat:send-message-stream',
    STREAM_CHUNK: 'chat:stream-chunk',
    STREAM_END: 'chat:stream-end',
    STREAM_ERROR: 'chat:stream-error',
    GET_CONVERSATIONS: 'chat:get-conversations',
    GET_CONVERSATION: 'chat:get-conversation',
    CREATE_CONVERSATION: 'chat:create-conversation',
    UPDATE_CONVERSATION_TITLE: 'chat:update-conversation-title',
    MESSAGE_RECEIVED: 'chat:message-received',
  },
  APP: {
    HEALTH_CHECK: 'app:health-check'
  },
  OLLAMA: {
    LIST_MODELS: 'ollama:list-models',
    SET_MODEL: 'ollama:set-model',
    CHECK_CONNECTION: 'ollama:check-connection',
    CANCEL_LOAD: 'ollama:cancel-load',
    MODEL_LOADING_STATE_CHANGED: 'ollama:model-loading-state-changed'
  }
} as const;
// Helper function for safe IPC calls with error handling
const safeInvoke = async <T>(channel: string, ...args: any[]): Promise<T> => {
  try {
    return await ipcRenderer.invoke(channel, ...args);
  } catch (error) {
    console.error(`IPC invoke failed for channel ${channel}:`, error);
    throw error;
  }
};
// Helper for creating stream listeners that return cleanup functions
const createStreamListener = (channel: string) => 
  (callback: (data: any) => void): (() => void) => {
    const listener = (_event: Electron.IpcRendererEvent, data: any) => callback(data);
    ipcRenderer.on(channel, listener);
    // Return cleanup function
    return () => ipcRenderer.removeListener(channel, listener);
  };
// Create the API object
const electronAPI: ElectronAPI = {
  // Chat functionality
  sendMessage: (message: string) => 
    safeInvoke(CHANNELS.CHAT.SEND_MESSAGE, message),
  sendMessageStream: (message: string) => 
    safeInvoke(CHANNELS.CHAT.SEND_MESSAGE_STREAM, message),
  // Health check
  healthCheck: () => 
    safeInvoke(CHANNELS.APP.HEALTH_CHECK),
  // Stream listeners
  stream: {
    onChunk: createStreamListener(CHANNELS.CHAT.STREAM_CHUNK),
    onEnd: createStreamListener(CHANNELS.CHAT.STREAM_END),
    onError: createStreamListener(CHANNELS.CHAT.STREAM_ERROR),
  },
  // Ollama API
  ollama: {
    listModels: () => safeInvoke(CHANNELS.OLLAMA.LIST_MODELS),
    setModel: (modelName: string) => safeInvoke(CHANNELS.OLLAMA.SET_MODEL, modelName),
    checkConnection: () => safeInvoke(CHANNELS.OLLAMA.CHECK_CONNECTION),
  },
  // Utility for cleanup
  removeAllListeners: (channel?: string) => {
    if (channel) {
      ipcRenderer.removeAllListeners(channel);
    } else {
      // Remove all listeners for stream channels
      Object.values(CHANNELS.CHAT).forEach(ch => 
        ipcRenderer.removeAllListeners(ch)
      );
    }
  },
};
// Expose the API to the renderer process
contextBridge.exposeInMainWorld('electronAPI', electronAPI);
// Expose version information for debugging
contextBridge.exposeInMainWorld('versions', {
  node: process.versions.node,
  chrome: process.versions.chrome,
  electron: process.versions.electron,
});
// Add development helpers
if (process.env.NODE_ENV === 'development') {
  contextBridge.exposeInMainWorld('__electronDebug', {
    listChannels: () => Object.values(CHANNELS).flatMap(obj => Object.values(obj)),
    ipcRenderer: {
      // Safe subset for debugging
      listenerCount: (channel: string) => ipcRenderer.listenerCount(channel),
    },
  });
}
</file>

<file path="packages/preload/vite.config.ts">
import { defineConfig } from 'vite';
import path from 'path';
export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, 'src/exposed.ts'),
      formats: ['cjs'],
      fileName: () => 'exposed.js',
    },
    outDir: 'dist',
    emptyOutDir: true,
    minify: false,
    sourcemap: true,
    rollupOptions: {
      external: [
        'electron',
        ...require('module').builtinModules,
      ],
      output: {
        entryFileNames: 'exposed.js',
      },
    },
    target: 'node16',
  },
});
</file>

<file path="packages/renderer/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="packages/renderer/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="packages/renderer/src/components/__tests__/basic-react.test.tsx">
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { JSDOM } from 'jsdom';
import React from 'react';
import ReactDOM from 'react-dom/client';
describe('Basic React Test', () => {
  let dom: JSDOM;
  let root: HTMLElement;
  beforeAll(() => {
    dom = new JSDOM('<!doctype html><html><body><div id="root"></div></body></html>');
    global.window = dom.window as unknown as Window & typeof globalThis;
    global.document = dom.window.document;
    root = document.getElementById('root')!;
  });
  afterAll(() => {
    (global.window as any).close();
  });
  test('can render basic React component', async () => {
    const TestComponent = () => <div data-testid="test-div">Hello</div>;
    const rootInstance = ReactDOM.createRoot(root);
    rootInstance.render(<TestComponent />);
    // Wait for React to finish rendering
    await new Promise(resolve => setTimeout(resolve, 0));
    const testDiv = document.querySelector('[data-testid="test-div"]');
    expect(testDiv).toBeDefined();
    expect(testDiv?.textContent).toBe('Hello');
  });
});
</file>

<file path="packages/renderer/src/components/__tests__/chat-integration.test.tsx">
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { JSDOM } from 'jsdom';
import React from 'react';
import ReactDOM from 'react-dom/client';
import { MockChatContainer } from './MockChatContainer';
describe('Chat Integration Test', () => {
  let dom: JSDOM;
  let root: HTMLElement;
  beforeAll(() => {
    dom = new JSDOM('<!doctype html><html><body><div id="root"></div></body></html>');
    global.window = dom.window as unknown as Window & typeof globalThis;
    global.document = dom.window.document;
    root = document.getElementById('root')!;
  });
  afterAll(() => {
    (global.window as any).close();
  });
  let rootInstance: ReactDOM.Root;
  beforeAll(() => {
    rootInstance = ReactDOM.createRoot(root);
  });
  test('renders chat container', async () => {
    rootInstance.render(<MockChatContainer />);
    await new Promise(resolve => setTimeout(resolve, 50));
    const input = document.querySelector('[data-testid="chat-input"]');
    const button = document.querySelector('[data-testid="send-button"]');
    expect(input).toBeInstanceOf(dom.window.HTMLInputElement);
    expect(button).toBeInstanceOf(dom.window.HTMLButtonElement);
  });
  test('allows typing in input', async () => {
    rootInstance.render(<MockChatContainer />);
    await new Promise(resolve => setTimeout(resolve, 50));
    const input = document.querySelector('[data-testid="chat-input"]') as HTMLInputElement;
    input.value = 'Test message';
    expect(input.value).toBe('Test message');
  });
});
</file>

<file path="packages/renderer/src/components/__tests__/Chat.test.tsx">
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/vitest';
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { JSDOM } from 'jsdom';
import { MockChatContainer } from './MockChatContainer';
// Set up DOM environment
beforeAll(() => {
  const dom = new JSDOM('<!doctype html><html><body></body></html>');
  global.window = dom.window as unknown as Window & typeof globalThis;
  global.document = dom.window.document;
});
afterAll(() => {
  (global.window as any).close();
});
// Set up basic DOM environment before tests
beforeAll(() => {
  const dom = new JSDOM('<!doctype html><html><body></body></html>', {
    url: 'http://localhost'
  });
  (global as any).window = dom.window;
  (global as any).document = dom.window.document;
  (global as any).navigator = dom.window.navigator;
});
// Clean up after tests
afterAll(() => {
  (global as any).window.close();
});
describe('Chat component', () => {
  test('renders input and send button', async () => {
    render(<MockChatContainer />);
    await new Promise(resolve => setTimeout(resolve, 0)); // Wait for React render
    const input = screen.getByTestId('chat-input');
    const button = screen.getByTestId('send-button');
    expect(input).toBeInTheDocument();
    expect(button).toBeInTheDocument();
  });
  test('allows user to type in input', async () => {
    render(<MockChatContainer />);
    await new Promise(resolve => setTimeout(resolve, 0)); // Wait for React render
    const input = screen.getByTestId('chat-input');
    fireEvent.change(input, { target: { value: 'Hello' } });
    expect(input).toHaveValue('Hello');
  });
});
</file>

<file path="packages/renderer/src/components/__tests__/dom-integration.test.ts">
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { JSDOM } from 'jsdom';
describe('DOM Integration Test', () => {
  let dom: JSDOM;
  beforeAll(() => {
    dom = new JSDOM(`
      <!DOCTYPE html>
      <html>
        <body>
          <div id="root"></div>
        </body>
      </html>
    `, {
      url: 'http://localhost',
      runScripts: 'dangerously'
    });
    global.window = dom.window as unknown as Window & typeof globalThis;
    global.document = dom.window.document;
    global.navigator = dom.window.navigator;
  });
  afterAll(() => {
    dom.window.close();
  });
  test('can create and query DOM elements', () => {
    const div = document.createElement('div');
    div.id = 'test-element';
    document.body.appendChild(div);
    const found = document.getElementById('test-element');
    expect(found).toBeDefined();
    expect(found?.id).toBe('test-element');
  });
});
</file>

<file path="packages/renderer/src/components/__tests__/dom.test.ts">
import { describe, test, expect } from 'vitest';
describe('Basic DOM tests', () => {
  test('document exists', () => {
    expect(document).toBeDefined();
    expect(document.createElement).toBeDefined();
  });
  test('can create and append elements', () => {
    const div = document.createElement('div');
    div.textContent = 'Hello World';
    document.body.appendChild(div);
    const found = document.querySelector('div');
    expect(found).toBeDefined();
    expect(found?.textContent).toBe('Hello World');
    document.body.removeChild(div);
  });
});
</file>

<file path="packages/renderer/src/components/__tests__/isolated-chat.test.tsx">
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { JSDOM } from 'jsdom';
import React from 'react';
import ReactDOM from 'react-dom/client';
describe('Isolated Chat Test', () => {
  let dom: JSDOM;
  let root: HTMLElement;
  beforeAll(() => {
    dom = new JSDOM('<!doctype html><html><body><div id="root"></div></body></html>');
    global.window = dom.window as unknown as Window & typeof globalThis;
    global.document = dom.window.document;
    root = document.getElementById('root')!;
  });
  afterAll(() => {
    (global.window as any).close();
  });
  test('renders basic chat UI', async () => {
    const TestComponent = () => (
      <div>
        <input data-testid="test-input" />
        <button data-testid="test-button">Send</button>
      </div>
    );
    const rootInstance = ReactDOM.createRoot(root);
    rootInstance.render(<TestComponent />);
    // Wait for React to finish rendering
    await new Promise(resolve => setTimeout(resolve, 50));
    const input = document.querySelector('[data-testid="test-input"]');
    const button = document.querySelector('[data-testid="test-button"]');
    expect(input).toBeInstanceOf(dom.window.HTMLInputElement);
    expect(button).toBeInstanceOf(dom.window.HTMLButtonElement);
    expect(button?.textContent).toBe('Send');
  });
});
</file>

<file path="packages/renderer/src/components/__tests__/manual-dom.test.ts">
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { JSDOM } from 'jsdom';
describe('Manual DOM tests', () => {
  let dom: JSDOM;
  beforeAll(() => {
    // Create a basic DOM environment
    dom = new JSDOM('<!doctype html><html><body></body></html>', {
      url: 'http://localhost'
    });
    // Assign to global scope
    (global as any).window = dom.window;
    (global as any).document = dom.window.document;
    (global as any).navigator = dom.window.navigator;
  });
  afterAll(() => {
    // Clean up
    dom.window.close();
  });
  test('document exists', () => {
    expect(document).toBeDefined();
    expect(document.createElement).toBeDefined();
  });
  test('can create and append elements', () => {
    const div = document.createElement('div');
    div.textContent = 'Hello World';
    document.body.appendChild(div);
    const found = document.querySelector('div');
    expect(found).toBeDefined();
    expect(found?.textContent).toBe('Hello World');
    document.body.removeChild(div);
  });
});
</file>

<file path="packages/renderer/src/components/__tests__/MockChatContainer.tsx">
import React, { FC } from 'react';
interface MockChatContainerProps {
  testId?: string;
}
export const MockChatContainer: FC<MockChatContainerProps> = ({ testId = 'mock-chat' }) => {
  return (
    <div data-testid={testId}>
      <input 
        data-testid="chat-input"
        placeholder="type your message"
      />
      <button data-testid="send-button">
        Send
      </button>
    </div>
  );
};
</file>

<file path="packages/renderer/src/components/__tests__/simple-chat.test.tsx">
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { render, screen } from '@testing-library/react';
import React from 'react';
import { JSDOM } from 'jsdom';
// Set up DOM environment
beforeAll(() => {
  const dom = new JSDOM('<!doctype html><html><body></body></html>');
  global.window = dom.window as unknown as Window & typeof globalThis;
  global.document = dom.window.document;
});
afterAll(() => {
  (global.window as any).close();
});
// Simple component that doesn't depend on project internals
const SimpleChat = () => (
  <div>
    <input data-testid="simple-input" />
    <button data-testid="simple-button">Send</button>
  </div>
);
describe('Simple Chat Test', () => {
  test('renders input and button', () => {
    render(<SimpleChat />);
    expect(screen.getByTestId('simple-input')).toBeInTheDocument();
    expect(screen.getByTestId('simple-button')).toBeInTheDocument();
  });
});
</file>

<file path="packages/renderer/src/components/AppHeader.tsx">
import React from 'react';
export default function AppHeader() {
  console.log('[DEBUG] AppHeader mounting');
  return (
    <div className="bg-blue-500/20 p-4 w-full">
      <div className="bg-blue-500/30 p-4 rounded">
        AppHeader 
      </div>
    </div>
  );
}
</file>

<file path="packages/renderer/src/components/AppLayout.tsx">
import React from 'react';
import { Toaster } from 'react-hot-toast';
import { ThemeProvider } from '../contexts/ThemeContext';
import ErrorBoundary from './ErrorBoundary';
import AppHeader from './AppHeader';
import { LayoutLeftSidebar } from './LayoutLeftSidebar';
import { ChatUI } from './ChatUI';
export const AppLayout: React.FC = () => {
  console.log('[DEBUG] AppLayout mounting');
  return (
    <ThemeProvider>
      <Toaster position="top-right" />
      <div className="flex flex-col h-screen bg-gradient-to-br from-indigo-50 to-purple-50 dark:from-gray-900 dark:to-gray-800">
        <AppHeader />
        <div className="flex flex-1 overflow-hidden">
          <LayoutLeftSidebar />
          <main className="flex-1 overflow-hidden">
            <ErrorBoundary>
              <ChatUI />
            </ErrorBoundary>
          </main>
        </div>
      </div>
    </ThemeProvider>
  );
};
export default AppLayout;
</file>

<file path="packages/renderer/src/components/Chat.tsx">
import React from 'react';
import ChatContainer from './ChatContainer';
export const Chat: React.FC = () => {
  return <ChatContainer />;
};
export default Chat;
</file>

<file path="packages/renderer/src/components/ChatContainer.tsx">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Paperclip, X } from 'lucide-react';
// Import necessary hooks and utilities we've built
import { useTheme } from '../contexts/ThemeContext';
import { useMemory } from '../hooks/useMemory';
import toast from 'react-hot-toast';
import { ipcRenderer } from 'electron';
// MemoryChunk interface (matches main process structure)
interface MemoryChunk {
  id: string;
  content: string;
  metadata: {
    timestamp: number;
    source: string;
    type: string;
    tags?: string[];
    [key: string]: any;
  };
}
// MemoryState interface
interface MemoryState {
  isInitialized: boolean;
  isLoading: boolean;
  error: string | null;
  searchMemory: (query: string, options?: { limit?: number }) => Promise<MemoryChunk[]>;
  storeMemory: (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>) => Promise<{ success: boolean; id?: string; error?: string }>;
  getRecentMemories: (limit?: number) => Promise<MemoryChunk[]>;
}
// MemoryAPI interface
interface MemoryAPI {
  initialize: () => Promise<{ success: boolean; error?: string }>;
  store: (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>) => Promise<{ success: boolean; id?: string; error?: string }>;
  search: (query: string, options?: { limit?: number }) => Promise<{ success: boolean; results?: MemoryChunk[]; error?: string }>;
  getRecent: (limit?: number) => Promise<{ success: boolean; results?: MemoryChunk[]; error?: string }>;
}
// Declare global window properties for Electron and Memory APIs
declare global {
  interface Window {
    memoryAPI: MemoryAPI;
  }
}
export default function ChatContainer() {
  // Use theme hook
  const { theme, toggleTheme } = useTheme();
  // Use memory hook
  const { isInitialized: isMemoryInitialized, isLoading: isMemoryLoading, error: memoryError, searchMemory, storeMemory } = useMemory();
  // File upload state (keep for now, backend not implemented)
  const [uploads, setUploads] = useState<File[]>([]);
  // Chat state
  const [messages, setMessages] = useState<{ role: 'user' | 'assistant'; content: string; animate?: boolean; timestamp: number }[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false); // Combined loading for chat and memory search
  const [streaming, setStreaming] = useState(false); // Indicates if the assistant is currently streaming
  const [currentAssistant, setCurrentAssistant] = useState(''); // Holds the partial streaming response
  const [streamData, setStreamData] = useState('');
  // Refs
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  // Effects
  useEffect(() => {
    // Auto-scroll to bottom on new messages or streaming updates
    scrollToBottom();
  }, [messages, streaming, currentAssistant]);
  useEffect(() => {
    // Set focus to input when loading is false
    if (!loading && inputRef.current) {
      inputRef.current.focus();
    }
  }, [loading]);
  useEffect(() => {
    // Define handler functions with explicit types
    const handleStreamChunk = (event: Electron.IpcRendererEvent, chunk: string) => {
      setStreamData(prev => prev + chunk);
    };
    const handleStreamEnd = (event: Electron.IpcRendererEvent) => { // event param type
      console.log('Stream ended');
      // Optional: Set a state to indicate stream is complete
    };
    const handleStreamError = (event: Electron.IpcRendererEvent, error: string) => {
      console.error('Stream error:', error);
      // Optional: Display error in UI
    };
    // Subscribe to IPC events
    ipcRenderer.on('ollama-stream', handleStreamChunk);
    ipcRenderer.on('ollama-stream-end', handleStreamEnd as any); // Type assertion if needed
    ipcRenderer.on('ollama-stream-error', handleStreamError);
    // Example: Send a test query to trigger the stream
    // In a real app, this would be triggered by user input
    // ipcRenderer.invoke('ollama-query', 'Tell me a short story.');
    // Cleanup listeners on component unmount
    return () => {
      ipcRenderer.removeListener('ollama-stream', handleStreamChunk);
      ipcRenderer.removeListener('ollama-stream-end', handleStreamEnd as any); // Type assertion if needed
      ipcRenderer.removeListener('ollama-stream-error', handleStreamError);
    };
  }, []); // Empty dependency array means this effect runs once on mount
  // Handlers
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    setUploads((prev) => [...prev, ...files]);
    // TODO: Implement backend IPC to handle file processing
  };
  const removeFile = (index: number) => {
    setUploads((prev) => prev.filter((_, i) => i !== index));
  };
  const handleCopy = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success('Copied to clipboard!');
  };
  const formatTime = (timestamp: number) => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };
  const handleSend = async () => {
    if (!input.trim() || loading || !isMemoryInitialized) {
      if (!isMemoryInitialized && !memoryError) {
         toast.error('Memory service is not initialized.');
      }
      return;
    }
    const userMessageContent = input.trim();
    setInput(''); // Clear input immediately
    setLoading(true); // Start loading indicator
    setStreaming(true); // Indicate streaming is expected
    setCurrentAssistant(''); // Clear previous assistant message
    // Add user message to chat history
    setMessages((prev) => [
      ...prev,
      { role: 'user', content: userMessageContent, timestamp: Date.now() },
    ]);
    try {
      // 1. Store user message in memory
      // We don't await this to avoid blocking the chat response, but we track it with toast
      toast.promise(
        storeMemory(userMessageContent, { type: 'conversation', source: 'chat', tags: ['user-input'] }),
        {
          loading: 'Storing user message in memory...',
          success: 'User message stored.',
          error: 'Failed to store user message.',
        }
      );
      // 2. Search for relevant memories based on user input
      const relevantMemories = await toast.promise(
         searchMemory(userMessageContent, { limit: 5 }), // Search for top 5 relevant memories
         {
            loading: 'Searching memories...',
            success: (results) => `Found ${results.length} relevant memories.`, // Toast success message includes count
            error: 'Failed to search memories.',
         }
      );
      // 3. Construct a context-aware prompt
      let context = '';
      if (relevantMemories && relevantMemories.length > 0) {
        context = relevantMemories.map(mem => mem.content).join('\n---\n');
        // Add instructions to the model to use the provided context
        context = `Use the following context to answer the user's question. If you cannot answer the question based on the context, say so.\n\nContext:\n${context}\n\n`;
      }
      const fullPrompt = `${context}User: ${userMessageContent}\nAssistant:`;
      console.log('Full prompt sent to model:', fullPrompt);
      // 4. Send the context-aware prompt to the language model
      await window.electronAPI.sendMessageStream(fullPrompt);
      // Loading will be set to false in handleStreamEnd or handleStreamError
    } catch (error: any) {
      console.error('Error during RAG process:', error);
      toast.error(`Error during RAG process: ${error.message || 'Unknown error'}`);
      setMessages((prev) => [
        ...prev,
        { role: 'assistant', content: `Error: ${error.message || 'Unknown error'}`, timestamp: Date.now() },
      ]);
      setLoading(false); // Ensure loading is false on error
      setStreaming(false); // Ensure streaming is false on error
    }
  };
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };
  // Example button to trigger a query
  const sendTestQuery = () => {
    setStreamData(''); // Clear previous data
    ipcRenderer.invoke('ollama-query', 'Tell me a short story.');
  };
  return (
    <div className="relative flex h-screen w-full text-gray-900 dark:text-gray-100 bg-white dark:bg-gray-900">
      {/* Left Sidebar */}
      <aside className="hidden md:flex flex-col w-64 border-r border-gray-200 dark:border-gray-800 bg-gray-50 dark:bg-gray-950 p-4">
        <h2 className="text-sm font-semibold mb-4">Conversations</h2>
        {/* Sidebar content... */}
        <nav className="space-y-2 text-sm text-gray-700 dark:text-gray-300">
          {/* Placeholder buttons - Replace with actual conversation list */} 
          <button className="w-full text-left hover:text-blue-600">New Chat</button>
          <button className="w-full text-left hover:text-blue-600">History</button>
           {/* Add MemoryChat component here or integrate its functionality if desired */}
            {/* <MemoryChat /> */}
        </nav>
      </aside>
      {/* Main Chat Area */}
      <main className="flex-1 flex flex-col overflow-hidden">
        {/* Header */}
        <header className="border-b border-gray-200 dark:border-gray-800 px-6 py-3 flex items-center justify-between">
          <h1 className="text-lg font-semibold">Chat</h1>
          {/* Theme switcher button - Use our ThemeToggle component */}
           {/* Replace the inline SVG button with ThemeToggle component */}
            <button
              className="cursor-pointer text-gray-500 hover:text-yellow-400"
              aria-label="Toggle theme"
              onClick={toggleTheme} // Use the toggleTheme from useTheme
            >
              {/* Inline SVGs removed - ThemeToggle component will render the appropriate icon */}
               {theme === 'light' ? (
              // Sun SVG placeholder (remove this after integrating ThemeToggle)
              <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="11" cy="11" r="5" fill="#facc15" />
                <g stroke="#facc15" strokeWidth="1.5">
                  <line x1="11" y1="2" x2="11" y2="5" />
                  <line x1="11" y1="17" x2="11" y2="20" />
                  <line x1="2" y1="11" x2="5" y2="11" />
                  <line x1="17" y1="11" x2="20" y2="11" />
                  <line x1="5.64" y1="5.64" x2="7.76" y2="7.76" />
                  <line x1="14.24" y1="14.24" x2="16.36" y2="16.36" />
                  <line x1="5.64" y1="16.36" x2="7.76" y2="14.24" />
                  <line x1="14.24" y1="7.76" x2="16.36" y2="5.64" />
                </g>
              </svg>
            ) : (
              // Moon SVG placeholder (remove this after integrating ThemeToggle)
              <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M17.5 14.5C16.5 15 15.5 15.25 14.5 15.25C11.05 15.25 8.25 12.45 8.25 9C8.25 7.5 8.75 6.1 9.6 5C7.1 5.5 5.25 7.7 5.25 10.25C5.25 13.45 7.8 16 11 16C13.55 16 15.75 14.15 16.25 11.65C16.1 12.5 16.5 13.5 17.5 14.5Z" fill="#facc15" />
              </svg>
            )}
            </button>
        </header>
        {/* Chat Messages */}
        <div className="flex-1 overflow-y-auto px-6 py-6 space-y-6">
          {messages.map((msg, idx) => (
            <div
              key={idx}
              className={`bg-gray-100 dark:bg-gray-800 rounded-xl p-4 max-w-3xl mx-auto ${
                msg.role === 'user' ? 'text-right' : 'text-left'
              }`}
            >
              {/* Assistant avatar */}
              {msg.role === 'assistant' && (
                <div className="mb-2">
                  <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="11" cy="11" r="10" fill="#e0e7ef" stroke="#c7d2fe" strokeWidth="1.5"/>
                    <ellipse cx="7.5" cy="11" rx="1.5" ry="2" fill="#94a3b8"/>
                    <ellipse cx="14.5" cy="11" rx="1.5" ry="2" fill="#94a3b8"/>
                    <rect x="8" y="15" width="6" height="1.5" rx="0.75" fill="#c7d2fe"/>
                    <rect x="9.5" y="6" width="3" height="1.2" rx="0.6" fill="#c7d2fe"/>
                  </svg>
                </div>
              )}
              <p className="whitespace-pre-wrap">{msg.content}</p>
              {/* Copy button for assistant messages */}
              {msg.role === 'assistant' && (
                <button
                  className="mt-2 text-sm text-blue-600 hover:underline"
                  onClick={() => handleCopy(msg.content)}
                >
                  Copy
                </button>
              )}
              {/* Timestamp */}
              <div className="text-xs text-gray-500 mt-1">{formatTime(msg.timestamp)}</div>
            </div>
          ))}
          {streaming && currentAssistant && ( // Show partial streaming response
            <div className="bg-gray-100 dark:bg-gray-800 rounded-xl p-4 max-w-3xl mx-auto text-left flex items-center gap-2">
              {/* Assistant avatar for streaming */}
              <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="11" cy="11" r="10" fill="#e0e7ef" stroke="#c7d2fe" strokeWidth="1.5"/>
                <ellipse cx="7.5" cy="11" rx="1.5" ry="2" fill="#94a3b8"/>
                <ellipse cx="14.5" cy="11" rx="1.5" ry="2" fill="#94a3b8"/>
                <rect x="8" y="15" width="6" height="1.5" rx="0.75" fill="#c7d2fe"/>
                <rect x="9.5" y="6" width="3" height="1.2" rx="0.6" fill="#c7d2fe"/>
              </svg>
              <span>{currentAssistant}</span>
              <div className="typing-indicator flex gap-1 ml-2">
                <span className="dot w-2 h-2 rounded-full bg-gray-500 animate-pulse"></span>
                <span className="dot w-2 h-2 rounded-full bg-gray-500 animate-pulse delay-150"></span>
                <span className="dot w-2 h-2 rounded-full bg-gray-500 animate-pulse delay-300"></span>
              </div>
            </div>
          )}
          {loading && !streaming && !currentAssistant && ( // Show a general loading indicator if not streaming yet
             <div className="flex justify-start">
                 <div className="max-w-[80%] rounded-lg p-4 bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white italic">
                     Processing...
                 </div>
             </div>
         )}
           {/* Display memory service errors and initialization status */}
          {memoryError && (
             <div className="p-2 bg-red-500 text-white text-center text-sm max-w-3xl mx-auto">Memory Service Error: {memoryError}</div>
          )}
           {!isMemoryInitialized && !memoryError && (
               <div className="p-2 bg-yellow-500 text-gray-900 text-center text-sm max-w-3xl mx-auto">Memory Service is initializing...</div>
           )}
          <div ref={messagesEndRef} /> {/* Scroll anchor */}
        </div>
        {/* Upload Bar */}
        {uploads.length > 0 && (
          <div className="w-full border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 px-6 py-2">
            <div className="flex flex-wrap gap-2 max-w-3xl mx-auto">
              {uploads.map((file, i) => (
                <div key={i} className="flex items-center gap-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg px-3 py-1 text-sm">
                  <span>{file.name}</span>
                  <button onClick={() => removeFile(i)}>
                    <X className="w-4 h-4 text-gray-500 hover:text-red-500" />
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
        {/* Input Area */}
        <footer className="w-full border-t border-gray-200 dark:border-gray-800 px-6 py-4 bg-white dark:bg-gray-900">
          <form
            className="mx-auto max-w-3xl flex items-center gap-3 border border-gray-300 dark:border-gray-700 rounded-xl px-4 py-3 shadow-sm bg-white dark:bg-gray-800"
            onSubmit={(e) => {
              e.preventDefault();
              handleSend();
            }}
          >
            {/* Upload Button (keep for now, backend pending) */}
            <label className="cursor-pointer text-gray-500 hover:text-blue-600">
              <Paperclip className="w-5 h-5" />
              <input
                type="file"
                multiple
                className="hidden"
                onChange={handleFileChange}
                 disabled={loading || isMemoryLoading || !isMemoryInitialized} // Disable file upload while processing
              />
            </label>
            {/* Message Input */}
            <textarea
              ref={inputRef}
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={!isMemoryInitialized && !memoryError ? "Initializing memory..." : "Type your message..."}
              className="flex-grow p-2 border-none outline-none bg-transparent text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 resize-none"
              rows={1}
              disabled={loading || isMemoryLoading || !isMemoryInitialized}
            />
            {/* Send Button */}
            <button
              type="submit"
              disabled={loading || isMemoryLoading || !isMemoryInitialized || !input.trim()}
              className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {loading && !streaming ? 'Processing...' : 'Send'}
            </button>
          </form>
        </footer>
      </main>
      {/* Right Sidebar - Placeholder */}
       {/* This can be used for ModelSelector or MemoryChat if needed */}
      <aside className="hidden md:flex flex-col w-64 border-l border-gray-200 dark:border-gray-800 bg-gray-50 dark:bg-gray-950 p-4">
         <h2 className="text-sm font-semibold mb-4">Details</h2>
         {/* Add ModelSelector or other components here */}
      </aside>
    </div>
  );
}
</file>

<file path="packages/renderer/src/components/ChatUI.tsx">
import React from 'react';
export function ChatUI() {
  console.log('[DEBUG] ChatUI mounting');
  return (
    <div className="bg-gray-500/20 p-4 h-full">
      <div className="bg-gray-500/30 p-4 rounded">
        ChatUI 
      </div>
    </div>
  );
}
</file>

<file path="packages/renderer/src/components/ConversationList.tsx">
import React from 'react';
export function ConversationList() {
  console.log('[DEBUG] ConversationList mounting');
  return (
    <div className="bg-red-500/30 p-4 rounded">
      ConversationList 
    </div>
  );
}
</file>

<file path="packages/renderer/src/components/ErrorBoundary.tsx">
import React from 'react';
interface ErrorBoundaryProps {
  children: React.ReactNode;
}
interface ErrorBoundaryState {
  hasError: boolean;
}
class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  state = { hasError: false };
  static getDerivedStateFromError(): ErrorBoundaryState {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    // You can also log the error to an error reporting service
    console.error('Uncaught error:', error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return <div className="error p-4 bg-red-100 text-red-700 rounded">Error occurred. Please refresh.</div>;
    }
    return this.props.children;
  }
}
export default ErrorBoundary;
</file>

<file path="packages/renderer/src/components/LayoutLeftSidebar.tsx">
import React, { useState } from 'react';
import { ConversationList } from './ConversationList';
import { SettingsPanel } from './SettingsPanel';
import { MemoryHealthIndicator } from './MemoryHealthIndicator';
import { ServiceToggle } from './ServiceToggle';
export function LayoutLeftSidebar() {
  console.log('[DEBUG] LayoutLeftSidebar mounting');
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  return (
    <aside className="w-80 bg-red-500/20 backdrop-blur border-r border-white/10 flex flex-col justify-between">
      <div className="p-4 space-y-4">
        <div className="bg-red-500/50 p-2 rounded">
          <ConversationList />
        </div>
        {isSettingsOpen && (
          <div className="animate-fade-in bg-red-500/50 p-2 rounded">
            <SettingsPanel isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />
          </div>
        )}
      </div>
      <div className="p-4 border-t border-white/10">
        <div className="bg-red-500/50 p-2 rounded mb-2">
          <MemoryHealthIndicator />
        </div>
        <div className="bg-red-500/50 p-2 rounded">
          <ServiceToggle />
        </div>
      </div>
    </aside>
  );
}
</file>

<file path="packages/renderer/src/components/MemoryChat.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { useMemory } from '../hooks/useMemory';
// MemoryChunk interface (matches main process structure)
interface MemoryChunk {
  id: string;
  content: string;
  metadata: {
    timestamp: number;
    source: string;
    type: string;
    tags?: string[];
    [key: string]: any; // Allow additional properties
  };
}
const MemoryChat: React.FC = () => {
  const { isInitialized, isLoading, error, storeMemory, searchMemory, getRecentMemories } = useMemory();
  const [message, setMessage] = useState('');
  const [searchQuery, setSearchQuery] = useState('');
  const [memories, setMemories] = useState<MemoryChunk[]>([]);
  const [recentMemories, setRecentMemories] = useState<MemoryChunk[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isStoring, setIsStoring] = useState(false);
  const [isFetchingRecent, setIsFetchingRecent] = useState(false);
  const loadRecentMemories = useCallback(async () => {
    if (!isInitialized || isFetchingRecent) return;
    setIsFetchingRecent(true);
    try {
      const recent = await getRecentMemories(10); // Fetch last 10 recent memories
      setRecentMemories(recent);
    } catch (err) {
      console.error('Failed to load recent memories:', err);
    } finally {
      setIsFetchingRecent(false);
    }
  }, [isInitialized, isFetchingRecent, getRecentMemories]);
  useEffect(() => {
    // Load recent memories on component mount and when initialized
    if (isInitialized) {
      loadRecentMemories();
    }
  }, [isInitialized, loadRecentMemories]);
  const handleStoreMemory = async () => {
    if (!message.trim() || isStoring || !isInitialized) return;
    setIsStoring(true);
    const metadata = {
      type: 'conversation',
      source: 'chat',
      tags: ['user-input'],
    };
    try {
      const id = await storeMemory(message.trim(), metadata);
      if (id) {
        setMessage('');
        // Refresh recent memories after storing
        loadRecentMemories();
      }
    } catch (err) {
      console.error('Failed to store memory:', err);
    } finally {
      setIsStoring(false);
    }
  };
  const handleSearchMemory = async () => {
    if (!searchQuery.trim() || isSearching || !isInitialized) return;
    setIsSearching(true);
    try {
      const results = await searchMemory(searchQuery.trim(), { limit: 5 }); // Search for top 5
      setMemories(results);
    } catch (err) {
      console.error('Failed to search memory:', err);
    } finally {
      setIsSearching(false);
    }
  };
  return (
    <div className="p-4 space-y-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg">
      <h2 className="text-2xl font-bold text-gray-900 dark:text-white">Memory Management</h2>
      {error && (
        <div className="p-4 bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 rounded-md">
          Error: {error}
        </div>
      )}
      {!isInitialized && (
        <div className="p-4 bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 rounded-md">
          Initializing memory service...
        </div>
      )}
      {isLoading && (
         <div className="p-4 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-md">
           Loading...
         </div>
      )}
      {/* Store Memory Section */}
      <div className="space-y-4">
        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">Store Memory</h3>
        <textarea
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Enter text to store in memory..."
          className="w-full p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
          rows={3}
          disabled={!isInitialized || isStoring || isLoading}
        />
        <button
          onClick={handleStoreMemory}
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
          disabled={!isInitialized || isStoring || isLoading || !message.trim()}
        >
          {isStoring ? 'Storing...' : 'Store Memory'}
        </button>
      </div>
      {/* Search Memory Section */}
      <div className="space-y-4">
        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">Search Memory</h3>
        <div className="flex space-x-2">
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Enter search query..."
            className="flex-grow p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            disabled={!isInitialized || isSearching || isLoading}
          />
          <button
            onClick={handleSearchMemory}
            className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 disabled:opacity-50"
            disabled={!isInitialized || isSearching || isLoading || !searchQuery.trim()}
          >
            {isSearching ? 'Searching...' : 'Search'}
          </button>
        </div>
        {memories.length > 0 && (
          <div className="mt-4 space-y-2">
            <h4 className="text-lg font-medium text-gray-700 dark:text-gray-300">Search Results:</h4>
            {memories.map((mem) => (
              <div key={mem.id} className="p-3 border rounded-md dark:border-gray-700 dark:text-gray-300">
                <p className="text-sm font-semibold">Content:</p>
                <p className="text-gray-800 dark:text-gray-200 break-words">{mem.content}</p>
                <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                  Source: {mem.metadata.source}, Type: {mem.metadata.type}, Timestamp: {new Date(mem.metadata.timestamp).toLocaleString()}
                </p>
              </div>
            ))}
          </div>
        )}
         {isInitialized && !isSearching && memories.length === 0 && searchQuery.trim() && (
             <p className="text-sm text-gray-500 dark:text-gray-400">No search results found.</p>
         )}
      </div>
      {/* Recent Memories Section */}
      <div className="space-y-4">
        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">Recent Memories</h3>
         {isFetchingRecent ? (
             <p className="text-sm text-gray-500 dark:text-gray-400">Loading recent memories...</p>
         ) : recentMemories.length === 0 ? (
             <p className="text-sm text-gray-500 dark:text-gray-400">No recent memories found.</p>
         ) : (
            <div className="mt-4 space-y-2">
              {recentMemories.map((mem) => (
                <div key={mem.id} className="p-3 border rounded-md dark:border-gray-700 dark:text-gray-300">
                  <p className="text-sm font-semibold">Content:</p>
                  <p className="text-gray-800 dark:text-gray-200 break-words">{mem.content}</p>
                  <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    Source: {mem.metadata.source}, Type: {mem.metadata.type}, Timestamp: {new Date(mem.metadata.timestamp).toLocaleString()}
                  </p>
                </div>
              ))}
            </div>
         )}
      </div>
    </div>
  );
};
export default MemoryChat;
</file>

<file path="packages/renderer/src/components/MemoryHealthIndicator.tsx">
import React from 'react';
export function MemoryHealthIndicator() {
  console.log('[DEBUG] MemoryHealthIndicator mounting');
  return (
    <div className="bg-red-500/30 p-4 rounded">
      MemoryHealthIndicator 
    </div>
  );
}
</file>

<file path="packages/renderer/src/components/ModelLoadingOverlay.tsx">
import React from 'react';
import { useModelStatus } from '../hooks/useModelStatus';
interface ProgressBarProps {
  value: number;
}
const ProgressBar: React.FC<ProgressBarProps> = ({ value }) => {
  return (
    <div className="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
      <div
        className="h-full bg-blue-600 dark:bg-blue-500 transition-all duration-300 ease-in-out"
        style={{ width: `${value}%` }}
      />
    </div>
  );
};
const OllamaLogo: React.FC<{ className?: string }> = ({ className }) => (
  <svg
    className={className}
    width="48"
    height="48"
    viewBox="0 0 48 48"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M24 4C12.954 4 4 12.954 4 24C4 35.046 12.954 44 24 44C35.046 44 44 35.046 44 24C44 12.954 35.046 4 24 4ZM24 40C15.163 40 8 32.837 8 24C8 15.163 15.163 8 24 8C32.837 8 40 15.163 40 24C40 32.837 32.837 40 24 40Z"
      fill="currentColor"
    />
    <path
      d="M24 12C17.373 12 12 17.373 12 24C12 30.627 17.373 36 24 36C30.627 36 36 30.627 36 24C36 17.373 30.627 12 24 12ZM24 32C19.582 32 16 28.418 16 24C16 19.582 19.582 16 24 16C28.418 16 32 19.582 32 24C32 28.418 28.418 32 24 32Z"
      fill="currentColor"
    />
  </svg>
);
const formatTime = (seconds: number): string => {
  if (seconds < 60) {
    return `${Math.round(seconds)} seconds`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.round(seconds % 60);
  return `${minutes} minute${minutes > 1 ? 's' : ''}${remainingSeconds > 0 ? ` ${remainingSeconds} seconds` : ''}`;
};
export const ModelLoadingOverlay: React.FC = () => {
  const { isLoading, modelName, progress, estimatedTimeRemaining, error } = useModelStatus();
  if (!isLoading) return null;
  const handleCancel = () => {
    // TODO: Implement cancel functionality
    console.log('Cancel model loading');
  };
  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md shadow-xl">
        <div className="flex flex-col items-center space-y-4">
          <div className="text-blue-600 dark:text-blue-400">
            <OllamaLogo className="animate-pulse" />
          </div>
          <h3 className="text-xl font-semibold text-gray-900 dark:text-white">
            Loading {modelName}
          </h3>
          <div className="w-full">
            <ProgressBar value={progress} />
          </div>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            {estimatedTimeRemaining > 0
              ? `About ${formatTime(estimatedTimeRemaining)} remaining`
              : 'Initializing model...'}
          </p>
          {error && (
            <p className="text-sm text-red-600 dark:text-red-400">{error}</p>
          )}
          <button
            onClick={handleCancel}
            className="mt-4 px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};
export default ModelLoadingOverlay;
</file>

<file path="packages/renderer/src/components/ServiceToggle.tsx">
import React from 'react';
export function ServiceToggle() {
  console.log('[DEBUG] ServiceToggle mounting');
  return (
    <div className="bg-red-500/30 p-4 rounded">
      ServiceToggle 
    </div>
  );
}
</file>

<file path="packages/renderer/src/components/SettingsPanel.tsx">
import React from 'react';
interface SettingsPanelProps {
  isOpen: boolean;
  onClose: () => void;
}
export function SettingsPanel({ isOpen, onClose }: SettingsPanelProps) {
  console.log('[DEBUG] SettingsPanel mounting');
  if (!isOpen) return null;
  return (
    <div className="bg-red-500/30 p-4 rounded">
      SettingsPanel 
    </div>
  );
}
</file>

<file path="packages/renderer/src/components/ThemeToggle.tsx">
import React from 'react';
import { useTheme } from '../contexts/ThemeContext';
const ThemeToggle: React.FC = () => {
  const { theme, toggleTheme } = useTheme();
  return (
    <button
      onClick={toggleTheme}
      className="theme-toggle"
      aria-label={`Switch to ${theme === 'light' ? 'dark' : 'light'} theme`}
      title={`Switch to ${theme === 'light' ? 'dark' : 'light'} theme`}
    >
      <div className="theme-toggle-track">
        <div className="theme-toggle-thumb">
          {theme === 'light' ? (
            // Sun icon
            <svg
              className="theme-toggle-icon"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <circle cx="12" cy="12" r="5" />
              <line x1="12" y1="1" x2="12" y2="3" />
              <line x1="12" y1="21" x2="12" y2="23" />
              <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" />
              <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" />
              <line x1="1" y1="12" x2="3" y2="12" />
              <line x1="21" y1="12" x2="23" y2="12" />
              <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" />
              <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" />
            </svg>
          ) : (
            // Moon icon
            <svg
              className="theme-toggle-icon"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" />
            </svg>
          )}
        </div>
      </div>
    </button>
  );
};
export default ThemeToggle;
</file>

<file path="packages/renderer/src/contexts/ThemeContext.tsx">
import React, { createContext, useContext, useEffect, useState } from 'react';
type Theme = 'light' | 'dark';
interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
}
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>(() => {
    // Check localStorage first
    const savedTheme = localStorage.getItem('theme') as Theme;
    if (savedTheme) return savedTheme;
    // Fall back to system preference
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  });
  useEffect(() => {
    // Update localStorage and document attribute when theme changes
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
    // Update meta theme-color for mobile browsers
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
      metaThemeColor.setAttribute('content', theme === 'dark' ? '#1f2937' : '#ffffff');
    }
  }, [theme]);
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
</file>

<file path="packages/renderer/src/hooks/useMemory.ts">
import { useEffect, useState } from 'react';
import toast from 'react-hot-toast';
interface MemoryChunk {
  id: string;
  content: string;
  metadata: {
    timestamp: number;
    source: string;
    type: string;
    tags?: string[];
    [key: string]: any;
  };
}
interface MemoryAPI {
  initialize: () => Promise<{ success: boolean; error?: string }>;
  store: (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>) => Promise<{ success: boolean; id?: string; error?: string }>;
  search: (query: string, options?: { limit?: number }) => Promise<{ success: boolean; results?: MemoryChunk[]; error?: string }>;
  getRecent: (limit?: number) => Promise<{ success: boolean; results?: MemoryChunk[]; error?: string }>;
}
declare global {
  interface Window {
    memoryAPI: MemoryAPI;
  }
}
interface MemoryState {
  isInitialized: boolean;
  isLoading: boolean;
  error: string | null;
  searchMemory: (query: string, options?: { limit?: number }) => Promise<MemoryChunk[]>;
  storeMemory: (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>) => Promise<{ success: boolean; id?: string; error?: string }>;
  getRecentMemories: (limit?: number) => Promise<MemoryChunk[]>;
}
export function useMemory(): MemoryState {
  const [isInitialized, setIsInitialized] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    const initializeMemory = async () => {
      if (window.memoryAPI?.initialize) {
        try {
          const result = await window.memoryAPI.initialize();
          setIsInitialized(result.success);
          setError(result.error || null);
          toast.success('Memory service initialized!');
        } catch (err: any) {
          console.error('Error initializing memory service:', err);
          setError(err.message);
          toast.error(`Failed to initialize memory service: ${err.message}`);
        }
      } else {
        setError('Memory API not exposed in preload script.');
        toast.error('Memory API not available.');
        console.error('Memory API not exposed in preload script.');
      }
      setIsLoading(false);
    };
    initializeMemory();
  }, []);
  const searchMemory = async (query: string, options?: { limit?: number }): Promise<MemoryChunk[]> => {
    if (!window.memoryAPI?.search) {
      throw new Error('Memory API not available');
    }
    const result = await window.memoryAPI.search(query, options);
    if (!result.success) {
      throw new Error(result.error || 'Failed to search memories');
    }
    return result.results || [];
  };
  const storeMemory = async (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>): Promise<{ success: boolean; id?: string; error?: string }> => {
    if (!window.memoryAPI?.store) {
      throw new Error('Memory API not available');
    }
    return window.memoryAPI.store(content, metadata);
  };
  const getRecentMemories = async (limit?: number): Promise<MemoryChunk[]> => {
    if (!window.memoryAPI?.getRecent) {
      throw new Error('Memory API not available');
    }
    const result = await window.memoryAPI.getRecent(limit);
    if (!result.success) {
      throw new Error(result.error || 'Failed to get recent memories');
    }
    return result.results || [];
  };
  return {
    isInitialized,
    isLoading,
    error,
    searchMemory,
    storeMemory,
    getRecentMemories
  };
}
</file>

<file path="packages/renderer/src/hooks/useModelStatus.ts">
import { useState, useEffect } from 'react';
import { ModelLoadingState } from '../../../shared/ipcTypes';
export function useModelStatus(): ModelLoadingState {
  const [state, setState] = useState<ModelLoadingState>({
    isLoading: false,
    modelName: '',
    progress: 0,
    estimatedTimeRemaining: 0
  });
  useEffect(() => {
    const handleModelLoadingStateChanged = (newState: ModelLoadingState) => {
      setState(newState);
    };
    // Subscribe to model loading state changes
    window.electronAPI.onModelLoadingStateChanged(handleModelLoadingStateChanged);
    return () => {
      // Cleanup subscription
      window.electronAPI.offModelLoadingStateChanged(handleModelLoadingStateChanged);
    };
  }, []);
  return state;
}
</file>

<file path="packages/renderer/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}
.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}
@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}
.card {
  padding: 2em;
}
.read-the-docs {
  color: #888;
}
</file>

<file path="packages/renderer/src/App.jsx">
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'
function App() {
  const [count, setCount] = useState(0)
  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.jsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}
export default App
</file>

<file path="packages/renderer/src/electronAPI.d.ts">
export {}; // This ensures the file is treated as a module
interface ModelLoadingState {
  isLoading: boolean;
  modelName: string;
  progress: number;
  estimatedTimeRemaining: number;
  error?: string;
}
interface ElectronAPI {
  sendMessage: (message: string) => Promise<string>;
  healthCheck: () => Promise<{ status: string; timestamp: number }>;
  onStreamChunk: (callback: (chunk: string) => void) => void;
  onStreamEnd: (callback: (fullText: string) => void) => void;
  onStreamError: (callback: (error: string) => void) => void;
  sendMessageStream: (message: string) => Promise<void>;
  onMemoryUpdate: (callback: (memory: any) => void) => void;
  onMemoryError: (callback: (error: string) => void) => void;
  onMemoryInitialized: (callback: () => void) => void;
  onMemoryLoading: (callback: (isLoading: boolean) => void) => void;
  onMemoryStored: (callback: (memory: any) => void) => void;
  onMemorySearched: (callback: (memories: any[]) => void) => void;
  onMemoryRecent: (callback: (memories: any[]) => void) => void;
  onModelLoadingStateChanged: (callback: (state: ModelLoadingState) => void) => void;
  offModelLoadingStateChanged: (callback: (state: ModelLoadingState) => void) => void;
}
interface OllamaModel {
  name: string;
  modified_at: string;
  size: number;
  digest: string;
  details: {
    format: string;
    family: string;
    parameter_size: string;
    quantization_level: string;
  };
}
interface OllamaAPI {
  listModels: () => Promise<{ models: OllamaModel[] }>;
  setModel: (modelName: string) => Promise<void>;
}
declare global {
  interface Window {
    electronAPI: ElectronAPI;
    ollama: OllamaAPI;
  }
}
</file>

<file path="packages/renderer/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
/* Basic Reset and Body Styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background: linear-gradient(135deg, #f8fafc 0%, #e0e7ef 100%);
  min-height: 100vh;
  color: #111827;
}
/* Theme Variables */
:root {
  --primary-color: #3b82f6;
  --primary-hover: #2563eb;
  --text-color: #1f2937;
  --bg-color: #ffffff;
  --message-bg: #f3f4f6;
  --user-message-bg: #3b82f6;
  --user-message-text: #ffffff;
  --border-color: #e5e7eb;
  --shadow-color: rgba(0, 0, 0, 0.1);
  /* Glassmorphic Variables */
  --glass-ior: 1.5;
  --glass-thickness: 1px;
  --glass-edge-bleed: 0.04;
  --glass-frosting: 0.15;
  --glass-opacity: 0.3;
  --glass-blur: 14px;
  --glass-radius: 18px;
  --glass-shadow: 0 4px 24px rgba(0, 0, 0, 0.25);
  --glass-base-light: oklch(98% 0.02 250);
  --glass-base-dark: oklch(20% 0.02 250);
  --glass-accent-light: oklch(75% 0.25 250);
  --glass-accent-dark: oklch(65% 0.25 250);
  /* Other UI variables */
  --radius-button: 0.5rem;
  --radius-input: 0.5rem;
  --elevation-low: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --elevation-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  /* Light theme */
  --bg-primary: #ffffff;
  --bg-secondary: #f3f4f6;
  --text-primary: #111827;
  --text-secondary: #4b5563;
  --accent-color: #4f46e5;
  --accent-hover: #4338ca;
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
}
[data-theme="dark"] {
  --primary-color: #60a5fa;
  --primary-hover: #3b82f6;
  --text-color: #f3f4f6;
  --bg-color: #1f2937;
  --message-bg: #374151;
  --user-message-bg: #3b82f6;
  --user-message-text: #ffffff;
  --border-color: #4b5563;
  --shadow-color: rgba(0, 0, 0, 0.3);
  /* Glassmorphic Variables - Dark Mode */
  --glass-bg: color-mix(in oklch, var(--glass-base-dark), transparent calc(100% - var(--glass-opacity)));
  --glass-border: color-mix(in oklch, var(--glass-accent-dark), transparent 80%);
  --glass-edge: linear-gradient(to bottom, rgba(0, 0, 0, var(--glass-edge-bleed)), transparent 70%);
  /* Dark theme */
  --bg-primary: #111827;
  --bg-secondary: #1f2937;
  --text-primary: #f9fafb;
  --text-secondary: #d1d5db;
  --accent-color: #60a5fa;
  --accent-hover: #3b82f6;
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4);
}
/* Chat Window */
.chat-window {
  display: flex;
  flex-direction: column;
  height: 100vh;
  padding: 2.5rem 2rem 2rem 2rem; /* Adjusted padding */
  position: relative;
  margin: 2rem auto;
  max-width: 600px; /* Example max width */
  min-height: 80vh;
  background: rgba(255, 255, 255, 0.85); /* Base background */
  box-shadow: 0 8px 32px rgba(60, 60, 60, 0.08), 0 1.5px 6px rgba(0, 0, 0, 0.04); /* Subtle shadow */
  border-radius: 24px; /* Rounded corners */
  border: none; /* Remove default border */
}
[data-theme="dark"] .chat-window {
  background: rgba(30,32,36,0.92);
  box-shadow: 0 8px 32px rgba(0,0,0,0.18), 0 1.5px 6px rgba(0,0,0,0.12);
}
/* Window Controls (macOS style) */
.window-controls {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 10;
  display: flex;
  gap: 0.5rem;
  padding: 8px 12px; /* Adjusted padding */
}
.win-btn {
  width: 12px;
  height: 12px;
  border-radius: 999px; /* Full rounded */
  border: none;
  background: #111; /* Default dark background */
  box-shadow: inset 0 0 2px rgba(255, 255, 255, 0.2), 0 1px 3px rgba(0, 0, 0, 0.6); /* Inner and outer shadow */
  transition: all 0.2s cubic-bezier(0.4,0,0.2,1), background 0.2s cubic-bezier(0.4,0,0.2,1), transform 0.2s cubic-bezier(0.4,0,0.2,1);
  appearance: none; /* Remove default button styles */
  -webkit-appearance: none;
  pointer-events: all;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}
.win-btn svg {
  display: block;
  stroke: #fff; /* White icons */
  stroke-width: 1.5;
}
.win-btn:hover {
  background: #444; /* Darker hover */
  transform: scale(1.18); /* Slight scale up */
  box-shadow: 0 2px 8px rgba(0,0,0,0.18), 0 1px 3px rgba(0,0,0,0.6); /* More prominent shadow on hover */
}
.win-btn.close {
  background: linear-gradient(to bottom, #ff5f57, #e0443e); /* Red gradient */
}
.win-btn.minimize {
  background: linear-gradient(to bottom, #febc2e, #f5a623); /* Yellow gradient */
}
.win-btn.maximize {
  background: linear-gradient(to bottom, #28c840, #1da831); /* Green gradient */
}
/* Theme Switcher */
.theme-switcher {
  position: absolute;
  right: 1rem;
  top: 1rem;
  z-index: 20;
  background: transparent;
  border: none;
  padding: 0.5rem;
  border-radius: 9999px;
  cursor: pointer;
  transition: background-color 0.2s;
}
.theme-switcher:hover {
  background-color: rgba(0, 0, 0, 0.05); /* Subtle hover effect */
}
[data-theme="dark"] .theme-switcher:hover {
  background-color: rgba(255, 255, 255, 0.05); /* Subtle hover effect for dark mode */
}
/* Messages Container */
.messages-container {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 1.5rem; /* Increased gap */
  padding-bottom: 1rem;
  /* No background or border needed here as chat-window has it */
}
/* Message Bubbles */
.message-bubble {
  max-width: 75%;
  border-radius: 0.75rem; /* Rounded corners */
  padding: 1rem;
  position: relative;
  white-space: pre-wrap; /* Preserve whitespace */
  word-break: break-word; /* Break long words */
  animation: popIn 0.32s cubic-bezier(0.16,1,0.3,1); /* Pop in animation */
  box-shadow: 0 2px 12px rgba(0,0,0,0.06); /* Subtle shadow */
  border: none; /* Remove default border */
}
@keyframes popIn {
  0% { opacity: 0; transform: scale(0.95) translateY(16px); }
  60% { opacity: 1; transform: scale(1.04) translateY(-2px); }
  100% { opacity: 1; transform: scale(1) translateY(0); }
}
.message-bubble.user {
  background: linear-gradient(90deg, #2563eb 80%, #60a5fa 100%); /* User message gradient */
  color: white;
  margin-left: auto; /* Align to right */
  box-shadow: 0 2px 12px rgba(37,99,235,0.08); /* User message shadow */
}
.message-bubble.assistant {
  background: rgba(243,244,246,0.85); /* Assistant background */
  color: #111827;
  margin-right: auto; /* Align to left */
  box-shadow: 0 2px 12px rgba(60,60,60,0.06); /* Assistant message shadow */
  display: flex; /* For avatar alignment */
  align-items: flex-start;
  gap: 0.75rem;
}
[data-theme="dark"] .message-bubble.assistant {
  background: rgba(60,62,70,0.85);
  color: #f3f4f6;
}
/* Assistant Avatar */
.assistant-avatar {
  width: 32px; /* Increased size */
  height: 32px; /* Increased size */
  border-radius: 50%;
  background: linear-gradient(135deg, #e0e7ef 0%, #c7d2fe 100%); /* Avatar gradient */
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 4px rgba(60,60,60,0.08); /* Avatar shadow */
  flex-shrink: 0; /* Prevent shrinking */
  animation: avatarPop 0.4s cubic-bezier(0.16,1,0.3,1); /* Pop in animation */
}
@keyframes avatarPop {
  0% { opacity: 0; transform: scale(0.7); }
  100% { opacity: 1; transform: scale(1); }
}
[data-theme="dark"] .assistant-avatar {
  background: linear-gradient(135deg, #23272e 0%, #4f5b7a 100%);
  box-shadow: 0 1px 4px rgba(0,0,0,0.18);
}
/* Copy Button */
.copy-button {
  position: absolute;
  top: 0.25rem;
  right: 0.5rem;
  font-size: 0.75rem;
  color: #9ca3af;
  opacity: 0; /* Hidden by default */
  transition: opacity 0.2s, background 0.2s, transform 0.2s; /* Smooth transition */
  background: transparent;
  border: none;
  padding: 2px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.message-bubble.assistant:hover .copy-button {
  opacity: 1; /* Show on hover */
}
.copy-button:hover {
  background: #e5e7eb; /* Subtle hover background */
  transform: scale(1.15); /* Slight scale effect */
}
[data-theme="dark"] .copy-button {
  color: #b6bac2;
}
[data-theme="dark"] .copy-button:hover {
  background: #23272e;
}
/* Message Timestamp */
.message-timestamp {
  font-size: 0.75rem;
  color: #9ca3af;
  opacity: 0.8; /* Slightly transparent */
  margin-top: 0.5rem;
  text-align: right;
  user-select: none;
}
[data-theme="dark"] .message-timestamp {
  color: #b6bac2;
}
/* Typing Indicator */
.typing-indicator {
  display: inline-flex;
  align-items: center;
  margin-left: 0.5rem;
}
.dot {
  width: 6px;
  height: 6px;
  margin: 0 1.5px; /* Adjusted margin */
  border-radius: 50%;
  background: #b6bac2; /* Dot color */
  animation: blink 1.2s infinite both; /* Blink animation */
}
.dot:nth-child(2) { animation-delay: 0.2s; }
.dot:nth-child(3) { animation-delay: 0.4s; }
@keyframes blink {
  0%, 80%, 100% { opacity: 0.2; }
  40% { opacity: 1; }
}
[data-theme="dark"] .typing-indicator .dot {
  background: #b6bac2;
}
/* Input Form */
.input-form {
  display: flex;
  gap: 0.5rem; /* Adjusted gap */
  border-top: 1px solid #e5e7eb; /* Top border */
  padding-top: 1rem;
}
[data-theme="dark"] .input-form {
  border-top-color: #4b5563;
}
.input-box {
  flex: 1; /* Take available space */
  border: none; /* Remove default border */
  box-shadow: 0 1px 4px rgba(0,0,0,0.04) inset; /* Inner shadow */
  background: rgba(255,255,255,0.95); /* Background */
  border-radius: 0.5rem; /* Rounded corners */
  padding: 0.75rem 1rem; /* Adjusted padding */
  resize: none; /* Disable resizing */
  font-family: inherit;
  font-size: 1rem;
  line-height: 1.5;
  color: #111827;
}
.input-box:focus {
  outline: none; /* Remove default outline */
  box-shadow: 0 0 0 2px #60a5fa; /* Focus ring */
}
[data-theme="dark"] .input-box {
  background: rgba(30,32,36,0.98);
  color: #f3f4f6;
  box-shadow: 0 1px 4px rgba(0,0,0,0.12) inset;
}
[data-theme="dark"] .input-box:focus {
  box-shadow: 0 0 0 2px #60a5fa;
}
/* Send Button */
.send-button {
  border: none; /* Remove default border */
  background: linear-gradient(90deg, #2563eb 80%, #60a5fa 100%); /* Button gradient */
  color: white;
  font-weight: 600;
  border-radius: 0.5rem; /* Rounded corners */
  padding: 0.5rem 1.25rem;
  cursor: pointer;
  transition: background-color 0.2s, opacity 0.2s; /* Smooth transition */
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(37,99,235,0.08); /* Button shadow */
}
.send-button:hover:not(:disabled) {
  background: linear-gradient(90deg, #1d4ed8 80%, #60a5fa 100%); /* Darker hover gradient */
}
.send-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
[data-theme="dark"] .send-button {
  background: linear-gradient(90deg, #2563eb 80%, #60a5fa 100%);
  color: #fff;
  box-shadow: 0 2px 8px rgba(37,99,235,0.18);
}
[data-theme="dark"] .send-button:hover:not(:disabled) {
  background: linear-gradient(90deg, #1d4ed8 80%, #60a5fa 100%);
}
.send-button svg {
  stroke: currentColor;
  stroke-width: 1.5;
  fill: none; /* Ensure fill is none for outline icons */
}
/* Theme Toggle Styles */
.theme-toggle {
  position: relative;
  width: 48px;
  height: 24px;
  padding: 0;
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: 12px;
  transition: transform 0.2s ease;
}
.theme-toggle:hover {
  transform: scale(1.05);
}
.theme-toggle:active {
  transform: scale(0.95);
}
.theme-toggle-track {
  position: relative;
  width: 100%;
  height: 100%;
  background: linear-gradient(to right, #4f46e5, #7c3aed);
  border-radius: 12px;
  transition: background 0.3s ease;
  overflow: hidden;
}
.theme-toggle-track::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(to right, #60a5fa, #3b82f6);
  opacity: 0;
  transition: opacity 0.3s ease;
}
.theme-toggle:hover .theme-toggle-track::before {
  opacity: 1;
}
.theme-toggle-thumb {
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
[data-theme="dark"] .theme-toggle-thumb {
  transform: translateX(24px);
  background: #1f2937;
}
.theme-toggle-icon {
  color: #4f46e5;
  transition: color 0.3s ease;
}
[data-theme="dark"] .theme-toggle-icon {
  color: #60a5fa;
}
/* Apply theme variables */
body {
  background-color: var(--bg-primary);
  color: var(--text-primary);
  transition: background-color 0.3s ease, color 0.3s ease;
}
.chat-window {
  background-color: var(--bg-secondary);
  border-color: var(--border-color);
  box-shadow: var(--shadow-lg);
}
.message-bubble {
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  border-color: var(--border-color);
  box-shadow: var(--shadow-sm);
}
.message-bubble.user {
  background: linear-gradient(90deg, var(--accent-color) 80%, var(--accent-hover) 100%);
  color: white;
}
.input-box {
  background-color: var(--bg-primary);
  color: var(--text-primary);
  border-color: var(--border-color);
}
.input-box:focus {
  border-color: var(--accent-color);
  box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent-color), transparent 85%);
}
.send-button {
  background: linear-gradient(90deg, var(--accent-color) 80%, var(--accent-hover) 100%);
  color: white;
  box-shadow: var(--shadow-sm);
}
.send-button:hover:not(:disabled) {
  background: linear-gradient(90deg, var(--accent-hover) 80%, var(--accent-color) 100%);
  box-shadow: var(--shadow-md);
}
</file>

<file path="packages/renderer/src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppLayout from './components/AppLayout';
import { ThemeProvider } from './contexts/ThemeContext';
import { Toaster } from 'react-hot-toast';
import './index.css';
console.log('Renderer process started and main.tsx is executing.');
ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ThemeProvider>
      <AppLayout />
    </ThemeProvider>
    <Toaster position="bottom-right" />
  </React.StrictMode>,
);
</file>

<file path="packages/renderer/src/setupTests.ts">
import { expect } from 'vitest';
import * as matchers from '@testing-library/jest-dom/matchers';
import { JSDOM } from 'jsdom';
import '@testing-library/jest-dom/vitest';
// Set up a basic DOM environment
const dom = new JSDOM('<!doctype html><html><body></body></html>', {
  url: 'http://localhost'
});
(global as any).window = dom.window;
(global as any).document = dom.window.document;
(global as any).navigator = dom.window.navigator;
// Extend expect with jest-dom matchers
expect.extend(matchers);
// Clean up after all tests
afterAll(() => {
  dom.window.close();
});
</file>

<file path="packages/renderer/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="packages/renderer/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
</file>

<file path="packages/renderer/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.tsx"></script>
  </body>
</html>
</file>

<file path="packages/renderer/package.json">
{
  "name": "@app/renderer",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "lucide-react": "^0.378.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.4.1"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.3",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  },
  "main": "./dist/index.html",
  "exports": {
    ".": {
      "default": "./dist/index.html"
    },
    "./dist/index.html": "./dist/index.html"
  },
  "files": [
    "dist/**",
    "package.json"
  ]
}
</file>

<file path="packages/renderer/postcss.config.cjs">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="packages/renderer/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="packages/renderer/README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="packages/renderer/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    './index.html',
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="packages/renderer/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "composite": true,
    "declaration": true,
    "jsx": "react-jsx",
    "paths": {
      "@app/shared/*": [
        "../../shared/*"
      ]
    },
    "strict": true,
    "skipLibCheck": true,
    "esModuleInterop": true
  },
  "references": [
    {
      "path": "../shared"
    }
  ],
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "**/*.js",
    "dist/**",
    "node_modules"
  ]
}
</file>

<file path="packages/renderer/vite.config.ts">
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default defineConfig(({ mode }) => {
  // Load env file based on `mode` in the current directory.
  // Set the third parameter to '' to load all env regardless of the `VITE_` prefix.
  const env = loadEnv(mode, process.cwd(), '');
  return {
    root: '.',
    plugins: [react()],
    base: mode === 'development' ? '/' : './',
    build: {
      outDir: 'dist',
      emptyOutDir: true,
      sourcemap: mode === 'development' ? 'inline' : false,
      // Enable minification
      minify: 'terser',
      // Enable chunk size warnings
      chunkSizeWarningLimit: 1000,
      // Configure rollup options
      rollupOptions: {
        output: {
          // Configure chunk size
          manualChunks: {
            'react-vendor': ['react', 'react-dom'],
          },
          // Configure asset file names
          assetFileNames: (assetInfo) => {
            const name = assetInfo.name || '';
            if (/\.(css|scss|sass|less|styl)$/.test(name)) {
              return `assets/css/[name]-[hash][extname]`;
            }
            if (/\.(png|jpe?g|gif|svg|webp|avif)$/.test(name)) {
              return `assets/images/[name]-[hash][extname]`;
            }
            if (/\.(woff2?|eot|ttf|otf)$/.test(name)) {
              return `assets/fonts/[name]-[hash][extname]`;
            }
            return `assets/[name]-[hash][extname]`;
          },
          // Configure chunk file names
          chunkFileNames: 'assets/js/[name]-[hash].js',
          // Configure entry file names
          entryFileNames: 'assets/js/[name]-[hash].js',
        },
      },
      // Configure terser options
      terserOptions: {
        compress: {
          drop_console: mode === 'production',
          drop_debugger: mode === 'production',
        },
      },
      reportCompressedSize: true,
      cssCodeSplit: true,
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
        '@components': path.resolve(__dirname, './src/components'),
        '@assets': path.resolve(__dirname, './src/assets'),
      },
      extensions: ['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json'],
    },
    server: {
      port: 3013,
      strictPort: false,
      // Enable HMR
      hmr: {
        overlay: true,
      },
      // Configure proxy if needed
      proxy: {
        // Add your proxy configuration here
      },
    },
    // Configure CSS options
    css: {
      postcss: path.resolve(__dirname, 'postcss.config.js'),
      // Enable CSS modules
      modules: {
        localsConvention: 'camelCase',
        generateScopedName: '[name]__[local]___[hash:base64:5]',
      },
      // Enable CSS preprocessors
      preprocessorOptions: {
        scss: {
          additionalData: `@import "@/styles/variables.scss";`,
        },
      },
    },
    // Configure optimization options
    optimizeDeps: {
      include: ['react', 'react-dom'],
      exclude: ['@electron-toolkit/preload'],
    },
    // Configure environment variables
    define: {
      __APP_VERSION__: JSON.stringify(env.npm_package_version),
      __APP_ENV__: JSON.stringify(mode),
    },
    // Configure error handling
    logLevel: 'info',
    clearScreen: false,
  };
});
</file>

<file path="packages/renderer/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
export default defineConfig({
  plugins: [react({
    jsxRuntime: 'classic'
  })],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/setupTests.ts',
    include: ['src/**/*.test.{ts,tsx}'],
    exclude: ['node_modules/**'],
    server: {
      deps: {
        inline: ['react', 'react-dom']
      }
    },
    coverage: {
      reporter: ['text', 'json', 'html'],
      provider: 'istanbul'
    }
  }
});
</file>

<file path="packages/shared/src/api/OllamaClient.d.ts">
import type { ChatMessage, ChatResponse, OllamaModel, OllamaConnectionStatus } from '../../types/ipc';
import type { StreamParserOptions } from '../../types/ollama';
import { EventEmitter } from 'events';
export declare class OllamaClient extends EventEmitter {
    private static instance;
    private baseUrl;
    private currentModel;
    private fallbackModels;
    private connectionPool;
    private maxConnections;
    private requestQueue;
    private isProcessingQueue;
    private healthCheckInterval;
    private connectionStatus;
    private loadingState;
    private abortController;
    private isInitialized;
    private constructor();
    static getInstance(): OllamaClient;
    private makeRequest;
    initialize(): Promise<void>;
    checkConnection(): Promise<OllamaConnectionStatus>;
    private getWebSocketUrl;
    private createConnection;
    private getConnection;
    private queueRequest;
    private processQueue;
    private parseStream;
    private tryFallbackModel;
    sendMessage(message: ChatMessage): Promise<ChatResponse>;
    sendMessageStream(message: ChatMessage, options: StreamParserOptions): Promise<void>;
    listModels(): Promise<{
        success: boolean;
        error?: string;
        result?: {
            models: OllamaModel[];
        };
    }>;
    setModel(modelName: string): Promise<{
        success: boolean;
        error?: string;
    }>;
    startHealthCheck(interval?: number): void;
    stopHealthCheck(): void;
    getConnectionStatus(): OllamaConnectionStatus;
    getCurrentModel(): string;
    private getModelStatus;
    private loadModel;
    cancelLoad(): Promise<void>;
    generate(message: string): Promise<{
        response: string;
    }>;
    embed(text: string): Promise<number[]>;
    pullModel(modelName: string): Promise<void>;
}
</file>

<file path="packages/shared/src/api/OllamaClient.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OllamaClient = void 0;
const events_1 = require("events");
const logger_1 = require("../../utils/logger");
const node_fetch_1 = __importDefault(require("node-fetch"));
const OLLAMA_BASE_URL = 'http://localhost:11434';
const MAX_RETRIES = 3;
const TIMEOUT_MS = 300000; // 5 minutes
const POLL_INTERVAL = 500; // 500ms
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
async function withRetryAndTimeout(fn, retries = MAX_RETRIES) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), TIMEOUT_MS);
    try {
        return await fn();
    }
    catch (error) {
        if (retries > 0 && !controller.signal.aborted) {
            await delay(1000 * (MAX_RETRIES - retries));
            return withRetryAndTimeout(fn, retries - 1);
        }
        throw error;
    }
    finally {
        clearTimeout(timeout);
    }
}
class OllamaClient extends events_1.EventEmitter {
    constructor() {
        super();
        this.baseUrl = OLLAMA_BASE_URL;
        this.currentModel = 'llama2';
        this.fallbackModels = ['mistral', 'codellama', 'neural-chat'];
        this.connectionPool = new Set();
        this.maxConnections = 5;
        this.requestQueue = [];
        this.isProcessingQueue = false;
        this.healthCheckInterval = null;
        this.connectionStatus = { status: 'disconnected', lastChecked: Date.now() };
        this.loadingState = {
            status: 'loaded',
            isLoading: false,
            modelName: '',
            progress: 0,
            estimatedTimeRemaining: 0
        };
        this.abortController = null;
        this.isInitialized = false;
    }
    static getInstance() {
        if (!OllamaClient.instance) {
            OllamaClient.instance = new OllamaClient();
        }
        return OllamaClient.instance;
    }
    async makeRequest(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        logger_1.logger.debug(`Making request to ${url}`);
        try {
            const headers = {
                'Content-Type': 'application/json',
                ...(options.headers || {})
            };
            const response = await (0, node_fetch_1.default)(url, {
                ...options,
                headers
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Request failed: ${response.statusText}, ${errorText}`);
            }
            return response.json();
        }
        catch (error) {
            logger_1.logger.error(`Request to ${url} failed:`, error);
            throw error;
        }
    }
    async initialize() {
        if (this.isInitialized) {
            logger_1.logger.info('OllamaClient already initialized');
            return;
        }
        logger_1.logger.info('Initializing OllamaClient...');
        try {
            logger_1.logger.debug('Checking Ollama connection...');
            const status = await this.checkConnection();
            if (status.status !== 'connected') {
                logger_1.logger.warn('Ollama service is not available. Some features may be limited.');
                this.connectionStatus = status;
                return;
            }
            // Load available models
            try {
                logger_1.logger.debug('Loading available models...');
                const models = await this.listModels();
                logger_1.logger.info(`Successfully loaded ${models.result?.models.length} models: ${models.result?.models.map(m => m.name).join(', ')}`);
                this.emit('modelsLoaded', models.result?.models);
            }
            catch (error) {
                logger_1.logger.error('Error loading models:', error);
                // Continue initialization even if model loading fails
            }
            this.connectionStatus = status;
            this.isInitialized = true;
            this.startHealthCheck();
            logger_1.logger.info('OllamaClient initialized successfully');
        }
        catch (error) {
            logger_1.logger.error('Failed to initialize OllamaClient:', error);
            this.connectionStatus = {
                status: 'disconnected',
                lastChecked: Date.now(),
                error: error instanceof Error ? error.message : 'Unknown error'
            };
        }
    }
    async checkConnection() {
        const retries = 3;
        const delay = 1000;
        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                logger_1.logger.debug(`Connection attempt ${attempt}/${retries}...`);
                await this.makeRequest('/api/tags');
                const status = {
                    status: 'connected',
                    lastChecked: Date.now()
                };
                logger_1.logger.info('Successfully connected to Ollama service');
                this.connectionStatus = status;
                return status;
            }
            catch (error) {
                logger_1.logger.warn(`Connection attempt ${attempt}/${retries} failed. Retrying in ${delay}ms...`, error);
                if (attempt < retries) {
                    await new Promise(res => setTimeout(res, delay));
                }
            }
        }
        logger_1.logger.error('All connection attempts failed');
        const status = {
            status: 'disconnected',
            lastChecked: Date.now(),
            error: 'All connection attempts failed'
        };
        this.connectionStatus = status;
        return status;
    }
    getWebSocketUrl(path) {
        return this.baseUrl
            .replace(/^http:\/\//, 'ws://')
            .replace(/^https:\/\//, 'wss://')
            + path;
    }
    async createConnection() {
        const wsUrl = this.getWebSocketUrl('/api/chat');
        logger_1.logger.debug(`Creating WebSocket connection to ${wsUrl}`);
        const ws = new WebSocket(wsUrl);
        return new Promise((resolve, reject) => {
            ws.onopen = () => {
                logger_1.logger.info(`WebSocket connection established at ${wsUrl}`);
                resolve(ws);
            };
            ws.onerror = (error) => {
                logger_1.logger.error('WebSocket connection error:', error);
                reject(error);
            };
            ws.onclose = () => {
                logger_1.logger.info('WebSocket connection closed');
                this.connectionPool.delete(ws);
            };
        });
    }
    async getConnection() {
        // Try to get an existing connection
        for (const conn of this.connectionPool) {
            if (conn.readyState === WebSocket.OPEN) {
                return conn;
            }
        }
        // Create new connection if pool isn't full
        if (this.connectionPool.size < this.maxConnections) {
            const conn = await this.createConnection();
            this.connectionPool.add(conn);
            return conn;
        }
        // Wait for a connection to become available
        return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
                for (const conn of this.connectionPool) {
                    if (conn.readyState === WebSocket.OPEN) {
                        clearInterval(checkInterval);
                        resolve(conn);
                        return;
                    }
                }
            }, 100);
        });
    }
    async queueRequest(request, maxRetries = 3) {
        return new Promise((resolve, reject) => {
            const queueItem = {
                id: Math.random().toString(36).substr(2, 9),
                request,
                retries: 0,
                maxRetries,
                resolve,
                reject,
            };
            this.requestQueue.push(queueItem);
            this.processQueue();
        });
    }
    async processQueue() {
        if (this.isProcessingQueue || this.requestQueue.length === 0)
            return;
        this.isProcessingQueue = true;
        const item = this.requestQueue[0];
        try {
            const result = await item.request();
            item.resolve(result);
        }
        catch (error) {
            if (item.retries < item.maxRetries) {
                item.retries++;
                // Exponential backoff
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, item.retries) * 1000));
                this.processQueue();
                return;
            }
            item.reject(error);
        }
        this.requestQueue.shift();
        this.isProcessingQueue = false;
        this.processQueue();
    }
    async parseStream(response, options) {
        const text = await response.text();
        const lines = text.split('\n').filter(line => line.trim());
        for (const line of lines) {
            try {
                const chunk = JSON.parse(line);
                options.onChunk(chunk.response || '');
            }
            catch (parseError) {
                options.onError(new Error(`Failed to parse chunk: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`));
            }
        }
        options.onComplete();
    }
    async tryFallbackModel(error) {
        const currentIndex = this.fallbackModels.indexOf(this.currentModel);
        if (currentIndex === -1 || currentIndex === this.fallbackModels.length - 1) {
            logger_1.logger.warn('No more fallback models available');
            return false;
        }
        const nextModel = this.fallbackModels[currentIndex + 1];
        try {
            logger_1.logger.info(`Attempting to fall back to model ${nextModel}...`);
            const result = await this.setModel(nextModel);
            if (!result.success) {
                throw new Error(result.error || 'Failed to set model');
            }
            logger_1.logger.info(`Successfully fell back to model ${nextModel}`);
            return true;
        }
        catch (fallbackError) {
            logger_1.logger.error(`Failed to fall back to model ${nextModel}:`, fallbackError);
            return false;
        }
    }
    async sendMessage(message) {
        return this.queueRequest(async () => {
            try {
                return await this.makeRequest('/api/chat', {
                    method: 'POST',
                    body: JSON.stringify({
                        model: this.currentModel,
                        messages: [message]
                    })
                });
            }
            catch (error) {
                if (await this.tryFallbackModel(error)) {
                    return this.sendMessage(message);
                }
                throw error;
            }
        });
    }
    async sendMessageStream(message, options) {
        return this.queueRequest(async () => {
            try {
                const response = await (0, node_fetch_1.default)(`${this.baseUrl}/api/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: this.currentModel,
                        messages: [message],
                        stream: true
                    })
                });
                if (!response.ok) {
                    throw new Error(`Ollama API error: ${response.statusText}`);
                }
                const text = await response.text();
                const lines = text.split('\n').filter(line => line.trim());
                for (const line of lines) {
                    try {
                        const chunk = JSON.parse(line);
                        options.onChunk(chunk.response || '');
                    }
                    catch (parseError) {
                        options.onError(new Error(`Failed to parse chunk: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`));
                    }
                }
                options.onComplete();
            }
            catch (error) {
                if (await this.tryFallbackModel(error)) {
                    return this.sendMessageStream(message, options);
                }
                throw error;
            }
        });
    }
    async listModels() {
        return this.queueRequest(async () => {
            try {
                const data = await this.makeRequest('/api/tags');
                if (!data || !data.models || !Array.isArray(data.models)) {
                    logger_1.logger.error('Invalid response format from Ollama API:', data);
                    return {
                        success: false,
                        error: 'Invalid response format from Ollama API'
                    };
                }
                const models = data.models.map((model) => ({
                    name: model.name,
                    size: model.size || 0,
                    digest: model.digest || '',
                    modified_at: model.modified_at || new Date().toISOString(),
                    details: {
                        format: model.details?.format || 'gguf',
                        family: model.details?.family || 'llama',
                        families: model.details?.families || ['llama'],
                        parameter_size: model.details?.parameter_size || '7B',
                        quantization_level: model.details?.quantization_level || 'Q4_0'
                    }
                }));
                return {
                    success: true,
                    result: { models }
                };
            }
            catch (error) {
                logger_1.logger.error('Error listing models:', error);
                return {
                    success: false,
                    error: error instanceof Error ? error.message : 'Failed to list models'
                };
            }
        });
    }
    async setModel(modelName) {
        if (this.currentModel === modelName) {
            return { success: true };
        }
        try {
            await this.loadModel(modelName);
            this.currentModel = modelName;
            return { success: true };
        }
        catch (error) {
            logger_1.logger.error(`Failed to set model to ${modelName}:`, error);
            return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
        }
    }
    startHealthCheck(interval = 30000) {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(async () => {
            const status = await this.checkConnection();
            this.emit('healthCheck', status);
        }, interval);
    }
    stopHealthCheck() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = null;
        }
    }
    getConnectionStatus() {
        return this.connectionStatus;
    }
    getCurrentModel() {
        return this.currentModel;
    }
    async getModelStatus(modelName) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/api/tags`);
            const data = await response.json();
            const model = data.models.find((m) => m.name === modelName);
            return {
                progress: model ? 100 : 0
            };
        }
        catch (error) {
            console.error('Error getting model status:', error);
            return { progress: 0 };
        }
    }
    async loadModel(modelName) {
        const startTime = Date.now();
        this.loadingState = {
            status: 'loading',
            isLoading: true,
            modelName,
            progress: 0,
            estimatedTimeRemaining: 0
        };
        this.emit('modelLoadingStateChanged', this.loadingState);
        try {
            // Poll model status every 500ms
            const pollInterval = setInterval(async () => {
                const status = await this.getModelStatus(modelName);
                this.loadingState.progress = status.progress;
                this.emit('modelLoadingStateChanged', this.loadingState);
            }, POLL_INTERVAL);
            this.abortController = new AbortController();
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/api/pull`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ name: modelName, stream: true }),
                signal: this.abortController.signal
            });
            if (!response.ok) {
                throw new Error(`Failed to load model: ${response.statusText}`);
            }
            const text = await response.text();
            const lines = text.split('\n').filter(line => line.trim());
            for (const line of lines) {
                try {
                    const data = JSON.parse(line);
                    if (data.status === 'pulling') {
                        this.loadingState.progress = data.completed || 0;
                        this.loadingState.estimatedTimeRemaining = data.remaining || 0;
                        this.emit('modelLoadingStateChanged', this.loadingState);
                    }
                }
                catch (error) {
                    logger_1.logger.error('Error parsing stream:', error);
                }
            }
            clearInterval(pollInterval);
            this.loadingState.isLoading = false;
            this.emit('modelLoadingStateChanged', this.loadingState);
        }
        catch (error) {
            this.loadingState.isLoading = false;
            this.loadingState.error = error instanceof Error ? error.message : 'Failed to load model';
            this.emit('modelLoadingStateChanged', this.loadingState);
            throw error;
        }
        finally {
            this.abortController = null;
        }
    }
    async cancelLoad() {
        if (this.abortController) {
            this.abortController.abort();
            this.loadingState.isLoading = false;
            this.loadingState.error = 'Model loading cancelled';
            this.emit('modelLoadingStateChanged', this.loadingState);
        }
    }
    async generate(message) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/api/generate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: this.currentModel,
                    prompt: message,
                    stream: false,
                }),
            });
            if (!response.ok) {
                throw new Error(`Failed to generate response: ${response.statusText}`);
            }
            const data = await response.json();
            return { response: data.response };
        }
        catch (error) {
            logger_1.logger.error('Error generating response:', error);
            throw error;
        }
    }
    async embed(text) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/api/embeddings`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: this.currentModel,
                    prompt: text,
                }),
            });
            if (!response.ok) {
                throw new Error(`Failed to generate embedding: ${response.statusText}`);
            }
            const data = await response.json();
            return data.embedding;
        }
        catch (error) {
            logger_1.logger.error('Error generating embedding:', error);
            throw error;
        }
    }
    async pullModel(modelName) {
        const response = await (0, node_fetch_1.default)(`${this.baseUrl}/api/pull`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ name: modelName })
        });
        if (!response.ok) {
            throw new Error(`Failed to pull model: ${response.statusText}`);
        }
        const text = await response.text();
        const lines = text.split('\n').filter(line => line.trim());
        try {
            for (const line of lines) {
                if (line.trim()) {
                    try {
                        const status = JSON.parse(line);
                        this.emit('modelLoadingStateChanged', {
                            status: 'loading',
                            isLoading: true,
                            modelName,
                            progress: status.progress || 0,
                            estimatedTimeRemaining: status.estimatedTimeRemaining
                        });
                    }
                    catch (parseError) {
                        logger_1.logger.error('Failed to parse pull status:', parseError);
                    }
                }
            }
            this.emit('modelLoadingStateChanged', {
                status: 'loaded',
                isLoading: false,
                modelName,
                progress: 100
            });
        }
        catch (error) {
            this.emit('modelLoadingStateChanged', {
                status: 'error',
                isLoading: false,
                modelName,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
            throw error;
        }
    }
}
exports.OllamaClient = OllamaClient;
//# sourceMappingURL=OllamaClient.js.map
</file>

<file path="packages/shared/src/api/OllamaClient.js.map">
{"version":3,"file":"OllamaClient.js","sourceRoot":"","sources":["OllamaClient.ts"],"names":[],"mappings":"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"}
</file>

<file path="packages/shared/src/api/OllamaClient.ts">
import type { ChatMessage, ChatResponse, OllamaModel, OllamaConnectionStatus, ModelLoadingState } from '../../types/ipc';
import type { RequestQueueItem, StreamParserOptions } from '../../types/ollama';
import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import fetch, { Response as NodeFetchResponse, RequestInit as NodeFetchRequestInit } from 'node-fetch';
const OLLAMA_BASE_URL = 'http://localhost:11434';
const MAX_RETRIES = 3;
const TIMEOUT_MS = 300000; // 5 minutes
const POLL_INTERVAL = 500; // 500ms
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
async function withRetryAndTimeout<T>(
  fn: () => Promise<T>,
  retries = MAX_RETRIES
): Promise<T> {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), TIMEOUT_MS);
  try {
    return await fn();
  } catch (error) {
    if (retries > 0 && !controller.signal.aborted) {
      await delay(1000 * (MAX_RETRIES - retries));
      return withRetryAndTimeout(fn, retries - 1);
    }
    throw error;
  } finally {
    clearTimeout(timeout);
  }
}
export class OllamaClient extends EventEmitter {
  private static instance: OllamaClient;
  private baseUrl: string;
  private currentModel: string;
  private fallbackModels: string[];
  private connectionPool: Set<WebSocket>;
  private maxConnections: number;
  private requestQueue: RequestQueueItem[];
  private isProcessingQueue: boolean;
  private healthCheckInterval: NodeJS.Timeout | null;
  private connectionStatus: OllamaConnectionStatus;
  private loadingState: ModelLoadingState;
  private abortController: AbortController | null;
  private isInitialized: boolean;
  private constructor() {
    super();
    this.baseUrl = OLLAMA_BASE_URL;
    this.currentModel = 'llama2';
    this.fallbackModels = ['mistral', 'codellama', 'neural-chat'];
    this.connectionPool = new Set();
    this.maxConnections = 5;
    this.requestQueue = [];
    this.isProcessingQueue = false;
    this.healthCheckInterval = null;
    this.connectionStatus = { status: 'disconnected', lastChecked: Date.now() };
    this.loadingState = {
      status: 'loaded',
      isLoading: false,
      modelName: '',
      progress: 0,
      estimatedTimeRemaining: 0
    };
    this.abortController = null;
    this.isInitialized = false;
  }
  public static getInstance(): OllamaClient {
    if (!OllamaClient.instance) {
      OllamaClient.instance = new OllamaClient();
    }
    return OllamaClient.instance;
  }
  private async makeRequest(endpoint: string, options: NodeFetchRequestInit = {}): Promise<any> {
    const url = `${this.baseUrl}${endpoint}`;
    logger.debug(`Making request to ${url}`);
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(options.headers || {})
      };
      const response = await fetch(url, {
        ...options,
        headers
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Request failed: ${response.statusText}, ${errorText}`);
      }
      return response.json();
    } catch (error) {
      logger.error(`Request to ${url} failed:`, error);
      throw error;
    }
  }
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      logger.info('OllamaClient already initialized');
      return;
    }
    logger.info('Initializing OllamaClient...');
    try {
      logger.debug('Checking Ollama connection...');
      const status = await this.checkConnection();
      if (status.status !== 'connected') {
        logger.warn('Ollama service is not available. Some features may be limited.');
        this.connectionStatus = status;
        return;
      }
      // Load available models
      try {
        logger.debug('Loading available models...');
        const models = await this.listModels();
        logger.info(`Successfully loaded ${models.result?.models.length} models: ${models.result?.models.map(m => m.name).join(', ')}`);
        this.emit('modelsLoaded', models.result?.models);
      } catch (error) {
        logger.error('Error loading models:', error);
        // Continue initialization even if model loading fails
      }
      this.connectionStatus = status;
      this.isInitialized = true;
      this.startHealthCheck();
      logger.info('OllamaClient initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize OllamaClient:', error);
      this.connectionStatus = {
        status: 'disconnected',
        lastChecked: Date.now(),
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
  public async checkConnection(): Promise<OllamaConnectionStatus> {
    const retries = 3;
    const delay = 1000;
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        logger.debug(`Connection attempt ${attempt}/${retries}...`);
        await this.makeRequest('/api/tags');
        const status: OllamaConnectionStatus = {
          status: 'connected',
          lastChecked: Date.now()
        };
        logger.info('Successfully connected to Ollama service');
        this.connectionStatus = status;
        return status;
      } catch (error) {
        logger.warn(`Connection attempt ${attempt}/${retries} failed. Retrying in ${delay}ms...`, error);
        if (attempt < retries) {
          await new Promise(res => setTimeout(res, delay));
        }
      }
    }
    logger.error('All connection attempts failed');
    const status: OllamaConnectionStatus = {
      status: 'disconnected',
      lastChecked: Date.now(),
      error: 'All connection attempts failed'
    };
    this.connectionStatus = status;
    return status;
  }
  private getWebSocketUrl(path: string): string {
    return this.baseUrl
      .replace(/^http:\/\//, 'ws://')
      .replace(/^https:\/\//, 'wss://')
      + path;
  }
  private async createConnection(): Promise<WebSocket> {
    const wsUrl = this.getWebSocketUrl('/api/chat');
    logger.debug(`Creating WebSocket connection to ${wsUrl}`);
    const ws = new WebSocket(wsUrl);
    return new Promise((resolve, reject) => {
      ws.onopen = () => {
        logger.info(`WebSocket connection established at ${wsUrl}`);
        resolve(ws);
      };
      ws.onerror = (error) => {
        logger.error('WebSocket connection error:', error);
        reject(error);
      };
      ws.onclose = () => {
        logger.info('WebSocket connection closed');
        this.connectionPool.delete(ws);
      };
    });
  }
  private async getConnection(): Promise<WebSocket> {
    // Try to get an existing connection
    for (const conn of this.connectionPool) {
      if (conn.readyState === WebSocket.OPEN) {
        return conn;
      }
    }
    // Create new connection if pool isn't full
    if (this.connectionPool.size < this.maxConnections) {
      const conn = await this.createConnection();
      this.connectionPool.add(conn);
      return conn;
    }
    // Wait for a connection to become available
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        for (const conn of this.connectionPool) {
          if (conn.readyState === WebSocket.OPEN) {
            clearInterval(checkInterval);
            resolve(conn);
            return;
          }
        }
      }, 100);
    });
  }
  private async queueRequest<T>(
    request: () => Promise<T>,
    maxRetries: number = 3
  ): Promise<T> {
    return new Promise((resolve, reject) => {
      const queueItem: RequestQueueItem = {
        id: Math.random().toString(36).substr(2, 9),
        request,
        retries: 0,
        maxRetries,
        resolve,
        reject,
      };
      this.requestQueue.push(queueItem);
      this.processQueue();
    });
  }
  private async processQueue() {
    if (this.isProcessingQueue || this.requestQueue.length === 0) return;
    this.isProcessingQueue = true;
    const item = this.requestQueue[0];
    try {
      const result = await item.request();
      item.resolve(result);
    } catch (error) {
      if (item.retries < item.maxRetries) {
        item.retries++;
        // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, item.retries) * 1000));
        this.processQueue();
        return;
      }
      item.reject(error as Error);
    }
    this.requestQueue.shift();
    this.isProcessingQueue = false;
    this.processQueue();
  }
  private async parseStream(
    response: NodeFetchResponse,
    options: StreamParserOptions
  ): Promise<void> {
    const text = await response.text();
    const lines = text.split('\n').filter(line => line.trim());
    for (const line of lines) {
      try {
        const chunk = JSON.parse(line);
        options.onChunk(chunk.response || '');
      } catch (parseError) {
        options.onError(new Error(`Failed to parse chunk: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`));
      }
    }
    options.onComplete();
  }
  private async tryFallbackModel(error: Error): Promise<boolean> {
    const currentIndex = this.fallbackModels.indexOf(this.currentModel);
    if (currentIndex === -1 || currentIndex === this.fallbackModels.length - 1) {
      logger.warn('No more fallback models available');
      return false;
    }
    const nextModel = this.fallbackModels[currentIndex + 1];
    try {
      logger.info(`Attempting to fall back to model ${nextModel}...`);
      const result = await this.setModel(nextModel);
      if (!result.success) {
        throw new Error(result.error || 'Failed to set model');
      }
      logger.info(`Successfully fell back to model ${nextModel}`);
      return true;
    } catch (fallbackError) {
      logger.error(`Failed to fall back to model ${nextModel}:`, fallbackError);
      return false;
    }
  }
  public async sendMessage(message: ChatMessage): Promise<ChatResponse> {
    return this.queueRequest(async () => {
      try {
        return await this.makeRequest('/api/chat', {
          method: 'POST',
          body: JSON.stringify({
            model: this.currentModel,
            messages: [message]
          })
        });
      } catch (error) {
        if (await this.tryFallbackModel(error as Error)) {
          return this.sendMessage(message);
        }
        throw error;
      }
    });
  }
  public async sendMessageStream(
    message: ChatMessage,
    options: StreamParserOptions
  ): Promise<void> {
    return this.queueRequest(async () => {
      try {
        const response = await fetch(`${this.baseUrl}/api/chat`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: this.currentModel,
            messages: [message],
            stream: true
          })
        });
        if (!response.ok) {
          throw new Error(`Ollama API error: ${response.statusText}`);
        }
        const text = await response.text();
        const lines = text.split('\n').filter(line => line.trim());
        for (const line of lines) {
          try {
            const chunk = JSON.parse(line);
            options.onChunk(chunk.response || '');
          } catch (parseError) {
            options.onError(new Error(`Failed to parse chunk: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`));
          }
        }
        options.onComplete();
      } catch (error) {
        if (await this.tryFallbackModel(error as Error)) {
          return this.sendMessageStream(message, options);
        }
        throw error;
      }
    });
  }
  public async listModels(): Promise<{ success: boolean; error?: string; result?: { models: OllamaModel[] } }> {
    return this.queueRequest(async () => {
      try {
        const data = await this.makeRequest('/api/tags');
        if (!data || !data.models || !Array.isArray(data.models)) {
          logger.error('Invalid response format from Ollama API:', data);
          return { 
            success: false, 
            error: 'Invalid response format from Ollama API' 
          };
        }
        const models = data.models.map((model: any) => ({
          name: model.name,
          size: model.size || 0,
          digest: model.digest || '',
          modified_at: model.modified_at || new Date().toISOString(),
          details: {
            format: model.details?.format || 'gguf',
            family: model.details?.family || 'llama',
            families: model.details?.families || ['llama'],
            parameter_size: model.details?.parameter_size || '7B',
            quantization_level: model.details?.quantization_level || 'Q4_0'
          }
        }));
        return { 
          success: true, 
          result: { models } 
        };
      } catch (error) {
        logger.error('Error listing models:', error);
        return { 
          success: false, 
          error: error instanceof Error ? error.message : 'Failed to list models' 
        };
      }
    });
  }
  public async setModel(modelName: string): Promise<{ success: boolean; error?: string }> {
    if (this.currentModel === modelName) {
      return { success: true };
    }
    try {
      await this.loadModel(modelName);
      this.currentModel = modelName;
      return { success: true };
    } catch (error) {
      logger.error(`Failed to set model to ${modelName}:`, error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }
  public startHealthCheck(interval: number = 30000): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
    this.healthCheckInterval = setInterval(async () => {
      const status = await this.checkConnection();
      this.emit('healthCheck', status);
    }, interval);
  }
  public stopHealthCheck(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }
  }
  public getConnectionStatus(): OllamaConnectionStatus {
    return this.connectionStatus;
  }
  public getCurrentModel(): string {
    return this.currentModel;
  }
  private async getModelStatus(modelName: string): Promise<{ progress: number }> {
    try {
      const response = await fetch(`${this.baseUrl}/api/tags`);
      const data = await response.json();
      const model = data.models.find((m: any) => m.name === modelName);
      return {
        progress: model ? 100 : 0
      };
    } catch (error) {
      console.error('Error getting model status:', error);
      return { progress: 0 };
    }
  }
  private async loadModel(modelName: string): Promise<void> {
    const startTime = Date.now();
    this.loadingState = {
      status: 'loading',
      isLoading: true,
      modelName,
      progress: 0,
      estimatedTimeRemaining: 0
    };
    this.emit('modelLoadingStateChanged', this.loadingState);
    try {
      // Poll model status every 500ms
      const pollInterval = setInterval(async () => {
        const status = await this.getModelStatus(modelName);
        this.loadingState.progress = status.progress;
        this.emit('modelLoadingStateChanged', this.loadingState);
      }, POLL_INTERVAL);
      this.abortController = new AbortController();
      const response = await fetch(`${this.baseUrl}/api/pull`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ name: modelName, stream: true }),
        signal: this.abortController.signal
      });
      if (!response.ok) {
        throw new Error(`Failed to load model: ${response.statusText}`);
      }
      const text = await response.text();
      const lines = text.split('\n').filter(line => line.trim());
      for (const line of lines) {
        try {
          const data = JSON.parse(line);
          if (data.status === 'pulling') {
            this.loadingState.progress = data.completed || 0;
            this.loadingState.estimatedTimeRemaining = data.remaining || 0;
            this.emit('modelLoadingStateChanged', this.loadingState);
          }
        } catch (error) {
          logger.error('Error parsing stream:', error);
        }
      }
      clearInterval(pollInterval);
      this.loadingState.isLoading = false;
      this.emit('modelLoadingStateChanged', this.loadingState);
    } catch (error) {
      this.loadingState.isLoading = false;
      this.loadingState.error = error instanceof Error ? error.message : 'Failed to load model';
      this.emit('modelLoadingStateChanged', this.loadingState);
      throw error;
    } finally {
      this.abortController = null;
    }
  }
  public async cancelLoad(): Promise<void> {
    if (this.abortController) {
      this.abortController.abort();
      this.loadingState.isLoading = false;
      this.loadingState.error = 'Model loading cancelled';
      this.emit('modelLoadingStateChanged', this.loadingState);
    }
  }
  public async generate(message: string): Promise<{ response: string }> {
    try {
      const response = await fetch(`${this.baseUrl}/api/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.currentModel,
          prompt: message,
          stream: false,
        }),
      });
      if (!response.ok) {
        throw new Error(`Failed to generate response: ${response.statusText}`);
      }
      const data = await response.json();
      return { response: data.response };
    } catch (error) {
      logger.error('Error generating response:', error);
      throw error;
    }
  }
  public async embed(text: string): Promise<number[]> {
    try {
      const response = await fetch(`${this.baseUrl}/api/embeddings`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.currentModel,
          prompt: text,
        }),
      });
      if (!response.ok) {
        throw new Error(`Failed to generate embedding: ${response.statusText}`);
      }
      const data = await response.json();
      return data.embedding;
    } catch (error) {
      logger.error('Error generating embedding:', error);
      throw error;
    }
  }
  public async pullModel(modelName: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/api/pull`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ name: modelName })
    });
    if (!response.ok) {
      throw new Error(`Failed to pull model: ${response.statusText}`);
    }
    const text = await response.text();
    const lines = text.split('\n').filter(line => line.trim());
    try {
      for (const line of lines) {
        if (line.trim()) {
          try {
            const status = JSON.parse(line);
            this.emit('modelLoadingStateChanged', {
              status: 'loading',
              isLoading: true,
              modelName,
              progress: status.progress || 0,
              estimatedTimeRemaining: status.estimatedTimeRemaining
            });
          } catch (parseError) {
            logger.error('Failed to parse pull status:', parseError);
          }
        }
      }
      this.emit('modelLoadingStateChanged', {
        status: 'loaded',
        isLoading: false,
        modelName,
        progress: 100
      });
    } catch (error) {
      this.emit('modelLoadingStateChanged', {
        status: 'error',
        isLoading: false,
        modelName,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }
}
</file>

<file path="packages/shared/src/api/VectorStoreClient.d.ts">
import { EventEmitter } from 'events';
export interface VectorDocument {
    id: string;
    content: string;
    metadata: Record<string, any>;
    embedding?: number[];
    createdAt: Date;
    updatedAt: Date;
}
export interface VectorSearchResult {
    document: VectorDocument;
    score: number;
}
export interface VectorStoreStats {
    totalDocuments: number;
    totalVectors: number;
    dimensions: number;
    lastUpdated: Date;
}
export declare class VectorStoreClient extends EventEmitter {
    private static instance;
    private baseUrl;
    private isInitialized;
    private constructor();
    static getInstance(): VectorStoreClient;
    initialize(): Promise<void>;
    addDocument(document: Omit<VectorDocument, 'id' | 'createdAt' | 'updatedAt'>): Promise<VectorDocument>;
    updateDocument(id: string, document: Partial<VectorDocument>): Promise<VectorDocument>;
    deleteDocument(id: string): Promise<void>;
    search(query: string, options?: {
        limit?: number;
        threshold?: number;
    }): Promise<VectorSearchResult[]>;
    getStats(): Promise<VectorStoreStats>;
    getDocument(id: string): Promise<VectorDocument>;
    listDocuments(options?: {
        limit?: number;
        offset?: number;
    }): Promise<VectorDocument[]>;
}
</file>

<file path="packages/shared/src/api/VectorStoreClient.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorStoreClient = void 0;
const events_1 = require("events");
const logger_1 = require("../../utils/logger");
const node_fetch_1 = __importDefault(require("node-fetch"));
class VectorStoreClient extends events_1.EventEmitter {
    constructor() {
        super();
        this.baseUrl = 'http://localhost:11434/api/vector';
        this.isInitialized = false;
    }
    static getInstance() {
        if (!VectorStoreClient.instance) {
            VectorStoreClient.instance = new VectorStoreClient();
        }
        return VectorStoreClient.instance;
    }
    async initialize() {
        if (this.isInitialized) {
            logger_1.logger.info('VectorStoreClient already initialized');
            return;
        }
        try {
            logger_1.logger.info('Initializing VectorStoreClient...');
            // Check if vector store is available
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/status`);
            if (!response.ok) {
                throw new Error(`Vector store not available: ${response.statusText}`);
            }
            this.isInitialized = true;
            logger_1.logger.info('VectorStoreClient initialized successfully');
        }
        catch (error) {
            logger_1.logger.error('Failed to initialize VectorStoreClient:', error);
            throw error;
        }
    }
    async addDocument(document) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/documents`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(document)
            });
            if (!response.ok) {
                throw new Error(`Failed to add document: ${response.statusText}`);
            }
            return response.json();
        }
        catch (error) {
            logger_1.logger.error('Error adding document:', error);
            throw error;
        }
    }
    async updateDocument(id, document) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/documents/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(document)
            });
            if (!response.ok) {
                throw new Error(`Failed to update document: ${response.statusText}`);
            }
            return response.json();
        }
        catch (error) {
            logger_1.logger.error('Error updating document:', error);
            throw error;
        }
    }
    async deleteDocument(id) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/documents/${id}`, {
                method: 'DELETE'
            });
            if (!response.ok) {
                throw new Error(`Failed to delete document: ${response.statusText}`);
            }
        }
        catch (error) {
            logger_1.logger.error('Error deleting document:', error);
            throw error;
        }
    }
    async search(query, options = {}) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/search`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query, ...options })
            });
            if (!response.ok) {
                throw new Error(`Search failed: ${response.statusText}`);
            }
            return response.json();
        }
        catch (error) {
            logger_1.logger.error('Error searching documents:', error);
            throw error;
        }
    }
    async getStats() {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/stats`);
            if (!response.ok) {
                throw new Error(`Failed to get stats: ${response.statusText}`);
            }
            return response.json();
        }
        catch (error) {
            logger_1.logger.error('Error getting vector store stats:', error);
            throw error;
        }
    }
    async getDocument(id) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/documents/${id}`);
            if (!response.ok) {
                throw new Error(`Failed to get document: ${response.statusText}`);
            }
            return response.json();
        }
        catch (error) {
            logger_1.logger.error('Error getting document:', error);
            throw error;
        }
    }
    async listDocuments(options = {}) {
        try {
            const queryParams = new URLSearchParams();
            if (options.limit)
                queryParams.append('limit', options.limit.toString());
            if (options.offset)
                queryParams.append('offset', options.offset.toString());
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/documents?${queryParams}`);
            if (!response.ok) {
                throw new Error(`Failed to list documents: ${response.statusText}`);
            }
            return response.json();
        }
        catch (error) {
            logger_1.logger.error('Error listing documents:', error);
            throw error;
        }
    }
}
exports.VectorStoreClient = VectorStoreClient;
//# sourceMappingURL=VectorStoreClient.js.map
</file>

<file path="packages/shared/src/api/VectorStoreClient.js.map">
{"version":3,"file":"VectorStoreClient.js","sourceRoot":"","sources":["VectorStoreClient.ts"],"names":[],"mappings":"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"}
</file>

<file path="packages/shared/src/api/VectorStoreClient.ts">
import { EventEmitter } from 'events';
import { logger } from '../../utils/logger';
import fetch from 'node-fetch';
export interface VectorDocument {
  id: string;
  content: string;
  metadata: Record<string, any>;
  embedding?: number[];
  createdAt: Date;
  updatedAt: Date;
}
export interface VectorSearchResult {
  document: VectorDocument;
  score: number;
}
export interface VectorStoreStats {
  totalDocuments: number;
  totalVectors: number;
  dimensions: number;
  lastUpdated: Date;
}
export class VectorStoreClient extends EventEmitter {
  private static instance: VectorStoreClient;
  private baseUrl: string;
  private isInitialized: boolean;
  private constructor() {
    super();
    this.baseUrl = 'http://localhost:11434/api/vector';
    this.isInitialized = false;
  }
  public static getInstance(): VectorStoreClient {
    if (!VectorStoreClient.instance) {
      VectorStoreClient.instance = new VectorStoreClient();
    }
    return VectorStoreClient.instance;
  }
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      logger.info('VectorStoreClient already initialized');
      return;
    }
    try {
      logger.info('Initializing VectorStoreClient...');
      // Check if vector store is available
      const response = await fetch(`${this.baseUrl}/status`);
      if (!response.ok) {
        throw new Error(`Vector store not available: ${response.statusText}`);
      }
      this.isInitialized = true;
      logger.info('VectorStoreClient initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize VectorStoreClient:', error);
      throw error;
    }
  }
  public async addDocument(document: Omit<VectorDocument, 'id' | 'createdAt' | 'updatedAt'>): Promise<VectorDocument> {
    try {
      const response = await fetch(`${this.baseUrl}/documents`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(document)
      });
      if (!response.ok) {
        throw new Error(`Failed to add document: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      logger.error('Error adding document:', error);
      throw error;
    }
  }
  public async updateDocument(id: string, document: Partial<VectorDocument>): Promise<VectorDocument> {
    try {
      const response = await fetch(`${this.baseUrl}/documents/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(document)
      });
      if (!response.ok) {
        throw new Error(`Failed to update document: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      logger.error('Error updating document:', error);
      throw error;
    }
  }
  public async deleteDocument(id: string): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/documents/${id}`, {
        method: 'DELETE'
      });
      if (!response.ok) {
        throw new Error(`Failed to delete document: ${response.statusText}`);
      }
    } catch (error) {
      logger.error('Error deleting document:', error);
      throw error;
    }
  }
  public async search(query: string, options: { limit?: number; threshold?: number } = {}): Promise<VectorSearchResult[]> {
    try {
      const response = await fetch(`${this.baseUrl}/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query, ...options })
      });
      if (!response.ok) {
        throw new Error(`Search failed: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      logger.error('Error searching documents:', error);
      throw error;
    }
  }
  public async getStats(): Promise<VectorStoreStats> {
    try {
      const response = await fetch(`${this.baseUrl}/stats`);
      if (!response.ok) {
        throw new Error(`Failed to get stats: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      logger.error('Error getting vector store stats:', error);
      throw error;
    }
  }
  public async getDocument(id: string): Promise<VectorDocument> {
    try {
      const response = await fetch(`${this.baseUrl}/documents/${id}`);
      if (!response.ok) {
        throw new Error(`Failed to get document: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      logger.error('Error getting document:', error);
      throw error;
    }
  }
  public async listDocuments(options: { limit?: number; offset?: number } = {}): Promise<VectorDocument[]> {
    try {
      const queryParams = new URLSearchParams();
      if (options.limit) queryParams.append('limit', options.limit.toString());
      if (options.offset) queryParams.append('offset', options.offset.toString());
      const response = await fetch(`${this.baseUrl}/documents?${queryParams}`);
      if (!response.ok) {
        throw new Error(`Failed to list documents: ${response.statusText}`);
      }
      return response.json();
    } catch (error) {
      logger.error('Error listing documents:', error);
      throw error;
    }
  }
}
</file>

<file path="packages/shared/types/app.d.ts">
export interface AppStatus {
    status: 'healthy' | 'unhealthy';
    timestamp: number;
    details: {
        ollamaConnected: boolean;
        currentModel: string;
    };
}
export interface Document {
    id: string;
    content: string;
    metadata: {
        filename?: string;
        type?: string;
        size?: number;
        timestamp: number;
        source?: string;
        [key: string]: any;
    };
}
export interface Vector {
    id: string;
    content: string;
    embedding?: number[];
}
</file>

<file path="packages/shared/types/app.js">
"use strict";
// Canonical shared types for app-level entities
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=app.js.map
</file>

<file path="packages/shared/types/app.js.map">
{"version":3,"file":"app.js","sourceRoot":"","sources":["app.ts"],"names":[],"mappings":";AAAA,gDAAgD"}
</file>

<file path="packages/shared/types/app.ts">
// Canonical shared types for app-level entities
export interface AppStatus {
  status: 'healthy' | 'unhealthy';
  timestamp: number;
  details: {
    ollamaConnected: boolean;
    currentModel: string;
  };
}
export interface Document {
  id: string;
  content: string;
  metadata: {
    filename?: string;
    type?: string;
    size?: number;
    timestamp: number;
    source?: string;
    [key: string]: any;
  };
}
export interface Vector {
  id: string;
  content: string;
  embedding?: number[];
}
</file>

<file path="packages/shared/types/better-sqlite3.d.ts">
declare module 'better-sqlite3' {
  class Database {
    constructor(path: string);
    prepare(sql: string): Statement;
    exec(sql: string): this;
    close(): void;
    pragma(sql: string, simplify?: boolean): any;
  }
  interface Statement {
    run(...params: any[]): void;
    get(...params: any[]): any;
    all(...params: any[]): any[];
  }
  export = Database;
}
</file>

<file path="packages/shared/types/chat.d.ts">
export interface ChatMessage {
    id: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    timestamp: number;
}
export interface Conversation {
    id: string;
    title: string;
    createdAt: number;
    updatedAt: number;
    metadata?: Record<string, any>;
}
</file>

<file path="packages/shared/types/chat.d.ts.map">
{"version":3,"file":"chat.d.ts","sourceRoot":"","sources":["chat.ts"],"names":[],"mappings":"AAAA,MAAM,WAAW,WAAW;IAC1B,EAAE,EAAE,MAAM,CAAC;IACX,IAAI,EAAE,MAAM,CAAC;IACb,OAAO,EAAE,MAAM,CAAC;IAChB,SAAS,EAAE,MAAM,CAAC;CACnB;AAED,MAAM,WAAW,YAAY;IAC3B,EAAE,EAAE,MAAM,CAAC;IACX,KAAK,EAAE,MAAM,CAAC;IACd,SAAS,EAAE,MAAM,CAAC;IAClB,SAAS,EAAE,MAAM,CAAC;IAClB,QAAQ,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;CAChC;AAED,MAAM,WAAW,YAAY;IAC3B,WAAW,CAAC,cAAc,EAAE,MAAM,EAAE,OAAO,EAAE,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;IACzE,eAAe,CAAC,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;IACpD,kBAAkB,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;IACnF,iBAAiB,IAAI,OAAO,CAAC,YAAY,EAAE,CAAC,CAAC;IAC7C,kBAAkB,CAAC,EAAE,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;IAC9C,uBAAuB,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;CACnE"}
</file>

<file path="packages/shared/types/chat.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=chat.js.map
</file>

<file path="packages/shared/types/chat.js.map">
{"version":3,"file":"chat.js","sourceRoot":"","sources":["chat.ts"],"names":[],"mappings":""}
</file>

<file path="packages/shared/types/chat.ts">
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
}
export interface Conversation {
  id: string;
  title: string;
  createdAt: number;
  updatedAt: number;
  metadata?: Record<string, any>;
}
export interface ChatResponse {
  id: string;
  messages: ChatMessage[];
  createdAt: number;
  updatedAt: number;
}
export type Role = 'user' | 'assistant' | 'system';
</file>

<file path="packages/shared/types/Document.d.ts">
export interface Document {
    id: string;
    content: string;
    metadata: {
        [key: string]: any;
    };
}
</file>

<file path="packages/shared/types/Document.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=Document.js.map
</file>

<file path="packages/shared/types/Document.js.map">
{"version":3,"file":"Document.js","sourceRoot":"","sources":["Document.ts"],"names":[],"mappings":""}
</file>

<file path="packages/shared/types/Document.ts">
export interface Document {
  id: string;
  content: string;
  metadata: {
    [key: string]: any;
  };
}
</file>

<file path="packages/shared/types/electron.d.ts">
import { ServiceStatus, ServiceStatusInfo } from '../config/services';
declare global {
  interface Window {
    electronAPI: {
      // Service management
      getServiceStatus: (service: string) => Promise<ServiceStatusInfo | undefined>;
      getAllServiceStatus: () => Promise<Map<string, ServiceStatusInfo>>;
      restartService: (service: string) => Promise<void>;
      stopService: (service: string) => Promise<void>;
      // Event handling
      onServiceStatusChange: (callback: (event: { 
        serviceName: string; 
        status: ServiceStatus; 
        error?: string; 
        details?: Record<string, any> 
      }) => void) => () => void;
      // Window management
      minimize: () => Promise<void>;
      maximize: () => Promise<void>;
      close: () => Promise<void>;
      isMaximized: () => Promise<boolean>;
      // Theme management
      getTheme: () => Promise<'light' | 'dark' | 'system'>;
      setTheme: (theme: 'light' | 'dark' | 'system') => Promise<void>;
    };
  }
}
</file>

<file path="packages/shared/types/embedding.d.ts">
export interface EmbeddingConfig {
    provider: 'openai' | 'ollama' | 'local' | string;
    apiKey?: string;
    model?: string;
    dimensions?: number;
    [key: string]: any;
}
</file>

<file path="packages/shared/types/embedding.js">
"use strict";
// Shared types for embedding configuration
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=embedding.js.map
</file>

<file path="packages/shared/types/embedding.js.map">
{"version":3,"file":"embedding.js","sourceRoot":"","sources":["embedding.ts"],"names":[],"mappings":";AAAA,2CAA2C"}
</file>

<file path="packages/shared/types/embedding.ts">
// Shared types for embedding configuration
export interface EmbeddingConfig {
  provider: 'openai' | 'ollama' | 'local' | string;
  apiKey?: string;
  model?: string;
  dimensions?: number;
  [key: string]: any;
}
</file>

<file path="packages/shared/types/hnswlib-node.d.ts">
declare module 'hnswlib-node' {
  export class HnswLib {
    constructor(dimensions: number, path: string);
    initIndex(maxElements: number): Promise<void>;
    addPoint(vector: number[], id: number): Promise<void>;
    searchKnn(vector: number[], k: number): Promise<{ neighbors: number[], distances: number[] }>;
    deletePoint(id: number): Promise<void>;
    clearIndex(): Promise<void>;
  }
}
</file>

<file path="packages/shared/types/index.d.ts">
export * from './app';
export * from './chat';
export * from './embedding';
export * from './ollama';
export * from './ipc';
export * from './services';
export * from './settings';
</file>

<file path="packages/shared/types/index.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./app"), exports);
__exportStar(require("./chat"), exports);
__exportStar(require("./embedding"), exports);
__exportStar(require("./ollama"), exports);
__exportStar(require("./ipc"), exports);
__exportStar(require("./services"), exports);
__exportStar(require("./settings"), exports);
//# sourceMappingURL=index.js.map
</file>

<file path="packages/shared/types/index.js.map">
{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,wCAAsB;AACtB,yCAAuB;AACvB,8CAA4B;AAC5B,2CAAyB;AACzB,wCAAsB;AACtB,6CAA2B;AAC3B,6CAA2B"}
</file>

<file path="packages/shared/types/index.ts">
export * from './app';
export * from './chat';
export * from './embedding';
export * from './ollama';
export * from './ipc';
export * from './services';
export * from './settings';
</file>

<file path="packages/shared/types/ipc.d.ts">
import type { ChatMessage, Conversation } from './chat';
import type { AppStatus, Document } from './app';
import type { OllamaModel, ModelLoadingState, OllamaConnectionStatus, OllamaRequestOptions } from './ollama';
export interface IpcMessageMap {
    'chat:send-message': {
        request: ChatMessage;
        response: ChatMessage;
    };
    'chat:send-message-stream': {
        request: ChatMessage;
        response: void;
    };
    'chat:create-conversation': {
        request: string;
        response: string;
    };
    'chat:get-conversation': {
        request: string;
        response: ChatMessage[];
    };
    'chat:get-conversations': {
        request: void;
        response: Conversation[];
    };
    'chat:delete-conversation': {
        request: string;
        response: void;
    };
    'chat:update-conversation-title': {
        request: {
            id: string;
            title: string;
        };
        response: void;
    };
    'chat:message-received': {
        request: ChatMessage;
        response: void;
    };
    'app:health-check': {
        request: void;
        response: AppStatus;
    };
    'ollama:list-models': {
        request: void;
        response: {
            models: OllamaModel[];
        };
    };
    'ollama:set-model': {
        request: {
            modelName: string;
        };
        response: void;
    };
    'ollama:check-connection': {
        request: void;
        response: OllamaConnectionStatus;
    };
    'ollama:cancel-load': {
        request: void;
        response: void;
    };
    'ollama:save-config': {
        request: {
            modelName: string;
            config: OllamaRequestOptions;
        };
        response: void;
    };
    'ollama:model-loading-state-changed': {
        request: ModelLoadingState;
        response: void;
    };
    'vector:search': {
        request: string;
        response: Document[];
    };
    'vector:add': {
        request: Omit<Document, 'id'>;
        response: void;
    };
    'vector:delete': {
        request: string;
        response: void;
    };
    'vector:clear': {
        request: void;
        response: void;
    };
}
export interface ElectronAPI {
    ipc: {
        invoke: <K extends keyof IpcMessageMap>(channel: K, request: IpcMessageMap[K]['request']) => Promise<IpcMessageMap[K]['response']>;
        on: <K extends string>(channel: K, callback: (...args: any[]) => void) => () => void;
    };
}
</file>

<file path="packages/shared/types/ipc.js">
"use strict";
// Canonical shared types for IPC and Electron API
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ipc.js.map
</file>

<file path="packages/shared/types/ipc.js.map">
{"version":3,"file":"ipc.js","sourceRoot":"","sources":["ipc.ts"],"names":[],"mappings":";AAAA,kDAAkD"}
</file>

<file path="packages/shared/types/ipc.ts">
// Canonical shared types for IPC and Electron API
import type { ChatMessage, ChatResponse, Conversation, Role } from './chat';
import type { AppStatus, Document, Vector } from './app';
import type { OllamaModel, ModelLoadingState, OllamaConnectionStatus, OllamaRequestOptions } from './ollama';
export interface IpcMessageMap {
  'chat:send-message': {
    request: ChatMessage;
    response: ChatMessage;
  };
  'chat:send-message-stream': {
    request: ChatMessage;
    response: void;
  };
  'chat:create-conversation': {
    request: string;
    response: string;
  };
  'chat:get-conversation': {
    request: string;
    response: ChatMessage[];
  };
  'chat:get-conversations': {
    request: void;
    response: Conversation[];
  };
  'chat:delete-conversation': {
    request: string;
    response: void;
  };
  'chat:update-conversation-title': {
    request: { id: string; title: string };
    response: void;
  };
  'chat:message-received': {
    request: ChatMessage;
    response: void;
  };
  'app:health-check': {
    request: void;
    response: AppStatus;
  };
  'ollama:list-models': {
    request: void;
    response: { models: OllamaModel[] };
  };
  'ollama:set-model': {
    request: { modelName: string };
    response: void;
  };
  'ollama:check-connection': {
    request: void;
    response: OllamaConnectionStatus;
  };
  'ollama:cancel-load': {
    request: void;
    response: void;
  };
  'ollama:save-config': {
    request: { modelName: string; config: OllamaRequestOptions };
    response: void;
  };
  'ollama:model-loading-state-changed': {
    request: ModelLoadingState;
    response: void;
  };
  'vector:search': {
    request: string;
    response: Document[];
  };
  'vector:add': {
    request: Omit<Document, 'id'>;
    response: void;
  };
  'vector:delete': {
    request: string;
    response: void;
  };
  'vector:clear': {
    request: void;
    response: void;
  };
}
export interface ElectronAPI {
  ipc: {
    invoke: <K extends keyof IpcMessageMap>(
      channel: K,
      request: IpcMessageMap[K]['request']
    ) => Promise<IpcMessageMap[K]['response']>;
    on: <K extends string>(
      channel: K,
      callback: (...args: any[]) => void
    ) => () => void;
  };
}
export type { ChatMessage, ChatResponse, Conversation, Role } from './chat';
export type { AppStatus, Document, Vector } from './app';
export type { OllamaModel, ModelLoadingState, OllamaConnectionStatus, OllamaRequestOptions } from './ollama';
</file>

<file path="packages/shared/types/ollama.d.ts">
export interface OllamaModel {
    name: string;
    size: number;
    digest?: string;
    modified_at: string;
    details: {
        format: string;
        family: string;
        families: string[];
        parameter_size: string;
        quantization_level: string;
    };
}
export interface ModelLoadingState {
    status: 'loading' | 'loaded' | 'error';
    isLoading: boolean;
    error?: string;
    progress?: number;
    estimatedTimeRemaining?: number;
    modelName?: string;
}
export interface OllamaConnectionStatus {
    connected: boolean;
    error?: string;
}
export interface OllamaRequestOptions {
    model?: string;
    stream?: boolean;
    context?: number[];
    options?: {
        temperature?: number;
        top_p?: number;
        top_k?: number;
        repeat_penalty?: number;
        stop?: string[];
        [key: string]: any;
    };
}
export interface OllamaResponse<T = any> {
    success: boolean;
    data?: T;
    error?: string;
}
</file>

<file path="packages/shared/types/ollama.js">
"use strict";
// Canonical shared types for Ollama
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ollama.js.map
</file>

<file path="packages/shared/types/ollama.js.map">
{"version":3,"file":"ollama.js","sourceRoot":"","sources":["ollama.ts"],"names":[],"mappings":";AAAA,oCAAoC"}
</file>

<file path="packages/shared/types/ollama.ts">
// Canonical shared types for Ollama
export interface OllamaModel {
  name: string;
  size: number;
  digest?: string;
  modified_at: string;
  details: {
    format: string;
    family: string;
    families: string[];
    parameter_size: string;
    quantization_level: string;
  };
}
export interface ModelLoadingState {
  status: 'loading' | 'loaded' | 'error';
  isLoading: boolean;
  error?: string;
  progress?: number;
  estimatedTimeRemaining?: number;
  modelName?: string;
}
export interface OllamaConnectionStatus {
  connected: boolean;
  error?: string;
}
export interface OllamaRequestOptions {
  model?: string;
  stream?: boolean;
  context?: number[];
  options?: {
    temperature?: number;
    top_p?: number;
    top_k?: number;
    repeat_penalty?: number;
    stop?: string[];
    [key: string]: any;
  };
}
export interface OllamaResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
}
</file>

<file path="packages/shared/types/services.d.ts">
export type ServiceName = 'ollama' | 'embedding' | 'vectorStore' | 'memory' | string;
export type ServiceState = 'starting' | 'running' | 'stopped' | 'error' | 'restarting' | 'unavailable';
export interface ServiceStatus {
    name: ServiceName;
    state: ServiceState;
    error?: string;
    lastChecked?: number;
}
</file>

<file path="packages/shared/types/services.js">
"use strict";
// Shared types for service management
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=services.js.map
</file>

<file path="packages/shared/types/services.js.map">
{"version":3,"file":"services.js","sourceRoot":"","sources":["services.ts"],"names":[],"mappings":";AAAA,sCAAsC"}
</file>

<file path="packages/shared/types/services.ts">
// Shared types for service management
export type ServiceName = 'ollama' | 'embedding' | 'vectorStore' | 'memory' | string;
export type ServiceState = 'starting' | 'running' | 'stopped' | 'error' | 'restarting' | 'unavailable';
export interface ServiceStatus {
  name: ServiceName;
  state: ServiceState;
  error?: string;
  lastChecked?: number;
}
</file>

<file path="packages/shared/types/settings.d.ts">
export interface SettingsError extends Error {
    type: string;
}
export type SettingsErrorType = 'invalid-api-key' | 'network-error' | 'unknown';
export interface SettingsState {
    apiKeys?: Record<string, string>;
    features?: Record<string, boolean>;
    security?: Record<string, any>;
    version?: string;
    [key: string]: any;
}
</file>

<file path="packages/shared/types/settings.js">
"use strict";
// Shared types for app settings and errors
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=settings.js.map
</file>

<file path="packages/shared/types/settings.js.map">
{"version":3,"file":"settings.js","sourceRoot":"","sources":["settings.ts"],"names":[],"mappings":";AAAA,2CAA2C"}
</file>

<file path="packages/shared/types/settings.ts">
// Shared types for app settings and errors
export interface SettingsError extends Error {
  type: string;
}
export type SettingsErrorType = 'invalid-api-key' | 'network-error' | 'unknown';
export interface SettingsState {
  apiKeys?: Record<string, string>;
  features?: Record<string, boolean>;
  security?: Record<string, any>;
  version?: string;
  [key: string]: any;
}
</file>

<file path="packages/dev-mode.js">
import {build, createServer} from 'vite';
import path from 'path';
/**
 * This script is designed to run multiple packages of your application in a special development mode.
 * To do this, you need to follow a few steps:
 */
/**
 * 1. We create a few flags to let everyone know that we are in development mode.
 */
const mode = 'development';
process.env.NODE_ENV = mode;
process.env.MODE = mode;
/**
 * 2. We create a development server for the renderer. It is assumed that the renderer exists and is located in the renderer package.
 * This server should be started first because other packages depend on its settings.
 */
/**
 * @type {import('vite').ViteDevServer}
 */
const rendererWatchServer = await createServer({
  mode,
  root: path.resolve('packages/renderer'),
});
await rendererWatchServer.listen();
/**
 * 3. We are creating a simple provider plugin.
 * Its only purpose is to provide access to the renderer dev-server to all other build processes.
 */
/** @type {import('vite').Plugin} */
const rendererWatchServerProvider = {
  name: '@app/renderer-watch-server-provider',
  api: {
    provideRendererWatchServer() {
      return rendererWatchServer;
    },
  },
};
/**
 * 4. Start building all other packages.
 * For each of them, we add a plugin provider so that each package can implement its own hot update mechanism.
 */
/** @type {string[]} */
const packagesToStart = [
  'packages/preload',
  'packages/main',
];
for (const pkg of packagesToStart) {
  await build({
    mode,
    root: path.resolve(pkg),
    plugins: [
      rendererWatchServerProvider,
    ],
  });
}
</file>

<file path="packages/entry-point.mjs">
import { initApp } from '@app/main/dist/index.js';
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

if (process.env.NODE_ENV === 'development' || process.env.PLAYWRIGHT_TEST === 'true' || !!process.env.CI) {
  function showAndExit(...args) {
    console.error(...args);
    process.exit(1);
  }

  process.on('uncaughtException', showAndExit);
  process.on('unhandledRejection', showAndExit);
}

// noinspection JSIgnoredPromiseFromCall
/**
 * We resolve '@app/renderer' and '@app/preload'
 * here and not in '@app/main'
 * to observe good practices of modular design.
 * This allows fewer dependencies and better separation of concerns in '@app/main'.
 * Thus,
 * the main module remains simplistic and efficient
 * as it receives initialization instructions rather than direct module imports.
 */
console.log('[Electron] Starting entry-point.mjs');
try {
  const __dirname = dirname(fileURLToPath(import.meta.url));
  
  initApp({
    renderer: (process.env.MODE === 'development') ?
      new URL(process.env.VITE_DEV_SERVER_URL || 'http://localhost:8080')
      : {
        path: fileURLToPath(import.meta.resolve('@app/renderer/dist/index.html')),
      },
    preload: {
      path: fileURLToPath(import.meta.resolve('@app/preload/dist/exposed.js')),
    },
  });
  console.log('[Electron] initApp called successfully');
} catch (err) {
  console.error('[Electron] Error during initApp:', err);
  process.exit(1);
}
</file>

<file path="public/trademark/icon-dark.svg">
<svg width="590" height="589" viewBox="0 0 590 589" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M81.6393 341.413C55.4536 315.228 55.4536 272.772 81.6393 246.587L156.146 172.08L264.52 280.453C272.002 287.935 272.002 300.065 264.52 307.547L156.146 415.92L81.6393 341.413Z" fill="white"/>
<path d="M173.08 155.146L247.587 80.6393C273.772 54.4536 316.228 54.4536 342.413 80.6393L416.92 155.146L308.547 263.52C301.065 271.002 288.935 271.002 281.453 263.52L173.08 155.146Z" fill="white"/>
<path d="M173.08 432.854L281.453 324.48C288.935 316.998 301.065 316.998 308.547 324.48L416.92 432.854L342.413 507.361C316.228 533.546 273.772 533.546 247.587 507.361L173.08 432.854Z" fill="white"/>
<path d="M325.48 307.547C317.998 300.065 317.998 287.935 325.48 280.453L433.854 172.08L508.361 246.587C534.546 272.772 534.546 315.228 508.361 341.413L433.854 415.92L325.48 307.547Z" fill="white"/>
</svg>
</file>

<file path="public/trademark/icon-light.svg">
<svg width="590" height="589" viewBox="0 0 590 589" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M81.6393 341.413C55.4536 315.228 55.4536 272.772 81.6393 246.587L156.146 172.08L264.52 280.453C272.002 287.935 272.002 300.065 264.52 307.547L156.146 415.92L81.6393 341.413Z" fill="black"/>
<path d="M173.08 155.146L247.587 80.6393C273.772 54.4536 316.228 54.4536 342.413 80.6393L416.92 155.146L308.547 263.52C301.065 271.002 288.935 271.002 281.453 263.52L173.08 155.146Z" fill="black"/>
<path d="M173.08 432.854L281.453 324.48C288.935 316.998 301.065 316.998 308.547 324.48L416.92 432.854L342.413 507.361C316.228 533.546 273.772 533.546 247.587 507.361L173.08 432.854Z" fill="black"/>
<path d="M325.48 307.547C317.998 300.065 317.998 287.935 325.48 280.453L433.854 172.08L508.361 246.587C534.546 272.772 534.546 315.228 508.361 341.413L433.854 415.92L325.48 307.547Z" fill="black"/>
</svg>
</file>

<file path="public/trademark/type-dark.svg">
<svg width="1830" height="589" viewBox="0 0 1830 589" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1617.54 463.22V234.86C1617.54 219.948 1629.62 207.86 1644.54 207.86H1668.42V436.22C1668.42 451.131 1656.33 463.22 1641.42 463.22H1617.54ZM1616.58 170.9V147.02C1616.58 132.108 1628.66 120.02 1643.58 120.02H1669.86V143.9C1669.86 158.811 1657.77 170.9 1642.86 170.9H1616.58Z" fill="white"/>
<path d="M1435.98 468.979C1410.38 468.979 1389.9 460.499 1374.54 443.539C1359.5 426.259 1351.98 402.419 1351.98 372.019V207.859H1375.86C1390.77 207.859 1402.86 219.948 1402.86 234.859V359.059C1402.86 382.099 1406.86 399.059 1414.86 409.939C1422.86 420.819 1435.02 426.259 1451.34 426.259C1469.9 426.259 1484.3 420.339 1494.54 408.499C1505.1 396.339 1510.38 379.379 1510.38 357.619V207.859H1561.26V463.219H1540.35C1525.59 463.219 1513.57 451.367 1513.36 436.608L1512.78 396.499L1519.98 399.379C1515.5 421.779 1506.06 439.059 1491.66 451.219C1477.26 463.059 1458.7 468.979 1435.98 468.979Z" fill="white"/>
<path d="M1081.63 468.98C1056.99 468.98 1035.55 463.54 1017.31 452.66C999.394 441.78 985.474 426.26 975.554 406.1C965.634 385.94 960.674 362.42 960.674 335.54C960.674 308.66 965.634 285.3 975.554 265.46C985.474 245.3 999.234 229.78 1016.83 218.9C1034.75 207.7 1055.87 202.1 1080.19 202.1C1103.55 202.1 1124.03 207.54 1141.63 218.42C1159.23 228.98 1172.83 244.34 1182.43 264.5C1192.35 284.66 1197.31 308.98 1197.31 337.46V350.42H1013.95C1015.23 375.38 1021.79 394.1 1033.63 406.58C1045.79 419.06 1061.95 425.3 1082.11 425.3C1097.47 425.3 1109.95 421.78 1119.55 414.74C1123.85 411.687 1127.61 408.184 1130.83 404.23C1138.47 394.849 1149.01 386.95 1161.08 387.718L1193.47 389.78C1186.75 413.46 1173.47 432.66 1153.63 447.38C1134.11 461.78 1110.11 468.98 1081.63 468.98ZM1013.95 312.02H1143.07C1141.47 289.3 1134.91 272.5 1123.39 261.62C1112.19 250.74 1097.79 245.3 1080.19 245.3C1062.27 245.3 1047.39 251.06 1035.55 262.58C1024.03 273.78 1016.83 290.26 1013.95 312.02Z" fill="white"/>
<path d="M821.715 468.98C797.075 468.98 775.635 463.54 757.395 452.66C739.475 441.78 725.395 426.26 715.155 406.1C705.235 385.94 700.275 362.42 700.275 335.54C700.275 308.66 705.235 285.3 715.155 265.46C725.395 245.3 739.475 229.78 757.395 218.9C775.635 207.7 797.075 202.1 821.715 202.1C842.195 202.1 860.435 205.78 876.435 213.14C892.755 220.18 906.035 230.58 916.275 244.34C926.515 258.1 932.915 274.9 935.475 294.74L907.111 296.287C893.245 297.043 881.896 286.575 874.968 274.54C871.612 268.709 867.301 263.762 862.035 259.7C851.155 250.74 837.715 246.26 821.715 246.26C800.275 246.26 783.475 254.26 771.315 270.26C759.155 285.94 753.075 307.7 753.075 335.54C753.075 363.38 759.155 385.3 771.315 401.3C783.475 416.98 800.275 424.82 821.715 424.82C837.715 424.82 851.155 420.34 862.035 411.38C867.784 406.617 872.394 400.632 875.866 393.424C881.964 380.768 893.469 370.208 907.496 370.973L935.475 372.5C932.915 392.02 926.515 408.98 916.275 423.38C906.355 437.78 893.235 448.98 876.915 456.98C860.915 464.98 842.515 468.98 821.715 468.98Z" fill="white"/>
<path d="M447.721 463.22V207.86H468.031C482.646 207.86 494.608 219.49 495.02 234.099L496.201 276.02L489.961 272.66C492.841 256.02 498.281 242.58 506.281 232.34C514.281 222.1 524.041 214.58 535.561 209.78C547.081 204.66 559.561 202.1 573.001 202.1C592.201 202.1 608.041 206.42 620.521 215.06C633.321 223.38 642.921 234.9 649.321 249.62C656.041 264.02 659.401 280.5 659.401 299.06V463.22H635.521C620.609 463.22 608.521 451.131 608.521 436.22V314.42C608.521 299.38 606.921 286.74 603.721 276.5C600.521 266.26 595.241 258.42 587.881 252.98C580.521 247.54 570.921 244.82 559.081 244.82C541.161 244.82 526.601 250.74 515.401 262.58C504.201 274.42 498.601 291.7 498.601 314.42V463.22H447.721Z" fill="white"/>
<path d="M282.163 468.98C257.843 468.98 236.563 463.54 218.323 452.66C200.083 441.78 185.843 426.26 175.603 406.1C165.683 385.94 160.723 362.42 160.723 335.54C160.723 308.34 165.683 284.82 175.603 264.98C185.843 245.14 200.083 229.78 218.323 218.9C236.563 207.7 257.843 202.1 282.163 202.1C306.483 202.1 327.603 207.7 345.523 218.9C363.763 229.78 377.843 245.14 387.763 264.98C398.003 284.82 403.123 308.34 403.123 335.54C403.123 362.42 398.003 385.94 387.763 406.1C377.843 426.26 363.763 441.78 345.523 452.66C327.603 463.54 306.483 468.98 282.163 468.98ZM282.163 424.82C303.603 424.82 320.243 416.98 332.083 401.3C344.243 385.3 350.323 363.38 350.323 335.54C350.323 307.7 344.243 285.94 332.083 270.26C320.243 254.26 303.603 246.26 282.163 246.26C260.723 246.26 243.923 254.26 231.763 270.26C219.603 285.94 213.523 307.7 213.523 335.54C213.523 363.38 219.603 385.3 231.763 401.3C243.923 416.98 260.723 424.82 282.163 424.82Z" fill="white"/>
</svg>
</file>

<file path="public/trademark/type-light.svg">
<svg width="1830" height="589" viewBox="0 0 1830 589" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1617.54 463.22V234.86C1617.54 219.948 1629.62 207.86 1644.54 207.86H1668.42V436.22C1668.42 451.131 1656.33 463.22 1641.42 463.22H1617.54ZM1616.58 170.9V147.02C1616.58 132.108 1628.66 120.02 1643.58 120.02H1669.86V143.9C1669.86 158.811 1657.77 170.9 1642.86 170.9H1616.58Z" fill="black"/>
<path d="M1435.98 468.979C1410.38 468.979 1389.9 460.499 1374.54 443.539C1359.5 426.259 1351.98 402.419 1351.98 372.019V207.859H1375.86C1390.77 207.859 1402.86 219.948 1402.86 234.859V359.059C1402.86 382.099 1406.86 399.059 1414.86 409.939C1422.86 420.819 1435.02 426.259 1451.34 426.259C1469.9 426.259 1484.3 420.339 1494.54 408.499C1505.1 396.339 1510.38 379.379 1510.38 357.619V207.859H1561.26V463.219H1540.35C1525.59 463.219 1513.57 451.367 1513.36 436.608L1512.78 396.499L1519.98 399.379C1515.5 421.779 1506.06 439.059 1491.66 451.219C1477.26 463.059 1458.7 468.979 1435.98 468.979Z" fill="black"/>
<path d="M1081.63 468.98C1056.99 468.98 1035.55 463.54 1017.31 452.66C999.394 441.78 985.474 426.26 975.554 406.1C965.634 385.94 960.674 362.42 960.674 335.54C960.674 308.66 965.634 285.3 975.554 265.46C985.474 245.3 999.234 229.78 1016.83 218.9C1034.75 207.7 1055.87 202.1 1080.19 202.1C1103.55 202.1 1124.03 207.54 1141.63 218.42C1159.23 228.98 1172.83 244.34 1182.43 264.5C1192.35 284.66 1197.31 308.98 1197.31 337.46V350.42H1013.95C1015.23 375.38 1021.79 394.1 1033.63 406.58C1045.79 419.06 1061.95 425.3 1082.11 425.3C1097.47 425.3 1109.95 421.78 1119.55 414.74C1123.85 411.687 1127.61 408.184 1130.83 404.23C1138.47 394.849 1149.01 386.95 1161.08 387.718L1193.47 389.78C1186.75 413.46 1173.47 432.66 1153.63 447.38C1134.11 461.78 1110.11 468.98 1081.63 468.98ZM1013.95 312.02H1143.07C1141.47 289.3 1134.91 272.5 1123.39 261.62C1112.19 250.74 1097.79 245.3 1080.19 245.3C1062.27 245.3 1047.39 251.06 1035.55 262.58C1024.03 273.78 1016.83 290.26 1013.95 312.02Z" fill="black"/>
<path d="M821.715 468.98C797.075 468.98 775.635 463.54 757.395 452.66C739.475 441.78 725.395 426.26 715.155 406.1C705.235 385.94 700.275 362.42 700.275 335.54C700.275 308.66 705.235 285.3 715.155 265.46C725.395 245.3 739.475 229.78 757.395 218.9C775.635 207.7 797.075 202.1 821.715 202.1C842.195 202.1 860.435 205.78 876.435 213.14C892.755 220.18 906.035 230.58 916.275 244.34C926.515 258.1 932.915 274.9 935.475 294.74L907.111 296.287C893.245 297.043 881.896 286.575 874.968 274.54C871.612 268.709 867.301 263.762 862.035 259.7C851.155 250.74 837.715 246.26 821.715 246.26C800.275 246.26 783.475 254.26 771.315 270.26C759.155 285.94 753.075 307.7 753.075 335.54C753.075 363.38 759.155 385.3 771.315 401.3C783.475 416.98 800.275 424.82 821.715 424.82C837.715 424.82 851.155 420.34 862.035 411.38C867.784 406.617 872.394 400.632 875.866 393.424C881.964 380.768 893.469 370.208 907.496 370.973L935.475 372.5C932.915 392.02 926.515 408.98 916.275 423.38C906.355 437.78 893.235 448.98 876.915 456.98C860.915 464.98 842.515 468.98 821.715 468.98Z" fill="black"/>
<path d="M447.721 463.22V207.86H468.031C482.646 207.86 494.608 219.49 495.02 234.099L496.201 276.02L489.961 272.66C492.841 256.02 498.281 242.58 506.281 232.34C514.281 222.1 524.041 214.58 535.561 209.78C547.081 204.66 559.561 202.1 573.001 202.1C592.201 202.1 608.041 206.42 620.521 215.06C633.321 223.38 642.921 234.9 649.321 249.62C656.041 264.02 659.401 280.5 659.401 299.06V463.22H635.521C620.609 463.22 608.521 451.131 608.521 436.22V314.42C608.521 299.38 606.921 286.74 603.721 276.5C600.521 266.26 595.241 258.42 587.881 252.98C580.521 247.54 570.921 244.82 559.081 244.82C541.161 244.82 526.601 250.74 515.401 262.58C504.201 274.42 498.601 291.7 498.601 314.42V463.22H447.721Z" fill="black"/>
<path d="M282.163 468.98C257.843 468.98 236.563 463.54 218.323 452.66C200.083 441.78 185.843 426.26 175.603 406.1C165.683 385.94 160.723 362.42 160.723 335.54C160.723 308.34 165.683 284.82 175.603 264.98C185.843 245.14 200.083 229.78 218.323 218.9C236.563 207.7 257.843 202.1 282.163 202.1C306.483 202.1 327.603 207.7 345.523 218.9C363.763 229.78 377.843 245.14 387.763 264.98C398.003 284.82 403.123 308.34 403.123 335.54C403.123 362.42 398.003 385.94 387.763 406.1C377.843 426.26 363.763 441.78 345.523 452.66C327.603 463.54 306.483 468.98 282.163 468.98ZM282.163 424.82C303.603 424.82 320.243 416.98 332.083 401.3C344.243 385.3 350.323 363.38 350.323 335.54C350.323 307.7 344.243 285.94 332.083 270.26C320.243 254.26 303.603 246.26 282.163 246.26C260.723 246.26 243.923 254.26 231.763 270.26C219.603 285.94 213.523 307.7 213.523 335.54C213.523 363.38 219.603 385.3 231.763 401.3C243.923 416.98 260.723 424.82 282.163 424.82Z" fill="black"/>
</svg>
</file>

<file path="renderer/coverage/.tmp/coverage-0.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/edgeCases/serviceTransitions.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10645,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10645,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":983,"endOffset":4319,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1004,"endOffset":1061,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1124,"endOffset":1897,"count":1},{"startOffset":1557,"endOffset":1896,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1597,"endOffset":1795,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1952,"endOffset":2917,"count":1},{"startOffset":2307,"endOffset":2916,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2347,"endOffset":2554,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2599,"endOffset":2768,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2811,"endOffset":2911,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2966,"endOffset":4315,"count":1},{"startOffset":3972,"endOffset":4314,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3345,"endOffset":3527,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3562,"endOffset":3744,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3779,"endOffset":3963,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":4013,"endOffset":4309,"count":0}],"isBlockCoverage":false}]},{"scriptId":"1830","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusManager.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusManager","ranges":[{"startOffset":1243,"endOffset":5265,"count":4},{"startOffset":2878,"endOffset":3182,"count":0},{"startOffset":3207,"endOffset":3660,"count":0}],"isBlockCoverage":true},{"functionName":"handleTestConnection","ranges":[{"startOffset":1654,"endOffset":1705,"count":0}],"isBlockCoverage":false},{"functionName":"onToggle","ranges":[{"startOffset":2127,"endOffset":2169,"count":0}],"isBlockCoverage":false},{"functionName":"onClose","ranges":[{"startOffset":2977,"endOffset":3007,"count":0}],"isBlockCoverage":false},{"functionName":"onRetry","ranges":[{"startOffset":3414,"endOffset":3442,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":3882,"endOffset":3911,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":4442,"endOffset":4475,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":5375,"endOffset":5411,"count":3}],"isBlockCoverage":true}]},{"scriptId":"1834","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useServiceStatus.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"useServiceStatus","ranges":[{"startOffset":391,"endOffset":2794,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":628,"endOffset":707,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":771,"endOffset":1429,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1470,"endOffset":2703,"count":3}],"isBlockCoverage":true},{"functionName":"handleServiceStatusChanged","ranges":[{"startOffset":1517,"endOffset":2048,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2114,"endOffset":2544,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2664,"endOffset":2698,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":2900,"endOffset":2932,"count":4}],"isBlockCoverage":true}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusPanel.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusPanel","ranges":[{"startOffset":866,"endOffset":7393,"count":3},{"startOffset":1966,"endOffset":1971,"count":0},{"startOffset":2948,"endOffset":6998,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3397,"endOffset":6534,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":7501,"endOffset":7535,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2229","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/StatusIndicator.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":695,"endOffset":930,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusTooltip","ranges":[{"startOffset":957,"endOffset":1239,"count":0}],"isBlockCoverage":false},{"functionName":"StatusIndicator","ranges":[{"startOffset":1265,"endOffset":3962,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4067,"endOffset":4098,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2230","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ToastContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"ToastContainer","ranges":[{"startOffset":666,"endOffset":1673,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":926,"endOffset":1347,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1777,"endOffset":1807,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2231","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/Toast.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":541,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusIcon","ranges":[{"startOffset":800,"endOffset":993,"count":0}],"isBlockCoverage":false},{"functionName":"Toast","ranges":[{"startOffset":1009,"endOffset":3589,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3684,"endOffset":3705,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2232","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaSetupGuide.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaSetupGuide","ranges":[{"startOffset":543,"endOffset":21444,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":21550,"endOffset":21582,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2233","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ConnectionTroubleshooter.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"ConnectionTroubleshooter","ranges":[{"startOffset":1515,"endOffset":12380,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":12494,"endOffset":12534,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2234","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/utils/ipcMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"success","ranges":[{"startOffset":356,"endOffset":554,"count":0}],"isBlockCoverage":false},{"functionName":"error","ranges":[{"startOffset":565,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"event","ranges":[{"startOffset":787,"endOffset":1061,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1168,"endOffset":1199,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2235","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup/electronMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1787,"endOffset":1818,"count":0}],"isBlockCoverage":false}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-1.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/ipcServiceRecovery.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":12920,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":12920,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1051,"endOffset":1155,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1191,"endOffset":5002,"count":0}],"isBlockCoverage":false}]},{"scriptId":"1830","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusManager.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusManager","ranges":[{"startOffset":1243,"endOffset":5265,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":5375,"endOffset":5411,"count":0}],"isBlockCoverage":false}]},{"scriptId":"1834","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useServiceStatus.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"useServiceStatus","ranges":[{"startOffset":391,"endOffset":2794,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":2900,"endOffset":2932,"count":0}],"isBlockCoverage":false}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusPanel.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusPanel","ranges":[{"startOffset":866,"endOffset":7393,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":7501,"endOffset":7535,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2229","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/StatusIndicator.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":695,"endOffset":930,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusTooltip","ranges":[{"startOffset":957,"endOffset":1239,"count":0}],"isBlockCoverage":false},{"functionName":"StatusIndicator","ranges":[{"startOffset":1265,"endOffset":3962,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4067,"endOffset":4098,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2230","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ToastContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"ToastContainer","ranges":[{"startOffset":666,"endOffset":1673,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1777,"endOffset":1807,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2231","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/Toast.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":541,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusIcon","ranges":[{"startOffset":800,"endOffset":993,"count":0}],"isBlockCoverage":false},{"functionName":"Toast","ranges":[{"startOffset":1009,"endOffset":3589,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3684,"endOffset":3705,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2232","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaSetupGuide.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaSetupGuide","ranges":[{"startOffset":543,"endOffset":21444,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":21550,"endOffset":21582,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2233","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ConnectionTroubleshooter.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"ConnectionTroubleshooter","ranges":[{"startOffset":1515,"endOffset":12380,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":12494,"endOffset":12534,"count":0}],"isBlockCoverage":false}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-2.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/serviceStatus.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10647,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10647,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":820,"endOffset":4349,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1351,"endOffset":1562,"count":5}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1602,"endOffset":1973,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2010,"endOffset":2396,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2429,"endOffset":3236,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3280,"endOffset":3778,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3825,"endOffset":4345,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1831","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusManager.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusManager","ranges":[{"startOffset":1243,"endOffset":5265,"count":8},{"startOffset":2878,"endOffset":3182,"count":1},{"startOffset":3207,"endOffset":3660,"count":1}],"isBlockCoverage":true},{"functionName":"handleTestConnection","ranges":[{"startOffset":1654,"endOffset":1705,"count":0}],"isBlockCoverage":false},{"functionName":"onToggle","ranges":[{"startOffset":2127,"endOffset":2169,"count":1}],"isBlockCoverage":true},{"functionName":"onClose","ranges":[{"startOffset":2977,"endOffset":3007,"count":0}],"isBlockCoverage":false},{"functionName":"onRetry","ranges":[{"startOffset":3414,"endOffset":3442,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":3882,"endOffset":3911,"count":1}],"isBlockCoverage":true},{"functionName":"onClick","ranges":[{"startOffset":4442,"endOffset":4475,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":5375,"endOffset":5411,"count":5}],"isBlockCoverage":true}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useServiceStatus.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"useServiceStatus","ranges":[{"startOffset":391,"endOffset":2794,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":2900,"endOffset":2932,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1836","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusPanel.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusPanel","ranges":[{"startOffset":866,"endOffset":7393,"count":8},{"startOffset":1966,"endOffset":1971,"count":1},{"startOffset":1972,"endOffset":1975,"count":7},{"startOffset":2948,"endOffset":6998,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3397,"endOffset":6534,"count":4},{"startOffset":5637,"endOffset":6310,"count":2}],"isBlockCoverage":true},{"functionName":"onClick","ranges":[{"startOffset":5757,"endOffset":5783,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":7501,"endOffset":7535,"count":8}],"isBlockCoverage":true}]},{"scriptId":"2230","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/StatusIndicator.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":695,"endOffset":930,"count":4},{"startOffset":733,"endOffset":781,"count":2},{"startOffset":786,"endOffset":832,"count":1},{"startOffset":837,"endOffset":883,"count":1},{"startOffset":888,"endOffset":924,"count":0}],"isBlockCoverage":true},{"functionName":"getStatusTooltip","ranges":[{"startOffset":957,"endOffset":1239,"count":0}],"isBlockCoverage":false},{"functionName":"StatusIndicator","ranges":[{"startOffset":1265,"endOffset":3962,"count":4},{"startOffset":2131,"endOffset":3794,"count":0}],"isBlockCoverage":true},{"functionName":"onMouseEnter","ranges":[{"startOffset":1823,"endOffset":1849,"count":0}],"isBlockCoverage":false},{"functionName":"onMouseLeave","ranges":[{"startOffset":1873,"endOffset":1900,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4067,"endOffset":4098,"count":4}],"isBlockCoverage":true}]},{"scriptId":"2231","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ToastContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"ToastContainer","ranges":[{"startOffset":666,"endOffset":1673,"count":8}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":926,"endOffset":1347,"count":8}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1777,"endOffset":1807,"count":8}],"isBlockCoverage":true}]},{"scriptId":"2232","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/Toast.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":541,"endOffset":776,"count":8},{"startOffset":579,"endOffset":627,"count":0},{"startOffset":632,"endOffset":678,"count":0},{"startOffset":683,"endOffset":729,"count":0}],"isBlockCoverage":true},{"functionName":"getStatusIcon","ranges":[{"startOffset":800,"endOffset":993,"count":8},{"startOffset":838,"endOffset":875,"count":0},{"startOffset":880,"endOffset":914,"count":0},{"startOffset":919,"endOffset":956,"count":0}],"isBlockCoverage":true},{"functionName":"Toast","ranges":[{"startOffset":1009,"endOffset":3589,"count":8}],"isBlockCoverage":true},{"functionName":"onClick","ranges":[{"startOffset":3027,"endOffset":3045,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3684,"endOffset":3705,"count":8}],"isBlockCoverage":true}]},{"scriptId":"2233","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaSetupGuide.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaSetupGuide","ranges":[{"startOffset":543,"endOffset":21444,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":21550,"endOffset":21582,"count":1}],"isBlockCoverage":true}]},{"scriptId":"2234","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ConnectionTroubleshooter.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"ConnectionTroubleshooter","ranges":[{"startOffset":1515,"endOffset":12380,"count":1},{"startOffset":8143,"endOffset":8157,"count":0},{"startOffset":9387,"endOffset":10780,"count":0}],"isBlockCoverage":true},{"functionName":"handleTest","ranges":[{"startOffset":1821,"endOffset":2177,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":11398,"endOffset":11418,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":12494,"endOffset":12534,"count":1}],"isBlockCoverage":true}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-3.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/serviceStatusEdgeCases.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14266,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14266,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":831,"endOffset":5236,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":923,"endOffset":958,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1006,"endOffset":2571,"count":1},{"startOffset":2040,"endOffset":2570,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2163,"endOffset":2475,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2629,"endOffset":4214,"count":1},{"startOffset":4101,"endOffset":4155,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":4269,"endOffset":5232,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1831","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusManager.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusManager","ranges":[{"startOffset":1243,"endOffset":5265,"count":7},{"startOffset":2878,"endOffset":3182,"count":0},{"startOffset":3207,"endOffset":3660,"count":0}],"isBlockCoverage":true},{"functionName":"handleTestConnection","ranges":[{"startOffset":1654,"endOffset":1705,"count":0}],"isBlockCoverage":false},{"functionName":"onToggle","ranges":[{"startOffset":2127,"endOffset":2169,"count":1}],"isBlockCoverage":true},{"functionName":"onClose","ranges":[{"startOffset":2977,"endOffset":3007,"count":0}],"isBlockCoverage":false},{"functionName":"onRetry","ranges":[{"startOffset":3414,"endOffset":3442,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":3882,"endOffset":3911,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":4442,"endOffset":4475,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":5375,"endOffset":5411,"count":6}],"isBlockCoverage":true}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useServiceStatus.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"useServiceStatus","ranges":[{"startOffset":391,"endOffset":2794,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":2900,"endOffset":2932,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1836","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusPanel.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusPanel","ranges":[{"startOffset":866,"endOffset":7393,"count":7},{"startOffset":1966,"endOffset":1971,"count":1},{"startOffset":1972,"endOffset":1975,"count":6},{"startOffset":2948,"endOffset":6998,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3397,"endOffset":6534,"count":3}],"isBlockCoverage":true},{"functionName":"onClick","ranges":[{"startOffset":5757,"endOffset":5783,"count":3}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":7501,"endOffset":7535,"count":7}],"isBlockCoverage":true}]},{"scriptId":"2230","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/StatusIndicator.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":695,"endOffset":930,"count":3},{"startOffset":733,"endOffset":781,"count":0},{"startOffset":786,"endOffset":832,"count":0},{"startOffset":888,"endOffset":924,"count":0}],"isBlockCoverage":true},{"functionName":"getStatusTooltip","ranges":[{"startOffset":957,"endOffset":1239,"count":0}],"isBlockCoverage":false},{"functionName":"StatusIndicator","ranges":[{"startOffset":1265,"endOffset":3962,"count":3},{"startOffset":2131,"endOffset":3794,"count":0}],"isBlockCoverage":true},{"functionName":"onMouseEnter","ranges":[{"startOffset":1823,"endOffset":1849,"count":0}],"isBlockCoverage":false},{"functionName":"onMouseLeave","ranges":[{"startOffset":1873,"endOffset":1900,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4067,"endOffset":4098,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2231","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ToastContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"ToastContainer","ranges":[{"startOffset":666,"endOffset":1673,"count":7}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":926,"endOffset":1347,"count":7}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1777,"endOffset":1807,"count":7}],"isBlockCoverage":true}]},{"scriptId":"2232","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/Toast.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":541,"endOffset":776,"count":7},{"startOffset":579,"endOffset":627,"count":0},{"startOffset":632,"endOffset":678,"count":0},{"startOffset":683,"endOffset":729,"count":0}],"isBlockCoverage":true},{"functionName":"getStatusIcon","ranges":[{"startOffset":800,"endOffset":993,"count":7},{"startOffset":838,"endOffset":875,"count":0},{"startOffset":880,"endOffset":914,"count":0},{"startOffset":919,"endOffset":956,"count":0}],"isBlockCoverage":true},{"functionName":"Toast","ranges":[{"startOffset":1009,"endOffset":3589,"count":7}],"isBlockCoverage":true},{"functionName":"onClick","ranges":[{"startOffset":3027,"endOffset":3045,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":3684,"endOffset":3705,"count":7}],"isBlockCoverage":true}]},{"scriptId":"2233","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaSetupGuide.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaSetupGuide","ranges":[{"startOffset":543,"endOffset":21444,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":21550,"endOffset":21582,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2234","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ConnectionTroubleshooter.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"ConnectionTroubleshooter","ranges":[{"startOffset":1515,"endOffset":12380,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":12494,"endOffset":12534,"count":0}],"isBlockCoverage":false}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-4.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/memoryManagement.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":425,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":425,"count":1}],"isBlockCoverage":true}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-5.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/integration/userFlows.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14678,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14678,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":929,"endOffset":5832,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":950,"endOffset":1007,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1062,"endOffset":2593,"count":1},{"startOffset":1673,"endOffset":2592,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1565,"endOffset":1671,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2135,"endOffset":2245,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2458,"endOffset":2587,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2644,"endOffset":4036,"count":1},{"startOffset":3535,"endOffset":4035,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3421,"endOffset":3533,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3917,"endOffset":4030,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":4089,"endOffset":5828,"count":1},{"startOffset":4961,"endOffset":5827,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":4853,"endOffset":4959,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":5220,"endOffset":5330,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":5709,"endOffset":5822,"count":0}],"isBlockCoverage":false}]},{"scriptId":"1830","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/App.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7253,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7253,"count":1}],"isBlockCoverage":true},{"functionName":"App","ranges":[{"startOffset":1026,"endOffset":3206,"count":4}],"isBlockCoverage":true},{"functionName":"handleSendMessage","ranges":[{"startOffset":1156,"endOffset":1812,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3299,"endOffset":3318,"count":3}],"isBlockCoverage":true}]},{"scriptId":"1834","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7724,"count":1}],"isBlockCoverage":true},{"functionName":"ChatContainer","ranges":[{"startOffset":777,"endOffset":3358,"count":3},{"startOffset":1983,"endOffset":1993,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1133,"endOffset":1176,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1248,"endOffset":1312,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1380,"endOffset":1444,"count":0}],"isBlockCoverage":false},{"functionName":"handleSendMessage","ranges":[{"startOffset":1479,"endOffset":1626,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3460,"endOffset":3489,"count":3}],"isBlockCoverage":true}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatInput.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":28297,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":28297,"count":1}],"isBlockCoverage":true},{"functionName":"ChatInput","ranges":[{"startOffset":1365,"endOffset":13195,"count":3},{"startOffset":4904,"endOffset":4925,"count":0},{"startOffset":4992,"endOffset":5006,"count":0},{"startOffset":5007,"endOffset":5019,"count":0},{"startOffset":5443,"endOffset":6877,"count":0},{"startOffset":7351,"endOffset":7366,"count":0},{"startOffset":7367,"endOffset":7381,"count":0},{"startOffset":7382,"endOffset":7394,"count":0},{"startOffset":7466,"endOffset":7801,"count":0},{"startOffset":9651,"endOffset":10585,"count":0},{"startOffset":11911,"endOffset":12460,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1951,"endOffset":2143,"count":3},{"startOffset":2019,"endOffset":2139,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2215,"endOffset":2539,"count":0}],"isBlockCoverage":false},{"functionName":"navigateHistory","ranges":[{"startOffset":2579,"endOffset":3019,"count":0}],"isBlockCoverage":false},{"functionName":"handleSend","ranges":[{"startOffset":3042,"endOffset":3917,"count":0}],"isBlockCoverage":false},{"functionName":"onChange","ranges":[{"startOffset":4789,"endOffset":4822,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":13293,"endOffset":13318,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2229","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useOllama.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":12061,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":12061,"count":1}],"isBlockCoverage":true},{"functionName":"useOllama","ranges":[{"startOffset":366,"endOffset":3539,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":904,"endOffset":1341,"count":3},{"startOffset":1010,"endOffset":1112,"count":0},{"startOffset":1113,"endOffset":1118,"count":0},{"startOffset":1156,"endOffset":1169,"count":0},{"startOffset":1170,"endOffset":1176,"count":0},{"startOffset":1278,"endOffset":1304,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1403,"endOffset":1657,"count":3},{"startOffset":1515,"endOffset":1556,"count":0},{"startOffset":1620,"endOffset":1645,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1717,"endOffset":1964,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2027,"endOffset":2347,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2416,"endOffset":3124,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3165,"endOffset":3307,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3273,"endOffset":3302,"count":3}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":3637,"endOffset":3662,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2233","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/types/ipc.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7265,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7265,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":213,"endOffset":335,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":442,"endOffset":462,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2234","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/button.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":6695,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":6695,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2065,"endOffset":2608,"count":3},{"startOffset":2158,"endOffset":2186,"count":0}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":2738,"endOffset":2760,"count":3}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":2866,"endOffset":2896,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2239","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/lib/utils.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":1319,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":1319,"count":1}],"isBlockCoverage":true},{"functionName":"cn","ranges":[{"startOffset":481,"endOffset":583,"count":6}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":674,"endOffset":692,"count":6}],"isBlockCoverage":true}]},{"scriptId":"2241","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/input.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3367,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3367,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":626,"endOffset":1416,"count":3}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1543,"endOffset":1564,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2242","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatMessageList.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":22115,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":22115,"count":1}],"isBlockCoverage":true},{"functionName":"ChatMessageList","ranges":[{"startOffset":2091,"endOffset":9593,"count":3},{"startOffset":7709,"endOffset":8560,"count":0},{"startOffset":8575,"endOffset":9424,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2611,"endOffset":2865,"count":0}],"isBlockCoverage":false},{"functionName":"handleCorrection","ranges":[{"startOffset":2899,"endOffset":3964,"count":0}],"isBlockCoverage":false},{"functionName":"handleReaction","ranges":[{"startOffset":3991,"endOffset":4502,"count":0}],"isBlockCoverage":false},{"functionName":"CodeComponent","ranges":[{"startOffset":4528,"endOffset":5361,"count":0}],"isBlockCoverage":false},{"functionName":"renderMessageContent","ranges":[{"startOffset":5394,"endOffset":5934,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":6052,"endOffset":7691,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":9697,"endOffset":9728,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3157","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useMemory.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":15981,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":15981,"count":1}],"isBlockCoverage":true},{"functionName":"useMemory","ranges":[{"startOffset":536,"endOffset":4307,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":886,"endOffset":1917,"count":3}],"isBlockCoverage":true},{"functionName":"initializeMemory","ranges":[{"startOffset":923,"endOffset":1888,"count":3},{"startOffset":963,"endOffset":975,"count":0},{"startOffset":977,"endOffset":1635,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1958,"endOffset":2682,"count":3},{"startOffset":2000,"endOffset":2681,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2060,"endOffset":2131,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2166,"endOffset":2237,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2274,"endOffset":2334,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2369,"endOffset":2429,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2465,"endOffset":2546,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2582,"endOffset":2622,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2642,"endOffset":2677,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2746,"endOffset":3071,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3134,"endOffset":3315,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3384,"endOffset":3701,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3765,"endOffset":3918,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3983,"endOffset":4130,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4405,"endOffset":4430,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3465","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/card.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":8673,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":8673,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":622,"endOffset":1027,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1109,"endOffset":1473,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1566,"endOffset":1941,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2038,"endOffset":2400,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2505,"endOffset":2812,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2908,"endOffset":3269,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3404,"endOffset":3424,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3526,"endOffset":3552,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3654,"endOffset":3680,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3781,"endOffset":3806,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3913,"endOffset":3944,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4047,"endOffset":4074,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3466","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaTest.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaTest","ranges":[{"startOffset":515,"endOffset":9631,"count":4},{"startOffset":2432,"endOffset":3205,"count":0},{"startOffset":3206,"endOffset":3468,"count":3},{"startOffset":3657,"endOffset":6224,"count":0},{"startOffset":6611,"endOffset":8210,"count":0},{"startOffset":8211,"endOffset":8467,"count":3},{"startOffset":8649,"endOffset":9468,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":873,"endOffset":1654,"count":3}],"isBlockCoverage":true},{"functionName":"checkConnection","ranges":[{"startOffset":909,"endOffset":1163,"count":3},{"startOffset":1005,"endOffset":1051,"count":0},{"startOffset":1117,"endOffset":1147,"count":0}],"isBlockCoverage":true},{"functionName":"listModels","ranges":[{"startOffset":1188,"endOffset":1436,"count":3},{"startOffset":1292,"endOffset":1329,"count":0},{"startOffset":1395,"endOffset":1420,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1512,"endOffset":1560,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1615,"endOffset":1649,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":6711,"endOffset":8035,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":9730,"endOffset":9756,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3467","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusManager.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusManager","ranges":[{"startOffset":1243,"endOffset":5265,"count":4},{"startOffset":2878,"endOffset":3182,"count":0},{"startOffset":3207,"endOffset":3660,"count":0}],"isBlockCoverage":true},{"functionName":"handleTestConnection","ranges":[{"startOffset":1654,"endOffset":1705,"count":0}],"isBlockCoverage":false},{"functionName":"onToggle","ranges":[{"startOffset":2127,"endOffset":2169,"count":0}],"isBlockCoverage":false},{"functionName":"onClose","ranges":[{"startOffset":2977,"endOffset":3007,"count":0}],"isBlockCoverage":false},{"functionName":"onRetry","ranges":[{"startOffset":3414,"endOffset":3442,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":3882,"endOffset":3911,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":4442,"endOffset":4475,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":5375,"endOffset":5411,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3468","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useServiceStatus.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"useServiceStatus","ranges":[{"startOffset":391,"endOffset":2794,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":628,"endOffset":707,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":771,"endOffset":1429,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1470,"endOffset":2703,"count":3}],"isBlockCoverage":true},{"functionName":"handleServiceStatusChanged","ranges":[{"startOffset":1517,"endOffset":2048,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2114,"endOffset":2544,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2664,"endOffset":2698,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":2900,"endOffset":2932,"count":4}],"isBlockCoverage":true}]},{"scriptId":"3469","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusPanel.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusPanel","ranges":[{"startOffset":866,"endOffset":7393,"count":3},{"startOffset":1966,"endOffset":1971,"count":0},{"startOffset":2948,"endOffset":6998,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3397,"endOffset":6534,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":7501,"endOffset":7535,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3470","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/StatusIndicator.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":695,"endOffset":930,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusTooltip","ranges":[{"startOffset":957,"endOffset":1239,"count":0}],"isBlockCoverage":false},{"functionName":"StatusIndicator","ranges":[{"startOffset":1265,"endOffset":3962,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4067,"endOffset":4098,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3471","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ToastContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"ToastContainer","ranges":[{"startOffset":666,"endOffset":1673,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":926,"endOffset":1347,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1777,"endOffset":1807,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3472","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/Toast.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":541,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusIcon","ranges":[{"startOffset":800,"endOffset":993,"count":0}],"isBlockCoverage":false},{"functionName":"Toast","ranges":[{"startOffset":1009,"endOffset":3589,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3684,"endOffset":3705,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaSetupGuide.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaSetupGuide","ranges":[{"startOffset":543,"endOffset":21444,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":21550,"endOffset":21582,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3474","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ConnectionTroubleshooter.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"ConnectionTroubleshooter","ranges":[{"startOffset":1515,"endOffset":12380,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":12494,"endOffset":12534,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3475","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/utils/ipcMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"success","ranges":[{"startOffset":356,"endOffset":554,"count":0}],"isBlockCoverage":false},{"functionName":"error","ranges":[{"startOffset":565,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"event","ranges":[{"startOffset":787,"endOffset":1061,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1168,"endOffset":1199,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3476","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup/electronMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1787,"endOffset":1818,"count":0}],"isBlockCoverage":false}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-6.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/build.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10990,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10990,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":785,"endOffset":4048,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":806,"endOffset":841,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":896,"endOffset":1984,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2037,"endOffset":2848,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2912,"endOffset":4044,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1831","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/App.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7253,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7253,"count":1}],"isBlockCoverage":true},{"functionName":"App","ranges":[{"startOffset":1026,"endOffset":3206,"count":4}],"isBlockCoverage":true},{"functionName":"handleSendMessage","ranges":[{"startOffset":1156,"endOffset":1812,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3299,"endOffset":3318,"count":3}],"isBlockCoverage":true}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7724,"count":1}],"isBlockCoverage":true},{"functionName":"ChatContainer","ranges":[{"startOffset":777,"endOffset":3358,"count":3},{"startOffset":1983,"endOffset":1993,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1133,"endOffset":1176,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1248,"endOffset":1312,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1380,"endOffset":1444,"count":0}],"isBlockCoverage":false},{"functionName":"handleSendMessage","ranges":[{"startOffset":1479,"endOffset":1626,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3460,"endOffset":3489,"count":3}],"isBlockCoverage":true}]},{"scriptId":"1836","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatInput.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":28297,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":28297,"count":1}],"isBlockCoverage":true},{"functionName":"ChatInput","ranges":[{"startOffset":1365,"endOffset":13195,"count":3},{"startOffset":4904,"endOffset":4925,"count":0},{"startOffset":4992,"endOffset":5006,"count":0},{"startOffset":5007,"endOffset":5019,"count":0},{"startOffset":5443,"endOffset":6877,"count":0},{"startOffset":7351,"endOffset":7366,"count":0},{"startOffset":7367,"endOffset":7381,"count":0},{"startOffset":7382,"endOffset":7394,"count":0},{"startOffset":7466,"endOffset":7801,"count":0},{"startOffset":9651,"endOffset":10585,"count":0},{"startOffset":11911,"endOffset":12460,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1951,"endOffset":2143,"count":3},{"startOffset":2019,"endOffset":2139,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2215,"endOffset":2539,"count":0}],"isBlockCoverage":false},{"functionName":"navigateHistory","ranges":[{"startOffset":2579,"endOffset":3019,"count":0}],"isBlockCoverage":false},{"functionName":"handleSend","ranges":[{"startOffset":3042,"endOffset":3917,"count":0}],"isBlockCoverage":false},{"functionName":"onChange","ranges":[{"startOffset":4789,"endOffset":4822,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":13293,"endOffset":13318,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2230","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useOllama.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":12061,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":12061,"count":1}],"isBlockCoverage":true},{"functionName":"useOllama","ranges":[{"startOffset":366,"endOffset":3539,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":904,"endOffset":1341,"count":3},{"startOffset":1010,"endOffset":1112,"count":0},{"startOffset":1113,"endOffset":1118,"count":0},{"startOffset":1156,"endOffset":1169,"count":0},{"startOffset":1170,"endOffset":1176,"count":0},{"startOffset":1278,"endOffset":1304,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1403,"endOffset":1657,"count":3},{"startOffset":1515,"endOffset":1556,"count":0},{"startOffset":1620,"endOffset":1645,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1717,"endOffset":1964,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2027,"endOffset":2347,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2416,"endOffset":3124,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3165,"endOffset":3307,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3273,"endOffset":3302,"count":3}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":3637,"endOffset":3662,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2234","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/types/ipc.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7265,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7265,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":213,"endOffset":335,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":442,"endOffset":462,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2235","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/button.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":6695,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":6695,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2065,"endOffset":2608,"count":3},{"startOffset":2158,"endOffset":2186,"count":0}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":2738,"endOffset":2760,"count":3}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":2866,"endOffset":2896,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2240","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/lib/utils.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":1319,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":1319,"count":1}],"isBlockCoverage":true},{"functionName":"cn","ranges":[{"startOffset":481,"endOffset":583,"count":6}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":674,"endOffset":692,"count":6}],"isBlockCoverage":true}]},{"scriptId":"2242","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/input.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3367,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3367,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":626,"endOffset":1416,"count":3}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1543,"endOffset":1564,"count":3}],"isBlockCoverage":true}]},{"scriptId":"2243","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatMessageList.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":22115,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":22115,"count":1}],"isBlockCoverage":true},{"functionName":"ChatMessageList","ranges":[{"startOffset":2091,"endOffset":9593,"count":3},{"startOffset":7709,"endOffset":8560,"count":0},{"startOffset":8575,"endOffset":9424,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2611,"endOffset":2865,"count":0}],"isBlockCoverage":false},{"functionName":"handleCorrection","ranges":[{"startOffset":2899,"endOffset":3964,"count":0}],"isBlockCoverage":false},{"functionName":"handleReaction","ranges":[{"startOffset":3991,"endOffset":4502,"count":0}],"isBlockCoverage":false},{"functionName":"CodeComponent","ranges":[{"startOffset":4528,"endOffset":5361,"count":0}],"isBlockCoverage":false},{"functionName":"renderMessageContent","ranges":[{"startOffset":5394,"endOffset":5934,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":6052,"endOffset":7691,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":9697,"endOffset":9728,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3158","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useMemory.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":15981,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":15981,"count":1}],"isBlockCoverage":true},{"functionName":"useMemory","ranges":[{"startOffset":536,"endOffset":4307,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":886,"endOffset":1917,"count":3}],"isBlockCoverage":true},{"functionName":"initializeMemory","ranges":[{"startOffset":923,"endOffset":1888,"count":3},{"startOffset":963,"endOffset":975,"count":0},{"startOffset":977,"endOffset":1635,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1958,"endOffset":2682,"count":3},{"startOffset":2000,"endOffset":2681,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2060,"endOffset":2131,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2166,"endOffset":2237,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2274,"endOffset":2334,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2369,"endOffset":2429,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2465,"endOffset":2546,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2582,"endOffset":2622,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2642,"endOffset":2677,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2746,"endOffset":3071,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3134,"endOffset":3315,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3384,"endOffset":3701,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3765,"endOffset":3918,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3983,"endOffset":4130,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4405,"endOffset":4430,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3466","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/card.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":8673,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":8673,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":622,"endOffset":1027,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1109,"endOffset":1473,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1566,"endOffset":1941,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2038,"endOffset":2400,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2505,"endOffset":2812,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2908,"endOffset":3269,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3404,"endOffset":3424,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3526,"endOffset":3552,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3654,"endOffset":3680,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3781,"endOffset":3806,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3913,"endOffset":3944,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4047,"endOffset":4074,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3467","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaTest.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaTest","ranges":[{"startOffset":515,"endOffset":9631,"count":4},{"startOffset":2432,"endOffset":3205,"count":0},{"startOffset":3206,"endOffset":3468,"count":3},{"startOffset":3657,"endOffset":6224,"count":0},{"startOffset":6611,"endOffset":8210,"count":0},{"startOffset":8211,"endOffset":8467,"count":3},{"startOffset":8649,"endOffset":9468,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":873,"endOffset":1654,"count":3}],"isBlockCoverage":true},{"functionName":"checkConnection","ranges":[{"startOffset":909,"endOffset":1163,"count":0}],"isBlockCoverage":false},{"functionName":"listModels","ranges":[{"startOffset":1188,"endOffset":1436,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1512,"endOffset":1560,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1615,"endOffset":1649,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":6711,"endOffset":8035,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":9730,"endOffset":9756,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3468","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusManager.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusManager","ranges":[{"startOffset":1243,"endOffset":5265,"count":3},{"startOffset":2878,"endOffset":3182,"count":0},{"startOffset":3207,"endOffset":3660,"count":0}],"isBlockCoverage":true},{"functionName":"handleTestConnection","ranges":[{"startOffset":1654,"endOffset":1705,"count":0}],"isBlockCoverage":false},{"functionName":"onToggle","ranges":[{"startOffset":2127,"endOffset":2169,"count":0}],"isBlockCoverage":false},{"functionName":"onClose","ranges":[{"startOffset":2977,"endOffset":3007,"count":0}],"isBlockCoverage":false},{"functionName":"onRetry","ranges":[{"startOffset":3414,"endOffset":3442,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":3882,"endOffset":3911,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":4442,"endOffset":4475,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":5375,"endOffset":5411,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3469","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useServiceStatus.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"useServiceStatus","ranges":[{"startOffset":391,"endOffset":2794,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":2900,"endOffset":2932,"count":1}],"isBlockCoverage":true}]},{"scriptId":"3470","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusPanel.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusPanel","ranges":[{"startOffset":866,"endOffset":7393,"count":3},{"startOffset":1966,"endOffset":1971,"count":0},{"startOffset":2948,"endOffset":6998,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3397,"endOffset":6534,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":7501,"endOffset":7535,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3471","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/StatusIndicator.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":695,"endOffset":930,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusTooltip","ranges":[{"startOffset":957,"endOffset":1239,"count":0}],"isBlockCoverage":false},{"functionName":"StatusIndicator","ranges":[{"startOffset":1265,"endOffset":3962,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4067,"endOffset":4098,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3472","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ToastContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"ToastContainer","ranges":[{"startOffset":666,"endOffset":1673,"count":3}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":926,"endOffset":1347,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1777,"endOffset":1807,"count":3}],"isBlockCoverage":true}]},{"scriptId":"3473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/Toast.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":541,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusIcon","ranges":[{"startOffset":800,"endOffset":993,"count":0}],"isBlockCoverage":false},{"functionName":"Toast","ranges":[{"startOffset":1009,"endOffset":3589,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3684,"endOffset":3705,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3474","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaSetupGuide.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaSetupGuide","ranges":[{"startOffset":543,"endOffset":21444,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":21550,"endOffset":21582,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3475","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ConnectionTroubleshooter.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"ConnectionTroubleshooter","ranges":[{"startOffset":1515,"endOffset":12380,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":12494,"endOffset":12534,"count":0}],"isBlockCoverage":false}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-7.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/errorBoundary/errorHandling.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14261,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14261,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":933,"endOffset":5891,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":954,"endOffset":1099,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1080,"endOffset":1093,"count":12}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1114,"endOffset":1173,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1225,"endOffset":1871,"count":1},{"startOffset":1786,"endOffset":1870,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1672,"endOffset":1784,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1928,"endOffset":2919,"count":1},{"startOffset":2915,"endOffset":2918,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2611,"endOffset":2913,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2991,"endOffset":4293,"count":1},{"startOffset":3629,"endOffset":4292,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3436,"endOffset":3627,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3761,"endOffset":3948,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":4092,"endOffset":4287,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":4353,"endOffset":5887,"count":1},{"startOffset":5192,"endOffset":5886,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":5074,"endOffset":5190,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":5763,"endOffset":5881,"count":0}],"isBlockCoverage":false}]},{"scriptId":"1830","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/App.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7253,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7253,"count":1}],"isBlockCoverage":true},{"functionName":"App","ranges":[{"startOffset":1026,"endOffset":3206,"count":5}],"isBlockCoverage":true},{"functionName":"handleSendMessage","ranges":[{"startOffset":1156,"endOffset":1812,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3299,"endOffset":3318,"count":4}],"isBlockCoverage":true}]},{"scriptId":"1834","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7724,"count":1}],"isBlockCoverage":true},{"functionName":"ChatContainer","ranges":[{"startOffset":777,"endOffset":3358,"count":4},{"startOffset":1983,"endOffset":1993,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1133,"endOffset":1176,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1248,"endOffset":1312,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1380,"endOffset":1444,"count":0}],"isBlockCoverage":false},{"functionName":"handleSendMessage","ranges":[{"startOffset":1479,"endOffset":1626,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3460,"endOffset":3489,"count":4}],"isBlockCoverage":true}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatInput.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":28297,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":28297,"count":1}],"isBlockCoverage":true},{"functionName":"ChatInput","ranges":[{"startOffset":1365,"endOffset":13195,"count":4},{"startOffset":4904,"endOffset":4925,"count":0},{"startOffset":4992,"endOffset":5006,"count":0},{"startOffset":5007,"endOffset":5019,"count":0},{"startOffset":5443,"endOffset":6877,"count":0},{"startOffset":7351,"endOffset":7366,"count":0},{"startOffset":7367,"endOffset":7381,"count":0},{"startOffset":7382,"endOffset":7394,"count":0},{"startOffset":7466,"endOffset":7801,"count":0},{"startOffset":9651,"endOffset":10585,"count":0},{"startOffset":11911,"endOffset":12460,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1951,"endOffset":2143,"count":4},{"startOffset":2019,"endOffset":2139,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2215,"endOffset":2539,"count":0}],"isBlockCoverage":false},{"functionName":"navigateHistory","ranges":[{"startOffset":2579,"endOffset":3019,"count":0}],"isBlockCoverage":false},{"functionName":"handleSend","ranges":[{"startOffset":3042,"endOffset":3917,"count":0}],"isBlockCoverage":false},{"functionName":"onChange","ranges":[{"startOffset":4789,"endOffset":4822,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":13293,"endOffset":13318,"count":4}],"isBlockCoverage":true}]},{"scriptId":"2229","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useOllama.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":12061,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":12061,"count":1}],"isBlockCoverage":true},{"functionName":"useOllama","ranges":[{"startOffset":366,"endOffset":3539,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":904,"endOffset":1341,"count":4},{"startOffset":1010,"endOffset":1112,"count":0},{"startOffset":1113,"endOffset":1118,"count":0},{"startOffset":1156,"endOffset":1169,"count":0},{"startOffset":1170,"endOffset":1176,"count":0},{"startOffset":1278,"endOffset":1304,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1403,"endOffset":1657,"count":4},{"startOffset":1515,"endOffset":1556,"count":0},{"startOffset":1620,"endOffset":1645,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1717,"endOffset":1964,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2027,"endOffset":2347,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2416,"endOffset":3124,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3165,"endOffset":3307,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3273,"endOffset":3302,"count":4}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":3637,"endOffset":3662,"count":4}],"isBlockCoverage":true}]},{"scriptId":"2233","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/types/ipc.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7265,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7265,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":213,"endOffset":335,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":442,"endOffset":462,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2234","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/button.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":6695,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":6695,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2065,"endOffset":2608,"count":4},{"startOffset":2158,"endOffset":2186,"count":0}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":2738,"endOffset":2760,"count":4}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":2866,"endOffset":2896,"count":0}],"isBlockCoverage":false}]},{"scriptId":"2239","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/lib/utils.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":1319,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":1319,"count":1}],"isBlockCoverage":true},{"functionName":"cn","ranges":[{"startOffset":481,"endOffset":583,"count":8}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":674,"endOffset":692,"count":8}],"isBlockCoverage":true}]},{"scriptId":"2241","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/input.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3367,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3367,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":626,"endOffset":1416,"count":4}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1543,"endOffset":1564,"count":4}],"isBlockCoverage":true}]},{"scriptId":"2242","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ChatMessageList.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":22115,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":22115,"count":1}],"isBlockCoverage":true},{"functionName":"ChatMessageList","ranges":[{"startOffset":2091,"endOffset":9593,"count":4},{"startOffset":7709,"endOffset":8560,"count":0},{"startOffset":8575,"endOffset":9424,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2611,"endOffset":2865,"count":0}],"isBlockCoverage":false},{"functionName":"handleCorrection","ranges":[{"startOffset":2899,"endOffset":3964,"count":0}],"isBlockCoverage":false},{"functionName":"handleReaction","ranges":[{"startOffset":3991,"endOffset":4502,"count":0}],"isBlockCoverage":false},{"functionName":"CodeComponent","ranges":[{"startOffset":4528,"endOffset":5361,"count":0}],"isBlockCoverage":false},{"functionName":"renderMessageContent","ranges":[{"startOffset":5394,"endOffset":5934,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":6052,"endOffset":7691,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":9697,"endOffset":9728,"count":4}],"isBlockCoverage":true}]},{"scriptId":"3157","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useMemory.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":15981,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":15981,"count":1}],"isBlockCoverage":true},{"functionName":"useMemory","ranges":[{"startOffset":536,"endOffset":4307,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":886,"endOffset":1917,"count":4}],"isBlockCoverage":true},{"functionName":"initializeMemory","ranges":[{"startOffset":923,"endOffset":1888,"count":4},{"startOffset":963,"endOffset":975,"count":0},{"startOffset":977,"endOffset":1635,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1958,"endOffset":2682,"count":4},{"startOffset":2000,"endOffset":2681,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2060,"endOffset":2131,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2166,"endOffset":2237,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2274,"endOffset":2334,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2369,"endOffset":2429,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2465,"endOffset":2546,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2582,"endOffset":2622,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2642,"endOffset":2677,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2746,"endOffset":3071,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3134,"endOffset":3315,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3384,"endOffset":3701,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3765,"endOffset":3918,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":3983,"endOffset":4130,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4405,"endOffset":4430,"count":4}],"isBlockCoverage":true}]},{"scriptId":"3465","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ui/card.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":8673,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":8673,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":622,"endOffset":1027,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1109,"endOffset":1473,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1566,"endOffset":1941,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2038,"endOffset":2400,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2505,"endOffset":2812,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2908,"endOffset":3269,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3404,"endOffset":3424,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3526,"endOffset":3552,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3654,"endOffset":3680,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3781,"endOffset":3806,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3913,"endOffset":3944,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4047,"endOffset":4074,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3466","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaTest.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaTest","ranges":[{"startOffset":515,"endOffset":9631,"count":5},{"startOffset":2432,"endOffset":3205,"count":0},{"startOffset":3206,"endOffset":3468,"count":4},{"startOffset":3657,"endOffset":6224,"count":0},{"startOffset":6611,"endOffset":8210,"count":0},{"startOffset":8211,"endOffset":8467,"count":4},{"startOffset":8649,"endOffset":9468,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":873,"endOffset":1654,"count":4}],"isBlockCoverage":true},{"functionName":"checkConnection","ranges":[{"startOffset":909,"endOffset":1163,"count":4},{"startOffset":1005,"endOffset":1051,"count":0},{"startOffset":1117,"endOffset":1147,"count":0}],"isBlockCoverage":true},{"functionName":"listModels","ranges":[{"startOffset":1188,"endOffset":1436,"count":4},{"startOffset":1292,"endOffset":1329,"count":0},{"startOffset":1395,"endOffset":1420,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1512,"endOffset":1560,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1615,"endOffset":1649,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":6711,"endOffset":8035,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":9730,"endOffset":9756,"count":4}],"isBlockCoverage":true}]},{"scriptId":"3467","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusManager.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":10286,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusManager","ranges":[{"startOffset":1243,"endOffset":5265,"count":5},{"startOffset":2878,"endOffset":3182,"count":0},{"startOffset":3207,"endOffset":3660,"count":0}],"isBlockCoverage":true},{"functionName":"handleTestConnection","ranges":[{"startOffset":1654,"endOffset":1705,"count":0}],"isBlockCoverage":false},{"functionName":"onToggle","ranges":[{"startOffset":2127,"endOffset":2169,"count":0}],"isBlockCoverage":false},{"functionName":"onClose","ranges":[{"startOffset":2977,"endOffset":3007,"count":0}],"isBlockCoverage":false},{"functionName":"onRetry","ranges":[{"startOffset":3414,"endOffset":3442,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":3882,"endOffset":3911,"count":0}],"isBlockCoverage":false},{"functionName":"onClick","ranges":[{"startOffset":4442,"endOffset":4475,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":5375,"endOffset":5411,"count":4}],"isBlockCoverage":true}]},{"scriptId":"3468","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/hooks/useServiceStatus.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9707,"count":1}],"isBlockCoverage":true},{"functionName":"useServiceStatus","ranges":[{"startOffset":391,"endOffset":2794,"count":5}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":628,"endOffset":707,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":771,"endOffset":1429,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":1470,"endOffset":2703,"count":4}],"isBlockCoverage":true},{"functionName":"handleServiceStatusChanged","ranges":[{"startOffset":1517,"endOffset":2048,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2114,"endOffset":2544,"count":0}],"isBlockCoverage":false},{"functionName":"","ranges":[{"startOffset":2664,"endOffset":2698,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":2900,"endOffset":2932,"count":5}],"isBlockCoverage":true}]},{"scriptId":"3469","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ServiceStatusPanel.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":14470,"count":1}],"isBlockCoverage":true},{"functionName":"ServiceStatusPanel","ranges":[{"startOffset":866,"endOffset":7393,"count":4},{"startOffset":1966,"endOffset":1971,"count":0},{"startOffset":2948,"endOffset":6998,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3397,"endOffset":6534,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":7501,"endOffset":7535,"count":4}],"isBlockCoverage":true}]},{"scriptId":"3470","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/StatusIndicator.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":9201,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":695,"endOffset":930,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusTooltip","ranges":[{"startOffset":957,"endOffset":1239,"count":0}],"isBlockCoverage":false},{"functionName":"StatusIndicator","ranges":[{"startOffset":1265,"endOffset":3962,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":4067,"endOffset":4098,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3471","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ToastContainer.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":3846,"count":1}],"isBlockCoverage":true},{"functionName":"ToastContainer","ranges":[{"startOffset":666,"endOffset":1673,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":926,"endOffset":1347,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1777,"endOffset":1807,"count":4}],"isBlockCoverage":true}]},{"scriptId":"3472","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/Toast.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7988,"count":1}],"isBlockCoverage":true},{"functionName":"getStatusColor","ranges":[{"startOffset":541,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"getStatusIcon","ranges":[{"startOffset":800,"endOffset":993,"count":0}],"isBlockCoverage":false},{"functionName":"Toast","ranges":[{"startOffset":1009,"endOffset":3589,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":3684,"endOffset":3705,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaSetupGuide.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":34445,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaSetupGuide","ranges":[{"startOffset":543,"endOffset":21444,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":21550,"endOffset":21582,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3474","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/ConnectionTroubleshooter.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":23485,"count":1}],"isBlockCoverage":true},{"functionName":"ConnectionTroubleshooter","ranges":[{"startOffset":1515,"endOffset":12380,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":12494,"endOffset":12534,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3475","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/utils/ipcMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"success","ranges":[{"startOffset":356,"endOffset":554,"count":0}],"isBlockCoverage":false},{"functionName":"error","ranges":[{"startOffset":565,"endOffset":776,"count":0}],"isBlockCoverage":false},{"functionName":"event","ranges":[{"startOffset":787,"endOffset":1061,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":1168,"endOffset":1199,"count":0}],"isBlockCoverage":false}]},{"scriptId":"3476","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup/electronMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1787,"endOffset":1818,"count":0}],"isBlockCoverage":false}]}]}
</file>

<file path="renderer/coverage/.tmp/coverage-8.json">
{"result":[{"scriptId":"1199","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":724,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":724,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1473","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/components/OllamaTest.test.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":7318,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":7318,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":942,"endOffset":3464,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":963,"endOffset":1020,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1054,"endOffset":1448,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1495,"endOffset":2089,"count":1},{"startOffset":2085,"endOffset":2088,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1983,"endOffset":2083,"count":20}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2125,"endOffset":2679,"count":1},{"startOffset":2675,"endOffset":2678,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2570,"endOffset":2673,"count":19}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":2719,"endOffset":3460,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":3257,"endOffset":3454,"count":1}],"isBlockCoverage":true}]},{"scriptId":"1830","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/components/OllamaTest.tsx","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":19015,"count":1}],"isBlockCoverage":true},{"functionName":"OllamaTest","ranges":[{"startOffset":515,"endOffset":9631,"count":9},{"startOffset":2432,"endOffset":3205,"count":0},{"startOffset":3206,"endOffset":3468,"count":8},{"startOffset":3657,"endOffset":6224,"count":1},{"startOffset":4768,"endOffset":4772,"count":0},{"startOffset":5237,"endOffset":5529,"count":0},{"startOffset":6611,"endOffset":8210,"count":0},{"startOffset":8211,"endOffset":8467,"count":8},{"startOffset":8649,"endOffset":9468,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":873,"endOffset":1654,"count":4}],"isBlockCoverage":true},{"functionName":"checkConnection","ranges":[{"startOffset":909,"endOffset":1163,"count":4},{"startOffset":1005,"endOffset":1051,"count":0},{"startOffset":1117,"endOffset":1147,"count":0}],"isBlockCoverage":true},{"functionName":"listModels","ranges":[{"startOffset":1188,"endOffset":1436,"count":4},{"startOffset":1292,"endOffset":1329,"count":0},{"startOffset":1395,"endOffset":1420,"count":0}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1512,"endOffset":1560,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1615,"endOffset":1649,"count":4}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":6711,"endOffset":8035,"count":0}],"isBlockCoverage":false},{"functionName":"get","ranges":[{"startOffset":9730,"endOffset":9756,"count":4}],"isBlockCoverage":true}]},{"scriptId":"1835","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/utils/ipcMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4010,"count":1}],"isBlockCoverage":true},{"functionName":"success","ranges":[{"startOffset":356,"endOffset":554,"count":1},{"startOffset":507,"endOffset":550,"count":0}],"isBlockCoverage":true},{"functionName":"error","ranges":[{"startOffset":565,"endOffset":776,"count":1},{"startOffset":717,"endOffset":772,"count":0}],"isBlockCoverage":true},{"functionName":"event","ranges":[{"startOffset":787,"endOffset":1061,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":968,"endOffset":1049,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":1023,"endOffset":1040,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1168,"endOffset":1199,"count":3}],"isBlockCoverage":true}]},{"scriptId":"1836","url":"file:///Users/jibbr/Desktop/osipelican/renderer/src/tests/setup/electronMocks.ts","functions":[{"functionName":"","ranges":[{"startOffset":0,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"","ranges":[{"startOffset":13,"endOffset":4649,"count":1}],"isBlockCoverage":true},{"functionName":"get","ranges":[{"startOffset":1787,"endOffset":1818,"count":3}],"isBlockCoverage":true}]}]}
</file>

<file path="renderer/scripts/test.sh">
#!/bin/bash
# Exit on error
set -e
echo " Running test suite..."
# Clean previous coverage
rm -rf coverage/
# Run tests without coverage
npm run test
# Check if tests passed
if [ $? -eq 0 ]; then
    echo " All tests passed!"
else
    echo " Tests failed!"
    exit 1
fi
# Run tests in different environments
echo " Testing in different environments..."
# Test with Ollama unavailable
echo "Testing with Ollama unavailable..."
OLLAMA_AVAILABLE=false npm run test
# Test with high latency
echo "Testing with high latency..."
OLLAMA_LATENCY=1000 npm run test
# Test with limited resources
echo "Testing with limited resources..."
OLLAMA_MEMORY_LIMIT=512 npm run test
echo " Test suite completed!"
</file>

<file path="renderer/src/api/ollama.ts">
import type { 
  OllamaModel, 
  OllamaConnectionStatus,
  ModelLoadingState
} from '@electron-app/types/ipc';
import type {
  OllamaRequestOptions
} from '@electron-app/types/ollama';
// Type definitions for better type safety
interface ElectronAPI {
  ipc: {
    invoke: <T = any>(channel: string, ...args: any[]) => Promise<T>;
    on: (channel: string, callback: (...args: any[]) => void) => () => void;
    once: (channel: string, callback: (...args: any[]) => void) => void;
    removeListener: (channel: string, callback: (...args: any[]) => void) => void;
    removeAllListeners: (channel: string) => void;
  };
  ollama: {
    listModels: () => Promise<{ models: OllamaModel[] }>;
    setModel: (modelName: string) => Promise<void>;
    checkConnection: () => Promise<OllamaConnectionStatus>;
    cancelLoad: () => Promise<void>;
    saveConfig: (modelName: string, config: OllamaRequestOptions) => Promise<void>;
    onModelLoadingStateChanged: (callback: (state: ModelLoadingState) => void) => () => void;
  };
}
declare global {
  interface Window {
    electron: ElectronAPI;
  }
}
export const ollamaAPI = {
  listModels: () => window.electron.ollama.listModels(),
  setModel: (modelName: string) => window.electron.ollama.setModel(modelName),
  checkConnection: () => window.electron.ollama.checkConnection(),
  cancelLoad: () => window.electron.ollama.cancelLoad(),
  saveConfig: (modelName: string, config: OllamaRequestOptions) => 
    window.electron.ollama.saveConfig(modelName, config),
  onModelLoadingStateChanged: (callback: (state: ModelLoadingState) => void) => 
    window.electron.ollama.onModelLoadingStateChanged(callback),
  onConnectionStatusChanged: (callback: (status: OllamaConnectionStatus) => void) => {
    const checkStatus = async () => {
      try {
        const status = await window.electron.ollama.checkConnection();
        callback(status);
      } catch (error) {
        callback({ status: 'disconnected', lastChecked: Date.now() });
      }
    };
    // Initial check
    checkStatus();
    // Set up periodic checks
    const interval = setInterval(checkStatus, 5000);
    // Return cleanup function
    return () => {
      clearInterval(interval);
    };
  }
};
</file>

<file path="renderer/src/components/chat/ChatMessage.tsx">
import React from 'react';
import { User, Bot } from 'lucide-react';
import { ChatMessageWrapper } from './ChatMessageWrapper';
import { v4 as uuidv4 } from 'uuid';
import { MessageCommentButton } from './MessageCommentButton';
interface ChatMessageProps {
  content: string;
  role: 'user' | 'assistant';
  id?: string;
}
export function ChatMessage({ content, role, id = uuidv4() }: ChatMessageProps) {
  return (
    <ChatMessageWrapper messageId={id} role={role} content={content}>
      <div className="group relative flex gap-3">
        <div className="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity">
          <MessageCommentButton onClick={() => console.log('comment')} />
        </div>
        <div className="flex-shrink-0">
          {role === 'user' ? (
            <div className="w-6 h-6 rounded-full bg-mint-400/20 dark:bg-coral-400/20 flex items-center justify-center">
              <User className="w-3 h-3 text-mint-400 dark:text-coral-400" />
            </div>
          ) : (
            <div className="w-6 h-6 rounded-full bg-gray-200/20 dark:bg-gray-700/20 flex items-center justify-center">
              <Bot className="w-3 h-3 text-gray-500 dark:text-gray-400" />
            </div>
          )}
        </div>
        <div className="flex-1 min-w-0">
          <div className="text-xs text-gray-600 dark:text-gray-300 whitespace-pre-wrap">{content}</div>
        </div>
      </div>
    </ChatMessageWrapper>
  );
}
</file>

<file path="renderer/src/components/chat/ChatMessageWrapper.tsx">
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { MessageActionStrip } from './MessageActionStrip';
import { CommentModal } from './CommentModal';
import { useChatMessageStore } from '../../state/chatMessageStore';
interface ChatMessageWrapperProps {
  messageId: string;
  children: React.ReactNode;
  role: 'user' | 'assistant';
  content: string;
}
export function ChatMessageWrapper({ messageId, children, role, content }: ChatMessageWrapperProps) {
  const [showActions, setShowActions] = useState(false);
  const [showCommentModal, setShowCommentModal] = useState(false);
  const { 
    messageMetadata,
    addComment,
    togglePin,
    linkToMemory,
    addReaction,
    initializeMessage
  } = useChatMessageStore();
  useEffect(() => {
    if (!messageMetadata[messageId]) {
      initializeMessage(messageId);
    }
  }, [messageId, initializeMessage, messageMetadata]);
  const metadata = messageMetadata[messageId] || {
    comments: [],
    pinned: false,
    reactions: []
  };
  const handleComment = () => {
    setShowCommentModal(true);
  };
  const handleCommentSubmit = (comment: string) => {
    addComment(messageId, comment);
  };
  const handlePin = () => {
    togglePin(messageId);
  };
  const handleLink = () => {
    // TODO: Implement memory linking dialog
    linkToMemory(messageId, 'memory-123');
  };
  const handleReact = (reaction: string) => {
    addReaction(messageId, reaction);
  };
  return (
    <>
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        className={`group relative rounded-lg ${
          role === 'user' 
            ? 'bg-blue-500/10 border-blue-500/20' 
            : 'bg-white/5 border-white/10'
        } border backdrop-blur-sm`}
        onMouseEnter={() => setShowActions(true)}
        onMouseLeave={() => setShowActions(false)}
      >
        <div className="p-4">
          {children}
        </div>
        <AnimatePresence>
          {showActions && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 10 }}
              className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/20 to-transparent"
            >
              <MessageActionStrip
                onComment={handleComment}
                onPin={handlePin}
                onLink={handleLink}
                onReact={() => handleReact('')}
                isPinned={metadata.pinned}
                hasComments={metadata.comments.length > 0}
                hasReactions={metadata.reactions.length > 0}
              />
            </motion.div>
          )}
        </AnimatePresence>
        {metadata.pinned && (
          <div className="absolute top-2 right-2">
            <span className="text-yellow-400 text-xs"> Pinned</span>
          </div>
        )}
        {metadata.reactions.length > 0 && (
          <div className="absolute bottom-2 right-2 flex gap-1">
            {metadata.reactions.map((reaction, index) => (
              <span key={index} className="text-xs">{reaction}</span>
            ))}
          </div>
        )}
        {metadata.comments.length > 0 && (
          <div className="absolute bottom-2 left-2">
            <span className="text-blue-400 text-xs"> {metadata.comments.length}</span>
          </div>
        )}
      </motion.div>
      <CommentModal
        isOpen={showCommentModal}
        onClose={() => setShowCommentModal(false)}
        onSubmit={handleCommentSubmit}
        messageContent={content}
      />
    </>
  );
}
</file>

<file path="renderer/src/components/chat/ChatUI.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { Send, Loader2, Settings, Search, X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { InternetModeToggle } from '../InternetModeToggle';
import { useChatStore } from '../../state/chatStore';
import { ChatMessage } from './ChatMessage';
import { ModelSelector } from './ModelSelector';
import { MessageSearch } from './MessageSearch';
import { ChatInput } from './ChatInput';
import { ChatMessages } from './ChatMessages';
export function ChatUI() {
  console.log('[DEBUG] ChatUI mounted');
  const [input, setInput] = useState('');
  const [showSidebar, setShowSidebar] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { messages, isProcessing, sendMessage } = useChatStore();
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };
  useEffect(() => {
    scrollToBottom();
  }, [messages]);
  // Handle keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Close sidebar with Escape
      if (e.key === 'Escape' && showSidebar) {
        setShowSidebar(false);
      }
      // Toggle sidebar with Cmd/Ctrl + ,
      if ((e.metaKey || e.ctrlKey) && e.key === ',') {
        e.preventDefault();
        setShowSidebar(prev => !prev);
      }
      // Focus input with Cmd/Ctrl + K
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        const inputElement = document.querySelector('input[type="text"]') as HTMLInputElement;
        inputElement?.focus();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [showSidebar]);
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (input.trim() && !isProcessing) {
      await sendMessage(input);
      setInput('');
    }
  };
  return (
    <div className="flex h-full">
      {/* Sidebar */}
      <AnimatePresence>
        {showSidebar && (
          <motion.div
            initial={{ x: '100%' }}
            animate={{ x: 0 }}
            exit={{ x: '100%' }}
            transition={{ type: 'spring', damping: 25, stiffness: 300 }}
            className="fixed inset-y-0 right-0 w-80 bg-gray-900 shadow-xl"
          >
            <div className="h-full flex flex-col">
              <motion.div
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.1 }}
                className="p-4 border-b border-white/10 flex justify-between items-center"
              >
                <div className="flex items-center space-x-2">
                  <h2 className="text-lg font-semibold">Settings & Search</h2>
                  <span className="text-xs text-white/40">(Esc to close)</span>
                </div>
                <motion.button
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => setShowSidebar(false)}
                  className="p-1 rounded-lg hover:bg-white/10"
                >
                  <X className="w-5 h-5" />
                </motion.button>
              </motion.div>
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 0.2 }}
                className="flex-1 overflow-y-auto"
              >
                <ModelSelector />
                <MessageSearch />
              </motion.div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col h-full">
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {messages.map((message) => (
            <ChatMessage
              key={message.id}
              id={message.id}
              content={message.content}
              role={message.role}
            />
          ))}
          <div ref={messagesEndRef} />
        </div>
        <div className="relative border-t border-white/10 p-4">
          <div className="flex items-center justify-between mb-2">
            <InternetModeToggle />
            <motion.button
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.95 }}
              onClick={() => setShowSidebar(!showSidebar)}
              className="p-2 rounded-lg hover:bg-white/10"
              title="Settings (,)"
            >
              <Settings className="w-5 h-5" />
            </motion.button>
          </div>
          <form onSubmit={handleSubmit} className="flex gap-2">
            <input
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              placeholder="Type a message... (K to focus)"
              disabled={isProcessing}
              className="flex-1 px-4 py-2 rounded-lg bg-white/5 border border-white/10 
                text-white placeholder-white/50 focus:outline-none focus:ring-2 
                focus:ring-blue-500/50 focus:border-transparent
                disabled:opacity-50 disabled:cursor-not-allowed"
            />
            <motion.button
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              type="submit"
              disabled={!input.trim() || isProcessing}
              className="p-2 rounded-lg bg-blue-500/20 text-blue-300
                hover:bg-blue-500/30 border border-blue-500/20 transition-colors
                disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isProcessing ? (
                <Loader2 className="w-5 h-5 animate-spin" />
              ) : (
                <Send className="w-5 h-5" />
              )}
            </motion.button>
          </form>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/chat/CommentModal.tsx">
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';
interface CommentModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (comment: string) => void;
  messageContent: string;
}
export function CommentModal({ isOpen, onClose, onSubmit, messageContent }: CommentModalProps) {
  const [comment, setComment] = useState('');
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (comment.trim()) {
      onSubmit(comment.trim());
      setComment('');
      onClose();
    }
  };
  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center"
        >
          <motion.div
            initial={{ scale: 0.95, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.95, opacity: 0 }}
            className="w-full max-w-lg p-6 rounded-lg bg-white/5 border border-white/10 backdrop-blur-md"
          >
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-semibold text-white/90">Add Comment</h2>
              <button
                onClick={onClose}
                className="p-1.5 rounded-md bg-white/5 hover:bg-white/10 text-white/80 hover:text-white transition-colors"
              >
                <X className="w-4 h-4" />
              </button>
            </div>
            <div className="mb-4 p-3 rounded-md bg-white/5 text-sm text-white/70">
              {messageContent}
            </div>
            <form onSubmit={handleSubmit}>
              <textarea
                value={comment}
                onChange={(e) => setComment(e.target.value)}
                placeholder="Write your comment..."
                className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-md
                  text-white placeholder-white/50
                  focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-transparent
                  transition-all resize-none"
                rows={3}
              />
              <div className="mt-4 flex justify-end gap-2">
                <button
                  type="button"
                  onClick={onClose}
                  className="px-4 py-2 rounded-md bg-white/5 hover:bg-white/10 
                    text-white/80 hover:text-white transition-colors"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={!comment.trim()}
                  className="px-4 py-2 rounded-md bg-blue-500/20 text-blue-300
                    hover:bg-blue-500/30 border border-blue-500/20 transition-colors
                    disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  Add Comment
                </button>
              </div>
            </form>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="renderer/src/components/chat/MessageActionStrip.tsx">
import React, { useState } from 'react';
import { MessageSquare, Pin, Link, Smile } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
interface MessageActionStripProps {
  onComment: () => void;
  onPin: () => void;
  onLink: () => void;
  onReact: () => void;
  isPinned?: boolean;
  hasComments?: boolean;
  hasReactions?: boolean;
}
export function MessageActionStrip({
  onComment,
  onPin,
  onLink,
  onReact,
  isPinned = false,
  hasComments = false,
  hasReactions = false
}: MessageActionStripProps) {
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  return (
    <div className="flex items-center gap-2 px-2 py-1 text-xs text-white/60 hover:text-white/90 transition-colors">
      <button
        onClick={onComment}
        className={`p-1.5 rounded-md hover:bg-white/5 transition-colors ${
          hasComments ? 'text-blue-400' : ''
        }`}
        title="Add comment"
      >
        <MessageSquare className="w-3.5 h-3.5" />
      </button>
      <button
        onClick={onPin}
        className={`p-1.5 rounded-md hover:bg-white/5 transition-colors ${
          isPinned ? 'text-yellow-400' : ''
        }`}
        title={isPinned ? 'Unpin message' : 'Pin message'}
      >
        <Pin className={`w-3.5 h-3.5 ${isPinned ? 'fill-current' : ''}`} />
      </button>
      <button
        onClick={onLink}
        className="p-1.5 rounded-md hover:bg-white/5 transition-colors"
        title="Link to memory"
      >
        <Link className="w-3.5 h-3.5" />
      </button>
      <div className="relative">
        <button
          onClick={() => setShowEmojiPicker(!showEmojiPicker)}
          className={`p-1.5 rounded-md hover:bg-white/5 transition-colors ${
            hasReactions ? 'text-pink-400' : ''
          }`}
          title="Add reaction"
        >
          <Smile className="w-3.5 h-3.5" />
        </button>
        <AnimatePresence>
          {showEmojiPicker && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 10 }}
              className="absolute bottom-full right-0 mb-2 p-2 rounded-lg bg-white/10 
                backdrop-blur-sm border border-white/10 shadow-lg"
            >
              <div className="grid grid-cols-6 gap-1">
                {['', '', '', '', '', ''].map((emoji) => (
                  <button
                    key={emoji}
                    onClick={() => {
                      onReact();
                      setShowEmojiPicker(false);
                    }}
                    className="p-1 hover:bg-white/10 rounded transition-colors"
                  >
                    {emoji}
                  </button>
                ))}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/chat/MessageCommentButton.tsx">
import React from 'react';
import { MessageSquare } from 'lucide-react';
import { Button } from '../ui/button';
interface MessageCommentButtonProps {
  onClick: () => void;
}
export function MessageCommentButton({ onClick }: MessageCommentButtonProps) {
  return (
    <Button
      size="icon"
      variant="ghost"
      onClick={onClick}
      className="h-6 w-6 text-muted-foreground hover:text-foreground"
    >
      <MessageSquare className="w-3 h-3" />
    </Button>
  );
}
</file>

<file path="renderer/src/components/chat/MessageSearch.tsx">
import React, { useState, useEffect } from 'react';
import { useChatStore } from '../../state/chatStore';
import { Search, X, Loader2 } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
export function MessageSearch() {
  const { messages } = useChatStore();
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<typeof messages>([]);
  const [isSearching, setIsSearching] = useState(false);
  useEffect(() => {
    if (!searchQuery.trim()) {
      setSearchResults([]);
      return;
    }
    setIsSearching(true);
    const query = searchQuery.toLowerCase();
    const results = messages.filter(
      (message) => message.content.toLowerCase().includes(query)
    );
    setSearchResults(results);
    setIsSearching(false);
  }, [searchQuery, messages]);
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 }
  };
  return (
    <div className="p-4">
      <motion.div
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
        className="relative mb-4"
      >
        <motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"
        >
          <Search className="h-5 w-5 text-white/40" />
        </motion.div>
        <motion.input
          whileFocus={{ scale: 1.02 }}
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          placeholder="Search messages..."
          className="w-full pl-10 pr-10 py-2 bg-white/5 border border-white/10 rounded-lg
            focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-transparent"
        />
        <AnimatePresence>
          {searchQuery && (
            <motion.button
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.95 }}
              onClick={() => setSearchQuery('')}
              className="absolute inset-y-0 right-0 pr-3 flex items-center"
            >
              <X className="h-5 w-5 text-white/40 hover:text-white/60" />
            </motion.button>
          )}
        </AnimatePresence>
      </motion.div>
      <AnimatePresence mode="wait">
        {isSearching ? (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="flex justify-center py-4"
          >
            <Loader2 className="w-6 h-6 animate-spin text-white/40" />
          </motion.div>
        ) : searchQuery ? (
          <motion.div
            variants={containerVariants}
            initial="hidden"
            animate="visible"
            className="space-y-2"
          >
            {searchResults.length > 0 ? (
              searchResults.map((message) => (
                <motion.div
                  key={message.id}
                  variants={itemVariants}
                  whileHover={{ scale: 1.02 }}
                  className="p-3 rounded-lg bg-white/5 hover:bg-white/10"
                >
                  <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    className="text-sm text-white/60 mb-1"
                  >
                    {message.role === 'user' ? 'You' : 'Assistant'} {' '}
                    {new Date(message.timestamp).toLocaleString()}
                  </motion.div>
                  <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    transition={{ delay: 0.1 }}
                    className="text-white/80"
                  >
                    {message.content}
                  </motion.div>
                </motion.div>
              ))
            ) : (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="text-center py-4 text-white/40"
              >
                No messages found
              </motion.div>
            )}
          </motion.div>
        ) : null}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="renderer/src/components/chat/ModelSelector.tsx">
import React, { useEffect, useState } from 'react';
import { useChatStore, OllamaModel } from '../../state/chatStore';
import { Download, Check, Loader2 } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
export function ModelSelector() {
  const { availableModels, currentModel, modelPullProgress, loadModels, setModel, pullModel } = useChatStore();
  const [isLoading, setIsLoading] = useState(false);
  const [selectedModel, setSelectedModel] = useState(currentModel);
  useEffect(() => {
    loadModels();
  }, [loadModels]);
  const handleModelChange = async (modelName: string) => {
    setSelectedModel(modelName);
    await setModel(modelName);
  };
  const handlePullModel = async (modelName: string) => {
    setIsLoading(true);
    try {
      await pullModel(modelName);
    } finally {
      setIsLoading(false);
    }
  };
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };
  const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 }
  };
  return (
    <div className="p-4 border-b border-white/10">
      <motion.h3
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
        className="text-lg font-semibold mb-4"
      >
        Model Selection
      </motion.h3>
      <motion.div
        variants={containerVariants}
        initial="hidden"
        animate="visible"
        className="space-y-2"
      >
        {availableModels.map((model, index) => (
          <motion.div
            key={model.name}
            variants={itemVariants}
            whileHover={{ scale: 1.02 }}
            className="flex items-center justify-between p-2 rounded-lg bg-white/5 hover:bg-white/10"
          >
            <div className="flex items-center space-x-2">
              <motion.input
                whileTap={{ scale: 0.95 }}
                type="radio"
                id={model.name}
                name="model"
                checked={selectedModel === model.name}
                onChange={() => handleModelChange(model.name)}
                className="w-4 h-4 text-blue-500"
              />
              <label htmlFor={model.name} className="flex-1">
                <motion.div
                  whileHover={{ x: 5 }}
                  className="font-medium"
                >
                  {model.name}
                </motion.div>
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  transition={{ delay: 0.2 + index * 0.1 }}
                  className="text-sm text-white/60"
                >
                  {model.details.parameter_size}  {model.details.quantization_level}
                </motion.div>
              </label>
            </div>
            <AnimatePresence mode="wait">
              {modelPullProgress > 0 && model.name === selectedModel ? (
                <motion.div
                  initial={{ opacity: 0, scale: 0.8 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.8 }}
                  className="flex items-center space-x-2"
                >
                  <Loader2 className="w-4 h-4 animate-spin" />
                  <motion.span
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    className="text-sm"
                  >
                    {Math.round(modelPullProgress * 100)}%
                  </motion.span>
                </motion.div>
              ) : (
                <motion.button
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={() => handlePullModel(model.name)}
                  disabled={isLoading}
                  className="p-1 rounded-lg bg-blue-500/20 text-blue-300 hover:bg-blue-500/30
                    disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Download className="w-4 h-4" />
                </motion.button>
              )}
            </AnimatePresence>
          </motion.div>
        ))}
      </motion.div>
    </div>
  );
}
</file>

<file path="renderer/src/components/layout/AppLayout.tsx">
import React from 'react';
import { LayoutHeader } from './LayoutHeader';
import { LayoutLeftSidebar } from './LayoutLeftSidebar';
import { LayoutRightSidebar } from './LayoutRightSidebar';
import { ChatUI } from '../chat/ChatUI';
import { ErrorBoundary } from '../ErrorBoundary';
export function AppLayout() {
  console.log('[DEBUG] AppLayout is rendering');
  return (
    <>
      <div className="flex h-screen bg-background">
        <ErrorBoundary>
          <LayoutLeftSidebar />
        </ErrorBoundary>
        <main className="flex-1 flex flex-col">
          <ErrorBoundary>
            <LayoutHeader />
          </ErrorBoundary>
          <div className="flex-1 overflow-hidden">
            <ErrorBoundary>
              <ChatUI />
            </ErrorBoundary>
          </div>
        </main>
        <ErrorBoundary>
          <LayoutRightSidebar />
        </ErrorBoundary>
      </div>
    </>
  );
}
</file>

<file path="renderer/src/components/layout/LayoutLeftSidebar.tsx">
import React, { useState } from 'react';
import { ConversationList } from '../components/ConversationList';
import { SettingsPanel } from '../components/SettingsPanel';
import { Button } from '../components/ui/button';
import { Cog } from 'lucide-react';
import { MemoryManager } from '../components/MemoryManager';
export const LayoutLeftSidebar: React.FC = () => {
  console.log('[DEBUG] LayoutLeftSidebar mounted');
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  return (
    <aside className="w-80 p-4 space-y-4 border-r border-white/10 bg-white/5 backdrop-blur dark:bg-black/10">
      <div className="flex items-center justify-between">
        <h2 className="text-xs font-medium tracking-wide text-gray-500 dark:text-gray-400 uppercase">Conversations</h2>
        <Button
          size="icon"
          variant="ghost"
          onClick={() => setIsSettingsOpen(!isSettingsOpen)}
          className="h-6 w-6 text-muted-foreground hover:text-foreground"
        >
          <Cog className="w-3 h-3" />
        </Button>
      </div>
      <ConversationList />
      <SettingsPanel isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />
      <div className="mt-4">
        <MemoryManager />
      </div>
    </aside>
  );
};
</file>

<file path="renderer/src/components/layout/LayoutRightSidebar.tsx">
import React from 'react';
import { MemoryCommitPanel } from '../MemoryCommitPanel';
import { StatusBar } from '../StatusBar';
import { CanvasPanel } from '../CanvasPanel';
import { useCanvasMode } from '@/hooks/useCanvasMode';
import { motion, AnimatePresence } from 'framer-motion';
import { PerformanceMetrics } from '../PerformanceMetrics';
import { SettingsPanel } from '../SettingsPanel';
import { Cog, BarChart2 } from 'lucide-react';
import { Button } from '../ui/button';
export function LayoutRightSidebar() {
  console.log('[DEBUG] LayoutRightSidebar mounted');
  const { isCanvasMode } = useCanvasMode();
  const [isSettingsOpen, setIsSettingsOpen] = React.useState(false);
  const [isMetricsOpen, setIsMetricsOpen] = React.useState(false);
  return (
    <div className="flex">
      <div className="fixed top-20 right-0 w-10 flex flex-col items-center space-y-2 p-2">
        <Button
          size="icon"
          variant="ghost"
          onClick={() => setIsSettingsOpen(!isSettingsOpen)}
          className="h-6 w-6 text-muted-foreground hover:text-foreground"
        >
          <Cog className="w-3 h-3" />
        </Button>
        <Button
          size="icon"
          variant="ghost"
          onClick={() => setIsMetricsOpen(!isMetricsOpen)}
          className="h-6 w-6 text-muted-foreground hover:text-foreground"
        >
          <BarChart2 className="w-3 h-3" />
        </Button>
      </div>
      <AnimatePresence>
        {(isSettingsOpen || isMetricsOpen || isCanvasMode) && (
          <motion.aside
            initial={{ x: 400, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: 400, opacity: 0 }}
            className="w-80 bg-white/5 backdrop-blur-md border-l border-white/10 shadow-inner overflow-y-auto"
          >
            <div className="p-4 space-y-4">
              <AnimatePresence>
                {isCanvasMode && (
                  <motion.div
                    initial={{ opacity: 0, height: 0 }}
                    animate={{ opacity: 1, height: 'auto' }}
                    exit={{ opacity: 0, height: 0 }}
                    transition={{ duration: 0.2 }}
                  >
                    <CanvasPanel />
                  </motion.div>
                )}
              </AnimatePresence>
              {isSettingsOpen && <SettingsPanel isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />}
              {isMetricsOpen && <PerformanceMetrics />}
              <MemoryCommitPanel />
              <StatusBar />
              <div className="rounded-lg p-2 text-xs text-gray-500 dark:text-gray-400 border border-white/10">
                Coming soon: <span className="italic">Visual Memory Map</span>
              </div>
            </div>
          </motion.aside>
        )}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="renderer/src/components/layout/LayoutTopBar.tsx">
import React from 'react';
import { ThemeToggle } from '../ThemeToggle';
import { ModelSelector } from '../ModelSelector';
import { CustomInstructionsToggle } from '../CustomInstructionsToggle';
import { CanvasModeToggle } from '../CanvasModeToggle';
import { ServiceStatusPanel } from '../ServiceStatusPanel';
import { SettingsButton } from '../SettingsButton';
interface LayoutTopBarProps {
  isCanvasMode: boolean;
  setIsCanvasMode: (value: boolean) => void;
}
export function LayoutTopBar({ isCanvasMode, setIsCanvasMode }: LayoutTopBarProps) {
  const [isServiceStatusExpanded, setIsServiceStatusExpanded] = React.useState(false);
  return (
    <header className="flex items-center justify-between px-6 py-3 bg-white/10 backdrop-blur-sm border-b border-white/10 shadow-sm z-10">
      <div className="flex items-center gap-3">
        <img src="/logo.svg" alt="HelloGPT" className="h-6 w-auto opacity-90" />
        <span className="text-lg font-semibold text-white/80">HelloGPT</span>
      </div>
      <div className="flex items-center gap-3">
        <ModelSelector />
        <ThemeToggle />
        <CustomInstructionsToggle />
        <CanvasModeToggle isActive={isCanvasMode} onToggle={() => setIsCanvasMode(!isCanvasMode)} />
        <SettingsButton />
        <ServiceStatusPanel
          isExpanded={isServiceStatusExpanded}
          onToggle={() => setIsServiceStatusExpanded(!isServiceStatusExpanded)}
          serviceStatuses={new Map()}
          onRetry={() => {}}
        />
      </div>
    </header>
  );
}
</file>

<file path="renderer/src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)
export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}
function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}
export { Badge, badgeVariants }
</file>

<file path="renderer/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"
export { Button, buttonVariants }
</file>

<file path="renderer/src/components/ui/card.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"
const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"
const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"
export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="renderer/src/components/ui/input.tsx">
import * as React from "react"
import { cn } from "@/lib/utils"
export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}
const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-background px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"
export { Input }
</file>

<file path="renderer/src/components/ui/label.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cn } from "@/lib/utils";
const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
      className
    )}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;
export { Label };
</file>

<file path="renderer/src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"
import { cn } from "@/lib/utils"
const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName
const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName
export { ScrollArea, ScrollBar }
</file>

<file path="renderer/src/components/ui/switch.tsx">
import * as React from "react";
import { cn } from "@/lib/utils";
interface SwitchProps extends React.InputHTMLAttributes<HTMLInputElement> {
  checked?: boolean;
  onCheckedChange?: (checked: boolean) => void;
}
const Switch = React.forwardRef<HTMLInputElement, SwitchProps>(
  ({ className, checked, onCheckedChange, ...props }, ref) => {
    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      onCheckedChange?.(e.target.checked);
    };
    return (
      <div className="relative inline-flex h-4 w-7 items-center">
        <input
          type="checkbox"
          ref={ref}
          checked={checked}
          onChange={handleChange}
          className={cn(
            "peer sr-only",
            className
          )}
          {...props}
        />
        <div
          className={cn(
            "absolute inset-0 rounded-full transition-colors",
            checked
              ? "bg-mint-400 dark:bg-coral-400"
              : "bg-gray-200 dark:bg-gray-700"
          )}
        />
        <div
          className={cn(
            "absolute left-0.5 h-3 w-3 rounded-full bg-white transition-transform",
            checked ? "translate-x-3" : "translate-x-0"
          )}
        />
      </div>
    );
  }
);
Switch.displayName = "Switch";
export { Switch };
</file>

<file path="renderer/src/components/AppHeaderDebug.tsx">
import React from 'react';
export default function AppHeaderDebug() {
  console.log('[DEBUG] AppHeader mounted');
  return (
    <div className="bg-pink-500 text-white p-4 text-center text-xl font-bold shadow-md">
      AppHeader 
    </div>
  );
}
</file>

<file path="renderer/src/components/AppLayout.tsx">
import React from 'react';
import { LayoutFooter } from './LayoutFooter';
interface AppLayoutProps {
  children: React.ReactNode;
}
export const AppLayout: React.FC<AppLayoutProps> = ({ children }) => {
  return (
    <div className="flex flex-col min-h-screen bg-black text-white">
      <main className="flex-1">
        {children}
      </main>
      <LayoutFooter />
    </div>
  );
};
export default AppLayout;
</file>

<file path="renderer/src/components/AppLayoutDebug.tsx">
import React from 'react';
import AppHeaderDebug from './AppHeaderDebug';
export default function AppLayoutDebug() {
  console.log('[DEBUG] AppLayout mounted');
  return (
    <div className="h-screen w-screen bg-black text-white flex overflow-hidden">
      <div className="w-64 bg-red-600 flex items-center justify-center text-lg font-bold">
        LeftSidebar 
      </div>
      <div className="flex-1 flex flex-col overflow-hidden">
        <AppHeaderDebug />
        <main className="flex-1 overflow-y-auto bg-gray-900 flex items-center justify-center text-lg font-bold">
          ChatUI 
        </main>
        <div className="h-12 bg-green-600 flex items-center justify-center text-sm">
          ServiceStatusManager 
        </div>
      </div>
      <div className="w-64 bg-yellow-400 flex items-center justify-center text-lg font-bold text-black">
        RightSidebar 
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/canvas.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { Code, MessageSquare, Split, Maximize2, Save, Download, Plus, X, Edit3, Eye, Minimize2 } from 'lucide-react';
import { ChatMessage, ChatResponse, ModelLoadingState, AppStatus, OllamaConnectionStatus, OllamaModel, Conversation } from '@/types';
import { Role } from '@/types/ipc';
import toast from 'react-hot-toast';
declare global {
  interface Window {
    electronAPI: {
      // Chat methods
      sendMessage: (message: ChatMessage) => Promise<ChatResponse>;
      sendMessageStream: (message: ChatMessage) => Promise<void>;
      onStreamChunk: (callback: (chunk: string) => void) => () => void;
      onStreamEnd: (callback: () => void) => () => void;
      onStreamError: (callback: (error: Error) => void) => () => void;
      // Message persistence methods
      createConversation: (title: string) => Promise<string>;
      getConversation: (id: string) => Promise<ChatMessage[]>;
      listConversations: () => Promise<Conversation[]>;
      deleteConversation: (id: string) => Promise<void>;
      updateConversationTitle: (id: string, title: string) => Promise<void>;
      // App methods
      healthCheck: () => Promise<AppStatus>;
      // Ollama methods
      listModels: () => Promise<{ models: OllamaModel[] }>;
      setModel: (model: { modelName: string }) => Promise<void>;
      checkConnection: () => Promise<OllamaConnectionStatus>;
      // Model loading events
      onModelLoadingStateChanged: (callback: (state: ModelLoadingState) => void) => () => void;
    };
  }
}
interface Message extends ChatMessage {
  animate?: boolean;
  timestamp: number;
}
interface Canvas {
  id: string;
  name: string;
  content: string;
  type: 'code' | 'markdown' | 'html' | 'react';
  language: string;
  lastModified: Date;
}
interface CanvasTab {
  id: string;
  canvasId: string;
  splitView: boolean;
  activeView: 'code' | 'preview';
}
const ChatWithCanvas: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const [streaming, setStreaming] = useState(false);
  const [currentAssistant, setCurrentAssistant] = useState('');
  const [activeView, setActiveView] = useState<'chat' | 'canvas' | 'split'>('chat');
  const [theme, setTheme] = useState<'light' | 'dark'>(
    () => (typeof window !== 'undefined' && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
  );
  // Canvas state
  const [canvases, setCanvases] = useState<Canvas[]>([
    {
      id: '1',
      name: 'Hello World',
      content: `function greetUser(name) {
  console.log(\`Hello, \${name}! Welcome to the canvas.\`);
  return \`Welcome \${name}\`;
}
// Call the function
greetUser('Developer');
// Create a simple component
const greeting = document.createElement('div');
greeting.innerHTML = '<h1>Hello Canvas!</h1>';
greeting.style.color = '#3b82f6';
greeting.style.fontFamily = 'system-ui';
document.body.appendChild(greeting);`,
      type: 'code',
      language: 'javascript',
      lastModified: new Date()
    }
  ]);
  const [tabs, setTabs] = useState<CanvasTab[]>([
    { id: 'tab-1', canvasId: '1', splitView: false, activeView: 'code' }
  ]);
  const [activeTabId, setActiveTabId] = useState('tab-1');
  const [isRenaming, setIsRenaming] = useState<string | null>(null);
  const [newName, setNewName] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  useEffect(() => {
    scrollToBottom();
  }, [messages, streaming, currentAssistant]);
  useEffect(() => {
    if (window.electronAPI) {
      const unsubscribeChunk = window.electronAPI.onStreamChunk(handleStreamChunk);
      const unsubscribeEnd = window.electronAPI.onStreamEnd(handleStreamEnd);
      const unsubscribeError = window.electronAPI.onStreamError(handleStreamError);
      return () => {
        unsubscribeChunk();
        unsubscribeEnd();
        unsubscribeError();
      };
    }
  }, []);
  useEffect(() => {
    if (!loading && inputRef.current) {
      inputRef.current.focus();
    }
  }, [loading]);
  useEffect(() => {
    document.body.setAttribute('data-theme', theme);
  }, [theme]);
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };
  const handleSend = async () => {
    if (!input.trim()) return;
    const userMessage: Message = {
      id: Date.now().toString(),
      role: Role.User,
      content: input.trim(),
      animate: true,
      timestamp: Date.now()
    };
    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setLoading(true);
    setStreaming(true);
    setCurrentAssistant('');
    try {
      if (window.electronAPI) {
        await window.electronAPI.sendMessageStream(userMessage);
      } else {
        // Fallback for development
        setTimeout(() => {
          handleStreamEnd();
        }, 1000);
      }
    } catch (error) {
      toast.error('Failed to send message');
      setMessages((prev) => [...prev, {
        id: Date.now().toString(),
        role: Role.Assistant,
        content: 'Error: Failed to get response.',
        animate: true,
        timestamp: Date.now()
      }]);
      setLoading(false);
      setStreaming(false);
    }
  };
  function handleStreamChunk(chunk: string) {
    setCurrentAssistant((prev) => prev + chunk);
  }
  function handleStreamEnd() {
    setMessages((prev) => [...prev, {
      id: Date.now().toString(),
      role: Role.Assistant,
      content: currentAssistant,
      animate: true,
      timestamp: Date.now()
    }]);
    setCurrentAssistant('');
    setLoading(false);
    setStreaming(false);
  }
  function handleStreamError(error: Error) {
    toast.error(error.message);
    setMessages((prev) => [...prev, {
      id: Date.now().toString(),
      role: Role.Assistant,
      content: `Error: ${error.message}`,
      animate: true,
      timestamp: Date.now()
    }]);
    setCurrentAssistant('');
    setLoading(false);
    setStreaming(false);
  }
  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };
  const handleCopy = (text: string) => {
    navigator.clipboard.writeText(text);
    toast.success('Copied to clipboard');
  };
  const formatTime = (timestamp: number) => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };
  // Canvas functions
  const getActiveCanvas = () => {
    const activeTab = tabs.find(tab => tab.id === activeTabId);
    return canvases.find(canvas => canvas.id === activeTab?.canvasId);
  };
  const updateCanvasContent = (content: string) => {
    const activeTab = tabs.find(tab => tab.id === activeTabId);
    if (!activeTab) return;
    setCanvases(prev => prev.map(canvas => 
      canvas.id === activeTab.canvasId 
        ? { ...canvas, content, lastModified: new Date() }
        : canvas
    ));
  };
  const createNewCanvas = () => {
    const newCanvas: Canvas = {
      id: Date.now().toString(),
      name: `Canvas ${canvases.length + 1}`,
      content: '// New canvas\nconsole.log("Hello from new canvas!");',
      type: 'code',
      language: 'javascript',
      lastModified: new Date()
    };
    const newTab: CanvasTab = {
      id: `tab-${Date.now()}`,
      canvasId: newCanvas.id,
      splitView: false,
      activeView: 'code'
    };
    setCanvases(prev => [...prev, newCanvas]);
    setTabs(prev => [...prev, newTab]);
    setActiveTabId(newTab.id);
    toast.success('New canvas created');
  };
  const deleteCanvas = (canvasId: string) => {
    if (canvases.length <= 1) {
      toast.error('Cannot delete the last canvas');
      return;
    }
    setCanvases(prev => prev.filter(canvas => canvas.id !== canvasId));
    setTabs(prev => {
      const updatedTabs = prev.filter(tab => tab.canvasId !== canvasId);
      if (activeTabId && prev.find(tab => tab.id === activeTabId)?.canvasId === canvasId) {
        setActiveTabId(updatedTabs[0]?.id || '');
      }
      return updatedTabs;
    });
    toast.success('Canvas deleted');
  };
  const renameCanvas = (canvasId: string, newName: string) => {
    setCanvases(prev => prev.map(canvas => 
      canvas.id === canvasId ? { ...canvas, name: newName } : canvas
    ));
    setIsRenaming(null);
    toast.success('Canvas renamed');
  };
  const downloadCanvas = (canvas: Canvas) => {
    const blob = new Blob([canvas.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${canvas.name}.${canvas.language}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    toast.success('Canvas downloaded');
  };
  const toggleSplitView = () => {
    setTabs(prev => prev.map(tab => 
      tab.id === activeTabId 
        ? { ...tab, splitView: !tab.splitView }
        : tab
    ));
  };
  const executeCode = (code: string) => {
    try {
      // Create a safe execution environment
      const func = new Function(code);
      func();
    } catch (error) {
      toast.error('Code execution error: ' + error);
      console.error('Code execution error:', error);
    }
  };
  const renderPreview = (canvas: Canvas) => {
    if (canvas.language === 'html') {
      return (
        <iframe
          srcDoc={canvas.content}
          className="w-full h-full border-none bg-white"
          title="HTML Preview"
        />
      );
    } else if (canvas.language === 'javascript') {
      return (
        <div className="p-4 h-full overflow-auto">
          <div className="text-sm text-[#858585] dark:text-[#858585] light:text-[#666666] mb-2">Console Output:</div>
          <div 
            className="bg-[#252526] dark:bg-[#252526] light:bg-[#F3F3F3] p-3 rounded-lg font-mono text-sm text-[#D4D4D4] dark:text-[#D4D4D4] light:text-[#1E1E1E]"
            id="preview-output"
          >
            Click "Run Code" to execute
          </div>
          <button
            onClick={() => {
              const output = document.getElementById('preview-output');
              if (output) {
                output.innerHTML = '';
                const originalLog = console.log;
                console.log = (...args) => {
                  output.innerHTML += args.join(' ') + '\n';
                  originalLog(...args);
                };
                executeCode(canvas.content);
                console.log = originalLog;
              }
            }}
            className="mt-2 px-3 py-1.5 bg-[#0E639C] text-white rounded hover:bg-[#1177BB] transition-colors"
          >
            Run Code
          </button>
        </div>
      );
    }
    return <div className="p-4 text-[#858585] dark:text-[#858585] light:text-[#666666]">Preview not available for this file type</div>;
  };
  const renderChatView = () => (
    <div className="flex flex-col h-full bg-background/40 backdrop-blur-glass">
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((msg, idx) => (
          <div
            key={idx}
            className={`flex ${
              msg.role === Role.User ? 'justify-end' : 'justify-start'
            } animate-in slide-in duration-200`}
          >
            <div
              className={`max-w-[80%] rounded-2xl px-4 py-2
                ${
                  msg.role === Role.User
                    ? 'glass glass-hover bg-coral/10 text-coral-foreground'
                    : 'glass glass-hover bg-mint/10 text-mint-foreground'
                }
                shadow-glass`}
            >
              <p className="whitespace-pre-wrap">{msg.content}</p>
              <div className="text-xs text-muted-foreground mt-1">
                {formatTime(msg.timestamp)}
              </div>
            </div>
          </div>
        ))}
        {streaming && (
          <div className="flex justify-start animate-in slide-in duration-200">
            <div className="glass glass-hover bg-mint/10 text-mint-foreground rounded-2xl px-4 py-2 max-w-[80%]">
              <p className="whitespace-pre-wrap">{currentAssistant}</p>
              <div className="typing-indicator mt-2">
                <span className="dot"></span>
                <span className="dot"></span>
                <span className="dot"></span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>
      <form
        onSubmit={(e) => { e.preventDefault(); handleSend(); }}
        className="glass border-t border-white/10 p-4"
      >
        <div className="flex items-end gap-2">
          <textarea
            ref={inputRef}
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Type your message..."
            className="input min-h-[44px] max-h-[200px] resize-none"
            rows={1}
            disabled={loading}
          />
          <button
            type="submit"
            disabled={loading || !input.trim()}
            className="btn btn-primary p-2"
          >
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M3.33334 10H16.6667" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
              <path d="M10 3.33334L16.6667 10L10 16.6667" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
            </svg>
          </button>
        </div>
      </form>
    </div>
  );
  const renderCanvasView = () => {
    const activeCanvas = getActiveCanvas();
    const activeTab = tabs.find(tab => tab.id === activeTabId);
    return (
      <div className="flex flex-col h-full bg-[#1E1E1E] dark:bg-[#1E1E1E] light:bg-white">
        {/* Canvas Tabs */}
        <div className="bg-[#252526] dark:bg-[#252526] light:bg-[#F3F3F3] border-b border-[#3C3C3C] dark:border-[#3C3C3C] light:border-[#E0E0E0] px-4 py-2">
          <div className="flex items-center space-x-2 flex-1">
            {tabs.map(tab => {
              const canvas = canvases.find(c => c.id === tab.canvasId);
              if (!canvas) return null;
              return (
                <div
                  key={tab.id}
                  className={`flex items-center space-x-2 px-3 py-1.5 rounded-t-lg cursor-pointer transition-all ${
                    tab.id === activeTabId 
                      ? 'bg-[#1E1E1E] dark:bg-[#1E1E1E] light:bg-white text-[#D4D4D4] dark:text-[#D4D4D4] light:text-[#1E1E1E]' 
                      : 'bg-[#2D2D2D] dark:bg-[#2D2D2D] light:bg-[#F3F3F3] text-[#858585] dark:text-[#858585] light:text-[#666666] hover:text-[#D4D4D4] dark:hover:text-[#D4D4D4] light:hover:text-[#1E1E1E]'
                  }`}
                  onClick={() => setActiveTabId(tab.id)}
                >
                  {isRenaming === canvas.id ? (
                    <input
                      type="text"
                      value={newName}
                      onChange={(e) => setNewName(e.target.value)}
                      onBlur={() => {
                        renameCanvas(canvas.id, newName);
                        setIsRenaming(null);
                      }}
                      onKeyDown={(e) => {
                        if (e.key === 'Enter') {
                          renameCanvas(canvas.id, newName);
                          setIsRenaming(null);
                        }
                        if (e.key === 'Escape') {
                          setIsRenaming(null);
                        }
                      }}
                      className="bg-transparent border-none outline-none text-sm w-24 text-[#D4D4D4]"
                      autoFocus
                    />
                  ) : (
                    <>
                      <Code size={14} className="text-[#858585] dark:text-[#858585] light:text-[#666666]" />
                      <span className="text-sm font-medium">{canvas.name}</span>
                      <div className="flex items-center space-x-1">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setIsRenaming(canvas.id);
                            setNewName(canvas.name);
                          }}
                          className="p-1 hover:bg-[#3C3C3C] rounded"
                        >
                          <Edit3 size={12} className="text-[#858585] dark:text-[#858585] light:text-[#666666]" />
                        </button>
                        {tabs.length > 1 && (
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              deleteCanvas(canvas.id);
                            }}
                            className="p-1 hover:bg-[#3C3C3C] rounded"
                          >
                            <X size={12} className="text-[#858585] dark:text-[#858585] light:text-[#666666]" />
                          </button>
                        )}
                      </div>
                    </>
                  )}
                </div>
              );
            })}
          </div>
          <div className="flex items-center space-x-2">
            <button
              onClick={createNewCanvas}
              className="px-3 py-1.5 bg-[#0E639C] text-white rounded hover:bg-[#1177BB] transition-colors"
            >
              <Plus size={14} className="mr-2" />
              New
            </button>
            {activeCanvas && (
              <>
                <button
                  onClick={toggleSplitView}
                  className="p-1.5 text-[#858585] dark:text-[#858585] light:text-[#666666] hover:bg-[#3C3C3C] rounded"
                >
                  {activeTab?.splitView ? <Minimize2 size={14} /> : <Split size={14} />}
                </button>
                <button
                  onClick={() => downloadCanvas(activeCanvas)}
                  className="p-1.5 text-[#858585] dark:text-[#858585] light:text-[#666666] hover:bg-[#3C3C3C] rounded"
                >
                  <Download size={14} />
                </button>
              </>
            )}
          </div>
        </div>
        {/* Main Content Area */}
        {activeCanvas && activeTab && (
          <div className="flex flex-1 overflow-hidden">
            {/* Code Editor */}
            <div className={`${activeTab.splitView ? 'w-1/2' : 'w-full'} flex flex-col`}>
              <div className="bg-[#252526] dark:bg-[#252526] light:bg-[#F3F3F3] border-b border-[#3C3C3C] dark:border-[#3C3C3C] light:border-[#E0E0E0] px-4 py-2">
                <div className="flex items-center space-x-2">
                  <Code size={16} className="text-[#858585] dark:text-[#858585] light:text-[#666666]" />
                  <span className="text-sm font-medium text-[#D4D4D4] dark:text-[#D4D4D4] light:text-[#1E1E1E]">Code Editor</span>
                  <span className="text-xs text-[#858585] dark:text-[#858585] light:text-[#666666]">({activeCanvas.language})</span>
                </div>
                <div className="text-xs text-[#858585] dark:text-[#858585] light:text-[#666666]">
                  Last modified: {activeCanvas.lastModified.toLocaleTimeString()}
                </div>
              </div>
              <div className="flex-1 relative">
                {/* Line Numbers */}
                <div className="absolute left-0 top-0 bottom-0 w-12 bg-[#252526] dark:bg-[#252526] light:bg-[#F3F3F3] border-r border-[#3C3C3C] dark:border-[#3C3C3C] light:border-[#E0E0E0] overflow-hidden">
                  <div className="relative h-full">
                    {activeCanvas.content.split('\n').map((_, index) => (
                      <div
                        key={index}
                        className="text-right pr-2 text-xs text-[#858585] dark:text-[#858585] light:text-[#666666] select-none"
                        style={{ height: '24px', lineHeight: '24px' }}
                      >
                        {index + 1}
                      </div>
                    ))}
                  </div>
                </div>
                {/* Code Editor with Background Pattern */}
                <div className="absolute inset-0 pl-12">
                  <div className="absolute inset-0 bg-[#1E1E1E] dark:bg-[#1E1E1E] light:bg-white">
                    {/* Background Pattern */}
                    <div className="absolute inset-0 opacity-[0.03] dark:opacity-[0.03] light:opacity-[0.1]"
                         style={{
                           backgroundImage: `radial-gradient(circle at 1px 1px, currentColor 1px, transparent 1px)`,
                           backgroundSize: '20px 20px'
                         }}
                    />
                  </div>
                  <textarea
                    ref={textareaRef}
                    value={activeCanvas.content}
                    onChange={(e) => updateCanvasContent(e.target.value)}
                    className="absolute inset-0 w-full h-full p-4 font-mono text-sm leading-6 resize-none border-none outline-none bg-transparent text-[#D4D4D4] dark:text-[#D4D4D4] light:text-[#1E1E1E]"
                    style={{
                      fontFamily: '"JetBrains Mono", "Fira Code", "Source Code Pro", monospace',
                      fontSize: '14px',
                      lineHeight: '24px',
                      tabSize: 2,
                      caretColor: '#D4D4D4',
                      letterSpacing: '0.3px'
                    }}
                    placeholder="Start coding..."
                    spellCheck={false}
                  />
                </div>
              </div>
            </div>
            {/* Preview Panel */}
            {activeTab.splitView && (
              <div className="w-1/2 flex flex-col border-l border-[#3C3C3C] dark:border-[#3C3C3C] light:border-[#E0E0E0]">
                <div className="bg-[#252526] dark:bg-[#252526] light:bg-[#F3F3F3] border-b border-[#3C3C3C] dark:border-[#3C3C3C] light:border-[#E0E0E0] px-4 py-2">
                  <div className="flex items-center space-x-2">
                    <Eye size={16} className="text-[#858585] dark:text-[#858585] light:text-[#666666]" />
                    <span className="text-sm font-medium text-[#D4D4D4] dark:text-[#D4D4D4] light:text-[#1E1E1E]">Preview</span>
                  </div>
                </div>
                <div className="flex-1 overflow-hidden bg-[#1E1E1E] dark:bg-[#1E1E1E] light:bg-white">
                  {renderPreview(activeCanvas)}
                </div>
              </div>
            )}
          </div>
        )}
        {/* Status Bar */}
        <div className="bg-[#007ACC] text-white px-4 py-1 text-xs flex justify-between items-center">
          <div>
            {activeCanvas && (
              <span>
                {activeCanvas.name}  {activeCanvas.language}  {activeCanvas.content.length} characters
              </span>
            )}
          </div>
          <div>
            {canvases.length} canvas{canvases.length !== 1 ? 'es' : ''}
          </div>
        </div>
      </div>
    );
  };
  return (
    <div className="flex flex-col h-screen bg-background/40 backdrop-blur-glass">
      {/* View Toggle Header */}
      <div className="glass border-b border-white/10 px-6 py-3">
        <div className="flex items-center space-x-4">
          <h1 className="text-xl font-semibold text-foreground">HelloGPT</h1>
          <div className="flex bg-background/40 backdrop-blur-glass rounded-lg p-1">
            <button
              onClick={() => setActiveView('chat')}
              className={`flex items-center space-x-2 px-3 py-1.5 rounded-md transition-all ${
                activeView === 'chat' 
                  ? 'glass bg-coral/10 text-coral-foreground' 
                  : 'text-muted-foreground hover:text-foreground'
              }`}
            >
              <MessageSquare size={16} />
              <span className="text-sm font-medium">Chat</span>
            </button>
            <button
              onClick={() => setActiveView('canvas')}
              className={`flex items-center space-x-2 px-3 py-1.5 rounded-md transition-all ${
                activeView === 'canvas' 
                  ? 'glass bg-coral/10 text-coral-foreground' 
                  : 'text-muted-foreground hover:text-foreground'
              }`}
            >
              <Code size={16} />
              <span className="text-sm font-medium">Canvas</span>
            </button>
            <button
              onClick={() => setActiveView('split')}
              className={`flex items-center space-x-2 px-3 py-1.5 rounded-md transition-all ${
                activeView === 'split' 
                  ? 'glass bg-coral/10 text-coral-foreground' 
                  : 'text-muted-foreground hover:text-foreground'
              }`}
            >
              <Split size={16} />
              <span className="text-sm font-medium">Split</span>
            </button>
          </div>
        </div>
        <div className="flex items-center space-x-3">
          <div className="text-sm text-muted-foreground">
            {canvases.length} canvas{canvases.length !== 1 ? 'es' : ''}
          </div>
        </div>
      </div>
      {/* Main Content */}
      <div className="flex-1 overflow-hidden">
        {activeView === 'chat' && renderChatView()}
        {activeView === 'canvas' && renderCanvasView()}
        {activeView === 'split' && (
          <div className="flex h-full">
            <div className="w-1/2 border-r border-white/10">
              {renderChatView()}
            </div>
            <div className="w-1/2">
              {renderCanvasView()}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};
export default ChatWithCanvas;
</file>

<file path="renderer/src/components/CanvasModeToggle.tsx">
import React from 'react';
import { MonitorIcon } from 'lucide-react';
interface CanvasModeToggleProps {
  onToggle: () => void;
  isActive: boolean;
  className?: string;
}
export const CanvasModeToggle: React.FC<CanvasModeToggleProps> = ({
  onToggle,
  isActive,
  className = ''
}) => {
  return (
    <button
      onClick={onToggle}
      className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-sm font-medium transition-all
        ${isActive 
          ? 'bg-white/20 text-white shadow-lg shadow-white/10' 
          : 'bg-white/10 text-white/70 hover:bg-white/20 hover:text-white'
        }
        ${className}
      `}
      title="Toggle Canvas Mode"
    >
      <MonitorIcon className="w-4 h-4" />
      <span className="hidden md:inline">Canvas</span>
    </button>
  );
};
</file>

<file path="renderer/src/components/CanvasPanel.tsx">
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus, X, Link, Unlink } from 'lucide-react';
import { useChatMessageStore } from '../../state/chatMessageStore';
import { ipcRenderer } from 'electron';
interface MemoryNodeProps {
  id: string;
  title: string;
  model: string;
  onDelete?: () => void;
  onLink?: () => void;
  isLinked?: boolean;
  linkedMessageId?: string;
}
function MemoryNode({ id, title, model, onDelete, onLink, isLinked, linkedMessageId }: MemoryNodeProps) {
  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.95 }}
      className="relative group bg-white/10 border border-white/10 rounded-lg shadow-sm 
        px-4 py-3 text-sm text-white backdrop-blur hover:shadow-md transition-all duration-200"
    >
      <div className="font-semibold">{title}</div>
      <div className="text-xs text-slate-300">{model}</div>
      {linkedMessageId && (
        <div className="text-xs text-blue-400 mt-1">Linked to message</div>
      )}
      <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity">
        <button
          onClick={onLink}
          className="p-1 rounded-md hover:bg-white/10 text-white/70 hover:text-white transition-colors"
          title={isLinked ? "Unlink from message" : "Link to message"}
        >
          {isLinked ? <Unlink className="w-3 h-3" /> : <Link className="w-3 h-3" />}
        </button>
        {onDelete && (
          <button
            onClick={onDelete}
            className="p-1 rounded-md hover:bg-white/10 text-white/70 hover:text-white transition-colors"
            title="Delete memory node"
          >
            <X className="w-3 h-3" />
          </button>
        )}
      </div>
    </motion.div>
  );
}
export function CanvasPanel() {
  const [nodes, setNodes] = useState([
    { id: '1', title: 'Agent Signals', model: 'phi4-mini-reasoning', isLinked: true, linkedMessageId: 'msg-1' },
    { id: '2', title: 'Startup Routines', model: 'wizardcoder-7b-python', isLinked: false },
    { id: '3', title: 'Tools Index', model: 'deepseek-coder-1.3b', isLinked: false },
  ]);
  const { metadata, linkMemory } = useChatMessageStore();
  // Sync linked messages with memory nodes
  useEffect(() => {
    const linkedMessages = Object.entries(metadata)
      .filter(([_, meta]) => meta.linkedMemoryId)
      .map(([messageId, meta]) => ({
        messageId,
        memoryId: meta.linkedMemoryId!
      }));
    setNodes(prevNodes => 
      prevNodes.map(node => ({
        ...node,
        isLinked: linkedMessages.some(link => link.memoryId === node.id),
        linkedMessageId: linkedMessages.find(link => link.memoryId === node.id)?.messageId
      }))
    );
  }, [metadata]);
  const handleAddNode = async () => {
    try {
      const newId = (nodes.length + 1).toString();
      const newNode = {
        id: newId,
        title: `New Memory ${newId}`,
        model: 'default-model',
        isLinked: false
      };
      await ipcRenderer.invoke('memory:create', newNode);
      setNodes([...nodes, newNode]);
    } catch (error) {
      console.error('Failed to create memory node:', error);
    }
  };
  const handleDeleteNode = async (id: string) => {
    try {
      await ipcRenderer.invoke('memory:delete', { id });
      setNodes(nodes.filter(node => node.id !== id));
    } catch (error) {
      console.error('Failed to delete memory node:', error);
    }
  };
  const handleToggleLink = async (id: string) => {
    try {
      const node = nodes.find(n => n.id === id);
      if (!node) return;
      if (node.isLinked && node.linkedMessageId) {
        // Unlink from message
        await linkMemory(node.linkedMessageId, '');
      } else {
        // Show message selection dialog
        const result = await ipcRenderer.invoke('memory:select-message');
        if (result?.messageId) {
          await linkMemory(result.messageId, id);
        }
      }
    } catch (error) {
      console.error('Failed to toggle memory link:', error);
    }
  };
  return (
    <div className="w-full h-96 bg-gradient-to-br from-blue-900/30 to-slate-800/30 
      border border-white/10 rounded-xl shadow-inner p-4 text-white space-y-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-semibold">Visual Memory Map</h2>
        <button
          onClick={handleAddNode}
          className="p-2 rounded-md bg-white/10 hover:bg-white/20 
            text-white/70 hover:text-white transition-colors"
          title="Add new memory node"
        >
          <Plus className="w-4 h-4" />
        </button>
      </div>
      <div className="grid grid-cols-2 gap-4">
        <AnimatePresence>
          {nodes.map((node) => (
            <MemoryNode
              key={node.id}
              id={node.id}
              title={node.title}
              model={node.model}
              onDelete={() => handleDeleteNode(node.id)}
              onLink={() => handleToggleLink(node.id)}
              isLinked={node.isLinked}
              linkedMessageId={node.linkedMessageId}
            />
          ))}
        </AnimatePresence>
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/CanvasToggle.tsx">
import React from 'react';
interface CanvasToggleProps {
  isEnabled?: boolean;
  onToggle?: () => void;
}
export const CanvasToggle: React.FC<CanvasToggleProps> = ({ 
  isEnabled = false, 
  onToggle = () => {} 
}) => {
  return (
    <button
      onClick={onToggle}
      className={`px-3 py-1 rounded-md text-sm transition-colors ${
        isEnabled 
          ? 'bg-blue-500 text-white' 
          : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
      }`}
    >
      {isEnabled ? 'Canvas On' : 'Canvas Off'}
    </button>
  );
};
export default CanvasToggle;
</file>

<file path="renderer/src/components/ChatContainer.tsx">
import React, { useState, useCallback } from 'react';
import { ChatInput } from './ChatInput';
import { ChatMessageList } from './ChatMessageList';
import { useConversation } from '@/hooks/useConversation';
import type { Conversation, ChatMessage } from '@/types/ipc';
import { Role } from '@/types/ipc';
interface ChatContainerProps {
  currentConversation: Conversation | null;
  onSendMessage: (content: string) => Promise<void>;
}
export function ChatContainer({ currentConversation, onSendMessage }: ChatContainerProps) {
  const [isThinking, setIsThinking] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);
  const handleMessageSent = useCallback((message: ChatMessage) => {
    setIsThinking(true);
  }, []);
  const handleStreamComplete = useCallback(() => {
    setIsThinking(false);
    setIsStreaming(false);
  }, []);
  const handleStopStream = useCallback(() => {
    setIsStreaming(false);
    setIsThinking(false);
  }, []);
  const handleSendMessage = async (content: string) => {
    setIsStreaming(true);
    try {
      await onSendMessage(content);
    } finally {
      setIsStreaming(false);
    }
  };
  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 overflow-y-auto p-4">
        <ChatMessageList 
          messages={currentConversation?.messages || []} 
          isThinking={isThinking}
          isTyping={isTyping}
        />
      </div>
      <div className="border-t border-gray-200 p-4">
        <ChatInput 
          onSendMessage={handleSendMessage}
          onMessageSent={handleMessageSent}
          onStreamComplete={handleStreamComplete}
          isStreaming={isStreaming}
          onStopStream={handleStopStream}
        />
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/ChatInput.tsx">
import React, { useState, useRef, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useOllama } from '../hooks/useOllama';
import { Send, StopCircle, ArrowUp, ArrowDown, Loader2 } from 'lucide-react';
import type { ChatMessage } from '../types/ipc';
import { Role } from '../types/ipc';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { InternetToggle } from './InternetToggle';
interface ChatInputProps {
  onSendMessage: (content: string) => Promise<void>;
  onMessageSent?: (message: ChatMessage) => void;
  onStreamComplete?: () => void;
  isStreaming?: boolean;
  onStopStream?: () => void;
}
export function ChatInput({ 
  onSendMessage, 
  onMessageSent, 
  onStreamComplete, 
  isStreaming = false, 
  onStopStream 
}: ChatInputProps) {
  const [message, setMessage] = useState('');
  const [history, setHistory] = useState<string[]>([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const { sendMessageStream, isConnected, error } = useOllama();
  const [isSending, setIsSending] = useState(false);
  // Auto-resize textarea
  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto';
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
    }
  }, [message]);
  // Handle keyboard shortcuts
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    } else if (e.key === 'ArrowUp' && e.ctrlKey) {
      e.preventDefault();
      navigateHistory('up');
    } else if (e.key === 'ArrowDown' && e.ctrlKey) {
      e.preventDefault();
      navigateHistory('down');
    }
  }, [message]);
  const navigateHistory = (direction: 'up' | 'down') => {
    if (direction === 'up' && historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setMessage(history[history.length - 1 - newIndex]);
    } else if (direction === 'down' && historyIndex > -1) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setMessage(newIndex === -1 ? '' : history[history.length - 1 - newIndex]);
    }
  };
  const handleSend = async () => {
    if (!message.trim() || !isConnected || isStreaming || isSending) return;
    setIsSending(true);
    try {
      const userMessage: ChatMessage = {
        id: crypto.randomUUID(),
        role: Role.User,
        content: message.trim(),
        timestamp: Date.now(),
      };
      // Add to history
      setHistory(prev => [...prev, message.trim()]);
      setHistoryIndex(-1);
      setMessage('');
      onMessageSent?.(userMessage);
      // Start streaming response
      await sendMessageStream(
        userMessage,
        {
          onChunk: (chunk) => {
            // Handle streaming chunks
          },
          onError: (error) => {
            console.error('Stream error:', error);
          },
          onComplete: () => {
            onStreamComplete?.();
          }
        }
      );
    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsSending(false);
    }
  };
  return (
    <motion.div
      initial={{ y: 20, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      className="fixed bottom-16 left-0 right-0 px-4 pb-4"
    >
      <div className="max-w-4xl mx-auto">
        <div className="relative">
          {/* Input Area */}
          <div className="relative bg-gray-800/50 backdrop-blur-sm rounded-lg border border-gray-700/50 shadow-xl">
            <div className="flex space-x-2">
              <InternetToggle />
              <Input
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                onKeyPress={handleKeyDown}
                placeholder={isConnected ? "Type a message..." : "Connecting to Ollama..."}
                disabled={!isConnected || isStreaming || isSending}
                className="flex-1"
              />
              <AnimatePresence>
                {isStreaming ? (
                  <motion.div
                    initial={{ scale: 0.8, opacity: 0 }}
                    animate={{ scale: 1, opacity: 1 }}
                    exit={{ scale: 0.8, opacity: 0 }}
                  >
                    <Button
                      onClick={onStopStream}
                      variant="destructive"
                      size="icon"
                    >
                      <StopCircle className="w-4 h-4" />
                    </Button>
                  </motion.div>
                ) : (
                  <motion.div
                    initial={{ scale: 0.8, opacity: 0 }}
                    animate={{ scale: 1, opacity: 1 }}
                    exit={{ scale: 0.8, opacity: 0 }}
                  >
                    <Button
                      onClick={handleSend}
                      disabled={!message.trim() || !isConnected || isStreaming || isSending}
                      size="icon"
                    >
                      {isSending ? (
                        <Loader2 className="w-4 h-4 animate-spin" />
                      ) : (
                        <Send className="w-4 h-4" />
                      )}
                    </Button>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
          {/* Status Indicators */}
          <div className="absolute -top-6 left-0 right-0 flex items-center justify-between px-2">
            <div className="flex items-center space-x-2">
              <span className="text-xs text-gray-400">
                {isStreaming ? (
                  <span className="flex items-center space-x-1">
                    <Loader2 className="w-3 h-3 animate-spin" />
                    <span>Generating response...</span>
                  </span>
                ) : (
                  <span className="flex items-center space-x-1">
                    <ArrowUp className="w-3 h-3" />
                    <span>Ctrl +  to navigate history</span>
                  </span>
                )}
              </span>
            </div>
            {error && (
              <motion.span
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                className="text-xs text-red-400"
              >
                {error}
              </motion.span>
            )}
          </div>
        </div>
      </div>
    </motion.div>
  );
}
</file>

<file path="renderer/src/components/ChatMessageList.tsx">
import React, { useState, useCallback } from 'react';
import { ChatMessage, Role } from '../types/ipc';
import { motion, AnimatePresence } from 'framer-motion';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { useMemory } from '../hooks/useMemory';
import toast from 'react-hot-toast';
import { formatDistanceToNow } from 'date-fns';
import { Card } from './ui/card';
interface Toast {
  id: string;
  message: string;
  type: 'success' | 'error' | 'info';
}
interface Correction {
  text: string;
  timestamp: number;
  history: string[];
}
interface Reaction {
  emoji: string;
  timestamp: number;
  messageId: string;
  role: Role;
}
interface ChatMessageListProps {
  messages: ChatMessage[];
  isThinking?: boolean;
  isTyping?: boolean;
  onStopResponse?: () => void;
  onReaction?: (messageId: string, emoji: string) => void;
}
interface CodeComponentProps {
  inline?: boolean;
  className?: string;
  children: React.ReactNode;
}
const REACTIONS = ['', '', '', '', '', '', '', ''] as const;
export function ChatMessageList({ messages, isThinking = false, isTyping = false, onStopResponse, onReaction }: ChatMessageListProps) {
  const { storeMemory } = useMemory();
  const [corrections, setCorrections] = useState<Record<string, Correction>>({});
  const [reactions, setReactions] = useState<Record<string, Reaction[]>>({});
  const [toasts, setToasts] = useState<Toast[]>([]);
  const [activePickerId, setActivePickerId] = useState<string | null>(null);
  const showToast = useCallback((message: string, type: Toast['type'] = 'info') => {
    const id = Math.random().toString(36).substr(2, 9);
    setToasts((prev) => [...prev, { id, message, type }]);
    setTimeout(() => {
      setToasts((prev) => prev.filter((toast) => toast.id !== id));
    }, 3000);
  }, []);
  const handleCorrection = async (messageId: string, original: string) => {
    const newText = prompt("Correct the assistant's response:", original);
    if (!newText || newText.trim() === original.trim()) return;
    setCorrections((prev) => ({
      ...prev,
      [messageId]: {
        text: newText,
        timestamp: Date.now(),
        history: [...(prev[messageId]?.history || []), original],
      },
    }));
    try {
      await toast.promise(
        storeMemory(
          `Correction: ${newText}`,
          {
            type: 'correction',
            source: 'chat',
            tags: ['correction', 'learning'],
            originalText: original,
            correctedText: newText,
            messageId,
          }
        ),
        {
          loading: 'Storing correction in memory...',
          success: 'Correction stored successfully',
          error: 'Failed to store correction',
        }
      );
    } catch (error) {
      console.error('Failed to store correction:', error);
      showToast('Failed to store correction in memory', 'error');
    }
  };
  const handleReaction = (messageId: string, emoji: string) => {
    const newReaction: Reaction = {
      emoji,
      timestamp: Date.now(),
      messageId,
      role: Role.Assistant,
    };
    setReactions((prev) => ({
      ...prev,
      [messageId]: [...(prev[messageId] || []), newReaction],
    }));
    onReaction?.(messageId, emoji);
    if (emoji === '') showToast('Feedback recorded - will avoid similar responses');
    if (emoji === '') showToast('Feedback recorded - will provide more responses like this', 'success');
  };
  const CodeComponent: React.FC<CodeComponentProps> = ({ inline, className, children }) => {
    const match = /language-(\w+)/.exec(className || '');
    return !inline && match ? (
      <SyntaxHighlighter
        style={oneDark}
        language={match[1]}
        PreTag="div"
      >
        {String(children).replace(/\n$/, '')}
      </SyntaxHighlighter>
    ) : (
      <code className={className}>
        {children}
      </code>
    );
  };
  const renderMessageContent = (text: string) => (
    <ReactMarkdown
      remarkPlugins={[remarkGfm]}
      rehypePlugins={[rehypeRaw]}
      components={{
        code: CodeComponent,
      }}
      className="prose prose-sm max-w-none dark:prose-invert"
    >
      {text}
    </ReactMarkdown>
  );
  return (
    <div className="space-y-4">
      {messages.map((msg) => (
        <div
          key={msg.id}
          className={`flex ${
            msg.role === 'user' ? 'justify-end' : 'justify-start'
          }`}
        >
          <Card
            className={`max-w-[80%] p-4 ${
              msg.role === 'user'
                ? 'bg-primary text-primary-foreground'
                : 'bg-muted'
            }`}
          >
            <p className="whitespace-pre-wrap">{msg.content}</p>
            <div className="mt-2 text-xs opacity-70">
              {formatDistanceToNow(msg.timestamp, { addSuffix: true })}
            </div>
          </Card>
        </div>
      ))}
      {isThinking && (
        <div className="flex justify-start">
          <Card className="max-w-[80%] p-4 bg-muted">
            <p className="text-muted-foreground">Thinking...</p>
          </Card>
        </div>
      )}
      {isTyping && (
        <div className="flex justify-start">
          <Card className="max-w-[80%] p-4 bg-muted">
            <p className="text-muted-foreground">Typing...</p>
          </Card>
        </div>
      )}
    </div>
  );
}
</file>

<file path="renderer/src/components/ChatUI.tsx">
import React, { useState } from 'react';
import { useChatStore } from '../state/chatStore';
import { useCorrectionStore } from '../state/correctionStore';
import { MessageActions } from './MessageActions';
import { Send } from 'lucide-react';
export const ChatUI = () => {
  const [input, setInput] = useState('');
  const { messages, loading, ask, selectedMessageIndex, selectMessage, clearSelection } = useChatStore();
  const { mark } = useCorrectionStore();
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim()) return;
    await ask(input);
    setInput('');
  };
  const handleComment = (index: number) => {
    // TODO: Implement comment functionality
    console.log('Comment on message:', index);
  };
  const handleReact = (index: number, reaction: 'like' | 'dislike') => {
    // TODO: Implement reaction functionality
    console.log('React to message:', index, reaction);
  };
  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((m, i) => (
          <div
            key={i}
            className={`p-4 rounded-lg backdrop-blur-sm border border-white/10 transition-all
              ${m.role === 'user' 
                ? 'bg-blue-500/10 ml-4' 
                : 'bg-white/5 mr-4'
              }
              ${selectedMessageIndex === i ? 'ring-2 ring-yellow-400/50' : ''}
              hover:bg-white/10
            `}
            onClick={() => {
              if (m.role === 'ai') {
                mark(i, m.content);
                selectMessage(i);
              }
            }}
          >
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold text-white/90">
                {m.role === 'user' ? 'You' : 'Assistant'}
              </div>
              <MessageActions
                onComment={() => handleComment(i)}
                onReact={(reaction) => handleReact(i, reaction)}
              />
            </div>
            <div className="whitespace-pre-wrap text-white/80">
              {m.content}
            </div>
          </div>
        ))}
        {loading && (
          <div className="flex items-center justify-center p-4">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500/50"></div>
          </div>
        )}
      </div>
      <form onSubmit={handleSubmit} className="p-4 border-t border-white/10">
        <div className="flex gap-2">
          <input
            type="text"
            value={input}
            onChange={e => setInput(e.target.value)}
            placeholder="Type your message..."
            className="flex-1 px-4 py-2 bg-white/5 border border-white/10 rounded-lg 
              text-white placeholder-white/50
              focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-transparent
              transition-all"
            disabled={loading}
          />
          <button
            type="submit"
            disabled={loading}
            className="px-6 py-2 bg-blue-500/20 text-white rounded-lg 
              hover:bg-blue-500/30 disabled:opacity-50 
              focus:outline-none focus:ring-2 focus:ring-blue-500/50
              border border-white/10 transition-all
              flex items-center gap-2"
          >
            <Send className="w-4 h-4" />
            <span>Send</span>
          </button>
        </div>
      </form>
    </div>
  );
};
</file>

<file path="renderer/src/components/ConnectionTroubleshooter.tsx">
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { ServiceName } from '../types/services';
interface TroubleshootingStep {
  title: string;
  description: string;
  solution: string;
}
const ollamaTroubleshootingSteps: TroubleshootingStep[] = [
  {
    title: 'Ollama Not Running',
    description: 'The Ollama service is not running on your system.',
    solution: 'Start Ollama by running "ollama serve" in your terminal.',
  },
  {
    title: 'Wrong Endpoint',
    description: 'The application cannot connect to Ollama at the default endpoint.',
    solution: 'Verify that Ollama is running at http://localhost:11434',
  },
  {
    title: 'Model Not Found',
    description: 'The required model is not available in Ollama.',
    solution: 'Pull the required model using "ollama pull <model-name>"',
  },
  {
    title: 'Insufficient Resources',
    description: 'Your system does not meet the minimum requirements.',
    solution: 'Ensure you have at least 4GB RAM and 1GB free disk space.',
  },
];
interface ConnectionTroubleshooterProps {
  serviceName: ServiceName;
  onTestConnection: () => Promise<void>;
  onRetry: () => void;
}
export const ConnectionTroubleshooter: React.FC<ConnectionTroubleshooterProps> = ({
  serviceName,
  onTestConnection,
  onRetry,
}) => {
  const [isTesting, setIsTesting] = useState(false);
  const [testResult, setTestResult] = useState<'success' | 'error' | null>(null);
  const [errorMessage, setErrorMessage] = useState<string>('');
  const handleTest = async () => {
    setIsTesting(true);
    setTestResult(null);
    setErrorMessage('');
    try {
      await onTestConnection();
      setTestResult('success');
    } catch (error) {
      setTestResult('error');
      setErrorMessage(error instanceof Error ? error.message : 'Connection test failed');
    } finally {
      setIsTesting(false);
    }
  };
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.9 }}
        className="bg-white rounded-lg p-6 max-w-lg w-full mx-4"
      >
        <h2 className="text-2xl font-bold mb-4">Connection Troubleshooter</h2>
        <div className="space-y-4">
          <div className="bg-gray-50 p-4 rounded">
            <h3 className="font-semibold mb-2">Common Issues</h3>
            <ul className="list-disc list-inside space-y-2 text-gray-700">
              <li>Service not running</li>
              <li>Port conflicts</li>
              <li>Firewall blocking connection</li>
              <li>Incorrect configuration</li>
            </ul>
          </div>
          <div className="bg-gray-50 p-4 rounded">
            <h3 className="font-semibold mb-2">Quick Checks</h3>
            <ul className="list-disc list-inside space-y-2 text-gray-700">
              <li>Verify service is installed</li>
              <li>Check service is running</li>
              <li>Confirm port availability</li>
              <li>Validate configuration</li>
            </ul>
          </div>
          <div className="flex flex-col space-y-2">
            <button
              onClick={handleTest}
              disabled={isTesting}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
            >
              {isTesting ? 'Testing...' : 'Test Connection'}
            </button>
            <button
              onClick={onRetry}
              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
            >
              Retry Connection
            </button>
          </div>
          <AnimatePresence>
            {testResult && (
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 10 }}
                className={`p-4 rounded ${
                  testResult === 'success' ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'
                }`}
              >
                {testResult === 'success' ? (
                  <p>Connection test successful!</p>
                ) : (
                  <p>Connection test failed: {errorMessage}</p>
                )}
              </motion.div>
            )}
          </AnimatePresence>
        </div>
        <div className="mt-6 flex justify-end">
          <button
            onClick={() => window.close()}
            className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
          >
            Close
          </button>
        </div>
      </motion.div>
    </div>
  );
};
</file>

<file path="renderer/src/components/ConversationList.tsx">
import React, { useState } from 'react';
import { Plus, Pencil, Trash2, Check, X } from 'lucide-react';
import { useConversations } from '@/hooks/useConversations';
import { Conversation } from '@/types';
export function ConversationList() {
  console.log('[DEBUG] ConversationList mounting');
  const {
    conversations,
    currentConversation,
    loadConversation,
    createConversation,
    deleteConversation,
    updateConversationTitle,
  } = useConversations();
  const [isCreating, setIsCreating] = useState(false);
  const [newTitle, setNewTitle] = useState('');
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editTitle, setEditTitle] = useState('');
  const handleCreate = async () => {
    if (!newTitle.trim()) return;
    await createConversation(newTitle.trim());
    setNewTitle('');
    setIsCreating(false);
  };
  const handleEdit = async (id: string) => {
    if (!editTitle.trim()) return;
    await updateConversationTitle(id, editTitle.trim());
    setEditingId(null);
    setEditTitle('');
  };
  const handleDelete = async (id: string) => {
    if (window.confirm('Are you sure you want to delete this conversation?')) {
      await deleteConversation(id);
    }
  };
  return (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b border-white/10">
        <h2 className="text-lg font-semibold text-white/90">Conversations</h2>
      </div>
      <div className="flex-1 overflow-y-auto p-2 space-y-1">
        {conversations.map((conversation) => (
          <div
            key={conversation.id}
            className={`group relative rounded-lg p-2 transition-all duration-200
              ${
                currentConversation?.id === conversation.id
                  ? 'bg-blue-500/20 text-white'
                  : 'bg-white/5 hover:bg-white/10 text-white/80'
              }
              backdrop-blur-sm border border-white/10
              animate-in slide-in duration-200`}
          >
            {editingId === conversation.id ? (
              <div className="flex items-center gap-2">
                <input
                  type="text"
                  value={editTitle}
                  onChange={(e) => setEditTitle(e.target.value)}
                  className="flex-1 px-3 py-1.5 bg-white/5 border border-white/10 rounded-md
                    text-white placeholder-white/50
                    focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-transparent
                    transition-all"
                  autoFocus
                />
                <button
                  onClick={() => handleEdit(conversation.id)}
                  className="p-1.5 rounded-md bg-white/10 hover:bg-white/20 text-white/80 hover:text-white transition-colors"
                >
                  <Check className="h-4 w-4" />
                </button>
                <button
                  onClick={() => setEditingId(null)}
                  className="p-1.5 rounded-md bg-white/10 hover:bg-white/20 text-white/80 hover:text-white transition-colors"
                >
                  <X className="h-4 w-4" />
                </button>
              </div>
            ) : (
              <div className="flex items-center gap-2">
                <button
                  onClick={() => loadConversation(conversation.id)}
                  className="flex-1 text-left truncate"
                >
                  <span className="font-medium">{conversation.title}</span>
                  <span className="block text-xs text-white/50">
                    {new Date(conversation.updatedAt).toLocaleDateString()}
                  </span>
                </button>
                <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                  <button
                    onClick={() => {
                      setEditingId(conversation.id);
                      setEditTitle(conversation.title);
                    }}
                    className="p-1.5 rounded-md bg-white/10 hover:bg-white/20 text-white/80 hover:text-white transition-colors"
                  >
                    <Pencil className="h-4 w-4" />
                  </button>
                  <button
                    onClick={() => handleDelete(conversation.id)}
                    className="p-1.5 rounded-md bg-white/10 hover:bg-white/20 text-red-400 hover:text-red-300 transition-colors"
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
      <div className="p-4 border-t border-white/10">
        {isCreating ? (
          <div className="flex items-center gap-2">
            <input
              type="text"
              value={newTitle}
              onChange={(e) => setNewTitle(e.target.value)}
              placeholder="New conversation title..."
              className="flex-1 px-3 py-1.5 bg-white/5 border border-white/10 rounded-md
                text-white placeholder-white/50
                focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-transparent
                transition-all"
              autoFocus
            />
            <button 
              onClick={handleCreate} 
              className="px-4 py-1.5 bg-blue-500/20 text-white rounded-md
                hover:bg-blue-500/30 focus:outline-none focus:ring-2 focus:ring-blue-500/50
                border border-white/10 transition-all"
            >
              Create
            </button>
            <button
              onClick={() => setIsCreating(false)}
              className="px-4 py-1.5 bg-white/10 text-white/80 rounded-md
                hover:bg-white/20 hover:text-white focus:outline-none focus:ring-2 focus:ring-white/50
                border border-white/10 transition-all"
            >
              Cancel
            </button>
          </div>
        ) : (
          <button
            onClick={() => setIsCreating(true)}
            className="w-full px-4 py-2 bg-blue-500/20 text-white rounded-md
              hover:bg-blue-500/30 focus:outline-none focus:ring-2 focus:ring-blue-500/50
              border border-white/10 transition-all
              flex items-center justify-center gap-2"
          >
            <Plus className="h-4 w-4" />
            New Conversation
          </button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/CustomInstructionsToggle.tsx">
import React from 'react';
import { FileText } from 'lucide-react';
export const CustomInstructionsToggle: React.FC = () => {
  const [isOpen, setIsOpen] = React.useState(false);
  return (
    <button
      onClick={() => setIsOpen(!isOpen)}
      className="p-2 rounded-lg bg-white/5 hover:bg-white/10 text-white/80 hover:text-white 
        border border-white/10 backdrop-blur-sm transition-colors"
      title="Custom Instructions"
    >
      <FileText className="w-5 h-5" />
    </button>
  );
};
</file>

<file path="renderer/src/components/DocumentPanel.tsx">
import React, { useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { DocumentIcon, TrashIcon, MagnifyingGlassIcon, FolderIcon } from '@heroicons/react/24/outline';
import { useVectorStore } from '@/hooks/useVectorStore';
export const DocumentPanel: React.FC = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const { 
    documents,
    searchDocuments,
    deleteDocument,
    addDocument,
    isLoading,
    error 
  } = useVectorStore();
  const onDrop = useCallback(
    async (acceptedFiles: File[]) => {
      for (const file of acceptedFiles) {
        await addDocument(file);
      }
    },
    [addDocument]
  );
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'text/*': ['.txt', '.md', '.json'],
      'application/pdf': ['.pdf'],
      'application/msword': ['.doc'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx']
    }
  });
  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    setIsSearching(true);
    try {
      await searchDocuments(searchQuery);
    } finally {
      setIsSearching(false);
    }
  };
  return (
    <div className="h-full flex flex-col bg-gray-50 border-r border-gray-200">
      {/* Header */}
      <div className="p-4 border-b border-gray-200">
        <h2 className="text-lg font-semibold text-gray-900">Documents</h2>
        <p className="text-sm text-gray-500">Manage your knowledge base</p>
      </div>
      {/* Search */}
      <div className="p-4 border-b border-gray-200">
        <div className="flex gap-2">
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search documents..."
            className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button
            onClick={handleSearch}
            disabled={isSearching}
            className="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <MagnifyingGlassIcon className="h-5 w-5" />
          </button>
        </div>
      </div>
      {/* Upload Area */}
      <div
        {...getRootProps()}
        className={`p-4 border-b border-gray-200 cursor-pointer ${
          isDragActive ? 'bg-blue-50' : ''
        }`}
      >
        <input {...getInputProps()} />
        <div className="flex flex-col items-center justify-center p-4 border-2 border-dashed border-gray-300 rounded-lg">
          <FolderIcon className="h-8 w-8 text-gray-400 mb-2" />
          <p className="text-sm text-gray-500">
            {isDragActive
              ? 'Drop the files here...'
              : 'Drag & drop files here, or click to select'}
          </p>
        </div>
      </div>
      {/* Document List */}
      <div className="flex-1 overflow-y-auto p-4">
        {isLoading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500" />
          </div>
        ) : error ? (
          <div className="text-red-500 text-center">{error.toString()}</div>
        ) : documents.length === 0 ? (
          <div className="text-center text-gray-500 py-8">
            No documents found
          </div>
        ) : (
          <div className="space-y-2">
            {documents.map((doc) => (
              <div
                key={doc.id}
                className="flex items-center justify-between p-2 bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow"
              >
                <div className="flex items-center gap-2">
                  <DocumentIcon className="h-5 w-5 text-gray-400" />
                  <div>
                    <p className="text-sm font-medium text-gray-900">
                      {doc.metadata.filename || 'Untitled'}
                    </p>
                    <p className="text-xs text-gray-500">
                      {new Date(doc.metadata.timestamp).toLocaleDateString()}
                    </p>
                  </div>
                </div>
                <button
                  onClick={() => deleteDocument(doc.id)}
                  className="p-1 text-gray-400 hover:text-red-500 focus:outline-none"
                >
                  <TrashIcon className="h-5 w-5" />
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/EmbeddingConfig.tsx">
import React, { useState, useEffect } from 'react';
import { Switch } from '@headlessui/react';
import { useConfigStore } from '../stores/configStore';
import type { EmbeddingConfig } from '../types/embedding';
interface EmbeddingConfigProps {
  onConfigChange: (config: Partial<EmbeddingConfig>) => void;
}
const DEFAULT_CONFIG: EmbeddingConfig = {
  model: 'nomic-embed-text',
  modelParameters: {
    temperature: 0.7,
    topK: 40,
    topP: 0.9,
    contextWindow: 4096,
    repeatPenalty: 1.1,
    presencePenalty: 0.0,
    frequencyPenalty: 0.0,
    mirostatMode: 1,
    mirostatTau: 5.0,
    mirostatEta: 0.1,
  },
  batchSize: 32,
  normalize: true,
  truncateStrategy: 'NONE',
  maxTokens: 4096,
  chunkSize: 1000,
  chunkOverlap: 200,
  chunkStrategy: 'SENTENCE',
  enableCache: true,
  cacheSize: 2000,
  cacheTTL: 3600,
  parallelProcessing: true,
  maxConcurrentRequests: 4,
  timeout: 30000,
  minSimilarityThreshold: 0.7,
  maxResults: 5,
  rerankResults: true,
};
export const EmbeddingConfigPanel: React.FC<EmbeddingConfigProps> = ({ onConfigChange }) => {
  const [config, setConfig] = useState<EmbeddingConfig | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activePreset, setActivePreset] = useState<'BALANCED' | 'FOCUSED' | 'CREATIVE' | 'PRECISE' | string>('BALANCED');
  const [showSavePreset, setShowSavePreset] = useState(false);
  const [newPresetName, setNewPresetName] = useState('');
  const { customPresets, addCustomPreset, removeCustomPreset } = useConfigStore();
  useEffect(() => {
    const loadConfig = async () => {
      try {
        setLoading(true);
        const currentConfig = await window.electron.ipc.invoke('embedding:get-config');
        setConfig(currentConfig);
        setError(null);
      } catch (err) {
        setError('Failed to load configuration');
        console.error('Error loading config:', err);
      } finally {
        setLoading(false);
      }
    };
    loadConfig();
  }, []);
  const handlePresetChange = (preset: 'BALANCED' | 'FOCUSED' | 'CREATIVE' | 'PRECISE' | string) => {
    if (!config) return;
    const newConfig = { ...config };
    if (preset in customPresets) {
      Object.assign(newConfig, customPresets[preset]);
    } else {
      switch (preset) {
        case 'FOCUSED':
          newConfig.modelParameters.temperature = 0.3;
          newConfig.modelParameters.topK = 20;
          newConfig.modelParameters.topP = 0.95;
          newConfig.minSimilarityThreshold = 0.8;
          newConfig.maxResults = 3;
          break;
        case 'CREATIVE':
          newConfig.modelParameters.temperature = 0.9;
          newConfig.modelParameters.topK = 60;
          newConfig.modelParameters.topP = 0.85;
          newConfig.minSimilarityThreshold = 0.6;
          newConfig.maxResults = 8;
          break;
        case 'PRECISE':
          newConfig.modelParameters.temperature = 0.2;
          newConfig.modelParameters.topK = 10;
          newConfig.modelParameters.topP = 0.98;
          newConfig.minSimilarityThreshold = 0.9;
          newConfig.maxResults = 2;
          break;
        default: // BALANCED
          newConfig.modelParameters.temperature = 0.7;
          newConfig.modelParameters.topK = 40;
          newConfig.modelParameters.topP = 0.9;
          newConfig.minSimilarityThreshold = 0.7;
          newConfig.maxResults = 5;
      }
    }
    setConfig(newConfig);
    setActivePreset(preset);
    onConfigChange(newConfig);
  };
  const handleReset = () => {
    if (!config) return;
    const newConfig = { ...DEFAULT_CONFIG };
    setConfig(newConfig);
    setActivePreset('BALANCED');
    onConfigChange(newConfig);
  };
  const handleSavePreset = () => {
    if (!config || !newPresetName.trim()) return;
    addCustomPreset(newPresetName.trim(), config);
    setActivePreset(newPresetName.trim());
    setShowSavePreset(false);
    setNewPresetName('');
  };
  const handleDeletePreset = (presetName: string) => {
    removeCustomPreset(presetName);
    if (activePreset === presetName) {
      handlePresetChange('BALANCED');
    }
  };
  const handleModelParamChange = (param: keyof EmbeddingConfig['modelParameters'], value: number) => {
    if (!config) return;
    const newConfig = {
      ...config,
      modelParameters: {
        ...config.modelParameters,
        [param]: value,
      },
    };
    setConfig(newConfig);
    onConfigChange(newConfig);
  };
  const handleNumericChange = (key: keyof EmbeddingConfig, value: number) => {
    if (!config) return;
    const newConfig = { ...config, [key]: value };
    setConfig(newConfig);
    onConfigChange(newConfig);
  };
  const handleToggle = (key: keyof EmbeddingConfig, value: boolean) => {
    if (!config) return;
    const newConfig = { ...config, [key]: value };
    setConfig(newConfig);
    onConfigChange(newConfig);
  };
  if (loading) {
    return (
      <div className="p-4 space-y-6 bg-white rounded-lg shadow animate-pulse">
        <div className="h-4 bg-gray-200 rounded w-1/4"></div>
        <div className="space-y-3">
          <div className="h-4 bg-gray-200 rounded"></div>
          <div className="h-4 bg-gray-200 rounded"></div>
        </div>
      </div>
    );
  }
  if (error) {
    return (
      <div className="p-4 space-y-6 bg-white rounded-lg shadow">
        <div className="text-red-600">{error}</div>
        <button
          onClick={() => window.location.reload()}
          className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700"
        >
          Retry
        </button>
      </div>
    );
  }
  if (!config) return null;
  return (
    <div className="p-4 space-y-6 bg-white rounded-lg shadow">
      <div className="space-y-2">
        <div className="flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900">Personality Presets</h3>
          <div className="space-x-2">
            <button
              onClick={() => setShowSavePreset(true)}
              className="px-3 py-1 text-sm font-medium text-blue-600 hover:text-blue-700"
            >
              Save Current
            </button>
            <button
              onClick={handleReset}
              className="px-3 py-1 text-sm font-medium text-gray-600 hover:text-gray-700"
            >
              Reset to Default
            </button>
          </div>
        </div>
        {showSavePreset && (
          <div className="flex items-center space-x-2 p-2 bg-gray-50 rounded-md">
            <input
              type="text"
              value={newPresetName}
              onChange={(e) => setNewPresetName(e.target.value)}
              placeholder="Preset name"
              className="flex-1 px-3 py-1 text-sm border rounded-md"
            />
            <button
              onClick={handleSavePreset}
              disabled={!newPresetName.trim()}
              className="px-3 py-1 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              Save
            </button>
            <button
              onClick={() => {
                setShowSavePreset(false);
                setNewPresetName('');
              }}
              className="px-3 py-1 text-sm font-medium text-gray-600 hover:text-gray-700"
            >
              Cancel
            </button>
          </div>
        )}
        <div className="grid grid-cols-2 gap-2">
          {(['BALANCED', 'FOCUSED', 'CREATIVE', 'PRECISE'] as const).map((preset) => (
            <button
              key={preset}
              onClick={() => handlePresetChange(preset)}
              className={`px-4 py-2 text-sm font-medium rounded-md ${
                activePreset === preset
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
              }`}
            >
              {preset.charAt(0) + preset.slice(1).toLowerCase()}
            </button>
          ))}
        </div>
        {Object.keys(customPresets).length > 0 && (
          <div className="mt-4">
            <h4 className="text-sm font-medium text-gray-700 mb-2">Custom Presets</h4>
            <div className="grid grid-cols-2 gap-2">
              {Object.keys(customPresets).map((presetName) => (
                <div key={presetName} className="flex items-center space-x-2">
                  <button
                    onClick={() => handlePresetChange(presetName)}
                    className={`flex-1 px-4 py-2 text-sm font-medium rounded-md ${
                      activePreset === presetName
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}
                  >
                    {presetName}
                  </button>
                  <button
                    onClick={() => handleDeletePreset(presetName)}
                    className="p-2 text-gray-400 hover:text-red-600"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
      <div className="space-y-4">
        <h3 className="text-lg font-medium text-gray-900">Model Parameters</h3>
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">Temperature</label>
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={config.modelParameters.temperature}
              onChange={(e) => handleModelParamChange('temperature', parseFloat(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-500">{config.modelParameters.temperature}</span>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">Top K</label>
            <input
              type="range"
              min="1"
              max="100"
              value={config.modelParameters.topK}
              onChange={(e) => handleModelParamChange('topK', parseInt(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-500">{config.modelParameters.topK}</span>
          </div>
        </div>
      </div>
      <div className="space-y-4">
        <h3 className="text-lg font-medium text-gray-900">Processing Options</h3>
        <div className="space-y-2">
          <Switch.Group>
            <div className="flex items-center justify-between">
              <Switch.Label className="text-sm font-medium text-gray-700">Normalize Embeddings</Switch.Label>
              <Switch
                checked={config.normalize}
                onChange={(checked) => handleToggle('normalize', checked)}
                className={`${
                  config.normalize ? 'bg-blue-600' : 'bg-gray-200'
                } relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2`}
              >
                <span
                  className={`${
                    config.normalize ? 'translate-x-6' : 'translate-x-1'
                  } inline-block h-4 w-4 transform rounded-full bg-white transition-transform`}
                />
              </Switch>
            </div>
          </Switch.Group>
          <Switch.Group>
            <div className="flex items-center justify-between">
              <Switch.Label className="text-sm font-medium text-gray-700">Rerank Results</Switch.Label>
              <Switch
                checked={config.rerankResults}
                onChange={(checked) => handleToggle('rerankResults', checked)}
                className={`${
                  config.rerankResults ? 'bg-blue-600' : 'bg-gray-200'
                } relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2`}
              >
                <span
                  className={`${
                    config.rerankResults ? 'translate-x-6' : 'translate-x-1'
                  } inline-block h-4 w-4 transform rounded-full bg-white transition-transform`}
                />
              </Switch>
            </div>
          </Switch.Group>
        </div>
      </div>
      <div className="space-y-4">
        <h3 className="text-lg font-medium text-gray-900">Quality Settings</h3>
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">Similarity Threshold</label>
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={config.minSimilarityThreshold}
              onChange={(e) => handleNumericChange('minSimilarityThreshold', parseFloat(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-500">{config.minSimilarityThreshold}</span>
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">Max Results</label>
            <input
              type="range"
              min="1"
              max="20"
              value={config.maxResults}
              onChange={(e) => handleNumericChange('maxResults', parseInt(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-500">{config.maxResults}</span>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/ErrorBoundary.tsx">
import React from 'react';
interface Props {
  children: React.ReactNode;
}
interface State {
  hasError: boolean;
  error: Error | null;
}
export class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return (
        <div className="flex items-center justify-center min-h-screen bg-background/40 backdrop-blur-glass p-4">
          <div className="glass p-6 rounded-xl shadow-glass max-w-md w-full">
            <div className="space-y-4">
              <h2 className="text-2xl font-semibold text-destructive">Something went wrong</h2>
              <p className="text-muted-foreground">
                {this.state.error?.message || 'An unexpected error occurred'}
              </p>
              <button
                onClick={() => window.location.reload()}
                className="btn btn-primary w-full"
              >
                Reload Page
              </button>
            </div>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}
</file>

<file path="renderer/src/components/InternetModeToggle.tsx">
import React from 'react';
import { Globe } from 'lucide-react';
import { useEnvironmentMode } from '../hooks/useEnvironmentMode';
export function InternetModeToggle() {
  const { mode, setMode } = useEnvironmentMode();
  const isCloud = mode === 'cloud';
  return (
    <button
      onClick={() => setMode(isCloud ? 'local' : 'cloud')}
      className={`absolute right-4 top-4 p-2 rounded-full shadow-md border transition-all duration-200
        ${isCloud 
          ? 'bg-blue-500/20 border-blue-400/30 text-blue-100 hover:bg-blue-500/30' 
          : 'bg-slate-600/30 border-slate-400/30 text-slate-100 hover:bg-slate-600/40'
        }`}
      title={isCloud ? 'Switch to Local Mode' : 'Switch to Cloud Mode'}
    >
      <Globe className="w-4 h-4" />
    </button>
  );
}
</file>

<file path="renderer/src/components/InternetToggle.tsx">
import React from 'react';
import { Globe } from 'lucide-react';
import { Button } from './ui/button';
interface InternetToggleProps {
  isEnabled?: boolean;
  onToggle?: () => void;
}
export function InternetToggle({ isEnabled = false, onToggle }: InternetToggleProps) {
  return (
    <Button
      size="icon"
      variant="ghost"
      onClick={onToggle}
      className={`text-muted-foreground hover:text-foreground ${isEnabled ? 'text-blue-400' : ''}`}
      title={isEnabled ? 'Internet access enabled' : 'Internet access disabled'}
    >
      <Globe className="w-4 h-4" />
    </Button>
  );
}
</file>

<file path="renderer/src/components/LayoutFooter.tsx">
import React from 'react';
import { ServiceStatusManager } from './ServiceStatusManager';
import { PerformanceMetrics } from './PerformanceMetrics';
import { CanvasToggle } from './CanvasToggle';
interface LayoutFooterProps {
  services?: Record<string, { status: 'available' | 'unavailable' | 'loading'; error?: string }>;
  onServiceRetry?: (serviceName: string) => void;
  isCanvasEnabled?: boolean;
  onCanvasToggle?: () => void;
}
export const LayoutFooter: React.FC<LayoutFooterProps> = ({
  services = {},
  onServiceRetry = () => {},
  isCanvasEnabled = false,
  onCanvasToggle = () => {},
}) => {
  return (
    <footer className="flex items-center justify-between px-4 py-2 border-t border-white/10 bg-black/10 backdrop-blur">
      <ServiceStatusManager services={services} onRetry={onServiceRetry} />
      <div className="flex items-center space-x-4">
        <PerformanceMetrics />
        <CanvasToggle isEnabled={isCanvasEnabled} onToggle={onCanvasToggle} />
      </div>
    </footer>
  );
};
export default LayoutFooter;
</file>

<file path="renderer/src/components/LayoutLeftSidebar.tsx">
import React, { useState } from 'react';
import { ConversationList } from '../components/ConversationList';
import { SettingsPanel } from '../components/SettingsPanel';
import { Button } from '../components/ui/button';
import { Cog } from 'lucide-react';
import { MemoryManager } from '../components/MemoryManager';
export const LayoutLeftSidebar: React.FC = () => {
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  return (
    <aside className="w-80 p-4 space-y-4 border-r border-white/10 bg-white/5 backdrop-blur dark:bg-black/10">
      <div className="flex items-center justify-between">
        <h2 className="text-xs font-medium tracking-wide text-gray-500 dark:text-gray-400 uppercase">Conversations</h2>
        <Button
          size="icon"
          variant="ghost"
          onClick={() => setIsSettingsOpen(!isSettingsOpen)}
          className="h-6 w-6 text-muted-foreground hover:text-foreground"
        >
          <Cog className="w-3 h-3" />
        </Button>
      </div>
      <ConversationList />
      <SettingsPanel isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />
      <div className="mt-4">
        <MemoryManager />
      </div>
    </aside>
  );
};
export default LayoutLeftSidebar;
</file>

<file path="renderer/src/components/LayoutMain.tsx">
import React from 'react';
import { ErrorBoundary } from '../components/ErrorBoundary';
import { ChatUI } from '../components/ChatUI';
export const LayoutMain: React.FC = () => {
  return (
    <main className="flex-1 overflow-hidden">
      <ErrorBoundary>
        <ChatUI />
      </ErrorBoundary>
    </main>
  );
};
export default LayoutMain;
</file>

<file path="renderer/src/components/LayoutRightSidebar.tsx">
import React from 'react';
import { MemoryCommitPanel } from '../components/MemoryCommitPanel';
import { StatusBar } from '../components/StatusBar';
export const LayoutRightSidebar: React.FC = () => {
  return (
    <aside className="w-80 border-l border-white/10 bg-white/5 backdrop-blur dark:bg-black/10 p-4 space-y-4">
      <MemoryCommitPanel />
      <StatusBar />
    </aside>
  );
};
export default LayoutRightSidebar;
</file>

<file path="renderer/src/components/Logo.tsx">
import React from 'react';
interface LogoProps {
  className?: string;
}
export const Logo: React.FC<LogoProps> = ({ className = '' }) => {
  return (
    <div className={`flex items-center gap-2 ${className}`}>
      <div className="relative">
        <div className="absolute inset-0 bg-gradient-to-br from-blue-500/20 to-purple-500/20 blur-sm rounded-lg" />
        <div className="relative h-8 w-8 rounded-lg bg-white/10 backdrop-blur-sm border border-white/20 flex items-center justify-center">
          <span className="text-lg font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
            H
          </span>
        </div>
      </div>
      <span className="text-lg font-semibold bg-gradient-to-r from-white/90 to-white/70 bg-clip-text text-transparent">
        HelloGPT
      </span>
    </div>
  );
};
</file>

<file path="renderer/src/components/MemoryCommitPanel.tsx">
import React, { useState } from 'react';
import { Save, X, Clock, Tag, Loader2 } from 'lucide-react';
import { useCorrectionStore } from '../state/correctionStore';
export const MemoryCommitPanel: React.FC = () => {
  const { corrections, update, commit } = useCorrectionStore();
  const [isExpanded, setIsExpanded] = useState(false);
  const [commitMessage, setCommitMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  if (corrections.length === 0) return null;
  const handleCommit = async () => {
    setIsLoading(true);
    try {
      await commit();
      setCommitMessage('');
      setIsExpanded(false);
    } catch (error) {
      console.error('Failed to commit:', error);
    } finally {
      setIsLoading(false);
    }
  };
  return (
    <div className="rounded-lg bg-white/5 border border-white/10 backdrop-blur-sm">
      <div className="p-4 border-b border-white/10">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-white/90">Memory Commit</h2>
          <button
            onClick={() => setIsExpanded(!isExpanded)}
            className="p-1.5 rounded-md bg-white/5 hover:bg-white/10 text-white/80 hover:text-white transition-colors"
            disabled={isLoading}
          >
            {isExpanded ? (
              <X className="w-4 h-4" />
            ) : (
              <Save className="w-4 h-4" />
            )}
          </button>
        </div>
      </div>
      {isExpanded && (
        <div className="p-4 space-y-4">
          <div className="space-y-2">
            <label className="block text-sm font-medium text-white/80">
              Commit Message
            </label>
            <textarea
              value={commitMessage}
              onChange={(e) => setCommitMessage(e.target.value)}
              placeholder="Describe what you want to remember..."
              className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-md
                text-white placeholder-white/50
                focus:outline-none focus:ring-2 focus:ring-blue-500/50 focus:border-transparent
                transition-all resize-none"
              rows={3}
              disabled={isLoading}
            />
          </div>
          <div className="flex items-center gap-2 text-sm text-white/60">
            <Clock className="w-4 h-4" />
            <span>Last commit: 2 hours ago</span>
          </div>
          <div className="flex flex-wrap gap-2">
            <button 
              className="px-3 py-1.5 rounded-full bg-blue-500/20 text-blue-300 
                border border-blue-500/20 hover:bg-blue-500/30 transition-colors
                flex items-center gap-1.5"
              disabled={isLoading}
            >
              <Tag className="w-3.5 h-3.5" />
              <span>Add Tag</span>
            </button>
            <button 
              className="px-3 py-1.5 rounded-full bg-white/5 text-white/80 
                border border-white/10 hover:bg-white/10 transition-colors"
              disabled={isLoading}
            >
              #context
            </button>
            <button 
              className="px-3 py-1.5 rounded-full bg-white/5 text-white/80 
                border border-white/10 hover:bg-white/10 transition-colors"
              disabled={isLoading}
            >
              #important
            </button>
          </div>
          <button 
            onClick={handleCommit}
            disabled={isLoading}
            className="w-full px-4 py-2 bg-blue-500/20 text-blue-300 rounded-lg
              hover:bg-blue-500/30 border border-blue-500/20 transition-colors
              flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isLoading ? (
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Save className="w-4 h-4" />
            )}
            <span>{isLoading ? 'Committing...' : 'Commit to Memory'}</span>
          </button>
        </div>
      )}
    </div>
  );
};
</file>

<file path="renderer/src/components/MemoryManager.tsx">
import React from 'react';
import { Brain, Trash2, RefreshCw } from 'lucide-react';
import { Button } from './ui/button';
interface MemoryManagerProps {
  onClear?: () => void;
  onRefresh?: () => void;
}
export function MemoryManager({ onClear, onRefresh }: MemoryManagerProps) {
  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Brain className="w-4 h-4 text-purple-400" />
          <span className="text-sm font-medium text-gray-600 dark:text-gray-300">Memory</span>
        </div>
        <div className="flex items-center gap-1">
          <Button
            size="icon"
            variant="ghost"
            onClick={onRefresh}
            className="h-6 w-6 text-muted-foreground hover:text-foreground"
            title="Refresh memory"
          >
            <RefreshCw className="w-3 h-3" />
          </Button>
          <Button
            size="icon"
            variant="ghost"
            onClick={onClear}
            className="h-6 w-6 text-muted-foreground hover:text-foreground"
            title="Clear memory"
          >
            <Trash2 className="w-3 h-3" />
          </Button>
        </div>
      </div>
      <div className="h-1 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
        <div className="h-full bg-purple-400 w-3/4" />
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/MemoryPanel.tsx">
import { useState, useEffect, ChangeEvent, KeyboardEvent } from 'react';
import { useMemory } from '@/hooks/useMemory';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Loader2, Search, Plus, Trash2, RefreshCw } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
export function MemoryPanel() {
  const {
    isInitialized,
    isLoading,
    error,
    memories,
    searchMemory,
    storeMemory,
    getRecentMemories,
    deleteMemory,
    clearMemories
  } = useMemory();
  const [searchQuery, setSearchQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [newMemory, setNewMemory] = useState('');
  useEffect(() => {
    if (isInitialized) {
      getRecentMemories(50).catch(console.error);
    }
  }, [isInitialized, getRecentMemories]);
  const handleSearch = async () => {
    if (!searchQuery.trim()) {
      await getRecentMemories(50);
      return;
    }
    setIsSearching(true);
    try {
      await searchMemory(searchQuery, { limit: 50 });
    } catch (error) {
      console.error('Search failed:', error);
    } finally {
      setIsSearching(false);
    }
  };
  const handleStore = async () => {
    if (!newMemory.trim()) return;
    try {
      const result = await storeMemory(newMemory, {
        type: 'user_input',
        source: 'memory_panel',
        tags: ['manual']
      });
      if (result.success) {
        setNewMemory('');
      } else {
        console.error('Failed to store memory:', result.error);
      }
    } catch (error) {
      console.error('Store failed:', error);
    }
  };
  const handleDelete = async (id: string) => {
    try {
      await deleteMemory(id);
    } catch (error) {
      console.error('Delete failed:', error);
    }
  };
  const handleClear = async () => {
    if (!confirm('Are you sure you want to clear all memories?')) return;
    try {
      await clearMemories();
    } catch (error) {
      console.error('Clear failed:', error);
    }
  };
  if (!isInitialized) {
    return (
      <div className="flex items-center justify-center h-full">
        <Loader2 className="w-6 h-6 animate-spin" />
        <span className="ml-2">Initializing memory service...</span>
      </div>
    );
  }
  if (error) {
    return (
      <div className="flex items-center justify-center h-full text-red-500">
        <span>Error: {error}</span>
      </div>
    );
  }
  return (
    <div className="flex flex-col h-full p-4 space-y-4">
      <div className="flex items-center space-x-2">
        <Input
          placeholder="Search memories..."
          value={searchQuery}
          onChange={(e: ChangeEvent<HTMLInputElement>) => setSearchQuery(e.target.value)}
          onKeyDown={(e: KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && handleSearch()}
          className="flex-1"
        />
        <Button
          variant="outline"
          size="icon"
          onClick={handleSearch}
          disabled={isSearching}
        >
          {isSearching ? (
            <Loader2 className="w-4 h-4 animate-spin" />
          ) : (
            <Search className="w-4 h-4" />
          )}
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={() => getRecentMemories(50)}
          disabled={isLoading}
        >
          <RefreshCw className="w-4 h-4" />
        </Button>
        <Button
          variant="outline"
          size="icon"
          onClick={handleClear}
          disabled={memories.length === 0}
        >
          <Trash2 className="w-4 h-4" />
        </Button>
      </div>
      <div className="flex items-center space-x-2">
        <Input
          placeholder="Add new memory..."
          value={newMemory}
          onChange={(e: ChangeEvent<HTMLInputElement>) => setNewMemory(e.target.value)}
          onKeyDown={(e: KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && handleStore()}
          className="flex-1"
        />
        <Button
          variant="outline"
          size="icon"
          onClick={handleStore}
          disabled={!newMemory.trim()}
        >
          <Plus className="w-4 h-4" />
        </Button>
      </div>
      <ScrollArea className="flex-1">
        <div className="space-y-2">
          {memories.map((memory) => (
            <Card key={memory.id} className="p-4">
              <div className="flex items-start justify-between">
                <div className="flex-1">
                  <p className="text-sm">{memory.content}</p>
                  <div className="flex items-center mt-2 space-x-2">
                    <Badge variant="secondary">
                      {memory.metadata.type}
                    </Badge>
                    <Badge variant="secondary">
                      {memory.metadata.source}
                    </Badge>
                    {memory.metadata.tags?.map((tag) => (
                      <Badge key={tag} variant="outline">
                        {tag}
                      </Badge>
                    ))}
                    <span className="text-xs text-muted-foreground">
                      {formatDistanceToNow(memory.metadata.timestamp, { addSuffix: true })}
                    </span>
                  </div>
                </div>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => handleDelete(memory.id)}
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            </Card>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
}
</file>

<file path="renderer/src/components/MessageActions.tsx">
import React from 'react';
import { MessageSquare, ThumbsUp, ThumbsDown } from 'lucide-react';
interface MessageActionsProps {
  onComment: () => void;
  onReact: (reaction: 'like' | 'dislike') => void;
  className?: string;
}
export const MessageActions: React.FC<MessageActionsProps> = ({
  onComment,
  onReact,
  className = ''
}) => {
  return (
    <div className={`flex items-center justify-between text-sm ${className}`}>
      <button
        onClick={onComment}
        className="flex items-center gap-1 px-2 py-1 rounded-md text-gray-400 hover:text-white hover:bg-white/10 transition-colors"
      >
        <MessageSquare className="w-4 h-4" />
        <span>Comment</span>
      </button>
      <div className="flex gap-1">
        <button
          onClick={() => onReact('like')}
          className="p-1 rounded-md text-gray-400 hover:text-green-400 hover:bg-white/10 transition-colors"
        >
          <ThumbsUp className="w-4 h-4" />
        </button>
        <button
          onClick={() => onReact('dislike')}
          className="p-1 rounded-md text-gray-400 hover:text-red-400 hover:bg-white/10 transition-colors"
        >
          <ThumbsDown className="w-4 h-4" />
        </button>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/ModelLoadingOverlay.tsx">
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useModelStatus } from '@/hooks/useModelStatus';
import { X, Loader2 } from 'lucide-react';
interface ProgressBarProps {
  value: number;
}
const ProgressBar: React.FC<ProgressBarProps> = ({ value }) => {
  return (
    <div className="w-full h-2 glass rounded-full overflow-hidden">
      <motion.div
        className="h-full bg-mint/20"
        initial={{ width: 0 }}
        animate={{ width: `${value}%` }}
        transition={{ duration: 0.3 }}
      />
    </div>
  );
};
const formatTime = (seconds: number): string => {
  if (seconds < 60) {
    return `${Math.ceil(seconds)} seconds`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.ceil(seconds % 60);
  return `${minutes} minute${minutes > 1 ? 's' : ''}${remainingSeconds > 0 ? ` ${remainingSeconds} seconds` : ''}`;
};
export const ModelLoadingOverlay: React.FC = () => {
  const { isLoading, modelName, progress, estimatedTimeRemaining, error } = useModelStatus();
  if (!isLoading) return null;
  const handleCancel = () => {
    // TODO: Implement cancel functionality through IPC
    window.electron.ipc.invoke('ollama:cancel-load', undefined);
  };
  return (
    <div className="absolute inset-0 glass backdrop-blur-glass flex items-center justify-center">
      <div className="glass p-6 rounded-xl shadow-glass flex flex-col items-center gap-4">
        <Loader2 className="h-8 w-8 animate-spin text-mint" />
        <p className="text-sm text-foreground">Processing...</p>
        {progress !== undefined && (
          <div className="w-full max-w-xs">
            <ProgressBar value={progress} />
            <p className="text-xs text-muted-foreground mt-2 text-center">
              {estimatedTimeRemaining !== undefined && formatTime(estimatedTimeRemaining)}
            </p>
          </div>
        )}
        <button
          onClick={handleCancel}
          className="btn btn-ghost p-2 mt-2"
        >
          <X className="h-4 w-4" />
        </button>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/ModelSelector.tsx">
import React, { useEffect } from 'react';
import { useModelStore } from '../state/modelStore';
export const ModelSelector: React.FC = () => {
  const { models, current, loading, error, load, set } = useModelStore();
  useEffect(() => {
    load();
  }, [load]);
  const handleModelChange = async (event: React.ChangeEvent<HTMLSelectElement>) => {
    const modelName = event.target.value;
    if (modelName) {
      await set(modelName);
    }
  };
  return (
    <div className="model-selector">
      <select
        value={current || ''}
        onChange={handleModelChange}
        disabled={loading}
        className="model-select"
      >
        <option value="">Select a model</option>
        {models.map((model) => (
          <option key={model.name} value={model.name}>
            {model.name}
          </option>
        ))}
      </select>
      {loading && <div className="loading">Loading...</div>}
      {error && <div className="error">{error}</div>}
    </div>
  );
};
</file>

<file path="renderer/src/components/ModelsList.tsx">
import React, { useEffect, useState } from 'react';
import type { OllamaModel } from '@shared/types/ollama';
export const ModelsList: React.FC = () => {
  const [models, setModels] = useState<OllamaModel[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    const fetchModels = async () => {
      try {
        setIsLoading(true);
        const response = await window.electron.ipc.invoke('ollama:list-models', undefined);
        setModels(response);
        setError(null);
      } catch (err) {
        console.error('Failed to fetch models:', err);
        setError('Failed to load models. Please check if Ollama is running.');
      } finally {
        setIsLoading(false);
      }
    };
    fetchModels();
  }, []);
  if (isLoading) {
    return (
      <div className="p-4 bg-white rounded-lg shadow">
        <h2 className="text-lg font-bold mb-4">Available Models</h2>
        <div className="animate-pulse">
          <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
          <div className="h-4 bg-gray-200 rounded w-1/2"></div>
        </div>
      </div>
    );
  }
  if (error) {
    return (
      <div className="p-4 bg-white rounded-lg shadow">
        <h2 className="text-lg font-bold mb-4">Available Models</h2>
        <div className="text-red-500">{error}</div>
      </div>
    );
  }
  return (
    <div className="p-4 bg-white rounded-lg shadow">
      <h2 className="text-lg font-bold mb-4">Available Models</h2>
      {models.length === 0 ? (
        <p className="text-gray-500">No models available</p>
      ) : (
        <ul className="space-y-2">
          {models.map((model) => (
            <li
              key={model.name}
              className="flex items-center justify-between p-2 bg-gray-50 rounded hover:bg-gray-100"
            >
              <div>
                <span className="font-medium">{model.name}</span>
                <span className="text-sm text-gray-500 ml-2">
                  ({model.details.parameter_size})
                </span>
              </div>
              <div className="text-sm text-gray-500">
                {model.details.format} / {model.details.quantization_level}
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};
</file>

<file path="renderer/src/components/OllamaConnectionNotification.tsx">
import React, { useEffect, useState } from 'react';
import { AlertCircle, ExternalLink } from 'lucide-react';
import toast from 'react-hot-toast';
import type { OllamaConnectionStatus } from '../types/ollama';
export function OllamaConnectionNotification() {
  const [connectionStatus, setConnectionStatus] = useState<OllamaConnectionStatus | null>(null);
  const [hasShownToast, setHasShownToast] = useState(false);
  useEffect(() => {
    // Check Ollama connection status on component mount
    const checkConnection = async () => {
      try {
        const status = await window.electronAPI.getServiceStatus('ollama');
        if (status && status.status === 'error') {
          setConnectionStatus({
            status: 'disconnected',
            lastChecked: status.lastCheck,
            error: status.error
          });
        } else if (status && status.status === 'running') {
          setConnectionStatus({
            status: 'connected',
            lastChecked: status.lastCheck
          });
        }
      } catch (error) {
        console.error('Failed to check Ollama connection:', error);
        setConnectionStatus({
          status: 'disconnected',
          lastChecked: Date.now(),
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    };
    checkConnection();
    // Set up listener for service status changes
    const unsubscribe = window.electronAPI.onServiceStatusChange((event) => {
      if (event.serviceName === 'ollama') {
        setConnectionStatus({
          status: event.status === 'running' ? 'connected' : 'disconnected',
          lastChecked: Date.now(),
          error: event.error
        });
      }
    });
    // Check connection periodically
    const interval = setInterval(checkConnection, 30000);
    return () => {
      clearInterval(interval);
      unsubscribe();
    };
  }, []);
  // Show toast notification when Ollama is disconnected
  useEffect(() => {
    if (connectionStatus && connectionStatus.status === 'disconnected' && !hasShownToast) {
      toast.error(
        <div className="flex flex-col gap-2">
          <div className="font-medium">Ollama Service Unavailable</div>
          <div className="text-sm">
            The Ollama service is not running or cannot be reached. Some features may be limited.
          </div>
          <div className="flex items-center gap-2 mt-1">
            <button
              className="px-3 py-1 bg-white/10 hover:bg-white/20 rounded text-xs flex items-center gap-1"
              onClick={() => window.electronAPI.restartService('ollama')}
            >
              Retry Connection
            </button>
            <a
              href="https://ollama.com/download"
              target="_blank"
              rel="noopener noreferrer"
              className="px-3 py-1 bg-white/10 hover:bg-white/20 rounded text-xs flex items-center gap-1"
            >
              Install Ollama <ExternalLink className="w-3 h-3 ml-1" />
            </a>
          </div>
        </div>,
        {
          duration: 10000,
          icon: <AlertCircle className="text-red-500" />,
          style: {
            borderRadius: '10px',
            background: '#1e1e2e',
            color: '#cdd6f4',
            border: '1px solid rgba(255, 255, 255, 0.1)',
          },
        }
      );
      setHasShownToast(true);
    }
  }, [connectionStatus, hasShownToast]);
  // Reset toast flag when connection status changes to connected
  useEffect(() => {
    if (connectionStatus && connectionStatus.status === 'connected') {
      setHasShownToast(false);
    }
  }, [connectionStatus]);
  // This component doesn't render anything visible
  return null;
}
</file>

<file path="renderer/src/components/OllamaSetupGuide.tsx">
import React from 'react';
import { motion } from 'framer-motion';
interface OllamaSetupGuideProps {
  onClose: () => void;
}
export const OllamaSetupGuide: React.FC<OllamaSetupGuideProps> = ({ onClose }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.9 }}
        className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto"
      >
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-2xl font-bold">Ollama Setup Guide</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 focus:outline-none"
          >
            
          </button>
        </div>
        <div className="space-y-6">
          <section>
            <h3 className="text-lg font-semibold mb-3">System Requirements</h3>
            <ul className="list-disc list-inside space-y-2 text-gray-700">
              <li>macOS, Linux, or Windows with WSL2</li>
              <li>4GB RAM minimum (8GB recommended)</li>
              <li>1GB free disk space</li>
              <li>Node.js 16 or higher</li>
            </ul>
          </section>
          <section>
            <h3 className="text-lg font-semibold mb-3">Installation Steps</h3>
            <ol className="list-decimal list-inside space-y-4 text-gray-700">
              <li>
                <div className="font-medium">Install Ollama</div>
                <p className="ml-6 mt-1">
                  Download and install Ollama from{' '}
                  <a
                    href="https://ollama.ai"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-blue-500 hover:text-blue-600"
                  >
                    https://ollama.ai
                  </a>
                </p>
              </li>
              <li>
                <div className="font-medium">Start Ollama Service</div>
                <p className="ml-6 mt-1">
                  Open a terminal and run:
                  <code className="block bg-gray-100 p-2 rounded mt-2 font-mono text-sm">
                    ollama serve
                  </code>
                </p>
              </li>
              <li>
                <div className="font-medium">Pull Required Models</div>
                <p className="ml-6 mt-1">
                  In a new terminal, run:
                  <code className="block bg-gray-100 p-2 rounded mt-2 font-mono text-sm">
                    ollama pull llama2
                  </code>
                </p>
              </li>
            </ol>
          </section>
          <section>
            <h3 className="text-lg font-semibold mb-3">Troubleshooting</h3>
            <div className="space-y-4">
              <div className="bg-gray-50 p-4 rounded">
                <h4 className="font-medium mb-2">Service Not Starting</h4>
                <ul className="list-disc list-inside space-y-1 text-gray-700">
                  <li>Verify Ollama is installed correctly</li>
                  <li>Check if port 11434 is available</li>
                  <li>Check system logs for errors</li>
                </ul>
              </div>
              <div className="bg-gray-50 p-4 rounded">
                <h4 className="font-medium mb-2">Model Loading Issues</h4>
                <ul className="list-disc list-inside space-y-1 text-gray-700">
                  <li>Ensure sufficient disk space</li>
                  <li>Check internet connection</li>
                  <li>Try pulling the model again</li>
                </ul>
              </div>
              <div className="bg-gray-50 p-4 rounded">
                <h4 className="font-medium mb-2">Performance Issues</h4>
                <ul className="list-disc list-inside space-y-1 text-gray-700">
                  <li>Increase system swap space</li>
                  <li>Close resource-intensive applications</li>
                  <li>Consider using a smaller model</li>
                </ul>
              </div>
            </div>
          </section>
          <section>
            <h3 className="text-lg font-semibold mb-3">Configuration</h3>
            <p className="text-gray-700">
              You can adjust Ollama settings in the application settings panel:
            </p>
            <ul className="list-disc list-inside space-y-2 text-gray-700 mt-2">
              <li>Model selection</li>
              <li>API endpoint configuration</li>
              <li>Performance settings</li>
              <li>Memory allocation</li>
            </ul>
          </section>
        </div>
        <div className="mt-6 flex justify-end">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300"
          >
            Close
          </button>
        </div>
      </motion.div>
    </div>
  );
};
</file>

<file path="renderer/src/components/OllamaTest.tsx">
import React, { useState, useEffect } from 'react';
import type { OllamaModel, ModelLoadingState } from '@shared/types/ollama';
export default function OllamaTest() {
  const [isConnected, setIsConnected] = useState(false);
  const [models, setModels] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  useEffect(() => {
    let isSubscribed = true;
    let unsubscribe: (() => void) | undefined;
    const checkConnection = async () => {
      try {
        const models = await window.electron.ollama.listModels();
        if (isSubscribed) {
          setIsConnected(true);
          setModels(models.map(model => model.name));
          setError(null);
        }
      } catch (err) {
        if (isSubscribed) {
          setIsConnected(false);
          setError(err instanceof Error ? err.message : 'Failed to connect to Ollama');
        }
      }
    };
    checkConnection();
    // Subscribe to model loading state changes
    if (window.electron.ollama.onModelLoadingStateChanged) {
      unsubscribe = window.electron.ollama.onModelLoadingStateChanged((state: ModelLoadingState) => {
        if (isSubscribed) {
          setIsLoading(state.isLoading);
        }
      });
    }
    return () => {
      isSubscribed = false;
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, []);
  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">Ollama API Test</h2>
      <div className="space-y-4">
        <div>
          <p className="font-semibold">Connection Status:</p>
          <p className={isConnected ? 'text-green-500' : 'text-red-500'}>
            {isConnected ? 'Connected' : 'Disconnected'}
          </p>
          {error && <p className="text-red-500 mt-2">{error}</p>}
        </div>
        <div>
          <p className="font-semibold">Available Models:</p>
          <p>{models.length > 0 ? models.join(', ') : 'No models found'}</p>
        </div>
        {isLoading && (
          <div className="text-blue-500">
            Loading...
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/PerformanceMetrics.tsx">
import React from 'react';
import { BarChart2, Cpu, HardDrive, Clock } from 'lucide-react';
interface MetricCardProps {
  icon: React.ReactNode;
  label: string;
  value: string;
  trend?: string;
}
function MetricCard({ icon, label, value, trend }: MetricCardProps) {
  return (
    <div className="p-3 rounded-lg border border-white/10 bg-white/5">
      <div className="flex items-center gap-2 text-xs text-muted-foreground">
        {icon}
        <span>{label}</span>
      </div>
      <div className="mt-1 flex items-baseline justify-between">
        <div className="text-sm font-medium">{value}</div>
        {trend && (
          <div className="text-xs text-mint-400 dark:text-coral-400">{trend}</div>
        )}
      </div>
    </div>
  );
}
export function PerformanceMetrics() {
  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2">
        <BarChart2 className="w-4 h-4 text-muted-foreground" />
        <h3 className="text-sm font-medium">Performance Metrics</h3>
      </div>
      <div className="grid gap-3">
        <MetricCard
          icon={<Cpu className="w-3 h-3" />}
          label="CPU Usage"
          value="32%"
          trend=" 2%"
        />
        <MetricCard
          icon={<HardDrive className="w-3 h-3" />}
          label="Memory Usage"
          value="1.2 GB"
          trend=" 0.1 GB"
        />
        <MetricCard
          icon={<Clock className="w-3 h-3" />}
          label="Response Time"
          value="120ms"
          trend=" 5ms"
        />
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/PerformanceStats.tsx">
import React, { useState, useEffect } from 'react';
import { performanceMonitor } from '../utils/performanceMonitor';
export const PerformanceStats: React.FC = () => {
  const [stats, setStats] = useState(performanceMonitor.getStats());
  const [isExpanded, setIsExpanded] = useState(false);
  useEffect(() => {
    const interval = setInterval(() => {
      setStats(performanceMonitor.getStats());
    }, 1000);
    return () => clearInterval(interval);
  }, []);
  const formatTime = (ms: number) => {
    if (ms < 1000) return `${ms.toFixed(1)}ms`;
    return `${(ms / 1000).toFixed(2)}s`;
  };
  const formatPercentage = (value: number) => {
    return `${(value * 100).toFixed(1)}%`;
  };
  return (
    <div className="bg-white rounded-lg shadow p-4">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-medium text-gray-900">Performance Statistics</h3>
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="text-sm text-blue-600 hover:text-blue-700"
        >
          {isExpanded ? 'Show Less' : 'Show More'}
        </button>
      </div>
      <div className="grid grid-cols-2 gap-4">
        <div>
          <p className="text-sm text-gray-500">Average Embedding Time</p>
          <p className="text-lg font-medium">{formatTime(stats.averageEmbeddingTime)}</p>
        </div>
        <div>
          <p className="text-sm text-gray-500">Total Tokens Processed</p>
          <p className="text-lg font-medium">{stats.totalTokensProcessed.toLocaleString()}</p>
        </div>
        <div>
          <p className="text-sm text-gray-500">Cache Hit Rate</p>
          <p className="text-lg font-medium">{formatPercentage(stats.cacheHitRate)}</p>
        </div>
        <div>
          <p className="text-sm text-gray-500">Error Rate</p>
          <p className="text-lg font-medium">{formatPercentage(stats.errorRate)}</p>
        </div>
      </div>
      {isExpanded && (
        <div className="mt-4 pt-4 border-t">
          <div className="flex justify-between items-center mb-2">
            <h4 className="text-sm font-medium text-gray-700">Recent Metrics</h4>
            <button
              onClick={() => performanceMonitor.clear()}
              className="text-sm text-red-600 hover:text-red-700"
            >
              Clear History
            </button>
          </div>
          <div className="max-h-48 overflow-y-auto">
            {performanceMonitor.getMetrics().slice(-10).map((metric, index) => (
              <div key={index} className="text-sm text-gray-600 py-1">
                <div className="flex justify-between">
                  <span>{new Date(metric.timestamp).toLocaleTimeString()}</span>
                  <span>{formatTime(metric.embeddingTime)}</span>
                </div>
                <div className="flex justify-between text-xs text-gray-500">
                  <span>Batch: {metric.batchSize}</span>
                  <span>Tokens: {metric.tokensProcessed}</span>
                  <span>Cache: {metric.cacheHits}/{metric.cacheHits + metric.cacheMisses}</span>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="renderer/src/components/ServiceStatusManager.tsx">
import React, { useState } from 'react';
import { ChevronUp, ChevronDown, RefreshCw } from 'lucide-react';
type ServiceStatus = 'available' | 'unavailable' | 'loading';
interface ServiceState {
  status: ServiceStatus;
  error?: string;
}
interface ServiceStatusManagerProps {
  services: Record<string, ServiceState>;
  onRetry: (serviceName: string) => void;
}
export const ServiceStatusManager: React.FC<ServiceStatusManagerProps> = ({ services, onRetry }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  return (
    <div className="fixed bottom-0 left-0 right-0">
      <div className="max-w-7xl mx-auto px-4">
        <div className="backdrop-blur-sm bg-white/5 border-t border-white/10 rounded-t-lg">
          <button
            onClick={() => setIsExpanded(!isExpanded)}
            className="w-full px-4 py-2 flex items-center justify-between text-white/80 hover:text-white transition-colors"
          >
            <span className="font-medium">Service Status</span>
            {isExpanded ? (
              <ChevronDown className="w-4 h-4" />
            ) : (
              <ChevronUp className="w-4 h-4" />
            )}
          </button>
          {isExpanded && (
            <div className="px-4 pb-4 space-y-2">
              {Object.entries(services).map(([name, state]) => (
                <div
                  key={name}
                  className="flex items-center justify-between p-2 rounded-lg bg-white/5 border border-white/10"
                >
                  <div className="flex items-center gap-2">
                    <div
                      className={`w-2 h-2 rounded-full ${
                        state.status === 'available'
                          ? 'bg-green-500'
                          : state.status === 'loading'
                          ? 'bg-yellow-500'
                          : 'bg-red-500'
                      }`}
                    />
                    <span className="font-medium text-white/90">{name}</span>
                    {state.error && (
                      <span className="text-sm text-white/50">{state.error}</span>
                    )}
                  </div>
                  {state.status === 'unavailable' && (
                    <button
                      onClick={() => onRetry(name)}
                      className="p-1.5 rounded-md bg-white/10 hover:bg-white/20 text-white/80 hover:text-white transition-colors"
                    >
                      <RefreshCw className="w-4 h-4" />
                    </button>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/ServiceStatusPanel.tsx">
import React from 'react';
import { ChevronDown, ChevronUp, RefreshCw } from 'lucide-react';
type ServiceStatus = 'available' | 'unavailable' | 'loading';
interface ServiceState {
  status: ServiceStatus;
  error?: string;
}
interface ServiceStatusPanelProps {
  isExpanded: boolean;
  onToggle: () => void;
  serviceStatuses: Map<string, ServiceState>;
  onRetry: (serviceName: string) => void;
}
export const ServiceStatusPanel: React.FC<ServiceStatusPanelProps> = ({
  isExpanded,
  onToggle,
  serviceStatuses,
  onRetry,
}) => {
  return (
    <div className="relative">
      <button
        onClick={onToggle}
        className="p-2 rounded-lg bg-white/5 hover:bg-white/10 text-white/80 hover:text-white 
          border border-white/10 backdrop-blur-sm transition-colors"
        title="Service Status"
      >
        {isExpanded ? (
          <ChevronUp className="w-5 h-5" />
        ) : (
          <ChevronDown className="w-5 h-5" />
        )}
      </button>
      {isExpanded && (
        <div className="absolute right-0 top-full mt-2 w-64 rounded-lg bg-white/5 border border-white/10 
          backdrop-blur-sm shadow-lg overflow-hidden">
          <div className="p-3 space-y-2">
            {Array.from(serviceStatuses.entries()).map(([name, state]) => (
              <div
                key={name}
                className="flex items-center justify-between p-2 rounded-lg bg-white/5 border border-white/10"
              >
                <div className="flex items-center gap-2">
                  <div
                    className={`w-2 h-2 rounded-full ${
                      state.status === 'available'
                        ? 'bg-green-500'
                        : state.status === 'loading'
                        ? 'bg-yellow-500'
                        : 'bg-red-500'
                    }`}
                  />
                  <span className="font-medium text-white/90">{name}</span>
                  {state.error && (
                    <span className="text-sm text-white/50">{state.error}</span>
                  )}
                </div>
                {state.status === 'unavailable' && (
                  <button
                    onClick={() => onRetry(name)}
                    className="p-1.5 rounded-md bg-white/10 hover:bg-white/20 text-white/80 hover:text-white transition-colors"
                  >
                    <RefreshCw className="w-4 h-4" />
                  </button>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="renderer/src/components/SettingsButton.tsx">
import React, { useState, useEffect } from 'react';
import { Settings as SettingsIcon } from 'lucide-react';
import { SettingsMenu } from './SettingsMenu';
import { SettingsErrorBoundary } from './SettingsErrorBoundary';
import { useSettingsStore } from '../stores/settingsStore';
interface SettingsButtonProps {
  className?: string;
}
/**
 * Button component that opens the settings menu
 */
export const SettingsButton: React.FC<SettingsButtonProps> = ({ className = '' }) => {
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const { lastError, setLastError } = useSettingsStore();
  // Clear any settings errors when closing the menu
  useEffect(() => {
    if (!isSettingsOpen && lastError) {
      setLastError(null);
    }
  }, [isSettingsOpen, lastError, setLastError]);
  // Handle keyboard shortcut (Cmd/Ctrl+,)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === ',') {
        e.preventDefault();
        setIsSettingsOpen(prev => !prev);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
  return (
    <SettingsErrorBoundary>
      <button
        onClick={() => setIsSettingsOpen(true)}
        className={`p-2 rounded-md transition-colors text-gray-500 hover:text-gray-700 hover:bg-gray-100 dark:text-gray-400 dark:hover:text-gray-200 dark:hover:bg-gray-800 ${className}`}
        title="Settings (Ctrl+,)"
        aria-label="Open Settings"
        aria-haspopup="dialog"
      >
        <SettingsIcon className="w-5 h-5" />
      </button>
      <SettingsMenu 
        isOpen={isSettingsOpen} 
        onClose={() => setIsSettingsOpen(false)} 
      />
    </SettingsErrorBoundary>
  );
};
export default SettingsButton;
</file>

<file path="renderer/src/components/SettingsErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertCircle, RefreshCw } from 'lucide-react';
interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}
interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}
/**
 * Error boundary specifically for settings-related components
 */
export class SettingsErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }
  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
      errorInfo: null
    };
  }
  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    this.setState({
      error,
      errorInfo
    });
    // Log the error
    console.error('Settings component error:', error, errorInfo);
  }
  handleReset = (): void => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };
  render(): ReactNode {
    if (this.state.hasError) {
      // Custom fallback UI
      return this.props.fallback || (
        <div className="p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
          <div className="flex items-center text-red-600 dark:text-red-400 mb-2">
            <AlertCircle className="w-5 h-5 mr-2" />
            <h3 className="font-medium">Settings Error</h3>
          </div>
          <p className="text-sm text-red-600 dark:text-red-400 mb-3">
            {this.state.error?.message || 'An unexpected error occurred in the settings component.'}
          </p>
          <button
            onClick={this.handleReset}
            className="flex items-center px-3 py-1.5 text-sm bg-red-100 dark:bg-red-800 text-red-700 dark:text-red-300 rounded-md hover:bg-red-200 dark:hover:bg-red-700"
          >
            <RefreshCw className="w-4 h-4 mr-1" />
            Try Again
          </button>
        </div>
      );
    }
    return this.props.children;
  }
}
</file>

<file path="renderer/src/components/SettingsMenu.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { X, Save, Trash2, AlertCircle, Check, ExternalLink, Eye, EyeOff, RefreshCw } from 'lucide-react';
import { useSettingsStore } from '../stores/settingsStore';
import { ThemeToggle } from './ThemeToggle';
import { isValidGeminiApiKey } from '../types/settings';
import { useGemini } from '../hooks/useGemini';
interface SettingsMenuProps {
  isOpen: boolean;
  onClose: () => void;
}
/**
 * Settings menu component for managing API keys and feature toggles
 */
export const SettingsMenu: React.FC<SettingsMenuProps> = ({ isOpen, onClose }) => {
  // Get settings from store
  const { 
    apiKeys, 
    features, 
    security,
    lastError,
    setApiKey, 
    clearApiKey, 
    toggleFeature,
    toggleApiKeyMasking,
    resetSettings,
    exportSettings,
    importSettings
  } = useSettingsStore();
  // Get Gemini API methods
  const { testApiKey, isLoading: isTestingApiKey } = useGemini();
  // Local state
  const [geminiKey, setGeminiKey] = useState(apiKeys.googleGemini || '');
  const [showGeminiKey, setShowGeminiKey] = useState(false);
  const [geminiKeyError, setGeminiKeyError] = useState<string | null>(null);
  const [showSavedMessage, setShowSavedMessage] = useState(false);
  const [isTestingKey, setIsTestingKey] = useState(false);
  const [testKeyResult, setTestKeyResult] = useState<boolean | null>(null);
  const [isImporting, setIsImporting] = useState(false);
  const [importError, setImportError] = useState<string | null>(null);
  // Refs
  const modalRef = useRef<HTMLDivElement>(null);
  const importFileInputRef = useRef<HTMLInputElement>(null);
  // Handle escape key to close modal
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };
    window.addEventListener('keydown', handleEscape);
    return () => window.removeEventListener('keydown', handleEscape);
  }, [onClose]);
  // Focus trap for accessibility
  useEffect(() => {
    if (isOpen) {
      // Set focus to the modal
      modalRef.current?.focus();
    }
  }, [isOpen]);
  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setGeminiKey(apiKeys.googleGemini || '');
      setGeminiKeyError(null);
      setShowSavedMessage(false);
      setTestKeyResult(null);
      setIsTestingKey(false);
      setImportError(null);
    }
  }, [isOpen, apiKeys.googleGemini]);
  // Early return if modal is closed
  if (!isOpen) return null;
  /**
   * Validates and saves the Gemini API key
   */
  const handleSaveGeminiKey = async () => {
    // Validate key format
    if (!isValidGeminiApiKey(geminiKey)) {
      setGeminiKeyError('Invalid API key format. Google API keys are typically ~40 characters.');
      return;
    }
    setGeminiKeyError(null);
    try {
      await setApiKey('googleGemini', geminiKey);
      setShowSavedMessage(true);
      setTimeout(() => setShowSavedMessage(false), 3000);
    } catch (error) {
      setGeminiKeyError(error instanceof Error ? error.message : 'Failed to save API key');
    }
  };
  /**
   * Clears the Gemini API key after confirmation
   */
  const handleClearGeminiKey = () => {
    if (window.confirm('Are you sure you want to remove this API key?')) {
      clearApiKey('googleGemini')
        .then(() => {
          setGeminiKey('');
          setGeminiKeyError(null);
          setTestKeyResult(null);
        })
        .catch(error => {
          setGeminiKeyError(error instanceof Error ? error.message : 'Failed to clear API key');
        });
    }
  };
  /**
   * Tests if the Gemini API key is valid
   */
  const handleTestGeminiKey = async () => {
    // Validate key format first
    if (!isValidGeminiApiKey(geminiKey)) {
      setGeminiKeyError('Invalid API key format. Google API keys are typically ~40 characters.');
      return;
    }
    setGeminiKeyError(null);
    setIsTestingKey(true);
    setTestKeyResult(null);
    try {
      const isValid = await testApiKey(geminiKey);
      setTestKeyResult(isValid);
      if (isValid) {
        // Auto-save if valid
        await setApiKey('googleGemini', geminiKey);
        setShowSavedMessage(true);
        setTimeout(() => setShowSavedMessage(false), 3000);
      } else {
        setGeminiKeyError('API key is invalid or has insufficient permissions.');
      }
    } catch (error) {
      setGeminiKeyError(error instanceof Error ? error.message : 'Failed to test API key');
      setTestKeyResult(false);
    } finally {
      setIsTestingKey(false);
    }
  };
  /**
   * Toggles the web surfing feature
   */
  const handleWebSurfingToggle = (e: React.ChangeEvent<HTMLInputElement>) => {
    toggleFeature('webSurfing', e.target.checked);
  };
  /**
   * Toggles API key masking
   */
  const handleApiKeyMaskingToggle = (e: React.ChangeEvent<HTMLInputElement>) => {
    toggleApiKeyMasking(e.target.checked);
  };
  /**
   * Exports settings to a JSON file
   */
  const handleExportSettings = () => {
    const settingsJson = exportSettings();
    const blob = new Blob([settingsJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'osipelican-settings.json';
    document.body.appendChild(a);
    a.click();
    // Clean up
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  /**
   * Opens the file picker for importing settings
   */
  const handleImportClick = () => {
    importFileInputRef.current?.click();
  };
  /**
   * Imports settings from a JSON file
   */
  const handleImportSettings = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    setIsImporting(true);
    setImportError(null);
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const settingsJson = event.target?.result as string;
        const success = importSettings(settingsJson);
        if (success) {
          // Update local state with new settings
          setGeminiKey(apiKeys.googleGemini || '');
          alert('Settings imported successfully');
        } else {
          setImportError('Failed to import settings: Invalid format');
        }
      } catch (error) {
        setImportError(error instanceof Error ? error.message : 'Failed to import settings');
      } finally {
        setIsImporting(false);
        // Reset file input
        if (importFileInputRef.current) {
          importFileInputRef.current.value = '';
        }
      }
    };
    reader.onerror = () => {
      setImportError('Failed to read file');
      setIsImporting(false);
    };
    reader.readAsText(file);
  };
  /**
   * Resets all settings after confirmation
   */
  const handleResetSettings = () => {
    if (window.confirm('Are you sure you want to reset all settings? This cannot be undone.')) {
      resetSettings();
      setGeminiKey('');
      setGeminiKeyError(null);
      setTestKeyResult(null);
    }
  };
  // Derived state
  const isGeminiKeyValid = isValidGeminiApiKey(geminiKey);
  const canEnableWebSurfing = !!apiKeys.googleGemini;
  return (
    <div 
      className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center"
      onClick={(e) => {
        // Close when clicking outside the modal
        if (e.target === e.currentTarget) onClose();
      }}
      role="dialog"
      aria-modal="true"
      aria-labelledby="settings-title"
    >
      <div 
        ref={modalRef}
        className="bg-white dark:bg-gray-800 rounded-lg shadow-lg w-full max-w-md mx-4 max-h-[90vh] overflow-y-auto"
        tabIndex={-1}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <h2 id="settings-title" className="text-xl font-semibold text-gray-900 dark:text-white">Settings</h2>
          <button 
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
            aria-label="Close settings"
          >
            <X size={20} />
          </button>
        </div>
        <div className="p-4 space-y-6">
          {/* Theme Settings */}
          <div className="space-y-2">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">Theme</h3>
            <div className="bg-gray-50 dark:bg-gray-900 p-3 rounded-md">
              <ThemeToggle />
            </div>
          </div>
          {/* API Keys */}
          <div className="space-y-3">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">API Keys</h3>
            {/* Google Gemini API Key */}
            <div className="bg-gray-50 dark:bg-gray-900 p-3 rounded-md space-y-2">
              <div className="flex justify-between items-center">
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                  Google Gemini API Key
                </label>
                <a 
                  href="https://ai.google.dev/tutorials/setup" 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 text-xs flex items-center"
                >
                  Get API Key <ExternalLink size={12} className="ml-1" />
                </a>
              </div>
              <div className="flex">
                <div className="relative flex-1">
                  <input
                    type={showGeminiKey ? "text" : "password"}
                    value={geminiKey}
                    onChange={(e) => {
                      setGeminiKey(e.target.value);
                      setGeminiKeyError(null);
                      setTestKeyResult(null);
                    }}
                    placeholder="Enter your Google Gemini API key"
                    className={`w-full px-3 py-2 border ${
                      geminiKeyError 
                        ? 'border-red-500 dark:border-red-400' 
                        : 'border-gray-300 dark:border-gray-600'
                    } rounded-l-md 
                    bg-white dark:bg-gray-800 text-gray-900 dark:text-white 
                    focus:outline-none focus:ring-2 focus:ring-blue-500`}
                    aria-invalid={!!geminiKeyError}
                    aria-describedby={geminiKeyError ? "gemini-key-error" : undefined}
                  />
                  <button
                    type="button"
                    onClick={() => setShowGeminiKey(!showGeminiKey)}
                    className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300"
                    aria-label={showGeminiKey ? "Hide API key" : "Show API key"}
                  >
                    {showGeminiKey ? <EyeOff size={16} /> : <Eye size={16} />}
                  </button>
                </div>
                <button
                  onClick={handleSaveGeminiKey}
                  disabled={!geminiKey.trim() || isTestingKey}
                  className="px-3 py-2 bg-blue-600 text-white rounded-none hover:bg-blue-700 
                           disabled:bg-blue-400 disabled:cursor-not-allowed"
                  aria-label="Save API key"
                >
                  <Save size={18} />
                </button>
                <button
                  onClick={handleTestGeminiKey}
                  disabled={!geminiKey.trim() || isTestingKey}
                  className="px-3 py-2 bg-green-600 text-white rounded-r-md hover:bg-green-700 
                           disabled:bg-green-400 disabled:cursor-not-allowed flex items-center"
                  aria-label="Test API key"
                >
                  {isTestingKey ? (
                    <RefreshCw size={18} className="animate-spin" />
                  ) : (
                    <Check size={18} />
                  )}
                </button>
                {apiKeys.googleGemini && (
                  <button
                    onClick={handleClearGeminiKey}
                    className="px-3 py-2 ml-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                    aria-label="Clear API key"
                  >
                    <Trash2 size={18} />
                  </button>
                )}
              </div>
              {geminiKeyError && (
                <div id="gemini-key-error" className="flex items-center text-red-600 dark:text-red-400 text-sm mt-1">
                  <AlertCircle size={16} className="mr-1 flex-shrink-0" />
                  <span>{geminiKeyError}</span>
                </div>
              )}
              {showSavedMessage && !geminiKeyError && (
                <div className="flex items-center text-green-600 dark:text-green-400 text-sm mt-1">
                  <Check size={16} className="mr-1" />
                  API key saved successfully
                </div>
              )}
              {testKeyResult === true && !geminiKeyError && (
                <div className="flex items-center text-green-600 dark:text-green-400 text-sm mt-1">
                  <Check size={16} className="mr-1" />
                  API key is valid
                </div>
              )}
              {testKeyResult === false && !geminiKeyError && (
                <div className="flex items-center text-red-600 dark:text-red-400 text-sm mt-1">
                  <AlertCircle size={16} className="mr-1" />
                  API key is invalid or has insufficient permissions
                </div>
              )}
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                Your API key is stored securely and never sent to our servers.
              </p>
            </div>
          </div>
          {/* Features */}
          <div className="space-y-3">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">Features</h3>
            {/* Web Surfing */}
            <div className="bg-gray-50 dark:bg-gray-900 p-3 rounded-md">
              <div className="flex items-center justify-between">
                <div>
                  <label htmlFor="toggle-web-surfing" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                    Web Surfing with Google Gemini
                  </label>
                  <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    Enable web browsing capabilities using Google Gemini
                  </p>
                </div>
                <div className="relative inline-block w-10 mr-2 align-middle select-none">
                  <input
                    type="checkbox"
                    id="toggle-web-surfing"
                    checked={features.webSurfing}
                    onChange={handleWebSurfingToggle}
                    disabled={!canEnableWebSurfing}
                    className="sr-only"
                    aria-describedby={!canEnableWebSurfing ? "web-surfing-error" : undefined}
                  />
                  <label
                    htmlFor="toggle-web-surfing"
                    className={`block overflow-hidden h-6 rounded-full cursor-pointer ${
                      !canEnableWebSurfing ? 'opacity-50 cursor-not-allowed' : ''
                    } ${
                      features.webSurfing ? 'bg-blue-600' : 'bg-gray-300 dark:bg-gray-700'
                    }`}
                  >
                    <span
                      className={`block h-6 w-6 rounded-full bg-white transform transition-transform ${
                        features.webSurfing ? 'translate-x-4' : 'translate-x-0'
                      }`}
                    ></span>
                  </label>
                </div>
              </div>
              {!canEnableWebSurfing && (
                <div id="web-surfing-error" className="flex items-center text-amber-600 dark:text-amber-400 text-xs mt-2">
                  <AlertCircle size={14} className="mr-1 flex-shrink-0" />
                  Google Gemini API key required for web surfing
                </div>
              )}
            </div>
          </div>
          {/* Security */}
          <div className="space-y-3">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">Security</h3>
            {/* API Key Masking */}
            <div className="bg-gray-50 dark:bg-gray-900 p-3 rounded-md">
              <div className="flex items-center justify-between">
                <div>
                  <label htmlFor="toggle-api-key-masking" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                    Mask API Keys
                  </label>
                  <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    Hide API keys in the UI for better security
                  </p>
                </div>
                <div className="relative inline-block w-10 mr-2 align-middle select-none">
                  <input
                    type="checkbox"
                    id="toggle-api-key-masking"
                    checked={security.maskApiKeys}
                    onChange={handleApiKeyMaskingToggle}
                    className="sr-only"
                  />
                  <label
                    htmlFor="toggle-api-key-masking"
                    className={`block overflow-hidden h-6 rounded-full cursor-pointer ${
                      security.maskApiKeys ? 'bg-blue-600' : 'bg-gray-300 dark:bg-gray-700'
                    }`}
                  >
                    <span
                      className={`block h-6 w-6 rounded-full bg-white transform transition-transform ${
                        security.maskApiKeys ? 'translate-x-4' : 'translate-x-0'
                      }`}
                    ></span>
                  </label>
                </div>
              </div>
            </div>
          </div>
          {/* Backup & Restore */}
          <div className="space-y-3">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white">Backup & Restore</h3>
            <div className="bg-gray-50 dark:bg-gray-900 p-3 rounded-md space-y-3">
              <div className="flex flex-col space-y-2">
                <button
                  onClick={handleExportSettings}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 flex items-center justify-center"
                >
                  Export Settings
                </button>
                <button
                  onClick={handleImportClick}
                  className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 flex items-center justify-center"
                  disabled={isImporting}
                >
                  {isImporting ? 'Importing...' : 'Import Settings'}
                </button>
                <input
                  type="file"
                  ref={importFileInputRef}
                  onChange={handleImportSettings}
                  accept=".json"
                  className="hidden"
                />
                {importError && (
                  <div className="flex items-center text-red-600 dark:text-red-400 text-sm mt-1">
                    <AlertCircle size={16} className="mr-1 flex-shrink-0" />
                    <span>{importError}</span>
                  </div>
                )}
                <button
                  onClick={handleResetSettings}
                  className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 flex items-center justify-center mt-2"
                >
                  Reset All Settings
                </button>
              </div>
              <p className="text-xs text-gray-500 dark:text-gray-400">
                Export your settings to back them up or transfer them to another device.
                Importing settings will overwrite your current settings.
              </p>
            </div>
          </div>
        </div>
        <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-white rounded-md hover:bg-gray-300 dark:hover:bg-gray-600"
          >
            Close
          </button>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/SettingsPanel.tsx">
import React from 'react';
import { X, Moon, Sun, Globe, MessageSquare } from 'lucide-react';
import { Button } from './ui/button';
import { Switch } from './ui/switch';
import { Label } from './ui/label';
interface SettingsPanelProps {
  isOpen: boolean;
  onClose: () => void;
}
export function SettingsPanel({ isOpen, onClose }: SettingsPanelProps) {
  const [darkMode, setDarkMode] = React.useState(false);
  const [internetAccess, setInternetAccess] = React.useState(true);
  const [messageHistory, setMessageHistory] = React.useState(true);
  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-medium">Settings</h3>
        <Button
          size="icon"
          variant="ghost"
          onClick={onClose}
          className="h-6 w-6 text-muted-foreground hover:text-foreground"
        >
          <X className="w-3 h-3" />
        </Button>
      </div>
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            {darkMode ? (
              <Moon className="w-3 h-3 text-muted-foreground" />
            ) : (
              <Sun className="w-3 h-3 text-muted-foreground" />
            )}
            <Label htmlFor="dark-mode" className="text-xs">Dark Mode</Label>
          </div>
          <Switch
            id="dark-mode"
            checked={darkMode}
            onCheckedChange={setDarkMode}
          />
        </div>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Globe className="w-3 h-3 text-muted-foreground" />
            <Label htmlFor="internet-access" className="text-xs">Internet Access</Label>
          </div>
          <Switch
            id="internet-access"
            checked={internetAccess}
            onCheckedChange={setInternetAccess}
          />
        </div>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <MessageSquare className="w-3 h-3 text-muted-foreground" />
            <Label htmlFor="message-history" className="text-xs">Message History</Label>
          </div>
          <Switch
            id="message-history"
            checked={messageHistory}
            onCheckedChange={setMessageHistory}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/StatusBar.tsx">
import React, { useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useOllama } from '../hooks/useOllama';
import { useModelStatus } from '../hooks/useModelStatus';
import { Plug, Unplug, ChevronDown, AlertCircle, CheckCircle2, Loader2, BatteryFull, BatteryMedium, BatteryLow, Activity, Cpu, HardDrive, Timer } from 'lucide-react';
import { ServiceName, ServiceState, ServiceStatus } from '@shared/types/services';
interface Metrics {
  fps: number;
  memory: number;
  cpuPressure: number;
  renderTime: number;
  ollamaLatency: number;
  vectorIndexingTime: number;
}
export const StatusBar: React.FC = () => {
  const {
    isConnected,
    currentModel,
    availableModels,
    isLoading,
    error,
    setModel,
    checkHealth,
    healthScore = 100 // Default to 100 if not provided
  } = useOllama();
  const {
    isLoading: isModelLoading,
    modelName: loadingModelName,
    progress,
    estimatedTimeRemaining,
    error: modelError
  } = useModelStatus();
  const [isModelMenuOpen, setIsModelMenuOpen] = useState(false);
  const [lastHealthCheck, setLastHealthCheck] = useState<number>(Date.now());
  const handleModelSelect = useCallback(async (modelName: string) => {
    await setModel(modelName);
    setIsModelMenuOpen(false);
  }, [setModel]);
  const handleHealthCheck = useCallback(async () => {
    await checkHealth();
    setLastHealthCheck(Date.now());
  }, [checkHealth]);
  const getStatusIcon = () => {
    if (isModelLoading) return <Loader2 className="w-4 h-4 animate-spin text-blue-500" />;
    if (isLoading) return <Loader2 className="w-4 h-4 animate-spin text-blue-500" />;
    if (error || modelError) return <AlertCircle className="w-4 h-4 text-red-500" />;
    return isConnected ? <Plug className="w-4 h-4 text-green-500" /> : <Unplug className="w-4 h-4 text-gray-500" />;
  };
  const getBatteryIcon = () => {
    if (healthScore > 66) return (
      <div title="Healthy">
        <BatteryFull className="w-4 h-4 text-green-500" />
      </div>
    );
    if (healthScore > 33) return (
      <div title="Moderate health">
        <BatteryMedium className="w-4 h-4 text-yellow-500" />
      </div>
    );
    return (
      <div title="Low health - reduce input size or restart model">
        <BatteryLow className="w-4 h-4 text-red-500" />
      </div>
    );
  };
  // In a real implementation, these would be actual metrics
  const metrics: Metrics = {
    fps: 60,
    memory: 256,
    cpuPressure: 45,
    renderTime: 16,
    ollamaLatency: 120,
    vectorIndexingTime: 50
  };
  return (
    <div className="rounded-lg bg-white/5 border border-white/10 backdrop-blur-sm">
      <div className="p-4 space-y-3">
        <div className="flex items-center justify-between text-sm">
          <div className="flex items-center gap-2 text-white/80">
            <Activity className="w-3 h-3 text-green-400" />
            <span>FPS: {metrics.fps}</span>
          </div>
          <div className="flex items-center gap-2 text-white/80">
            <HardDrive className="w-3 h-3 text-blue-400" />
            <span>Memory: {metrics.memory}MB</span>
          </div>
        </div>
        <div className="flex items-center justify-between text-sm">
          <div className="flex items-center gap-2 text-white/80">
            <Cpu className="w-3 h-3 text-yellow-400" />
            <span>CPU: {metrics.cpuPressure}%</span>
          </div>
          <div className="flex items-center gap-2 text-white/80">
            <Timer className="w-3 h-3 text-purple-400" />
            <span>Render: {metrics.renderTime}ms</span>
          </div>
        </div>
        <div className="pt-2 border-t border-white/10">
          <div className="flex items-center justify-between text-sm">
            <div className="flex items-center gap-2 text-white/80">
              <Timer className="w-3 h-3 text-indigo-400" />
              <span>Ollama: {metrics.ollamaLatency}ms</span>
            </div>
            <div className="flex items-center gap-2 text-white/80">
              <Timer className="w-3 h-3 text-pink-400" />
              <span>Vector: {metrics.vectorIndexingTime}ms</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/StatusIndicator.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { ServiceName, ServiceStatus } from '../types/services';
interface StatusIndicatorProps {
  serviceName: ServiceName;
  status: ServiceStatus;
  lastCheck?: number;
  error?: string;
  onClick?: () => void;
}
const getStatusColor = (status: ServiceStatus): string => {
  switch (status) {
    case 'operational':
      return 'bg-green-500';
    case 'degraded':
      return 'bg-yellow-500';
    case 'unavailable':
      return 'bg-red-500';
    default:
      return 'bg-gray-500';
  }
};
const getStatusTooltip = (status: ServiceStatus, error?: string): string => {
  switch (status) {
    case 'operational':
      return 'Service is operational';
    case 'degraded':
      return 'Service is degraded';
    case 'unavailable':
      return error || 'Service is unavailable';
    default:
      return 'Unknown status';
  }
};
export const StatusIndicator: React.FC<StatusIndicatorProps> = ({
  serviceName,
  status,
  lastCheck,
  error,
  onClick,
}) => {
  const [showTooltip, setShowTooltip] = React.useState(false);
  return (
    <div className="relative inline-block">
      <motion.div
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.95 }}
        className={`w-3 h-3 rounded-full ${getStatusColor(status)} cursor-pointer`}
        onClick={onClick}
        onMouseEnter={() => setShowTooltip(true)}
        onMouseLeave={() => setShowTooltip(false)}
      />
      {showTooltip && (
        <motion.div
          initial={{ opacity: 0, y: 5 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 5 }}
          className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 text-white text-sm rounded-lg shadow-lg whitespace-nowrap z-50"
        >
          <div className="font-semibold capitalize mb-1">{serviceName}</div>
          <div>{getStatusTooltip(status, error)}</div>
          {lastCheck && (
            <div className="text-xs opacity-75 mt-1">
              Last check: {new Date(lastCheck).toLocaleTimeString()}
            </div>
          )}
        </motion.div>
      )}
    </div>
  );
};
</file>

<file path="renderer/src/components/SystemRequirementsChecker.tsx">
import React, { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
interface Requirement {
  name: string;
  check: () => Promise<boolean>;
  errorMessage: string;
}
interface CheckResult {
  name: string;
  passed: boolean;
  error?: string;
}
export const SystemRequirementsChecker: React.FC = () => {
  const [results, setResults] = useState<CheckResult[]>([]);
  const [isChecking, setIsChecking] = useState(true);
  const requirements: Requirement[] = [
    {
      name: 'Node.js Version',
      check: async () => {
        const version = process.versions.node;
        const [major] = version.split('.');
        return parseInt(major) >= 16;
      },
      errorMessage: 'Node.js v16 or higher is required',
    },
    {
      name: 'Ollama Service',
      check: async () => {
        try {
          const response = await fetch('http://localhost:11434/api/tags');
          return response.ok;
        } catch {
          return false;
        }
      },
      errorMessage: 'Ollama service is not running',
    },
    {
      name: 'System Memory',
      check: async () => {
        // In a real app, you'd want to use a proper system info library
        // For now, we'll assume the requirement is met
        return true;
      },
      errorMessage: 'At least 4GB of RAM is required',
    },
    {
      name: 'Disk Space',
      check: async () => {
        // This is a simplified check. In a real app, you'd want to use a proper system info library
        return true; // Assume true for now
      },
      errorMessage: 'At least 1GB of free disk space is required',
    },
  ];
  useEffect(() => {
    const checkRequirements = async () => {
      const checkResults: CheckResult[] = [];
      for (const requirement of requirements) {
        try {
          const passed = await requirement.check();
          checkResults.push({
            name: requirement.name,
            passed,
            error: passed ? undefined : requirement.errorMessage,
          });
        } catch (error) {
          checkResults.push({
            name: requirement.name,
            passed: false,
            error: error instanceof Error ? error.message : 'Check failed',
          });
        }
      }
      setResults(checkResults);
      setIsChecking(false);
    };
    checkRequirements();
  }, []);
  if (isChecking) {
    return (
      <div className="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4" />
          <p className="text-lg font-medium">Checking system requirements...</p>
        </div>
      </div>
    );
  }
  const allPassed = results.every(result => result.passed);
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center"
    >
      <div className="bg-white rounded-lg shadow-xl p-8 max-w-lg w-full">
        <h2 className="text-2xl font-bold mb-6">System Requirements Check</h2>
        <div className="space-y-4 mb-6">
          {results.map((result, index) => (
            <motion.div
              key={result.name}
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: index * 0.1 }}
              className="flex items-center space-x-3"
            >
              <div
                className={`w-6 h-6 rounded-full flex items-center justify-center ${
                  result.passed ? 'bg-green-500' : 'bg-red-500'
                }`}
              >
                {result.passed ? '' : ''}
              </div>
              <div>
                <p className="font-medium">{result.name}</p>
                {result.error && (
                  <p className="text-sm text-red-500">{result.error}</p>
                )}
              </div>
            </motion.div>
          ))}
        </div>
        {allPassed ? (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="text-center"
          >
            <p className="text-green-500 font-medium mb-4">
              All requirements met! You're good to go.
            </p>
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
            >
              Continue
            </button>
          </motion.div>
        ) : (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="text-center"
          >
            <p className="text-red-500 font-medium mb-4">
              Some requirements are not met. Please fix the issues above.
            </p>
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
            >
              Retry
            </button>
          </motion.div>
        )}
      </div>
    </motion.div>
  );
};
</file>

<file path="renderer/src/components/SystemStatus.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { ServiceName, ServiceState } from '../types/services';
import { StatusIndicator } from './StatusIndicator';
interface SystemStatusProps {
  serviceStatuses: Map<ServiceName, ServiceState>;
  onRetry: (serviceName: ServiceName) => void;
}
const serviceLabels: Record<ServiceName, string> = {
  ollama: 'Ollama Service',
  embedding: 'Embedding Service',
  vectorStore: 'Vector Store',
  memory: 'Memory Service',
};
export const SystemStatus: React.FC<SystemStatusProps> = ({ serviceStatuses, onRetry }) => {
  return (
    <div className="bg-white rounded-lg shadow-lg p-6">
      <h2 className="text-2xl font-bold mb-6">System Status</h2>
      <div className="space-y-4">
        {Array.from(serviceStatuses.entries()).map(([serviceName, state]) => (
          <motion.div
            key={serviceName}
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            className="flex items-center justify-between p-4 bg-gray-50 rounded-lg"
          >
            <StatusIndicator
              serviceName={serviceLabels[serviceName]}
              status={state.status}
              error={state.error}
            />
            {state.status !== 'operational' && (
              <button
                onClick={() => onRetry(serviceName)}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
              >
                Retry
              </button>
            )}
          </motion.div>
        ))}
      </div>
      <div className="mt-8">
        <h3 className="text-lg font-semibold mb-4">System Requirements</h3>
        <ul className="space-y-2">
          <li className="flex items-center">
            <span className="w-2 h-2 bg-green-500 rounded-full mr-2" />
            <span>Node.js v16 or higher</span>
          </li>
          <li className="flex items-center">
            <span className="w-2 h-2 bg-green-500 rounded-full mr-2" />
            <span>Ollama v0.1.0 or higher</span>
          </li>
          <li className="flex items-center">
            <span className="w-2 h-2 bg-green-500 rounded-full mr-2" />
            <span>4GB RAM minimum</span>
          </li>
          <li className="flex items-center">
            <span className="w-2 h-2 bg-green-500 rounded-full mr-2" />
            <span>1GB free disk space</span>
          </li>
        </ul>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/components/ThemeToggle.tsx">
import React from 'react';
import { useTheme } from '../contexts/ThemeContext';
import { Moon, Sun, Monitor } from 'lucide-react';
interface ThemeToggleProps {
  className?: string;
}
export const ThemeToggle: React.FC<ThemeToggleProps> = ({ className = '' }) => {
  const { theme, toggleTheme, setTheme, isDarkMode } = useTheme();
  return (
    <div className={`flex items-center gap-2 ${className}`}>
      <button
        onClick={() => setTheme('light')}
        className={`p-2 rounded-md transition-colors ${
          theme === 'light'
            ? 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300'
            : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
        }`}
        title="Light Mode"
        aria-label="Light Mode"
      >
        <Sun className="w-5 h-5" />
      </button>
      <button
        onClick={() => setTheme('dark')}
        className={`p-2 rounded-md transition-colors ${
          theme === 'dark'
            ? 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300'
            : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
        }`}
        title="Dark Mode"
        aria-label="Dark Mode"
      >
        <Moon className="w-5 h-5" />
      </button>
      <button
        onClick={() => setTheme('system')}
        className={`p-2 rounded-md transition-colors ${
          theme === 'system'
            ? 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300'
            : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'
        }`}
        title="System Theme"
        aria-label="System Theme"
      >
        <Monitor className="w-5 h-5" />
      </button>
      <div className="ml-2 text-sm text-gray-600 dark:text-gray-300">
        {theme === 'system' ? (isDarkMode ? 'System (Dark)' : 'System (Light)') : theme}
      </div>
    </div>
  );
};
export default ThemeToggle;
</file>

<file path="renderer/src/components/Toast.tsx">
import React from 'react';
import { motion } from 'framer-motion';
import { ServiceName, ServiceStatus } from '../types/services';
interface ToastProps {
  id: string;
  serviceName: ServiceName;
  status: ServiceStatus;
  message: string;
  onRemove: (id: string) => void;
}
const getStatusColor = (status: ServiceStatus): string => {
  switch (status) {
    case 'operational':
      return 'bg-green-500';
    case 'degraded':
      return 'bg-yellow-500';
    case 'unavailable':
      return 'bg-red-500';
    default:
      return 'bg-gray-500';
  }
};
const getStatusIcon = (status: ServiceStatus): string => {
  switch (status) {
    case 'operational':
      return '';
    case 'degraded':
      return '';
    case 'unavailable':
      return '';
    default:
      return '';
  }
};
export const Toast: React.FC<ToastProps> = ({
  id,
  serviceName,
  status,
  message,
  onRemove,
}) => {
  return (
    <motion.div
      initial={{ opacity: 0, y: 50, scale: 0.3 }}
      animate={{ opacity: 1, y: 0, scale: 1 }}
      exit={{ opacity: 0, scale: 0.5, transition: { duration: 0.2 } }}
      className={`flex items-center p-4 mb-4 rounded-lg shadow-lg ${getStatusColor(status)} text-white`}
    >
      <div className="flex-shrink-0 mr-3">
        <span className="text-xl">{getStatusIcon(status)}</span>
      </div>
      <div className="flex-grow">
        <h3 className="font-semibold capitalize">{serviceName}</h3>
        <p className="text-sm opacity-90">{message}</p>
      </div>
      <button
        onClick={() => onRemove(id)}
        className="ml-4 text-white hover:text-gray-200 focus:outline-none"
      >
        
      </button>
    </motion.div>
  );
};
</file>

<file path="renderer/src/components/ToastContainer.tsx">
import React, { useState, useEffect } from 'react';
import { X } from 'lucide-react';
export type ToastType = 'success' | 'error' | 'warning' | 'info';
export interface Toast {
  id: string;
  message: string;
  type: ToastType;
  duration?: number;
}
interface ToastContainerProps {
  toasts: Toast[];
  onRemove: (id: string) => void;
}
export const ToastContainer: React.FC<ToastContainerProps> = ({ toasts, onRemove }) => {
  return (
    <div className="fixed top-4 right-4 z-50 space-y-2">
      {toasts.map((toast) => (
        <div
          key={toast.id}
          className={`flex items-center p-4 rounded-lg shadow-lg backdrop-blur-sm border border-white/10
            ${
              toast.type === 'success'
                ? 'bg-green-500/20 text-green-100'
                : toast.type === 'error'
                ? 'bg-red-500/20 text-red-100'
                : toast.type === 'warning'
                ? 'bg-yellow-500/20 text-yellow-100'
                : 'bg-blue-500/20 text-blue-100'
            }
            animate-in slide-in-from-right duration-200`}
        >
          <div className="flex-grow">
            <p className="font-medium">{toast.message}</p>
          </div>
          <button
            onClick={() => onRemove(toast.id)}
            className="ml-4 p-1 rounded-full hover:bg-white/10 transition-colors"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      ))}
    </div>
  );
};
</file>

<file path="renderer/src/components/TrainingPanel.tsx">
import React from 'react';
import { Brain, Upload, Database, Settings } from 'lucide-react';
interface TrainingOptionProps {
  icon: React.ReactNode;
  title: string;
  description: string;
  onClick?: () => void;
}
function TrainingOption({ icon, title, description, onClick }: TrainingOptionProps) {
  return (
    <button
      onClick={onClick}
      className="w-full p-4 rounded-lg border border-white/10 bg-white/5 
        hover:bg-white/10 transition-all duration-200 text-left group"
    >
      <div className="flex items-start gap-3">
        <div className="p-2 rounded-md bg-white/10 group-hover:bg-white/20 transition-colors">
          {icon}
        </div>
        <div>
          <h3 className="font-medium text-white/90">{title}</h3>
          <p className="text-sm text-white/60 mt-1">{description}</p>
        </div>
      </div>
    </button>
  );
}
export function TrainingPanel() {
  return (
    <div className="p-6 text-white space-y-6 rounded-lg border border-white/10 
      bg-gradient-to-b from-slate-800/50 to-slate-950/70 shadow-lg">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-bold flex items-center gap-2">
          <Brain className="w-5 h-5" />
          Training Mode
        </h2>
        <button className="p-2 rounded-md hover:bg-white/10 transition-colors">
          <Settings className="w-4 h-4 text-white/60" />
        </button>
      </div>
      <div className="grid gap-4">
        <TrainingOption
          icon={<Database className="w-5 h-5 text-blue-400" />}
          title="Train on Memory"
          description="Fine-tune models using your conversation history and memory nodes"
        />
        <TrainingOption
          icon={<Upload className="w-5 h-5 text-purple-400" />}
          title="Upload Training Data"
          description="Import custom datasets for specialized training"
        />
      </div>
      <div className="mt-6 p-4 rounded-lg bg-white/5 border border-white/10">
        <h3 className="text-sm font-medium text-white/80 mb-2">Training Logs</h3>
        <div className="text-xs text-white/60 space-y-1">
          <p> No active training sessions</p>
          <p> Last checkpoint: None</p>
          <p> Available models: 3</p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="renderer/src/components/VectorManager.tsx">
import React, { useEffect, useState } from 'react';
import { useVectorStore } from '../state/vectorStore';
export const VectorManager = () => {
  const { vectors, stats, search, add, delete: remove, loadStats } = useVectorStore();
  const [query, setQuery] = useState('');
  const [newDoc, setNewDoc] = useState('');
  useEffect(() => {
    search('');
    loadStats();
  }, []);
  return (
    <div className="p-4 space-y-4">
      <h2 className="text-xl font-bold">Vector Memory</h2>
      <div className="flex items-center gap-2">
        <input
          className="input"
          placeholder="Search"
          value={query}
          onChange={e => setQuery(e.target.value)}
        />
        <button className="btn" onClick={() => search(query)}>Search</button>
      </div>
      <div className="flex items-center gap-2">
        <input
          className="input"
          placeholder="Add new memory"
          value={newDoc}
          onChange={e => setNewDoc(e.target.value)}
        />
        <button 
          className="btn" 
          onClick={() => {
            if (newDoc.trim()) {
              add({ id: Date.now().toString(), content: newDoc });
              setNewDoc('');
            }
          }}
        >
          Add
        </button>
      </div>
      <div className="text-sm text-gray-500">
        Stats: {stats.count} vectors / {stats.dimensions} dims
      </div>
      <ul className="space-y-2">
        {vectors.map(v => (
          <li key={v.id} className="border p-2 rounded flex justify-between">
            <span>{v.content}</span>
            <button 
              className="btn-sm text-red-500" 
              onClick={() => remove(v.id)}
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};
</file>

<file path="renderer/src/contexts/ThemeContext.tsx">
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
type Theme = 'light' | 'dark' | 'system';
interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
  setTheme: (theme: Theme) => void;
  isDarkMode: boolean;
}
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
interface ThemeProviderProps {
  children: ReactNode;
}
export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  // Get initial theme from localStorage or system preference
  const [theme, setThemeState] = useState<Theme>(() => {
    const savedTheme = localStorage.getItem('theme') as Theme;
    if (savedTheme) return savedTheme;
    // Fall back to system preference
    return 'system';
  });
  // Track whether dark mode is active (regardless of source)
  const [isDarkMode, setIsDarkMode] = useState<boolean>(() => {
    if (theme === 'dark') return true;
    if (theme === 'light') return false;
    return window.matchMedia('(prefers-color-scheme: dark)').matches;
  });
  // Initialize theme based on system preference
  useEffect(() => {
    const initializeTheme = async () => {
      try {
        // Initial setup
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        // Apply theme to document
        document.documentElement.classList.toggle('dark', isDarkMode);
        // Sync with Electron's native theme
        if (window.electronAPI) {
          await window.electronAPI.setTheme(theme);
        }
      } catch (error) {
        console.error('Failed to initialize theme:', error);
      }
    };
    initializeTheme();
  }, []);
  // Listen for system theme changes
  useEffect(() => {
    const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const handleSystemThemeChange = (e: MediaQueryListEvent) => {
      if (theme === 'system') {
        setIsDarkMode(e.matches);
        document.documentElement.classList.toggle('dark', e.matches);
        // Sync with Electron if available
        if (window.electronAPI) {
          window.electronAPI.setTheme('system');
        }
      }
    };
    // Modern API (addEventListener)
    darkModeQuery.addEventListener('change', handleSystemThemeChange);
    // Cleanup
    return () => darkModeQuery.removeEventListener('change', handleSystemThemeChange);
  }, [theme]);
  // Listen for theme updates from Electron
  useEffect(() => {
    if (!window.electronAPI?.onThemeUpdated) return;
    const unsubscribe = window.electronAPI.onThemeUpdated((themeData) => {
      if (theme === 'system') {
        setIsDarkMode(themeData.shouldUseDarkColors);
        document.documentElement.classList.toggle('dark', themeData.shouldUseDarkColors);
      }
    });
    return unsubscribe;
  }, [theme]);
  // Update theme effects
  useEffect(() => {
    // Save to localStorage
    localStorage.setItem('theme', theme);
    // Update dark mode state based on theme selection
    if (theme === 'dark') {
      setIsDarkMode(true);
      document.documentElement.classList.add('dark');
    } else if (theme === 'light') {
      setIsDarkMode(false);
      document.documentElement.classList.remove('dark');
    } else {
      // For 'system', use the system preference
      const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setIsDarkMode(systemPrefersDark);
      document.documentElement.classList.toggle('dark', systemPrefersDark);
    }
    // Update meta theme-color for mobile browsers
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
      metaThemeColor.setAttribute('content', isDarkMode ? '#1f2937' : '#ffffff');
    }
    // Sync with Electron if available
    if (window.electronAPI) {
      window.electronAPI.setTheme(theme);
    }
  }, [theme, isDarkMode]);
  const setTheme = (newTheme: Theme) => {
    setThemeState(newTheme);
  };
  const toggleTheme = () => {
    setThemeState(prevTheme => {
      if (prevTheme === 'light') return 'dark';
      if (prevTheme === 'dark') return 'system';
      return 'light';
    });
  };
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme, setTheme, isDarkMode }}>
      {children}
    </ThemeContext.Provider>
  );
};
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
</file>

<file path="renderer/src/hooks/useCanvasMode.ts">
import { useState, useCallback } from 'react';
export const useCanvasMode = () => {
  const [isCanvasMode, setIsCanvasMode] = useState(false);
  const toggleCanvasMode = useCallback(() => {
    setIsCanvasMode(prev => !prev);
  }, []);
  return {
    isCanvasMode,
    toggleCanvasMode
  };
};
</file>

<file path="renderer/src/hooks/useChat.ts">
import { useCallback } from 'react';
import type { ChatMessage, ChatResponse } from '@shared/types/ipc';
export function useChat() {
  const sendMessage = useCallback(async (message: ChatMessage): Promise<ChatResponse> => {
    return window.electronAPI.chat.sendMessage(message);
  }, []);
  const sendMessageStream = useCallback(async (message: ChatMessage): Promise<void> => {
    await window.electronAPI.chat.sendMessageStream(message);
  }, []);
  return {
    sendMessage,
    sendMessageStream,
  };
}
</file>

<file path="renderer/src/hooks/useConversation.ts">
import { useState, useCallback } from 'react';
import type { Conversation, ChatMessage } from '@shared/types/ipc';
import { useMemory } from './useMemory';
export function useConversation() {
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { storeMemory } = useMemory();
  const loadConversations = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const conversations = await window.electronAPI.conversation.list();
      if (conversations.length > 0) {
        setCurrentConversation(conversations[0]);
      }
      return conversations;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load conversations');
      return [];
    } finally {
      setIsLoading(false);
    }
  }, []);
  const createConversation = useCallback(async (title: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const newConversation = await window.electronAPI.conversation.create(title);
      setCurrentConversation(newConversation);
      return newConversation;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create conversation');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);
  const handleConversationSelect = useCallback(async (id: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const conversation = await window.electronAPI.conversation.get(id);
      setCurrentConversation(conversation);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load conversation');
    } finally {
      setIsLoading(false);
    }
  }, []);
  const sendMessage = useCallback(async (message: ChatMessage) => {
    if (!currentConversation) return null;
    setIsLoading(true);
    setError(null);
    try {
      const response = await window.electronAPI.chat.sendMessage(message);
      const updatedConversation = await window.electronAPI.conversation.get(currentConversation.id);
      setCurrentConversation(updatedConversation);
      // Store user message as memory
      await storeMemory(message.content, {
        type: 'chat_message',
        source: 'user',
        timestamp: Date.now(),
        conversationId: currentConversation.id,
        conversationTitle: currentConversation.title
      });
      // Store assistant response as memory if available
      if (response.message) {
        await storeMemory(response.message.content, {
          type: 'chat_message',
          source: 'assistant',
          timestamp: Date.now(),
          conversationId: currentConversation.id,
          conversationTitle: currentConversation.title
        });
      }
      return response;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to send message');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [currentConversation, storeMemory]);
  return {
    currentConversation,
    isLoading,
    error,
    loadConversations,
    createConversation,
    handleConversationSelect,
    sendMessage,
  };
}
</file>

<file path="renderer/src/hooks/useConversations.ts">
import { useState, useEffect } from 'react';
import type { Conversation, ChatMessage, ChatResponse } from '../types/ipc';
export function useConversations() {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [currentConversation, setCurrentConversation] = useState<Conversation | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const loadConversations = async () => {
    try {
      setIsLoading(true);
      const loadedConversations = await window.electron.ipc.invoke('conversation:list', undefined);
      setConversations(loadedConversations);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load conversations');
    } finally {
      setIsLoading(false);
    }
  };
  const loadConversation = async (id: string) => {
    try {
      setIsLoading(true);
      const conversation = await window.electron.ipc.invoke('conversation:get', { id });
      setCurrentConversation(conversation);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load conversation');
    } finally {
      setIsLoading(false);
    }
  };
  const createConversation = async (title: string) => {
    try {
      setIsLoading(true);
      const conversation = await window.electron.ipc.invoke('conversation:create', { title });
      setConversations(prev => [...prev, conversation]);
      setCurrentConversation(conversation);
      setError(null);
      return conversation;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create conversation');
      throw err;
    } finally {
      setIsLoading(false);
    }
  };
  const deleteConversation = async (id: string) => {
    try {
      setIsLoading(true);
      await window.electron.ipc.invoke('conversation:delete', { id });
      setConversations(prev => prev.filter(conv => conv.id !== id));
      if (currentConversation?.id === id) {
        setCurrentConversation(null);
      }
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete conversation');
    } finally {
      setIsLoading(false);
    }
  };
  const updateConversationTitle = async (id: string, title: string) => {
    try {
      setIsLoading(true);
      const updated = await window.electron.ipc.invoke('conversation:update', { id, title });
      setConversations(prev => prev.map(conv => conv.id === id ? updated : conv));
      if (currentConversation?.id === id) {
        setCurrentConversation(updated);
      }
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update conversation title');
    } finally {
      setIsLoading(false);
    }
  };
  const sendMessage = async (message: ChatMessage) => {
    if (!currentConversation) {
      throw new Error('No active conversation');
    }
    try {
      setIsLoading(true);
      const response = await window.electron.ipc.invoke('chat:send-message', message);
      const updatedConversation = {
        ...currentConversation,
        messages: [...currentConversation.messages, message, response.message]
      };
      setCurrentConversation(updatedConversation);
      setConversations(prev => prev.map(conv => 
        conv.id === currentConversation.id ? updatedConversation : conv
      ));
      setError(null);
      return response;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to send message');
      throw err;
    } finally {
      setIsLoading(false);
    }
  };
  useEffect(() => {
    loadConversations();
    const unsubscribe = window.electron.ipc.on('conversation:updated', (conversation: Conversation) => {
      setConversations(prev => prev.map(conv => conv.id === conversation.id ? conversation : conv));
      if (currentConversation?.id === conversation.id) {
        setCurrentConversation(conversation);
      }
    });
    return () => {
      unsubscribe();
    };
  }, [currentConversation?.id]);
  return {
    conversations,
    currentConversation,
    isLoading,
    error,
    loadConversations,
    loadConversation,
    createConversation,
    deleteConversation,
    updateConversationTitle,
    sendMessage
  };
}
</file>

<file path="renderer/src/hooks/useEmbedding.ts">
import { useState, useEffect } from 'react';
import type { EmbeddingConfig } from '../types/embedding';
export function useEmbedding() {
  const [config, setConfig] = useState<EmbeddingConfig | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const loadConfig = async () => {
    try {
      setIsLoading(true);
      const loadedConfig = await window.electron.ipc.invoke('embedding:get-config', undefined);
      setConfig(loadedConfig);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load embedding config');
    } finally {
      setIsLoading(false);
    }
  };
  const updateConfig = async (newConfig: Partial<EmbeddingConfig>) => {
    try {
      setIsLoading(true);
      const updatedConfig = await window.electron.ipc.invoke('embedding:update-config', newConfig);
      setConfig(updatedConfig);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update embedding config');
    } finally {
      setIsLoading(false);
    }
  };
  useEffect(() => {
    loadConfig();
    const unsubscribe = window.electron.ipc.on('embedding:config-updated', (updatedConfig: EmbeddingConfig) => {
      setConfig(updatedConfig);
    });
    return () => {
      unsubscribe();
    };
  }, []);
  return {
    config,
    isLoading,
    error,
    loadConfig,
    updateConfig
  };
}
</file>

<file path="renderer/src/hooks/useEnvironmentMode.ts">
import { create } from 'zustand';
type Mode = 'local' | 'cloud';
interface EnvironmentModeState {
  mode: Mode;
  setMode: (mode: Mode) => void;
}
export const useEnvironmentMode = create<EnvironmentModeState>((set) => ({
  mode: 'local',
  setMode: (mode) => set({ mode }),
}));
</file>

<file path="renderer/src/hooks/useGemini.ts">
import { useState, useEffect, useRef, useCallback } from 'react';
import { GeminiService, GeminiResponse, GeminiError, GeminiErrorType } from '../services/GeminiService';
import { useSettingsStore } from '../stores/settingsStore';
import debounce from 'lodash.debounce';
/**
 * Hook for interacting with the Google Gemini API
 */
export function useGemini() {
  // State
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [errorType, setErrorType] = useState<GeminiErrorType | null>(null);
  // Refs
  const abortControllerRef = useRef<AbortController | null>(null);
  const requestCountRef = useRef(0);
  // Services
  const geminiService = GeminiService.getInstance();
  const { apiKeys, features } = useSettingsStore();
  // Derived state
  const isConfigured = !!apiKeys.googleGemini;
  const isWebSurfingEnabled = isConfigured && features.webSurfing;
  // Clean up on unmount
  useEffect(() => {
    return () => {
      // Cancel any in-flight requests when component unmounts
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);
  /**
   * Handles errors from the Gemini API
   */
  const handleGeminiError = (error: unknown): string => {
    if (error instanceof GeminiError) {
      setErrorType(error.type);
      return error.message;
    } else if (error instanceof Error) {
      setErrorType(GeminiErrorType.UNKNOWN_ERROR);
      return error.message;
    } else {
      setErrorType(GeminiErrorType.UNKNOWN_ERROR);
      return 'Unknown error occurred';
    }
  };
  /**
   * Generates a response from the Gemini API
   */
  const generateResponse = useCallback(async (
    prompt: string,
    options?: {
      temperature?: number;
      topK?: number;
      topP?: number;
      maxOutputTokens?: number;
      useCache?: boolean;
    }
  ): Promise<GeminiResponse | null> => {
    if (!isConfigured) {
      const errorMessage = 'Google Gemini API key is not set. Please add it in the settings.';
      setError(errorMessage);
      setErrorType(GeminiErrorType.MISSING_API_KEY);
      return null;
    }
    // Cancel any previous requests
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    // Create a new abort controller
    abortControllerRef.current = new AbortController();
    // Track request count to handle race conditions
    const requestId = ++requestCountRef.current;
    setIsLoading(true);
    setError(null);
    setErrorType(null);
    try {
      const response = await geminiService.generateResponse(prompt, options);
      // Only update state if this is the most recent request
      if (requestId === requestCountRef.current) {
        setIsLoading(false);
      }
      return response;
    } catch (err) {
      // Only update state if this is the most recent request
      if (requestId === requestCountRef.current) {
        const errorMessage = handleGeminiError(err);
        setError(errorMessage);
        setIsLoading(false);
      }
      return null;
    }
  }, [isConfigured, geminiService]);
  /**
   * Debounced version of generateResponse to prevent rapid API calls
   */
  const debouncedGenerateResponse = useCallback(
    debounce(generateResponse, 300),
    [generateResponse]
  );
  /**
   * Uses Gemini to browse the web for information
   */
  const browseWeb = useCallback(async (query: string): Promise<GeminiResponse | null> => {
    if (!isConfigured) {
      const errorMessage = 'Google Gemini API key is not set. Please add it in the settings.';
      setError(errorMessage);
      setErrorType(GeminiErrorType.MISSING_API_KEY);
      return null;
    }
    if (!isWebSurfingEnabled) {
      const errorMessage = 'Web surfing feature is disabled. Please enable it in the settings.';
      setError(errorMessage);
      setErrorType(GeminiErrorType.FEATURE_DISABLED);
      return null;
    }
    // Cancel any previous requests
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    // Create a new abort controller
    abortControllerRef.current = new AbortController();
    // Track request count to handle race conditions
    const requestId = ++requestCountRef.current;
    setIsLoading(true);
    setError(null);
    setErrorType(null);
    try {
      const response = await geminiService.browseWeb(query);
      // Only update state if this is the most recent request
      if (requestId === requestCountRef.current) {
        setIsLoading(false);
      }
      return response;
    } catch (err) {
      // Only update state if this is the most recent request
      if (requestId === requestCountRef.current) {
        const errorMessage = handleGeminiError(err);
        setError(errorMessage);
        setIsLoading(false);
      }
      return null;
    }
  }, [isConfigured, isWebSurfingEnabled, geminiService]);
  /**
   * Debounced version of browseWeb to prevent rapid API calls
   */
  const debouncedBrowseWeb = useCallback(
    debounce(browseWeb, 500),
    [browseWeb]
  );
  /**
   * Cancels any in-flight requests
   */
  const cancelRequest = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
      setIsLoading(false);
    }
  }, []);
  /**
   * Tests if an API key is valid
   */
  const testApiKey = useCallback(async (apiKey: string): Promise<boolean> => {
    try {
      setIsLoading(true);
      setError(null);
      setErrorType(null);
      const isValid = await geminiService.testApiKey(apiKey);
      setIsLoading(false);
      return isValid;
    } catch (err) {
      const errorMessage = handleGeminiError(err);
      setError(errorMessage);
      setIsLoading(false);
      return false;
    }
  }, [geminiService]);
  /**
   * Clears the response cache
   */
  const clearCache = useCallback(() => {
    geminiService.clearCache();
  }, [geminiService]);
  return {
    // Core methods
    generateResponse,
    debouncedGenerateResponse,
    browseWeb,
    debouncedBrowseWeb,
    cancelRequest,
    testApiKey,
    clearCache,
    // State
    isLoading,
    error,
    errorType,
    // Derived state
    isConfigured,
    isWebSurfingEnabled
  };
}
</file>

<file path="renderer/src/hooks/useMemory.ts">
import { useState, useEffect, useCallback } from 'react';
import toast from 'react-hot-toast';
interface MemoryChunk {
  id: string;
  content: string;
  metadata: {
    timestamp: number;
    type: string;
    source: string;
    tags?: string[];
    [key: string]: any;
  };
}
interface MemoryAPI {
  initialize: () => Promise<{ success: boolean; error?: string }>;
  store: (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>) => Promise<{ success: boolean; id?: string; error?: string }>;
  search: (query: string, options?: { limit?: number }) => Promise<{ success: boolean; results?: MemoryChunk[]; error?: string }>;
  getRecent: (limit?: number) => Promise<{ success: boolean; results?: MemoryChunk[]; error?: string }>;
  delete: (id: string) => Promise<{ success: boolean; error?: string }>;
  clear: () => Promise<{ success: boolean; error?: string }>;
  onInitialized: (callback: () => void) => () => void;
  onStored: (callback: (memory: MemoryChunk) => void) => () => void;
  onSearched: (callback: (memories: MemoryChunk[]) => void) => () => void;
  onRecent: (callback: (memories: MemoryChunk[]) => void) => () => void;
  onDeleted: (callback: (id: string) => void) => () => void;
  onCleared: (callback: () => void) => () => void;
}
declare global {
  interface Window {
    memoryAPI: MemoryAPI;
  }
}
interface MemoryState {
  isInitialized: boolean;
  isLoading: boolean;
  error: string | null;
  memories: MemoryChunk[];
  searchMemory: (query: string, options?: { limit?: number }) => Promise<MemoryChunk[]>;
  storeMemory: (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>) => Promise<{ success: boolean; id?: string; error?: string }>;
  getRecentMemories: (limit?: number) => Promise<MemoryChunk[]>;
  deleteMemory: (id: string) => Promise<{ success: boolean; error?: string }>;
  clearMemories: () => Promise<{ success: boolean; error?: string }>;
}
export function useMemory(): MemoryState {
  const [isInitialized, setIsInitialized] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [memories, setMemories] = useState<MemoryChunk[]>([]);
  useEffect(() => {
    const initializeMemory = async () => {
      if (window.memoryAPI?.initialize) {
        try {
          const result = await window.memoryAPI.initialize();
          setIsInitialized(result.success);
          setError(result.error || null);
          if (result.success) {
            toast.success('Memory service initialized!');
          } else {
            toast.error(`Failed to initialize memory service: ${result.error}`);
          }
        } catch (err: any) {
          console.error('Error initializing memory service:', err);
          setError(err.message);
          toast.error(`Failed to initialize memory service: ${err.message}`);
        }
      } else {
        setError('Memory API not exposed in preload script.');
        toast.error('Memory API not available.');
        console.error('Memory API not exposed in preload script.');
      }
      setIsLoading(false);
    };
    initializeMemory();
  }, []);
  // Set up event listeners
  useEffect(() => {
    if (!window.memoryAPI) return;
    const cleanup = [
      window.memoryAPI.onInitialized(() => {
        setIsInitialized(true);
        setError(null);
      }),
      window.memoryAPI.onStored((memory) => {
        setMemories(prev => [memory, ...prev]);
      }),
      window.memoryAPI.onSearched((newMemories) => {
        setMemories(newMemories);
      }),
      window.memoryAPI.onRecent((newMemories) => {
        setMemories(newMemories);
      }),
      window.memoryAPI.onDeleted((id) => {
        setMemories(prev => prev.filter(m => m.id !== id));
      }),
      window.memoryAPI.onCleared(() => {
        setMemories([]);
      })
    ];
    return () => cleanup.forEach(fn => fn());
  }, []);
  const searchMemory = useCallback(async (query: string, options?: { limit?: number }): Promise<MemoryChunk[]> => {
    if (!window.memoryAPI?.search) {
      throw new Error('Memory API not available');
    }
    const result = await window.memoryAPI.search(query, options);
    if (!result.success) {
      throw new Error(result.error || 'Failed to search memories');
    }
    return result.results || [];
  }, []);
  const storeMemory = useCallback(async (content: string, metadata: Omit<MemoryChunk['metadata'], 'timestamp'>): Promise<{ success: boolean; id?: string; error?: string }> => {
    if (!window.memoryAPI?.store) {
      throw new Error('Memory API not available');
    }
    return window.memoryAPI.store(content, metadata);
  }, []);
  const getRecentMemories = useCallback(async (limit?: number): Promise<MemoryChunk[]> => {
    if (!window.memoryAPI?.getRecent) {
      throw new Error('Memory API not available');
    }
    const result = await window.memoryAPI.getRecent(limit);
    if (!result.success) {
      throw new Error(result.error || 'Failed to get recent memories');
    }
    return result.results || [];
  }, []);
  const deleteMemory = useCallback(async (id: string): Promise<{ success: boolean; error?: string }> => {
    if (!window.memoryAPI?.delete) {
      throw new Error('Memory API not available');
    }
    return window.memoryAPI.delete(id);
  }, []);
  const clearMemories = useCallback(async (): Promise<{ success: boolean; error?: string }> => {
    if (!window.memoryAPI?.clear) {
      throw new Error('Memory API not available');
    }
    return window.memoryAPI.clear();
  }, []);
  return {
    isInitialized,
    isLoading,
    error,
    memories,
    searchMemory,
    storeMemory,
    getRecentMemories,
    deleteMemory,
    clearMemories
  };
}
</file>

<file path="renderer/src/hooks/useMemoryContext.ts">
import { useState, useEffect, useCallback } from 'react';
import { useMemory } from './useMemory';
import { Conversation } from '@shared/types/ipc';
export function useMemoryContext(currentConversation: Conversation | null) {
  const { searchMemory } = useMemory();
  const [relevantMemories, setRelevantMemories] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const searchRelevantMemories = useCallback(async (query: string) => {
    if (!currentConversation) return;
    setIsLoading(true);
    try {
      // Search for memories related to the current conversation
      const conversationMemories = await searchMemory(query, {
        limit: 5
      });
      // Filter memories by relevance to the current conversation
      const relevant = conversationMemories.filter(memory => 
        memory.metadata.conversationId === currentConversation.id ||
        memory.metadata.tags?.includes('chat')
      );
      setRelevantMemories(relevant);
    } catch (err) {
      setError('Failed to search relevant memories');
      console.error('Error searching memories:', err);
    } finally {
      setIsLoading(false);
    }
  }, [currentConversation, searchMemory]);
  // Clear relevant memories when conversation changes
  useEffect(() => {
    setRelevantMemories([]);
  }, [currentConversation?.id]);
  return {
    relevantMemories,
    isLoading,
    error,
    searchRelevantMemories
  };
}
</file>

<file path="renderer/src/hooks/useModel.ts">
import { useState, useCallback } from 'react';
import type { OllamaModel } from '@shared/types/ipc';
export function useModel() {
  const [models, setModels] = useState<OllamaModel[]>([]);
  const [currentModel, setCurrentModel] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const loadModels = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await window.electronAPI.ollama.listModels();
      setModels(response);
      return response;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load models');
      return [];
    } finally {
      setIsLoading(false);
    }
  }, []);
  const setModel = useCallback(async (modelName: string) => {
    setIsLoading(true);
    setError(null);
    try {
      await window.electronAPI.ollama.setModel(modelName);
      setCurrentModel(modelName);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to set model');
    } finally {
      setIsLoading(false);
    }
  }, []);
  return {
    models,
    currentModel,
    isLoading,
    error,
    loadModels,
    setModel,
  };
}
</file>

<file path="renderer/src/hooks/useModelStatus.ts">
import { useState, useEffect } from 'react';
import type { ModelLoadingState } from '@shared/types/ipc';
export function useModelStatus() {
  const [isLoading, setIsLoading] = useState(false);
  const [modelName, setModelName] = useState<string | undefined>();
  const [progress, setProgress] = useState<number | undefined>();
  const [estimatedTimeRemaining, setEstimatedTimeRemaining] = useState<number | undefined>();
  const [error, setError] = useState<string | undefined>();
  useEffect(() => {
    const unsubscribe = window.electronAPI.ollama.onModelLoadingStateChanged((newState: ModelLoadingState) => {
      setIsLoading(newState.isLoading);
      setModelName(newState.modelName);
      setProgress(newState.progress);
      setEstimatedTimeRemaining(newState.estimatedTimeRemaining);
      setError(newState.error);
    });
    return () => {
      unsubscribe();
    };
  }, []);
  return {
    isLoading,
    modelName,
    progress,
    estimatedTimeRemaining,
    error,
  };
}
</file>

<file path="renderer/src/hooks/useOllama.ts">
import { useState, useEffect } from 'react';
import type { OllamaModel, ModelLoadingState } from '@electron-app/types/ollama';
export function useOllama() {
  const [models, setModels] = useState<OllamaModel[]>([]);
  const [currentModel, setCurrentModel] = useState<OllamaModel | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [loadingState, setLoadingState] = useState<ModelLoadingState | null>(null);
  const loadModels = async () => {
    try {
      setIsLoading(true);
      const loadedModels = await window.electron.ipc.invoke('ollama:list-models', undefined);
      setModels(loadedModels);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load models');
    } finally {
      setIsLoading(false);
    }
  };
  const setModel = async (modelName: string) => {
    try {
      setIsLoading(true);
      await window.electron.ipc.invoke('ollama:set-model', { modelName });
      const model = models.find(m => m.name === modelName);
      if (model) {
        setCurrentModel(model);
      }
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to set model');
    } finally {
      setIsLoading(false);
    }
  };
  useEffect(() => {
    loadModels();
    const unsubscribe = window.electron.ipc.on('ollama:model-loading-state', (state: ModelLoadingState) => {
      setLoadingState(state);
      if (state.status === 'loaded') {
        setIsLoading(false);
      } else if (state.status === 'loading') {
        setIsLoading(true);
      }
    });
    return () => {
      unsubscribe();
    };
  }, []);
  return {
    models,
    currentModel,
    isLoading,
    error,
    loadingState,
    loadModels,
    setModel
  };
}
</file>

<file path="renderer/src/hooks/useServiceStatus.ts">
import { useState, useEffect } from 'react';
import type { ServiceName, ServiceState, ServiceStatus } from '../types/services';
export function useServiceStatus() {
  const [serviceStates, setServiceStates] = useState<Record<ServiceName, ServiceState>>({
    ollama: { status: 'unavailable' as ServiceStatus, lastCheck: Date.now() },
    embedding: { status: 'unavailable' as ServiceStatus, lastCheck: Date.now() },
    vectorStore: { status: 'unavailable' as ServiceStatus, lastCheck: Date.now() },
    memory: { status: 'unavailable' as ServiceStatus, lastCheck: Date.now() }
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const checkServiceStatus = async () => {
    try {
      setIsLoading(true);
      const status = await window.electron.ipc.invoke('app:health-check', undefined);
      setServiceStates(status);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to check service status');
    } finally {
      setIsLoading(false);
    }
  };
  const retryService = async (serviceName: ServiceName) => {
    try {
      setIsLoading(true);
      await window.electron.ipc.invoke('app:retry-service', { serviceName });
      await checkServiceStatus();
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to retry service');
    } finally {
      setIsLoading(false);
    }
  };
  useEffect(() => {
    checkServiceStatus();
    const unsubscribe = window.electron.ipc.on('app:service-status-changed', (status: Record<ServiceName, ServiceState>) => {
      setServiceStates(status);
    });
    const interval = setInterval(checkServiceStatus, 30000);
    return () => {
      clearInterval(interval);
      unsubscribe();
    };
  }, []);
  return {
    serviceStates,
    isLoading,
    error,
    checkServiceStatus,
    retryService
  };
}
</file>

<file path="renderer/src/hooks/useSettings.ts">
import { useState, useCallback, useEffect } from 'react';
export interface AppSettings {
  model: {
    name: string;
    temperature: number;
    contextWindow: number;
  };
  theme: {
    mode: 'light' | 'dark' | 'system';
    accentColor: string;
  };
  shortcuts: {
    sendMessage: string;
    newLine: string;
    messageHistory: string;
    toggleSettings: string;
  };
  prompts: {
    systemPrompt: string;
    savedPrompts: Array<{
      name: string;
      content: string;
    }>;
  };
}
const DEFAULT_SETTINGS: AppSettings = {
  model: {
    name: 'llama2',
    temperature: 0.7,
    contextWindow: 2048,
  },
  theme: {
    mode: 'system',
    accentColor: 'blue',
  },
  shortcuts: {
    sendMessage: 'Enter',
    newLine: 'Shift + Enter',
    messageHistory: 'Ctrl + /',
    toggleSettings: 'Ctrl + ,',
  },
  prompts: {
    systemPrompt: 'You are a helpful AI assistant.',
    savedPrompts: [
      {
        name: 'Default Assistant',
        content: 'You are a helpful AI assistant.',
      },
      {
        name: 'Code Expert',
        content: 'You are an expert programmer. Provide detailed, well-documented code examples.',
      },
      {
        name: 'Creative Writer',
        content: 'You are a creative writer. Help with storytelling, character development, and plot structure.',
      },
    ],
  },
};
export function useSettings() {
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  // Load settings from storage
  useEffect(() => {
    const loadSettings = async () => {
      try {
        const stored = localStorage.getItem('appSettings');
        if (stored) {
          setSettings(JSON.parse(stored));
        }
      } catch (err) {
        setError('Failed to load settings');
        console.error('Error loading settings:', err);
      } finally {
        setIsLoading(false);
      }
    };
    loadSettings();
  }, []);
  // Save settings to storage
  const saveSettings = useCallback(async (newSettings: AppSettings) => {
    try {
      localStorage.setItem('appSettings', JSON.stringify(newSettings));
      setSettings(newSettings);
      return true;
    } catch (err) {
      setError('Failed to save settings');
      console.error('Error saving settings:', err);
      return false;
    }
  }, []);
  // Update specific settings
  const updateSettings = useCallback(async (
    section: keyof AppSettings,
    value: Partial<AppSettings[keyof AppSettings]>
  ) => {
    const newSettings = {
      ...settings,
      [section]: {
        ...settings[section],
        ...value,
      },
    };
    return saveSettings(newSettings);
  }, [settings, saveSettings]);
  // Reset settings to defaults
  const resetSettings = useCallback(async () => {
    return saveSettings(DEFAULT_SETTINGS);
  }, [saveSettings]);
  return {
    settings,
    isLoading,
    error,
    saveSettings,
    updateSettings,
    resetSettings,
  };
} caches
</file>

<file path="renderer/src/hooks/useTrainingMode.ts">
import { create } from 'zustand';
interface TrainingModeState {
  isEnabled: boolean;
  activeSession: string | null;
  lastCheckpoint: string | null;
  availableModels: string[];
  enableTraining: () => void;
  disableTraining: () => void;
  setActiveSession: (sessionId: string | null) => void;
  setLastCheckpoint: (checkpoint: string | null) => void;
  setAvailableModels: (models: string[]) => void;
}
export const useTrainingMode = create<TrainingModeState>((set) => ({
  isEnabled: false,
  activeSession: null,
  lastCheckpoint: null,
  availableModels: [],
  enableTraining: () => set({ isEnabled: true }),
  disableTraining: () => set({ isEnabled: false }),
  setActiveSession: (sessionId) => set({ activeSession: sessionId }),
  setLastCheckpoint: (checkpoint) => set({ lastCheckpoint: checkpoint }),
  setAvailableModels: (models) => set({ availableModels: models }),
}));
</file>

<file path="renderer/src/hooks/useVectorStore.ts">
import { useState, useCallback } from 'react';
import type { Document } from '@shared/types/ipc';
export interface UseVectorStoreReturn {
  documents: Document[];
  isLoading: boolean;
  error: string | null;
  searchDocuments: (query: string) => Promise<void>;
  addDocument: (file: File) => Promise<void>;
  deleteDocument: (id: string) => Promise<void>;
  clearDocuments: () => Promise<void>;
}
export function useVectorStore(): UseVectorStoreReturn {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const searchDocuments = useCallback(async (query: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const results = await window.electronAPI.vectorStore.search(query);
      setDocuments(results);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to search documents');
    } finally {
      setIsLoading(false);
    }
  }, []);
  const addDocument = useCallback(async (file: File) => {
    setIsLoading(true);
    setError(null);
    try {
      const content = await file.text();
      await window.electronAPI.vectorStore.add({
        id: crypto.randomUUID(),
        content,
        metadata: {
          name: file.name,
          type: file.type,
          size: file.size,
          lastModified: file.lastModified,
        },
      });
      await searchDocuments('');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to add document');
    } finally {
      setIsLoading(false);
    }
  }, [searchDocuments]);
  const deleteDocument = useCallback(async (id: string) => {
    setIsLoading(true);
    setError(null);
    try {
      await window.electronAPI.vectorStore.delete(id);
      await searchDocuments('');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete document');
    } finally {
      setIsLoading(false);
    }
  }, [searchDocuments]);
  const clearDocuments = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      await window.electronAPI.vectorStore.clear();
      setDocuments([]);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to clear documents');
    } finally {
      setIsLoading(false);
    }
  }, []);
  return {
    documents,
    isLoading,
    error,
    searchDocuments,
    addDocument,
    deleteDocument,
    clearDocuments,
  };
}
</file>

<file path="renderer/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="renderer/src/pages/Settings.tsx">
import React, { useState } from 'react';
import { EmbeddingConfigPanel } from '../components/EmbeddingConfig';
import { PerformanceStats } from '../components/PerformanceStats';
import type { EmbeddingConfig as EmbeddingConfigType } from '../types/embedding';
import { validateConfig, getConfigValidationMessage } from '../utils/configValidation';
export const Settings: React.FC = () => {
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const handleConfigChange = async (config: Partial<EmbeddingConfigType>) => {
    try {
      // Validate configuration
      const validationErrors = validateConfig(config);
      if (validationErrors.length > 0) {
        setError(getConfigValidationMessage(validationErrors));
        return;
      }
      setIsSaving(true);
      setError(null);
      setSuccess(false);
      await window.electron.ipc.invoke('embedding:update-config', config);
      setSuccess(true);
      // Clear success message after 3 seconds
      setTimeout(() => setSuccess(false), 3000);
    } catch (error) {
      setError('Failed to update configuration. Please try again.');
      console.error('Failed to update embedding config:', error);
    } finally {
      setIsSaving(false);
    }
  };
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold text-gray-900 mb-6">Settings</h1>
      {error && (
        <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-red-600 whitespace-pre-line">{error}</p>
          <button
            onClick={() => setError(null)}
            className="mt-2 text-sm text-red-600 hover:text-red-700"
          >
            Dismiss
          </button>
        </div>
      )}
      {success && (
        <div className="mb-6 p-4 bg-green-50 border border-green-200 rounded-lg">
          <p className="text-green-600">Settings saved successfully!</p>
        </div>
      )}
      <div className="space-y-8">
        <section>
          <h2 className="text-xl font-semibold text-gray-900 mb-4">AI Personality</h2>
          <p className="text-gray-600 mb-4">
            Customize how the AI behaves in conversations. Choose a preset or fine-tune the settings to match your preferences.
          </p>
          <div className="relative">
            {isSaving && (
              <div className="absolute inset-0 bg-white bg-opacity-50 flex items-center justify-center">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
              </div>
            )}
            <EmbeddingConfigPanel onConfigChange={handleConfigChange} />
          </div>
        </section>
        <section>
          <h2 className="text-xl font-semibold text-gray-900 mb-4">Performance</h2>
          <p className="text-gray-600 mb-4">
            Monitor the performance of the embedding model and adjust settings for optimal results.
          </p>
          <PerformanceStats />
        </section>
        <section className="bg-white rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold text-gray-900 mb-4">Preset Descriptions</h2>
          <div className="space-y-4">
            <div>
              <h3 className="font-medium text-gray-900">Balanced</h3>
              <p className="text-gray-600">
                A well-rounded personality that balances accuracy, creativity, and efficiency. Good for general conversations.
              </p>
            </div>
            <div>
              <h3 className="font-medium text-gray-900">Focused</h3>
              <p className="text-gray-600">
                Stays strictly on topic with concise, accurate responses. Ideal for technical discussions and problem-solving.
              </p>
            </div>
            <div>
              <h3 className="font-medium text-gray-900">Creative</h3>
              <p className="text-gray-600">
                More expressive and imaginative responses. Great for brainstorming and creative writing.
              </p>
            </div>
            <div>
              <h3 className="font-medium text-gray-900">Precise</h3>
              <p className="text-gray-600">
                Highly accurate and detailed responses. Perfect for research and analysis.
              </p>
            </div>
          </div>
        </section>
        <section className="bg-white rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold text-gray-900 mb-4">Tips</h2>
          <ul className="list-disc list-inside space-y-2 text-gray-600">
            <li>Lower temperature values (0.2-0.4) make responses more focused and deterministic</li>
            <li>Higher temperature values (0.7-0.9) allow for more creative and diverse responses</li>
            <li>Enable "Rerank Results" for more accurate and relevant responses</li>
            <li>Adjust the similarity threshold to control how closely responses match the context</li>
            <li>Use the "Focused" preset for technical discussions and the "Creative" preset for brainstorming</li>
            <li>Monitor performance metrics to optimize batch size and caching settings</li>
            <li>Higher batch sizes improve throughput but increase memory usage</li>
            <li>Enable caching for frequently used embeddings to improve response time</li>
          </ul>
        </section>
      </div>
    </div>
  );
};
</file>

<file path="renderer/src/services/GeminiService.ts">
import { useSettingsStore } from '../stores/settingsStore';
import { isValidGeminiApiKey } from '../types/settings';
/**
 * Response from the Gemini API
 */
export interface GeminiResponse {
  text: string;
  sourceUrls?: string[];
  model?: string;
  finishReason?: string;
  safetyRatings?: any[];
}
/**
 * Error types for Gemini API calls
 */
export enum GeminiErrorType {
  INVALID_API_KEY = 'INVALID_API_KEY',
  MISSING_API_KEY = 'MISSING_API_KEY',
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
  CONTENT_FILTER_ERROR = 'CONTENT_FILTER_ERROR',
  FEATURE_DISABLED = 'FEATURE_DISABLED',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}
/**
 * Custom error class for Gemini API errors
 */
export class GeminiError extends Error {
  type: GeminiErrorType;
  statusCode?: number;
  constructor(message: string, type: GeminiErrorType = GeminiErrorType.UNKNOWN_ERROR, statusCode?: number) {
    super(message);
    this.type = type;
    this.statusCode = statusCode;
    this.name = 'GeminiError';
  }
}
/**
 * Service for interacting with the Google Gemini API
 */
export class GeminiService {
  private static instance: GeminiService;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  private requestTimeoutMs = 30000; // 30 seconds
  private cache = new Map<string, { response: GeminiResponse, timestamp: number }>();
  private cacheTtlMs = 5 * 60 * 1000; // 5 minutes
  private constructor() {}
  /**
   * Get the singleton instance of the GeminiService
   */
  public static getInstance(): GeminiService {
    if (!GeminiService.instance) {
      GeminiService.instance = new GeminiService();
    }
    return GeminiService.instance;
  }
  /**
   * Validates the API key format
   */
  private validateApiKey(apiKey: string | undefined): void {
    if (!apiKey) {
      throw new GeminiError(
        'Google Gemini API key is not set. Please add it in the settings.',
        GeminiErrorType.MISSING_API_KEY
      );
    }
    if (!isValidGeminiApiKey(apiKey)) {
      throw new GeminiError(
        'Invalid Google Gemini API key format. Please check your API key.',
        GeminiErrorType.INVALID_API_KEY
      );
    }
  }
  /**
   * Generates a cache key for a request
   */
  private getCacheKey(prompt: string, options: any = {}): string {
    return `${prompt}:${JSON.stringify(options)}`;
  }
  /**
   * Checks if a cached response is valid
   */
  private isCacheValid(cacheEntry: { response: GeminiResponse, timestamp: number }): boolean {
    return Date.now() - cacheEntry.timestamp < this.cacheTtlMs;
  }
  /**
   * Generates a response from the Gemini API
   */
  public async generateResponse(
    prompt: string, 
    options: {
      temperature?: number;
      topK?: number;
      topP?: number;
      maxOutputTokens?: number;
      useCache?: boolean;
    } = {}
  ): Promise<GeminiResponse> {
    const apiKey = useSettingsStore.getState().apiKeys.googleGemini;
    // Validate API key
    this.validateApiKey(apiKey);
    // Check cache if enabled
    const useCache = options.useCache !== false;
    const cacheKey = this.getCacheKey(prompt, options);
    if (useCache) {
      const cachedResponse = this.cache.get(cacheKey);
      if (cachedResponse && this.isCacheValid(cachedResponse)) {
        return cachedResponse.response;
      }
    }
    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.requestTimeoutMs);
    try {
      const response = await fetch(`${this.baseUrl}/models/gemini-pro:generateContent?key=${apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt
                }
              ]
            }
          ],
          generationConfig: {
            temperature: options.temperature ?? 0.7,
            topK: options.topK ?? 40,
            topP: options.topP ?? 0.95,
            maxOutputTokens: options.maxOutputTokens ?? 2048,
          }
        }),
        signal: controller.signal
      });
      // Clear timeout
      clearTimeout(timeoutId);
      // Handle HTTP errors
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const statusCode = response.status;
        // Handle specific error types
        if (statusCode === 400) {
          throw new GeminiError(
            errorData.error?.message || 'Invalid request to Gemini API',
            GeminiErrorType.UNKNOWN_ERROR,
            statusCode
          );
        } else if (statusCode === 401) {
          throw new GeminiError(
            'Invalid API key or unauthorized access',
            GeminiErrorType.INVALID_API_KEY,
            statusCode
          );
        } else if (statusCode === 403) {
          throw new GeminiError(
            'Access forbidden. Your API key may not have access to this resource.',
            GeminiErrorType.INVALID_API_KEY,
            statusCode
          );
        } else if (statusCode === 429) {
          throw new GeminiError(
            'Rate limit exceeded. Please try again later.',
            GeminiErrorType.RATE_LIMIT_ERROR,
            statusCode
          );
        } else if (statusCode >= 500) {
          throw new GeminiError(
            'Gemini API server error. Please try again later.',
            GeminiErrorType.NETWORK_ERROR,
            statusCode
          );
        } else {
          throw new GeminiError(
            errorData.error?.message || `Failed to generate response from Gemini API (${statusCode})`,
            GeminiErrorType.UNKNOWN_ERROR,
            statusCode
          );
        }
      }
      // Parse response
      const data = await response.json();
      // Check for content filtering
      if (data.promptFeedback?.blockReason) {
        throw new GeminiError(
          `Content filtered: ${data.promptFeedback.blockReason}`,
          GeminiErrorType.CONTENT_FILTER_ERROR
        );
      }
      // Extract response
      const geminiResponse: GeminiResponse = {
        text: data.candidates[0].content.parts[0].text,
        model: data.candidates[0].modelName,
        finishReason: data.candidates[0].finishReason,
        safetyRatings: data.candidates[0].safetyRatings
      };
      // Cache the response
      if (useCache) {
        this.cache.set(cacheKey, {
          response: geminiResponse,
          timestamp: Date.now()
        });
      }
      return geminiResponse;
    } catch (error) {
      // Clear timeout if it's still active
      clearTimeout(timeoutId);
      // Handle specific error types
      if (error instanceof GeminiError) {
        throw error;
      } else if (error instanceof DOMException && error.name === 'AbortError') {
        throw new GeminiError(
          'Request to Gemini API timed out. Please try again later.',
          GeminiErrorType.TIMEOUT_ERROR
        );
      } else if (error instanceof TypeError && error.message.includes('fetch')) {
        throw new GeminiError(
          'Network error. Please check your internet connection.',
          GeminiErrorType.NETWORK_ERROR
        );
      } else {
        console.error('Error calling Gemini API:', error);
        throw new GeminiError(
          error instanceof Error ? error.message : 'Unknown error calling Gemini API',
          GeminiErrorType.UNKNOWN_ERROR
        );
      }
    }
  }
  /**
   * Uses Gemini to browse the web for information
   */
  public async browseWeb(query: string): Promise<GeminiResponse> {
    const settings = useSettingsStore.getState();
    const apiKey = settings.apiKeys.googleGemini;
    // Validate API key
    this.validateApiKey(apiKey);
    // Check if web surfing is enabled
    if (!settings.features.webSurfing) {
      throw new GeminiError(
        'Web surfing feature is disabled. Please enable it in the settings.',
        GeminiErrorType.FEATURE_DISABLED
      );
    }
    try {
      // For web browsing, we'll use a special prompt that instructs Gemini to search the web
      const webBrowsingPrompt = `Search the web for information about: ${query}. 
      Please provide a comprehensive answer based on current information available online. 
      Include relevant facts, recent developments, and cite your sources.`;
      // Use a longer timeout for web browsing
      const response = await this.generateResponse(webBrowsingPrompt, {
        temperature: 0.3, // Lower temperature for more factual responses
        maxOutputTokens: 4096, // Allow longer responses for web search results
        useCache: true // Enable caching for web browsing
      });
      return response;
    } catch (error) {
      if (error instanceof GeminiError) {
        throw error;
      } else {
        console.error('Error browsing web with Gemini:', error);
        throw new GeminiError(
          error instanceof Error ? error.message : 'Unknown error browsing the web',
          GeminiErrorType.UNKNOWN_ERROR
        );
      }
    }
  }
  /**
   * Checks if web surfing is enabled
   */
  public isWebSurfingEnabled(): boolean {
    const settings = useSettingsStore.getState();
    return !!settings.apiKeys.googleGemini && settings.features.webSurfing;
  }
  /**
   * Clears the response cache
   */
  public clearCache(): void {
    this.cache.clear();
  }
  /**
   * Tests if an API key is valid
   */
  public async testApiKey(apiKey: string): Promise<boolean> {
    try {
      // Create abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      const response = await fetch(`${this.baseUrl}/models?key=${apiKey}`, {
        method: 'GET',
        signal: controller.signal
      });
      // Clear timeout
      clearTimeout(timeoutId);
      return response.ok;
    } catch (error) {
      console.error('Error testing Gemini API key:', error);
      return false;
    }
  }
}
</file>

<file path="renderer/src/state/chatMessageStore.ts">
import { create } from 'zustand';
import { ipcRenderer } from 'electron';
type ChatMessageMeta = {
  id: string;
  comments: string[];
  pinned: boolean;
  linkedMemoryId?: string;
  reactions?: string[];
};
type ChatMessageStore = {
  metadata: Record<string, ChatMessageMeta>;
  addComment: (id: string, comment: string) => Promise<void>;
  togglePin: (id: string) => Promise<void>;
  linkMemory: (id: string, memoryId: string) => Promise<void>;
  addReaction: (id: string, reaction: string) => Promise<void>;
  initializeMessage: (id: string) => void;
};
export const useChatMessageStore = create<ChatMessageStore>((set) => ({
  metadata: {},
  initializeMessage: (id) =>
    set((state) => {
      if (!state.metadata[id]) {
        return {
          metadata: {
            ...state.metadata,
            [id]: { id, comments: [], pinned: false, reactions: [] },
          },
        };
      }
      return state;
    }),
  addComment: async (id, comment) => {
    try {
      await ipcRenderer.invoke('chat:add-comment', { id, comment });
      set((state) => {
        const entry = state.metadata[id] ?? { id, comments: [], pinned: false };
        return {
          metadata: {
            ...state.metadata,
            [id]: { ...entry, comments: [...entry.comments, comment] },
          },
        };
      });
    } catch (error) {
      console.error('Failed to add comment:', error);
    }
  },
  togglePin: async (id) => {
    try {
      await ipcRenderer.invoke('chat:toggle-pin', { id });
      set((state) => {
        const entry = state.metadata[id] ?? { id, comments: [], pinned: false };
        return {
          metadata: {
            ...state.metadata,
            [id]: { ...entry, pinned: !entry.pinned },
          },
        };
      });
    } catch (error) {
      console.error('Failed to toggle pin:', error);
    }
  },
  linkMemory: async (id, memoryId) => {
    try {
      await ipcRenderer.invoke('chat:link-memory', { id, memoryId });
      set((state) => {
        const entry = state.metadata[id] ?? { id, comments: [], pinned: false };
        return {
          metadata: {
            ...state.metadata,
            [id]: { ...entry, linkedMemoryId: memoryId },
          },
        };
      });
    } catch (error) {
      console.error('Failed to link memory:', error);
    }
  },
  addReaction: async (id, reaction) => {
    try {
      await ipcRenderer.invoke('chat:add-reaction', { id, reaction });
      set((state) => {
        const entry = state.metadata[id] ?? { id, comments: [], pinned: false, reactions: [] };
        return {
          metadata: {
            ...state.metadata,
            [id]: {
              ...entry,
              reactions: [...(entry.reactions ?? []), reaction],
            },
          },
        };
      });
    } catch (error) {
      console.error('Failed to add reaction:', error);
    }
  },
}));
</file>

<file path="renderer/src/state/chatStore.ts">
import { create } from 'zustand';
export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: number;
  status: 'sending' | 'sent' | 'error';
  error?: string;
}
export interface OllamaModel {
  name: string;
  size: number;
  digest: string;
  details: {
    format: string;
    family: string;
    parameter_size: string;
    quantization_level: string;
  };
}
interface ChatState {
  messages: ChatMessage[];
  isProcessing: boolean;
  currentModel: string;
  availableModels: OllamaModel[];
  modelPullProgress: number;
  addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp' | 'status'>) => Promise<void>;
  updateMessage: (id: string, updates: Partial<ChatMessage>) => void;
  clearMessages: () => void;
  sendMessage: (content: string) => Promise<void>;
  deleteMessage: (id: string) => Promise<void>;
  loadModels: () => Promise<void>;
  setModel: (modelName: string) => Promise<void>;
  pullModel: (modelName: string) => Promise<void>;
}
export const useChatStore = create<ChatState>((set, get) => ({
  messages: [
    {
      id: 'welcome-1',
      content: 'Welcome to HelloGPT! How can I help you today?',
      role: 'assistant',
      timestamp: Date.now(),
      status: 'sent'
    }
  ],
  isProcessing: false,
  currentModel: 'llama2',
  availableModels: [],
  modelPullProgress: 0,
  addMessage: async (message) => {
    const newMessage: ChatMessage = {
      ...message,
      id: `msg-${Date.now()}`,
      timestamp: Date.now(),
      status: 'sending'
    };
    set(state => ({
      messages: [...state.messages, newMessage]
    }));
    try {
      // Send message to main process
      const response = await window.electronAPI.ipc.invoke('chat:send-message', message.content);
      // Update message status
      set(state => ({
        messages: state.messages.map(msg =>
          msg.id === newMessage.id
            ? { ...msg, status: 'sent' }
            : msg
        )
      }));
      // Add assistant's response
      if (response?.content) {
        set(state => ({
          messages: [...state.messages, {
            id: response.id,
            content: response.content,
            role: 'assistant',
            timestamp: response.timestamp,
            status: response.status
          }]
        }));
      }
    } catch (error) {
      console.error('Failed to send message:', error);
      set(state => ({
        messages: state.messages.map(msg =>
          msg.id === newMessage.id
            ? { ...msg, status: 'error', error: (error as Error).message }
            : msg
        )
      }));
    }
  },
  updateMessage: (id, updates) => {
    set(state => ({
      messages: state.messages.map(msg =>
        msg.id === id ? { ...msg, ...updates } : msg
      )
    }));
  },
  clearMessages: async () => {
    await window.electronAPI.ipc.invoke('chat:clear-history');
    set({ messages: [] });
  },
  sendMessage: async (content: string) => {
    const { addMessage, isProcessing } = get();
    if (isProcessing || !content.trim()) return;
    set({ isProcessing: true });
    try {
      await addMessage({
        content: content.trim(),
        role: 'user'
      });
    } finally {
      set({ isProcessing: false });
    }
  },
  deleteMessage: async (id: string) => {
    await window.electronAPI.ipc.invoke('chat:delete-message', id);
    set(state => ({
      messages: state.messages.filter(msg => msg.id !== id)
    }));
  },
  loadModels: async () => {
    try {
      const models = await window.electronAPI.ipc.invoke('chat:get-models');
      set({ availableModels: models });
    } catch (error) {
      console.error('Failed to load models:', error);
    }
  },
  setModel: async (modelName: string) => {
    try {
      await window.electronAPI.ipc.invoke('chat:set-model', modelName);
      set({ currentModel: modelName });
    } catch (error) {
      console.error('Failed to set model:', error);
    }
  },
  pullModel: async (modelName: string) => {
    try {
      // Listen for progress updates
      const progressHandler = (_: any, data: { modelName: string; progress: number }) => {
        if (data.modelName === modelName) {
          set({ modelPullProgress: data.progress });
        }
      };
      const cleanup = window.electronAPI.ipc.on('model-pull-progress', progressHandler);
      // Start pulling the model
      await window.electronAPI.ipc.invoke('chat:pull-model', modelName);
      // Clean up progress listener
      cleanup();
      set({ modelPullProgress: 0 });
      // Refresh available models
      await get().loadModels();
    } catch (error) {
      console.error('Failed to pull model:', error);
      set({ modelPullProgress: 0 });
    }
  }
}));
</file>

<file path="renderer/src/state/correctionStore.ts">
import { create } from 'zustand';
type Correction = {
  id: number;
  original: string;
  revised: string;
};
export const useCorrectionStore = create<{
  corrections: Correction[];
  mark: (id: number, text: string) => void;
  update: (id: number, revised: string) => void;
  commit: () => Promise<void>;
}>((set, get) => ({
  corrections: [],
  mark: (id, original) => {
    set(state => ({
      corrections: [...state.corrections, { id, original, revised: original }]
    }));
  },
  update: (id, revised) => {
    set(state => ({
      corrections: state.corrections.map(c =>
        c.id === id ? { ...c, revised } : c
      )
    }));
  },
  commit: async () => {
    for (const c of get().corrections) {
      await window.electron.ipc.invoke('vector:add', {
        id: `correction-${Date.now()}`,
        content: c.revised
      });
    }
    set({ corrections: [] });
  }
}));
</file>

<file path="renderer/src/state/modelStore.ts">
import { create } from 'zustand';
import { OllamaModel, OllamaResponse } from '@shared/types/ollama';
interface ModelState {
  models: OllamaModel[];
  current: string | null;
  loading: boolean;
  error: string | null;
  load: () => Promise<void>;
  set: (modelName: string) => Promise<void>;
}
export const useModelStore = create<ModelState>((set, get) => ({
  models: [],
  current: null,
  loading: false,
  error: null,
  load: async () => {
    set({ loading: true, error: null });
    try {
      const response = await window.electronAPI.ollama.listModels();
      if (!response.success) {
        throw new Error(response.error || 'Failed to load models');
      }
      const models = response.result?.models || [];
      set({ models, loading: false });
      if (models.length > 0 && !get().current) {
        await get().set(models[0].name);
      }
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Failed to load models',
        loading: false 
      });
    }
  },
  set: async (modelName: string) => {
    set({ loading: true, error: null });
    try {
      const response = await window.electronAPI.ollama.setModel(modelName);
      if (!response.success) {
        throw new Error(response.error || 'Failed to set model');
      }
      set({ current: modelName, loading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Failed to set model',
        loading: false 
      });
    }
  }
}));
</file>

<file path="renderer/src/state/vectorStore.ts">
import { create } from 'zustand';
type Vector = { id: string; content: string; embedding?: number[] };
type VectorStore = {
  vectors: Vector[];
  stats: { count: number; dimensions: number };
  search: (query: string) => Promise<void>;
  add: (doc: Vector) => Promise<void>;
  delete: (id: string) => Promise<void>;
  loadStats: () => Promise<void>;
};
export const useVectorStore = create<VectorStore>((set) => ({
  vectors: [],
  stats: { count: 0, dimensions: 0 },
  search: async (query) => {
    const res = await window.electron.ipc.invoke('vector:search', query);
    set({ vectors: res });
  },
  add: async (doc) => {
    await window.electron.ipc.invoke('vector:add', doc);
    await useVectorStore.getState().search('');
    await useVectorStore.getState().loadStats();
  },
  delete: async (id) => {
    await window.electron.ipc.invoke('vector:delete', id);
    await useVectorStore.getState().search('');
    await useVectorStore.getState().loadStats();
  },
  loadStats: async () => {
    const stats = await window.electron.ipc.invoke('vector:stats');
    set({ stats });
  }
}));
</file>

<file path="renderer/src/stores/configStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { EmbeddingConfig } from '../types/embedding';
interface ConfigState {
  customPresets: Record<string, EmbeddingConfig>;
  addCustomPreset: (name: string, config: EmbeddingConfig) => void;
  removeCustomPreset: (name: string) => void;
  getCustomPreset: (name: string) => EmbeddingConfig | undefined;
  getAllCustomPresets: () => Record<string, EmbeddingConfig>;
}
export const useConfigStore = create<ConfigState>()(
  persist(
    (set, get) => ({
      customPresets: {},
      addCustomPreset: (name: string, config: EmbeddingConfig) =>
        set((state) => ({
          customPresets: { ...state.customPresets, [name]: config },
        })),
      removeCustomPreset: (name: string) =>
        set((state) => {
          const { [name]: _, ...rest } = state.customPresets;
          return { customPresets: rest };
        }),
      getCustomPreset: (name: string) => get().customPresets[name],
      getAllCustomPresets: () => get().customPresets,
    }),
    {
      name: 'embedding-config-storage',
    }
  )
);
</file>

<file path="renderer/src/stores/settingsStore.ts">
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { 
  Settings, 
  DEFAULT_SETTINGS, 
  ApiKeys, 
  isValidGeminiApiKey,
  SettingsError,
  SettingsErrorType
} from '../types/settings';
import secureStorage from '../utils/secureStorage';
/**
 * Extended settings state with actions
 */
interface SettingsState extends Settings {
  // API key management
  setApiKey: (provider: keyof ApiKeys, key: string) => Promise<void>;
  clearApiKey: (provider: keyof ApiKeys) => Promise<void>;
  validateApiKey: (provider: keyof ApiKeys, key: string) => boolean;
  testApiKey: (provider: keyof ApiKeys, key: string) => Promise<boolean>;
  // Feature management
  toggleFeature: (feature: keyof Settings['features'], enabled: boolean) => void;
  // Security settings
  toggleApiKeyMasking: (enabled: boolean) => void;
  // Settings management
  resetSettings: () => void;
  exportSettings: () => string;
  importSettings: (settingsJson: string) => boolean;
  // Error state
  lastError: string | null;
  setLastError: (error: string | null) => void;
}
/**
 * Custom storage adapter for Zustand that uses secureStorage for API keys
 * and localStorage for non-sensitive settings
 */
const hybridStorage = {
  getItem: async (name: string): Promise<string | null> => {
    try {
      // Get regular settings from localStorage
      const settingsJson = localStorage.getItem(name);
      if (!settingsJson) return null;
      const settings = JSON.parse(settingsJson);
      // Get API keys from secure storage
      const apiKeys: ApiKeys = {};
      const providers = ['googleGemini'] as const;
      for (const provider of providers) {
        const key = await secureStorage.getItem(`apiKey_${provider}`);
        if (key) {
          apiKeys[provider] = key;
        }
      }
      // Merge API keys with regular settings
      return JSON.stringify({
        ...settings,
        state: {
          ...settings.state,
          apiKeys
        }
      });
    } catch (error) {
      console.error('Error retrieving settings:', error);
      return localStorage.getItem(name);
    }
  },
  setItem: async (name: string, value: string): Promise<void> => {
    try {
      const settings = JSON.parse(value);
      const { apiKeys, ...rest } = settings.state;
      // Store API keys in secure storage
      if (apiKeys) {
        for (const [provider, key] of Object.entries(apiKeys)) {
          if (key) {
            await secureStorage.setItem(`apiKey_${provider}`, key as string);
          }
        }
      }
      // Store everything else in localStorage
      localStorage.setItem(name, JSON.stringify({
        ...settings,
        state: {
          ...rest,
          apiKeys: {} // Don't store API keys in localStorage
        }
      }));
    } catch (error) {
      console.error('Error storing settings:', error);
      localStorage.setItem(name, value);
    }
  },
  removeItem: async (name: string): Promise<void> => {
    try {
      // Remove API keys from secure storage
      const providers = ['googleGemini'] as const;
      for (const provider of providers) {
        await secureStorage.removeItem(`apiKey_${provider}`);
      }
      // Remove regular settings from localStorage
      localStorage.removeItem(name);
    } catch (error) {
      console.error('Error removing settings:', error);
      localStorage.removeItem(name);
    }
  }
};
export const useSettingsStore = create<SettingsState>()(
  persist(
    (set, get) => ({
      ...DEFAULT_SETTINGS,
      lastError: null,
      setApiKey: async (provider, key) => {
        try {
          // Validate key format
          if (!get().validateApiKey(provider, key)) {
            throw new SettingsError(
              'Invalid API key format',
              SettingsErrorType.INVALID_API_KEY
            );
          }
          // Store in secure storage
          await secureStorage.setItem(`apiKey_${provider}`, key);
          // Update state
          set((state) => ({
            apiKeys: {
              ...state.apiKeys,
              [provider]: key
            },
            lastError: null
          }));
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Unknown error saving API key';
          console.error(`Error setting ${provider} API key:`, error);
          set({ lastError: message });
          throw error;
        }
      },
      clearApiKey: async (provider) => {
        try {
          // Remove from secure storage
          await secureStorage.removeItem(`apiKey_${provider}`);
          // Update state
          set((state) => {
            const newApiKeys = { ...state.apiKeys };
            delete newApiKeys[provider];
            return { 
              apiKeys: newApiKeys,
              lastError: null
            };
          });
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Unknown error clearing API key';
          console.error(`Error clearing ${provider} API key:`, error);
          set({ lastError: message });
          throw error;
        }
      },
      validateApiKey: (provider, key) => {
        if (provider === 'googleGemini') {
          return isValidGeminiApiKey(key);
        }
        return true;
      },
      testApiKey: async (provider, key) => {
        try {
          if (provider === 'googleGemini') {
            // Test Google Gemini API key with a simple request
            const response = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models?key=${key}`,
              { 
                method: 'GET',
                signal: AbortSignal.timeout(10000) // 10 second timeout
              }
            );
            if (!response.ok) {
              const data = await response.json();
              throw new SettingsError(
                data.error?.message || `API error: ${response.status}`,
                SettingsErrorType.NETWORK_ERROR
              );
            }
            set({ lastError: null });
            return true;
          }
          return false;
        } catch (error) {
          let message = 'Unknown error testing API key';
          let type = SettingsErrorType.UNKNOWN_ERROR;
          if (error instanceof DOMException && error.name === 'AbortError') {
            message = 'Request timed out';
            type = SettingsErrorType.TIMEOUT_ERROR;
          } else if (error instanceof TypeError) {
            message = 'Network error - check your connection';
            type = SettingsErrorType.NETWORK_ERROR;
          } else if (error instanceof SettingsError) {
            message = error.message;
            type = error.type;
          } else if (error instanceof Error) {
            message = error.message;
          }
          console.error(`Error testing ${provider} API key:`, error);
          set({ lastError: message });
          throw new SettingsError(message, type);
        }
      },
      toggleFeature: (feature, enabled) => 
        set((state) => ({
          features: {
            ...state.features,
            [feature]: enabled
          },
          lastError: null
        })),
      toggleApiKeyMasking: (enabled) => 
        set((state) => ({
          security: {
            ...state.security,
            maskApiKeys: enabled
          },
          lastError: null
        })),
      resetSettings: () => {
        // Clear API keys from secure storage
        const providers = ['googleGemini'] as const;
        for (const provider of providers) {
          secureStorage.removeItem(`apiKey_${provider}`).catch(console.error);
        }
        set({ ...DEFAULT_SETTINGS, lastError: null });
      },
      exportSettings: () => {
        const { apiKeys, features, security, version } = get();
        return JSON.stringify({
          apiKeys,
          features,
          security,
          version
        }, null, 2);
      },
      importSettings: (settingsJson) => {
        try {
          const settings = JSON.parse(settingsJson);
          // Validate settings structure
          if (!settings || typeof settings !== 'object') {
            throw new Error('Invalid settings format');
          }
          // Import API keys
          if (settings.apiKeys) {
            for (const [provider, key] of Object.entries(settings.apiKeys)) {
              if (key && typeof key === 'string') {
                secureStorage.setItem(`apiKey_${provider}`, key).catch(console.error);
              }
            }
          }
          // Import other settings
          set((state) => ({
            apiKeys: settings.apiKeys || state.apiKeys,
            features: settings.features || state.features,
            security: settings.security || state.security,
            version: settings.version || state.version,
            lastError: null
          }));
          return true;
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Unknown error importing settings';
          console.error('Error importing settings:', error);
          set({ lastError: message });
          return false;
        }
      },
      setLastError: (error) => set({ lastError: error })
    }),
    {
      name: 'osipelican-settings',
      storage: createJSONStorage(() => hybridStorage),
      partialize: (state) => ({
        // Don't include API keys in the persisted state
        // They are handled separately by the hybridStorage adapter
        features: state.features,
        security: state.security,
        version: state.version
      }),
      version: 1,
      onRehydrateStorage: () => (state) => {
        if (state) {
          console.log('Settings rehydrated successfully');
        } else {
          console.error('Failed to rehydrate settings');
        }
      }
    }
  )
);
</file>

<file path="renderer/src/styles/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --coral: 16 100% 66%;
    --coral-foreground: 16 100% 98%;
    --mint: 160 84% 39%;
    --mint-foreground: 160 84% 98%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --coral: 16 100% 66%;
    --coral-foreground: 16 100% 98%;
    --mint: 160 84% 39%;
    --mint-foreground: 160 84% 98%;
  }
}
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground antialiased;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}
/* Custom scrollbar styles */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  @apply bg-transparent;
}
::-webkit-scrollbar-thumb {
  @apply bg-muted-foreground/20 rounded-full;
}
::-webkit-scrollbar-thumb:hover {
  @apply bg-muted-foreground/30;
}
/* Glass effect styles */
.glass {
  @apply bg-background/60 backdrop-blur-glass border border-white/10 shadow-glass;
  backdrop-filter: blur(12px);
}
.glass-hover {
  @apply hover:bg-background/70 hover:shadow-glass-hover transition-all duration-200;
}
.glass-press {
  @apply active:bg-background/80 active:shadow-glass-press;
}
/* Button styles */
.btn {
  @apply inline-flex items-center justify-center rounded-lg text-sm font-medium
         transition-all duration-200
         focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2
         disabled:opacity-50 disabled:pointer-events-none ring-offset-background
         active:animate-button-press;
}
.btn-primary {
  @apply glass glass-hover glass-press text-primary-foreground;
}
.btn-secondary {
  @apply glass glass-hover glass-press text-secondary-foreground;
}
.btn-ghost {
  @apply hover:bg-accent/50 hover:text-accent-foreground;
}
/* Input styles */
.input {
  @apply glass flex h-10 w-full rounded-lg border border-white/10 bg-background/40 px-3 py-2 text-sm
         ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium
         placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2
         focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50
         transition-all duration-200;
}
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
}
body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
#root {
  width: 100%;
  height: 100vh;
}
/* Component styles */
@layer components {
  .card {
    @apply glass rounded-lg border border-white/10 shadow-glass;
  }
  .card-header {
    @apply flex flex-col space-y-1.5 p-6;
  }
  .card-title {
    @apply text-2xl font-semibold leading-none tracking-tight;
  }
  .card-description {
    @apply text-sm text-muted-foreground;
  }
  .card-content {
    @apply p-6 pt-0;
  }
  .card-footer {
    @apply flex items-center p-6 pt-0;
  }
}
/* Utility classes */
@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
  .text-pretty {
    text-wrap: pretty;
  }
  .backdrop-blur {
    backdrop-filter: blur(8px);
  }
  .glass {
    @apply bg-background/60 backdrop-blur supports-[backdrop-filter]:bg-background/40;
  }
  .transition-all {
    transition-property: all;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 150ms;
  }
}
</file>

<file path="renderer/src/styles/test.css">
/* This is a test CSS file to verify that CSS is properly extracted */
.test-css-extraction {
  color: red;
  background-color: blue;
  padding: 10px;
  margin: 10px;
  border-radius: 5px;
}
/* Add some more complex CSS to ensure it's properly processed */
.test-css-extraction:hover {
  transform: scale(1.1);
  transition: transform 0.3s ease;
}
@media (max-width: 768px) {
  .test-css-extraction {
    font-size: 14px;
  }
}
</file>

<file path="renderer/src/tests/components/OllamaTest.test.tsx">
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import OllamaTest from '../../components/OllamaTest';
import { mockElectron, resetMocks } from '../utils/electronMock';
import type { OllamaModel, ModelLoadingState } from '@electron-app/types/ollama';
describe('OllamaTest', () => {
  beforeEach(() => {
    resetMocks();
  });
  it('renders test interface', () => {
    render(<OllamaTest />);
    expect(screen.getByText('Ollama API Test')).toBeInTheDocument();
    expect(screen.getByText('Connection Status:')).toBeInTheDocument();
    expect(screen.getByText('Available Models:')).toBeInTheDocument();
  });
  it('handles successful connection check', async () => {
    const mockModels: OllamaModel[] = [
      { 
        name: 'llama2',
        digest: 'sha256:123',
        size: 7,
        details: {
          format: 'gguf',
          family: 'llama',
          parameter_size: '7B',
          quantization_level: 'q4_0'
        }
      },
      { 
        name: 'mistral',
        digest: 'sha256:456',
        size: 7,
        details: {
          format: 'gguf',
          family: 'mistral',
          parameter_size: '7B',
          quantization_level: 'q4_0'
        }
      }
    ];
    vi.mocked(mockElectron.ollama.listModels).mockResolvedValueOnce(mockModels);
    render(<OllamaTest />);
    await waitFor(() => {
      expect(screen.getByText('Connected')).toBeInTheDocument();
      expect(screen.getByText('llama2, mistral')).toBeInTheDocument();
    });
  });
  it('handles connection error', async () => {
    const errorMessage = 'Failed to connect to Ollama';
    vi.mocked(mockElectron.ollama.listModels).mockRejectedValueOnce(new Error(errorMessage));
    render(<OllamaTest />);
    await waitFor(() => {
      expect(screen.getByText('Disconnected')).toBeInTheDocument();
      expect(screen.getByText(errorMessage)).toBeInTheDocument();
    });
  });
  it('handles model loading state changes', async () => {
    render(<OllamaTest />);
    // Simulate loading state change
    const loadingCallback = vi.mocked(mockElectron.ollama.onModelLoadingStateChanged).mock.calls[0][0];
    const loadingState: ModelLoadingState = {
      isLoading: true,
      status: 'loading',
      modelName: 'llama2',
      progress: 0,
      estimatedTimeRemaining: 60
    };
    loadingCallback(loadingState);
    await waitFor(() => {
      expect(screen.getByText('Loading...')).toBeInTheDocument();
    });
    // Simulate loading complete
    const completeState: ModelLoadingState = {
      isLoading: false,
      status: 'loaded',
      modelName: 'llama2',
      progress: 100,
      estimatedTimeRemaining: 0
    };
    loadingCallback(completeState);
    await waitFor(() => {
      expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
    });
  });
});
</file>

<file path="renderer/src/tests/edgeCases/serviceStatusEdgeCases.test.tsx">
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, beforeEach } from 'vitest';
import { ServiceStatusManager } from '../../components/ServiceStatusManager';
import { mockElectron, resetMocks } from '../utils/electronMock';
import { ServiceName, ServiceState } from '../../types/services';
describe('Service Status Edge Cases', () => {
  beforeEach(() => {
    resetMocks();
  });
  it('handles rapid state transitions without UI glitches', async () => {
    const states: ServiceState['status'][] = ['ok', 'degraded', 'error', 'ok'];
    render(<ServiceStatusManager />);
    // Simulate rapid state changes
    for (const state of states) {
      const statuses: Record<ServiceName, ServiceState> = {
        ollama: { status: state, lastCheck: Date.now(), error: '' },
        embedding: { status: 'ok', lastCheck: Date.now(), error: '' },
        vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
        memory: { status: 'ok', lastCheck: Date.now(), error: '' }
      };
      mockElectron.ipc.invoke.mockResolvedValueOnce(statuses);
      await new Promise(resolve => setTimeout(resolve, 50));
    }
    // Verify final state is displayed correctly
    await waitFor(() => {
      expect(screen.getByText('Service Status')).toBeInTheDocument();
    });
  });
  it.skip('recovers gracefully after multiple failures', async () => {
    render(<ServiceStatusManager />);
    // Simulate multiple failures
    for (let i = 0; i < 3; i++) {
      const statuses: Record<ServiceName, ServiceState> = {
        ollama: { status: 'error', lastCheck: Date.now(), error: `Connection attempt ${i + 1} failed` },
        embedding: { status: 'ok', lastCheck: Date.now(), error: '' },
        vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
        memory: { status: 'ok', lastCheck: Date.now(), error: '' }
      };
      mockElectron.ipc.invoke.mockResolvedValueOnce(statuses);
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    // Simulate recovery
    const recoveredStatuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'ok', lastCheck: Date.now(), error: '' },
      embedding: { status: 'ok', lastCheck: Date.now(), error: '' },
      vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(recoveredStatuses);
    // Verify recovery state
    await waitFor(() => {
      expect(screen.queryByText(/ollama service is error/)).not.toBeInTheDocument();
    });
  });
  it.skip('handles concurrent service operations', async () => {
    render(<ServiceStatusManager />);
    // Simulate concurrent operations
    const statuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'degraded', lastCheck: Date.now(), error: 'High latency' },
      embedding: { status: 'degraded', lastCheck: Date.now(), error: 'Processing delay' },
      vectorStore: { status: 'degraded', lastCheck: Date.now(), error: 'Indexing in progress' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(statuses);
    // Verify all states are displayed correctly
    await waitFor(() => {
      expect(screen.getByText(/ollama service is degraded/)).toBeInTheDocument();
      expect(screen.getByText(/embedding service is degraded/)).toBeInTheDocument();
      expect(screen.getByText(/vectorStore service is degraded/)).toBeInTheDocument();
    });
  });
});
</file>

<file path="renderer/src/tests/edgeCases/serviceTransitions.test.tsx">
import React from 'react';
import { render, screen, act, waitFor } from '@testing-library/react';
import { ServiceStatusManager } from '../../components/ServiceStatusManager';
import { mockIpcResponse } from '../utils/ipcMocks';
import { ServiceStatus } from '../../types/services';
import { vi } from 'vitest';
describe('Service State Transitions', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  it('handles rapid state transitions without UI glitches', async () => {
    const states: ServiceStatus[] = ['ok', 'degraded', 'error', 'ok'];
    render(<ServiceStatusManager />);
    // Simulate rapid state changes
    for (const state of states) {
      await act(async () => {
        mockIpcResponse.event('ollama', 'onModelLoadingStateChanged', { status: state });
        // Small delay to simulate real-world timing
        await new Promise(resolve => setTimeout(resolve, 50));
      });
    }
    // Verify final state is displayed correctly
    expect(screen.getByText('Service Status')).toBeInTheDocument();
  });
  it('recovers gracefully after multiple failures', async () => {
    render(<ServiceStatusManager />);
    // Simulate multiple failures
    for (let i = 0; i < 3; i++) {
      await act(async () => {
        mockIpcResponse.error('ollama', 'checkConnection', `Connection attempt ${i + 1} failed`);
        await new Promise(resolve => setTimeout(resolve, 100));
      });
    }
    // Simulate recovery
    await act(async () => {
      mockIpcResponse.success('ollama', 'checkConnection', { 
        connected: true,
        lastChecked: Date.now()
      });
    });
    // Verify recovery state
    await waitFor(() => {
      expect(screen.getByText('Connected')).toBeInTheDocument();
    });
  });
  it('handles concurrent service operations', async () => {
    render(<ServiceStatusManager />);
    // Simulate concurrent operations
    await Promise.all([
      act(async () => {
        mockIpcResponse.event('ollama', 'onModelLoadingStateChanged', { 
          status: 'loading',
          isLoading: true
        });
      }),
      act(async () => {
        mockIpcResponse.event('embedding', 'onEmbeddingStateChanged', {
          status: 'processing',
          progress: 50
        });
      }),
      act(async () => {
        mockIpcResponse.event('vectorStore', 'onVectorStoreStateChanged', {
          status: 'indexing',
          progress: 75
        });
      })
    ]);
    // Verify all states are displayed correctly
    await waitFor(() => {
      expect(screen.getByText('Status: loading')).toBeInTheDocument();
      expect(screen.getByText('Status: processing')).toBeInTheDocument();
      expect(screen.getByText('Status: indexing')).toBeInTheDocument();
    });
  });
});
</file>

<file path="renderer/src/tests/errorBoundary/errorHandling.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { App } from '../../App';
import { mockIpcResponse } from '../utils/ipcMocks';
import { vi } from 'vitest';
describe('Error Handling', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Mock console.error to prevent test output pollution
    vi.spyOn(console, 'error').mockImplementation(() => {});
  });
  afterEach(() => {
    vi.restoreAllMocks();
  });
  it('handles unexpected IPC errors gracefully', async () => {
    render(<App />);
    // Simulate unexpected IPC error
    mockIpcResponse.error('ollama', 'checkConnection', 'Unexpected IPC error');
    // Verify error is displayed to user
    await waitFor(() => {
      expect(screen.getByText(/Something went wrong/i)).toBeInTheDocument();
    });
    // Verify retry option is available
    expect(screen.getByText('Retry')).toBeInTheDocument();
  });
  it('propagates errors through component hierarchy', async () => {
    render(<App />);
    // Simulate error in child component
    mockIpcResponse.error('ollama', 'onModelLoadingStateChanged', 'Model loading failed');
    mockIpcResponse.error('embedding', 'onEmbeddingStateChanged', 'Embedding failed');
    mockIpcResponse.error('vectorStore', 'onVectorStoreStateChanged', 'Vector store failed');
    // Verify all errors are caught and displayed
    await waitFor(() => {
      expect(screen.getByText('Model loading failed')).toBeInTheDocument();
      expect(screen.getByText('Embedding failed')).toBeInTheDocument();
      expect(screen.getByText('Vector store failed')).toBeInTheDocument();
    });
  });
  it('provides appropriate user feedback for different error types', async () => {
    render(<App />);
    // Test connection error
    mockIpcResponse.error('ollama', 'checkConnection', 'Connection refused');
    await waitFor(() => {
      expect(screen.getByText(/connection/i)).toBeInTheDocument();
      expect(screen.getByText('Setup Guide')).toBeInTheDocument();
    });
    // Test model error
    mockIpcResponse.error('ollama', 'loadModel', 'Model not found');
    await waitFor(() => {
      expect(screen.getByText(/model/i)).toBeInTheDocument();
      expect(screen.getByText('Troubleshoot')).toBeInTheDocument();
    });
    // Test resource error
    mockIpcResponse.error('ollama', 'checkConnection', 'Insufficient memory');
    await waitFor(() => {
      expect(screen.getByText(/memory/i)).toBeInTheDocument();
      expect(screen.getByText('System Requirements')).toBeInTheDocument();
    });
  });
  it('maintains application state after error recovery', async () => {
    render(<App />);
    // Start chat
    const input = screen.getByPlaceholderText('Type your message...');
    fireEvent.change(input, { target: { value: 'Hello' } });
    fireEvent.click(screen.getByText('Send'));
    // Simulate error
    mockIpcResponse.error('ollama', 'onMessageReceived', 'Message processing failed');
    // Verify error
    await waitFor(() => {
      expect(screen.getByText('Message processing failed')).toBeInTheDocument();
    });
    // Simulate recovery
    mockIpcResponse.success('ollama', 'checkConnection', { connected: true });
    // Verify chat history is preserved
    expect(screen.getByText('Hello')).toBeInTheDocument();
    // Verify can continue chatting
    fireEvent.change(input, { target: { value: 'Are you working now?' } });
    fireEvent.click(screen.getByText('Send'));
    mockIpcResponse.event('ollama', 'onMessageReceived', {
      content: 'Yes, everything is working!',
      role: 'assistant'
    });
    await waitFor(() => {
      expect(screen.getByText('Yes, everything is working!')).toBeInTheDocument();
    });
  });
});
</file>

<file path="renderer/src/tests/integration/userFlows.test.tsx">
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { App } from '../../App';
import { mockIpcResponse } from '../utils/ipcMocks';
import { vi } from 'vitest';
describe('User Flows', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  it('completes full chat flow with model loading', async () => {
    render(<App />);
    // Simulate model loading
    mockIpcResponse.event('ollama', 'onModelLoadingStateChanged', {
      status: 'loading',
      isLoading: true,
      progress: 0
    });
    // Wait for model to load
    await waitFor(() => {
      expect(screen.getByText('Status: loading')).toBeInTheDocument();
    });
    // Simulate model loaded
    mockIpcResponse.event('ollama', 'onModelLoaded', {
      status: 'operational',
      modelName: 'llama2'
    });
    // Send a message
    const input = screen.getByPlaceholderText('Type your message...');
    fireEvent.change(input, { target: { value: 'Hello, how are you?' } });
    fireEvent.click(screen.getByText('Send'));
    // Verify message appears in chat
    await waitFor(() => {
      expect(screen.getByText('Hello, how are you?')).toBeInTheDocument();
    });
    // Simulate response
    mockIpcResponse.event('ollama', 'onMessageReceived', {
      content: 'I am doing well, thank you for asking!',
      role: 'assistant'
    });
    // Verify response appears
    await waitFor(() => {
      expect(screen.getByText('I am doing well, thank you for asking!')).toBeInTheDocument();
    });
  });
  it('handles service degradation during chat', async () => {
    render(<App />);
    // Start chat
    const input = screen.getByPlaceholderText('Type your message...');
    fireEvent.change(input, { target: { value: 'Tell me a story' } });
    fireEvent.click(screen.getByText('Send'));
    // Simulate service degradation
    mockIpcResponse.event('ollama', 'onModelLoadingStateChanged', {
      status: 'degraded',
      error: 'High latency detected'
    });
    // Verify degradation is shown
    await waitFor(() => {
      expect(screen.getByText('High latency detected')).toBeInTheDocument();
    });
    // Verify chat still works
    fireEvent.change(input, { target: { value: 'Continue the story' } });
    fireEvent.click(screen.getByText('Send'));
    // Simulate response despite degradation
    mockIpcResponse.event('ollama', 'onMessageReceived', {
      content: 'The story continues...',
      role: 'assistant'
    });
    await waitFor(() => {
      expect(screen.getByText('The story continues...')).toBeInTheDocument();
    });
  });
  it('recovers from service failure during chat', async () => {
    render(<App />);
    // Start chat
    const input = screen.getByPlaceholderText('Type your message...');
    fireEvent.change(input, { target: { value: 'Hello' } });
    fireEvent.click(screen.getByText('Send'));
    // Simulate service failure
    mockIpcResponse.event('ollama', 'onModelLoadingStateChanged', {
      status: 'unavailable',
      error: 'Connection lost'
    });
    // Verify error is shown
    await waitFor(() => {
      expect(screen.getByText('Connection lost')).toBeInTheDocument();
    });
    // Click retry
    fireEvent.click(screen.getByText('Retry'));
    // Simulate recovery
    mockIpcResponse.event('ollama', 'onModelLoadingStateChanged', {
      status: 'operational'
    });
    // Verify recovery
    await waitFor(() => {
      expect(screen.getByText('Status: operational')).toBeInTheDocument();
    });
    // Verify chat works again
    fireEvent.change(input, { target: { value: 'Are you back?' } });
    fireEvent.click(screen.getByText('Send'));
    mockIpcResponse.event('ollama', 'onMessageReceived', {
      content: 'Yes, I am back online!',
      role: 'assistant'
    });
    await waitFor(() => {
      expect(screen.getByText('Yes, I am back online!')).toBeInTheDocument();
    });
  });
});
</file>

<file path="renderer/src/tests/setup/electronMocks.ts">
import { vi } from 'vitest';
// Mock the Electron API
const mockElectronAPI = {
  ollama: {
    onModelLoadingStateChanged: vi.fn(),
    onModelLoaded: vi.fn(),
    onModelLoadError: vi.fn(),
    loadModel: vi.fn(),
    getModelStatus: vi.fn(),
    getAvailableModels: vi.fn(),
    removeModel: vi.fn()
  },
  embedding: {
    onEmbeddingStateChanged: vi.fn(),
    onEmbeddingComplete: vi.fn(),
    onEmbeddingError: vi.fn(),
    generateEmbedding: vi.fn(),
    getEmbeddingStatus: vi.fn()
  },
  vectorStore: {
    onVectorStoreStateChanged: vi.fn(),
    onVectorStoreComplete: vi.fn(),
    onVectorStoreError: vi.fn(),
    storeVectors: vi.fn(),
    getVectorStoreStatus: vi.fn()
  },
  memory: {
    onMemoryStateChanged: vi.fn(),
    onMemoryComplete: vi.fn(),
    onMemoryError: vi.fn(),
    storeMemory: vi.fn(),
    getMemoryStatus: vi.fn()
  }
};
// Mock the window.electron object
Object.defineProperty(window, 'electron', {
  value: mockElectronAPI,
  writable: true
});
export { mockElectronAPI };
</file>

<file path="renderer/src/tests/setup/testSetup.ts">
import '@testing-library/jest-dom';
import { vi } from 'vitest';
import './electronMocks';
// Global test setup
beforeEach(() => {
  vi.clearAllMocks();
});
// Global test teardown
afterEach(() => {
  vi.resetAllMocks();
});
</file>

<file path="renderer/src/tests/utils/electronMock.ts">
import { vi } from 'vitest';
import type { ElectronAPI } from '../../types/ipc';
import type { OllamaModel, ModelLoadingState } from '@electron-app/types/ollama';
export const mockElectron: ElectronAPI = {
  ipc: {
    invoke: vi.fn(),
    on: vi.fn(),
  },
  ollama: {
    listModels: vi.fn(),
    setModel: vi.fn(),
    checkConnection: vi.fn(),
    cancelLoad: vi.fn(),
    saveConfig: vi.fn(),
    onModelLoadingStateChanged: vi.fn(),
  },
  vectorStore: {
    search: vi.fn(),
    add: vi.fn(),
    delete: vi.fn(),
    clear: vi.fn(),
  },
  chat: {
    sendMessage: vi.fn(),
    sendMessageStream: vi.fn(),
    onStreamChunk: vi.fn(),
    onStreamEnd: vi.fn(),
    onStreamError: vi.fn(),
  },
  conversation: {
    list: vi.fn(),
    get: vi.fn(),
    create: vi.fn(),
    update: vi.fn(),
    delete: vi.fn(),
  },
};
// Mock the window.electron object
Object.defineProperty(window, 'electron', {
  value: mockElectron,
  writable: true,
});
// Reset all mocks before each test
export const resetMocks = () => {
  vi.clearAllMocks();
};
</file>

<file path="renderer/src/tests/utils/ipcMocks.ts">
import { mockElectronAPI } from '../setup/electronMocks';
import { ServiceName } from '../../types/services';
import { Mock } from 'vitest';
type ServiceMethod = (...args: any[]) => any;
type ServiceEvent = (callback: (data: any) => void) => () => void;
interface ServiceAPI {
  [key: string]: ServiceMethod | ServiceEvent;
}
type ElectronAPI = {
  [K in ServiceName]: ServiceAPI;
};
export const mockIpcResponse = {
  success: (service: ServiceName, method: string, data: any) => {
    const serviceAPI = mockElectronAPI[service] as ServiceAPI;
    const mock = serviceAPI[method] as Mock;
    if (mock) {
      mock.mockResolvedValue(data);
    }
  },
  error: (service: ServiceName, method: string, error: string) => {
    const serviceAPI = mockElectronAPI[service] as ServiceAPI;
    const mock = serviceAPI[method] as Mock;
    if (mock) {
      mock.mockRejectedValue(new Error(error));
    }
  },
  event: (service: ServiceName, event: string, data: any) => {
    const serviceAPI = mockElectronAPI[service] as ServiceAPI;
    const mock = serviceAPI[event] as Mock;
    if (mock) {
      mock.mockImplementation((callback: (data: any) => void) => {
        callback(data);
        return () => {}; // Return unsubscribe function
      });
    }
  }
};
</file>

<file path="renderer/src/tests/utils/serviceMocks.ts">
import { ServiceState, ServiceStatus } from '../../types/services';
export const createServiceState = (
  status: ServiceStatus,
  error?: string
): ServiceState => ({
  status,
  lastCheck: Date.now(),
  ...(error && { error })
});
export const mockServiceStates = {
  operational: () => createServiceState('operational'),
  degraded: (error: string) => createServiceState('degraded', error),
  unavailable: (error: string) => createServiceState('unavailable', error)
};
</file>

<file path="renderer/src/tests/build.test.tsx">
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { App } from '../App';
import { useServiceStatus } from '../hooks/useServiceStatus';
import { vi } from 'vitest';
import { ServiceName, ServiceState } from '../types/services';
vi.mock('../hooks/useServiceStatus');
describe('Build Process', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  it('renders the application with all components', () => {
    const mockServiceStatuses = new Map<ServiceName, ServiceState>([
      ['ollama', { status: 'unavailable', lastCheck: Date.now(), error: 'Connection failed' }],
      ['embedding', { status: 'unavailable', lastCheck: Date.now(), error: 'Service error' }],
      ['vectorStore', { status: 'unavailable', lastCheck: Date.now(), error: 'Timeout' }]
    ]);
    vi.mocked(useServiceStatus).mockReturnValue({
      serviceStatuses: mockServiceStatuses,
      toasts: [],
      removeToast: vi.fn(),
      retryService: vi.fn()
    });
    render(<App />);
    // Verify all main components are rendered
    expect(screen.getByText('Service Status')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Setup Guide' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Troubleshoot' })).toBeInTheDocument();
  });
  it('handles missing Ollama service gracefully', () => {
    const mockServiceStatuses = new Map<ServiceName, ServiceState>([
      ['ollama', { status: 'unavailable', lastCheck: Date.now(), error: 'Connection failed' }]
    ]);
    vi.mocked(useServiceStatus).mockReturnValue({
      serviceStatuses: mockServiceStatuses,
      toasts: [],
      removeToast: vi.fn(),
      retryService: vi.fn()
    });
    render(<App />);
    // Verify the application still renders
    expect(screen.getByText('Service Status')).toBeInTheDocument();
    // Verify the retry button is available
    const retryButton = screen.getByText('Retry');
    expect(retryButton).toBeInTheDocument();
  });
  it('displays appropriate error messages for each service', () => {
    const mockServiceStatuses = new Map<ServiceName, ServiceState>([
      ['ollama', { status: 'unavailable', lastCheck: Date.now(), error: 'Connection failed' }],
      ['embedding', { status: 'degraded', lastCheck: Date.now(), error: 'High latency' }],
      ['vectorStore', { status: 'unavailable', lastCheck: Date.now(), error: 'Timeout' }]
    ]);
    vi.mocked(useServiceStatus).mockReturnValue({
      serviceStatuses: mockServiceStatuses,
      toasts: [],
      removeToast: vi.fn(),
      retryService: vi.fn()
    });
    render(<App />);
    // Expand the service status panel
    fireEvent.click(screen.getByText('Service Status'));
    // Verify error messages are displayed
    expect(screen.getByText('Connection failed')).toBeInTheDocument();
    expect(screen.getByText('High latency')).toBeInTheDocument();
    expect(screen.getByText('Timeout')).toBeInTheDocument();
  });
});
</file>

<file path="renderer/src/tests/ipcServiceRecovery.test.tsx">
import { render, screen, waitFor } from '@testing-library/react';
import { describe, it, expect, beforeEach } from 'vitest';
import { ServiceStatusManager } from '../components/ServiceStatusManager';
import { mockElectron, resetMocks } from './utils/electronMock';
import { ServiceName, ServiceState } from '../types/services';
describe('IPC Service Recovery', () => {
  beforeEach(() => {
    resetMocks();
  });
  it('handles service recovery after failure', async () => {
    // Initial state: ollama service is down
    const initialStatuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'error', lastCheck: Date.now(), error: 'Connection failed' },
      embedding: { status: 'ok', lastCheck: Date.now(), error: '' },
      vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(initialStatuses);
    render(<ServiceStatusManager />);
    // Verify error state is shown
    await waitFor(() => {
      expect(screen.getByText(/ollama service is error/)).toBeInTheDocument();
    });
    // Simulate service recovery
    const recoveredStatuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'ok', lastCheck: Date.now(), error: '' },
      embedding: { status: 'ok', lastCheck: Date.now(), error: '' },
      vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(recoveredStatuses);
    // Wait for recovery
    await waitFor(() => {
      expect(screen.queryByText(/ollama service is error/)).not.toBeInTheDocument();
    });
  });
  it.skip('handles multiple service failures', async () => {
    // Initial state: multiple services down
    const initialStatuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'error', lastCheck: Date.now(), error: 'Connection failed' },
      embedding: { status: 'error', lastCheck: Date.now(), error: 'Service unavailable' },
      vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(initialStatuses);
    render(<ServiceStatusManager />);
    // Verify error states are shown
    await waitFor(() => {
      expect(screen.getByText(/ollama service is error/)).toBeInTheDocument();
      expect(screen.getByText(/embedding service is error/)).toBeInTheDocument();
    });
    // Simulate partial recovery
    const partialRecoveryStatuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'ok', lastCheck: Date.now(), error: '' },
      embedding: { status: 'error', lastCheck: Date.now(), error: 'Service unavailable' },
      vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(partialRecoveryStatuses);
    // Wait for partial recovery
    await waitFor(() => {
      expect(screen.queryByText(/ollama service is error/)).not.toBeInTheDocument();
      expect(screen.getByText(/embedding service is error/)).toBeInTheDocument();
    });
  });
  it.skip('handles service degradation', async () => {
    // Initial state: service is degraded
    const initialStatuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'degraded', lastCheck: Date.now(), error: 'High latency' },
      embedding: { status: 'ok', lastCheck: Date.now(), error: '' },
      vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(initialStatuses);
    render(<ServiceStatusManager />);
    // Verify degraded state is shown
    await waitFor(() => {
      expect(screen.getByText(/ollama service is degraded/)).toBeInTheDocument();
    });
    // Simulate recovery
    const recoveredStatuses: Record<ServiceName, ServiceState> = {
      ollama: { status: 'ok', lastCheck: Date.now(), error: '' },
      embedding: { status: 'ok', lastCheck: Date.now(), error: '' },
      vectorStore: { status: 'ok', lastCheck: Date.now(), error: '' },
      memory: { status: 'ok', lastCheck: Date.now(), error: '' }
    };
    mockElectron.ipc.invoke.mockResolvedValueOnce(recoveredStatuses);
    // Wait for recovery
    await waitFor(() => {
      expect(screen.queryByText(/ollama service is degraded/)).not.toBeInTheDocument();
    });
  });
});
</file>

<file path="renderer/src/tests/memoryManagement.test.tsx">

</file>

<file path="renderer/src/tests/serviceStatus.test.tsx">
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { ServiceStatusManager } from '../../components/ServiceStatusManager';
import { mockElectron, resetMocks } from './utils/electronMock';
import { ServiceName, ServiceState } from '../../types/services';
describe('ServiceStatusManager', () => {
  beforeEach(() => {
    resetMocks();
  });
  it('renders service status panel', () => {
    render(<ServiceStatusManager />);
    expect(screen.getByText('Service Status')).toBeInTheDocument();
  });
  it('shows toast notifications', async () => {
    const mockStatuses = new Map<ServiceName, ServiceState>([
      ['ollama', { status: 'error', lastCheck: Date.now(), error: 'Service unavailable' }],
      ['embedding', { status: 'ok', lastCheck: Date.now(), error: '' }],
    ]);
    mockElectron.ipc.invoke.mockResolvedValue(mockStatuses);
    render(<ServiceStatusManager />);
    await waitFor(() => {
      expect(screen.getByText('Ollama service is unavailable')).toBeInTheDocument();
    });
  });
  it('handles service retry', async () => {
    const mockStatuses = new Map<ServiceName, ServiceState>([
      ['ollama', { status: 'error', lastCheck: Date.now(), error: 'Service unavailable' }],
    ]);
    mockElectron.ipc.invoke.mockResolvedValue(mockStatuses);
    render(<ServiceStatusManager />);
    // Find the retry button for ollama service
    const retryButtons = screen.getAllByText('Retry');
    const ollamaRetryButton = retryButtons[0]; // First retry button is for ollama
    fireEvent.click(ollamaRetryButton);
    await waitFor(() => {
      expect(mockElectron.ipc.invoke).toHaveBeenCalledWith('app:retry-service', 'ollama');
    });
  });
  it('shows setup guide when requested', () => {
    render(<ServiceStatusManager />);
    const setupButton = screen.getByText('Setup Guide');
    fireEvent.click(setupButton);
    expect(screen.getByText('Setup Guide')).toBeInTheDocument();
  });
  it('shows troubleshooter when requested', () => {
    render(<ServiceStatusManager />);
    const troubleshootButton = screen.getByText('Troubleshoot');
    fireEvent.click(troubleshootButton);
    expect(screen.getByText('Troubleshoot')).toBeInTheDocument();
  });
});
</file>

<file path="renderer/src/tests/serviceStatusEdgeCases.test.tsx">
import React from 'react';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { ServiceStatusManager } from '../components/ServiceStatusManager';
import { useServiceStatus } from '../hooks/useServiceStatus';
import { vi } from 'vitest';
import { ServiceName, ServiceState, ServiceStatus } from '../types/services';
vi.mock('../hooks/useServiceStatus');
describe('ServiceStatusManager Edge Cases', () => {
  const mockRetryService = vi.fn();
  const mockRemoveToast = vi.fn();
  beforeEach(() => {
    vi.clearAllMocks();
  });
  it('handles rapid service status changes', async () => {
    const statusChanges: ServiceState[] = [
      { status: 'operational', lastCheck: Date.now() },
      { status: 'degraded', lastCheck: Date.now(), error: 'High latency' },
      { status: 'unavailable', lastCheck: Date.now(), error: 'Connection lost' },
      { status: 'operational', lastCheck: Date.now() }
    ];
    let currentStatusIndex = 0;
    const mockServiceStatuses = new Map<ServiceName, ServiceState>([
      ['ollama', statusChanges[currentStatusIndex]]
    ]);
    vi.mocked(useServiceStatus).mockReturnValue({
      serviceStatuses: mockServiceStatuses,
      toasts: [],
      removeToast: mockRemoveToast,
      retryService: mockRetryService
    });
    const { rerender } = render(<ServiceStatusManager />);
    // Simulate rapid status changes
    for (let i = 1; i < statusChanges.length; i++) {
      currentStatusIndex = i;
      mockServiceStatuses.set('ollama', statusChanges[i]);
      await act(async () => {
        rerender(<ServiceStatusManager />);
      });
    }
    // Verify the final state
    expect(screen.getByText('Service Status')).toBeInTheDocument();
  });
  it('handles multiple simultaneous service failures', async () => {
    const mockServiceStatuses = new Map<ServiceName, ServiceState>([
      ['ollama', { status: 'unavailable', lastCheck: Date.now(), error: 'Connection failed' }],
      ['embedding', { status: 'unavailable', lastCheck: Date.now(), error: 'Service error' }],
      ['vectorStore', { status: 'unavailable', lastCheck: Date.now(), error: 'Timeout' }]
    ]);
    const mockToasts = [
      {
        id: '1',
        message: 'Ollama service is unavailable',
        type: 'unavailable' as ServiceStatus
      },
      {
        id: '2',
        message: 'Embedding service is unavailable',
        type: 'unavailable' as ServiceStatus
      },
      {
        id: '3',
        message: 'Vector store is unavailable',
        type: 'unavailable' as ServiceStatus
      }
    ];
    vi.mocked(useServiceStatus).mockReturnValue({
      serviceStatuses: mockServiceStatuses,
      toasts: mockToasts,
      removeToast: mockRemoveToast,
      retryService: mockRetryService
    });
    render(<ServiceStatusManager />);
    // Expand the panel
    fireEvent.click(screen.getByText('Service Status'));
    // Verify all retry buttons are present
    const retryButtons = screen.getAllByText('Retry');
    expect(retryButtons).toHaveLength(3);
    // Test retry for each service
    for (const button of retryButtons) {
      fireEvent.click(button);
    }
    expect(mockRetryService).toHaveBeenCalledTimes(3);
  });
  it('handles toast removal during status changes', async () => {
    const mockToasts = [
      {
        id: '1',
        message: 'Ollama service is unavailable',
        type: 'unavailable' as ServiceStatus
      }
    ];
    vi.mocked(useServiceStatus).mockReturnValue({
      serviceStatuses: new Map<ServiceName, ServiceState>([
        ['ollama', { status: 'unavailable', lastCheck: Date.now(), error: 'Connection failed' }]
      ]),
      toasts: mockToasts,
      removeToast: mockRemoveToast,
      retryService: mockRetryService
    });
    render(<ServiceStatusManager />);
    // Remove toast
    const closeButton = screen.getByRole('button', { name: '' });
    fireEvent.click(closeButton);
    expect(mockRemoveToast).toHaveBeenCalledWith('1');
  });
});
</file>

<file path="renderer/src/tests/setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="renderer/src/utils/configValidation.ts">
import type { EmbeddingConfig } from '../types/embedding';
interface ValidationError {
  field: string;
  message: string;
}
export function validateConfig(config: Partial<EmbeddingConfig>): ValidationError[] {
  const errors: ValidationError[] = [];
  // Model parameters validation
  if (config.modelParameters) {
    const { temperature, topK, topP, contextWindow } = config.modelParameters;
    if (temperature !== undefined && (temperature < 0 || temperature > 1)) {
      errors.push({
        field: 'modelParameters.temperature',
        message: 'Temperature must be between 0 and 1',
      });
    }
    if (topK !== undefined && (topK < 1 || topK > 100)) {
      errors.push({
        field: 'modelParameters.topK',
        message: 'Top K must be between 1 and 100',
      });
    }
    if (topP !== undefined && (topP < 0 || topP > 1)) {
      errors.push({
        field: 'modelParameters.topP',
        message: 'Top P must be between 0 and 1',
      });
    }
    if (contextWindow !== undefined && (contextWindow < 512 || contextWindow > 8192)) {
      errors.push({
        field: 'modelParameters.contextWindow',
        message: 'Context window must be between 512 and 8192',
      });
    }
  }
  // Processing settings validation
  if (config.batchSize !== undefined && (config.batchSize < 1 || config.batchSize > 128)) {
    errors.push({
      field: 'batchSize',
      message: 'Batch size must be between 1 and 128',
    });
  }
  if (config.chunkSize !== undefined && (config.chunkSize < 100 || config.chunkSize > 2000)) {
    errors.push({
      field: 'chunkSize',
      message: 'Chunk size must be between 100 and 2000',
    });
  }
  if (config.chunkOverlap !== undefined && config.chunkSize !== undefined && 
      (config.chunkOverlap < 0 || config.chunkOverlap > config.chunkSize)) {
    errors.push({
      field: 'chunkOverlap',
      message: 'Chunk overlap must be between 0 and chunk size',
    });
  }
  // Cache settings validation
  if (config.cacheSize !== undefined && (config.cacheSize < 100 || config.cacheSize > 10000)) {
    errors.push({
      field: 'cacheSize',
      message: 'Cache size must be between 100 and 10000',
    });
  }
  if (config.cacheTTL !== undefined && (config.cacheTTL < 60 || config.cacheTTL > 86400)) {
    errors.push({
      field: 'cacheTTL',
      message: 'Cache TTL must be between 60 and 86400 seconds',
    });
  }
  // Performance settings validation
  if (config.maxConcurrentRequests !== undefined && (config.maxConcurrentRequests < 1 || config.maxConcurrentRequests > 16)) {
    errors.push({
      field: 'maxConcurrentRequests',
      message: 'Max concurrent requests must be between 1 and 16',
    });
  }
  if (config.timeout !== undefined && (config.timeout < 1000 || config.timeout > 60000)) {
    errors.push({
      field: 'timeout',
      message: 'Timeout must be between 1000 and 60000 milliseconds',
    });
  }
  // Quality settings validation
  if (config.minSimilarityThreshold !== undefined && (config.minSimilarityThreshold < 0 || config.minSimilarityThreshold > 1)) {
    errors.push({
      field: 'minSimilarityThreshold',
      message: 'Similarity threshold must be between 0 and 1',
    });
  }
  if (config.maxResults !== undefined && (config.maxResults < 1 || config.maxResults > 50)) {
    errors.push({
      field: 'maxResults',
      message: 'Max results must be between 1 and 50',
    });
  }
  return errors;
}
export function getConfigValidationMessage(errors: ValidationError[]): string {
  if (errors.length === 0) return '';
  return errors.map(error => `${error.field}: ${error.message}`).join('\n');
}
</file>

<file path="renderer/src/utils/performanceMonitor.ts">
interface PerformanceMetrics {
  embeddingTime: number;
  batchSize: number;
  tokensProcessed: number;
  cacheHits: number;
  cacheMisses: number;
  errorRate: number;
  timestamp: number;
}
interface PerformanceStats {
  averageEmbeddingTime: number;
  totalTokensProcessed: number;
  cacheHitRate: number;
  errorRate: number;
  lastUpdate: number;
}
class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];
  private readonly maxMetrics = 1000; // Keep last 1000 metrics
  private readonly stats: PerformanceStats = {
    averageEmbeddingTime: 0,
    totalTokensProcessed: 0,
    cacheHitRate: 0,
    errorRate: 0,
    lastUpdate: Date.now(),
  };
  recordMetrics(metrics: Omit<PerformanceMetrics, 'timestamp'>) {
    const newMetric: PerformanceMetrics = {
      ...metrics,
      timestamp: Date.now(),
    };
    this.metrics.push(newMetric);
    if (this.metrics.length > this.maxMetrics) {
      this.metrics.shift();
    }
    this.updateStats();
  }
  private updateStats() {
    if (this.metrics.length === 0) return;
    const recentMetrics = this.metrics.slice(-100); // Use last 100 metrics for stats
    const totalCacheHits = recentMetrics.reduce((sum, m) => sum + m.cacheHits, 0);
    const totalCacheMisses = recentMetrics.reduce((sum, m) => sum + m.cacheMisses, 0);
    const totalErrors = recentMetrics.reduce((sum, m) => sum + m.errorRate, 0);
    this.stats.averageEmbeddingTime =
      recentMetrics.reduce((sum, m) => sum + m.embeddingTime, 0) / recentMetrics.length;
    this.stats.totalTokensProcessed = recentMetrics.reduce((sum, m) => sum + m.tokensProcessed, 0);
    this.stats.cacheHitRate = totalCacheHits / (totalCacheHits + totalCacheMisses) || 0;
    this.stats.errorRate = totalErrors / recentMetrics.length;
    this.stats.lastUpdate = Date.now();
  }
  getStats(): PerformanceStats {
    return { ...this.stats };
  }
  getMetrics(): PerformanceMetrics[] {
    return [...this.metrics];
  }
  clear() {
    this.metrics = [];
    this.updateStats();
  }
}
export const performanceMonitor = new PerformanceMonitor();
</file>

<file path="renderer/src/utils/secureStorage.ts">
/**
 * Secure storage utility for sensitive data like API keys
 * Uses localStorage in development but should use more secure options in production
 */
import { SettingsError, SettingsErrorType } from '../types/settings';
/**
 * Interface for secure storage operations
 */
interface SecureStorage {
  getItem: (key: string) => Promise<string | null>;
  setItem: (key: string, value: string) => Promise<void>;
  removeItem: (key: string) => Promise<void>;
}
/**
 * LocalStorage implementation (for development)
 * WARNING: This is not secure for production use
 */
class LocalStorageAdapter implements SecureStorage {
  private prefix = 'osipelican_secure_';
  async getItem(key: string): Promise<string | null> {
    try {
      return localStorage.getItem(this.prefix + key);
    } catch (error) {
      console.error('LocalStorage getItem error:', error);
      throw new SettingsError(
        'Failed to retrieve data from storage',
        SettingsErrorType.STORAGE_ERROR
      );
    }
  }
  async setItem(key: string, value: string): Promise<void> {
    try {
      localStorage.setItem(this.prefix + key, value);
    } catch (error) {
      console.error('LocalStorage setItem error:', error);
      throw new SettingsError(
        'Failed to save data to storage',
        SettingsErrorType.STORAGE_ERROR
      );
    }
  }
  async removeItem(key: string): Promise<void> {
    try {
      localStorage.removeItem(this.prefix + key);
    } catch (error) {
      console.error('LocalStorage removeItem error:', error);
      throw new SettingsError(
        'Failed to remove data from storage',
        SettingsErrorType.STORAGE_ERROR
      );
    }
  }
}
/**
 * Electron secure storage implementation
 * Uses IPC to communicate with the main process for secure storage
 */
class ElectronSecureStorage implements SecureStorage {
  async getItem(key: string): Promise<string | null> {
    try {
      // Check if electronAPI is available
      if (!window.electronAPI) {
        throw new Error('Electron API not available');
      }
      // This assumes you've added a secureStorage API to your Electron preload script
      // You would need to implement this in your Electron main process
      return await window.electronAPI.secureStorage?.getItem(key) || null;
    } catch (error) {
      console.error('ElectronSecureStorage getItem error:', error);
      // Fall back to localStorage if Electron API fails
      return new LocalStorageAdapter().getItem(key);
    }
  }
  async setItem(key: string, value: string): Promise<void> {
    try {
      if (!window.electronAPI) {
        throw new Error('Electron API not available');
      }
      await window.electronAPI.secureStorage?.setItem(key, value);
    } catch (error) {
      console.error('ElectronSecureStorage setItem error:', error);
      // Fall back to localStorage if Electron API fails
      return new LocalStorageAdapter().setItem(key, value);
    }
  }
  async removeItem(key: string): Promise<void> {
    try {
      if (!window.electronAPI) {
        throw new Error('Electron API not available');
      }
      await window.electronAPI.secureStorage?.removeItem(key);
    } catch (error) {
      console.error('ElectronSecureStorage removeItem error:', error);
      // Fall back to localStorage if Electron API fails
      return new LocalStorageAdapter().removeItem(key);
    }
  }
}
/**
 * Simple encryption/decryption for localStorage
 * NOTE: This is not truly secure, just obfuscation
 */
class EncryptedLocalStorage implements SecureStorage {
  private adapter = new LocalStorageAdapter();
  private encryptionKey = 'osipelican-local-encryption-key';
  private encrypt(text: string): string {
    // Simple XOR encryption (not secure, just obfuscation)
    const key = this.encryptionKey;
    let result = '';
    for (let i = 0; i < text.length; i++) {
      result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
    }
    return btoa(result); // Base64 encode
  }
  private decrypt(encoded: string): string {
    try {
      const text = atob(encoded); // Base64 decode
      const key = this.encryptionKey;
      let result = '';
      for (let i = 0; i < text.length; i++) {
        result += String.fromCharCode(text.charCodeAt(i) ^ key.charCodeAt(i % key.length));
      }
      return result;
    } catch (error) {
      console.error('Decryption error:', error);
      return '';
    }
  }
  async getItem(key: string): Promise<string | null> {
    const encrypted = await this.adapter.getItem(key);
    if (!encrypted) return null;
    return this.decrypt(encrypted);
  }
  async setItem(key: string, value: string): Promise<void> {
    const encrypted = this.encrypt(value);
    await this.adapter.setItem(key, encrypted);
  }
  async removeItem(key: string): Promise<void> {
    await this.adapter.removeItem(key);
  }
}
// Choose the appropriate storage implementation
// In a real app, you would use ElectronSecureStorage in production
// and possibly EncryptedLocalStorage or LocalStorageAdapter in development
let secureStorage: SecureStorage;
if (typeof window !== 'undefined' && window.electronAPI?.secureStorage) {
  secureStorage = new ElectronSecureStorage();
} else if (typeof window !== 'undefined') {
  // Use encrypted localStorage as fallback
  secureStorage = new EncryptedLocalStorage();
} else {
  // For SSR or environments without window
  secureStorage = {
    getItem: async () => null,
    setItem: async () => {},
    removeItem: async () => {}
  };
}
export default secureStorage;
</file>

<file path="renderer/src/App.tsx">
import React, { useEffect } from 'react';
import { AppLayout } from './components/layout/AppLayout';
import { OllamaConnectionNotification } from './components/OllamaConnectionNotification';
import type { OllamaModel, ModelLoadingState, OllamaConnectionStatus } from '@shared/types/ollama';
import type { ServiceName } from './types/services';
interface ElectronAPI {
  ipc: {
    invoke: <T = any>(channel: string, ...args: any[]) => Promise<T>;
    on: (channel: string, callback: (...args: any[]) => void) => () => void;
    once: (channel: string, callback: (...args: any[]) => void) => void;
    removeListener: (channel: string, callback: (...args: any[]) => void) => () => void;
    removeAllListeners: (channel: string) => void;
  };
  ollama: {
    listModels: () => Promise<{ models: OllamaModel[] }>;
    setModel: (modelName: string) => Promise<void>;
    checkConnection: () => Promise<OllamaConnectionStatus>;
    cancelLoad: () => Promise<void>;
    saveConfig: (config: { model: string }) => Promise<void>;
    onModelLoadingStateChanged: (callback: (state: ModelLoadingState) => void) => () => void;
  };
  vectorStore: {
    search: (query: string) => Promise<any>;
    add: (doc: { id: string; content: string }) => Promise<void>;
    delete: (id: string) => Promise<void>;
    clear: () => Promise<void>;
    stats: () => Promise<any>;
  };
  app: {
    healthCheck: () => Promise<void>;
    retryService: (serviceName: ServiceName) => Promise<void>;
    showSetupGuide: () => Promise<void>;
    showTroubleshooter: () => Promise<void>;
  };
  memory: {
    stats: () => Promise<void>;
    reset: () => Promise<void>;
  };
  getServiceStatus: (service: string) => Promise<any>;
  getAllServiceStatus: () => Promise<Map<string, any>>;
  restartService: (service: string) => Promise<void>;
  onServiceStatusChange: (callback: (event: any) => void) => () => void;
}
declare global {
  interface Window {
    electronAPI: ElectronAPI;
  }
}
export function App() {
  useEffect(() => {
    console.log('window.electronAPI:', window.electronAPI);
  }, []);
  return (
    <>
      <OllamaConnectionNotification />
      <AppLayout />
    </>
  );
}
</file>

<file path="renderer/src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
import { ThemeProvider } from './contexts/ThemeContext';
import { Toaster } from 'react-hot-toast';
import './styles/index.css';
import './styles/test.css'; // Import test CSS file to verify extraction
console.log('[DEBUG] main.tsx started');
const rootElement = document.getElementById('root');
console.log('[DEBUG] Root DOM:', rootElement);
if (!rootElement) {
  console.error('[ERROR] Root element not found!');
  throw new Error('Root element not found');
}
// Create a single root
const root = ReactDOM.createRoot(rootElement);
// Import ErrorBoundary
import { ErrorBoundary } from './components/ErrorBoundary';
// Render with error handling
try {
  console.log('[DEBUG] Attempting to render React app');
  root.render(
    <React.StrictMode>
      <ErrorBoundary>
        <ThemeProvider>
          <App />
          <Toaster position="bottom-right" />
        </ThemeProvider>
      </ErrorBoundary>
    </React.StrictMode>
  );
  console.log('[DEBUG] React app rendered successfully');
} catch (error) {
  console.error('[ERROR] Failed to render React app:', error);
}
</file>

<file path="renderer/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HelloGPT</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="renderer/package.json">
{
  "name": "renderer",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "description": "HelloGPT Renderer Process",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:no-types": "vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "test": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@electron-app/types": "file:../../packages/main",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-scroll-area": "1.2.9",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-toast": "^1.1.5",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "date-fns": "4.1.0",
    "framer-motion": "12.16.0",
    "lucide-react": "^0.323.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^9.0.1",
    "react-syntax-highlighter": "^15.5.0",
    "rehype-raw": "7.0.0",
    "remark-gfm": "4.0.1",
    "tailwind-merge": "^2.2.1",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@types/node": "^20.11.19",
    "@types/react": "^18.2.55",
    "@types/react-dom": "^18.2.19",
    "@types/react-syntax-highlighter": "^15.5.11",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "@vitejs/plugin-react": "^4.2.1",
    "@vitest/coverage-v8": "^1.2.2",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "jsdom": "^24.0.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.2.2",
    "vite": "^5.1.0",
    "vitest": "^1.2.2"
  }
}
</file>

<file path="renderer/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="renderer/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      fontFamily: {
        sans: [
          'SF Pro Display',
          'SF Pro',
          'system-ui',
          '-apple-system',
          'BlinkMacSystemFont',
          'Segoe UI',
          'Roboto',
          'Helvetica Neue',
          'Arial',
          'sans-serif'
        ],
      },
      spacing: {
        '4.5': '1.125rem', // 18px
        '5.5': '1.375rem', // 22px
        '6.5': '1.625rem', // 26px
        '7.5': '1.875rem', // 30px
      },
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        coral: {
          DEFAULT: 'hsl(var(--coral))',
          foreground: 'hsl(var(--coral-foreground))',
        },
        mint: {
          DEFAULT: 'hsl(var(--mint))',
          foreground: 'hsl(var(--mint-foreground))',
        },
      },
      borderRadius: {
        '4xl': '2rem',
        '3xl': '1.5rem',
        '2xl': '1.25rem',
        xl: '1rem',
        lg: '0.75rem',
        md: '0.5rem',
        sm: '0.375rem',
        DEFAULT: '0.25rem',
      },
      boxShadow: {
        'glass': '0 8px 32px 0 rgba(31, 38, 135, 0.07)',
        'glass-hover': '0 8px 32px 0 rgba(31, 38, 135, 0.12)',
        'glass-press': '0 4px 16px 0 rgba(31, 38, 135, 0.15)',
        'elevation-1': '0 1px 2px 0 rgb(0 0 0 / 0.05)',
        'elevation-2': '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
        'elevation-3': '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
        'elevation-4': '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
      },
      backdropBlur: {
        'glass': '12px',
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'button-press': 'button-press 0.2s ease-out',
        'fade-in': 'fade-in 0.2s ease-out',
        'fade-out': 'fade-out 0.2s ease-out',
        'slide-in': 'slide-in 0.3s ease-out',
        'slide-out': 'slide-out 0.3s ease-out',
        'typing': 'typing 1s steps(3) infinite',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        'button-press': {
          '0%': { transform: 'scale(1)' },
          '50%': { transform: 'scale(0.98)' },
          '100%': { transform: 'scale(1)' },
        },
        'fade-in': {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        'fade-out': {
          '0%': { opacity: '1' },
          '100%': { opacity: '0' },
        },
        'slide-in': {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        'slide-out': {
          '0%': { transform: 'translateY(0)', opacity: '1' },
          '100%': { transform: 'translateY(10px)', opacity: '0' },
        },
        'typing': {
          '0%': { content: '""' },
          '25%': { content: '"."' },
          '50%': { content: '".."' },
          '75%': { content: '"..."' },
        },
      },
      transitionTimingFunction: {
        'ease-out-expo': 'cubic-bezier(0.16, 1, 0.3, 1)',
      },
    },
  },
  plugins: [],
}
</file>

<file path="renderer/tsconfig.json">
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@electron-app/*": ["../electron-app/src/*"],
      "@shared/*": ["../packages/shared/*"]
    }
  },
  "include": [
    "src",
    "../electron-app/src/types",
    "../packages/shared/types/**/*"
  ],
  "references": [
    { "path": "./tsconfig.node.json" },
    { "path": "../packages/shared" }
  ],
  "composite": true
}
</file>

<file path="renderer/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="renderer/vite.config.d.ts">
declare const _default: import("vite").UserConfig;
export default _default;
</file>

<file path="renderer/vite.config.js">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
// https://vitejs.dev/config/
export default defineConfig({
    plugins: [react()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src')
        }
    },
    build: {
        outDir: 'dist',
        emptyOutDir: true,
        // Ensure CSS is output as separate files
        cssCodeSplit: true,
        // Configure rollup options for better CSS handling
        rollupOptions: {
            output: {
                // Configure asset file names
                assetFileNames: function (assetInfo) {
                    var name = assetInfo.name || '';
                    if (/\.(css|scss|sass|less|styl)$/.test(name)) {
                        return "assets/css/[name]-[hash][extname]";
                    }
                    return "assets/[name]-[hash][extname]";
                },
                // Configure chunk file names
                chunkFileNames: 'assets/js/[name]-[hash].js',
                // Configure entry file names
                entryFileNames: 'assets/js/[name]-[hash].js',
            }
        }
    },
    // Configure CSS options
    css: {
        // Ensure CSS modules work correctly
        modules: {
            localsConvention: 'camelCase',
            generateScopedName: '[name]__[local]___[hash:base64:5]',
        },
        // Ensure CSS is extracted
        devSourcemap: true,
        // Use postcss for processing
        postcss: './postcss.config.js',
    },
    server: {
        port: 5173,
        strictPort: true
    },
    base: process.env.NODE_ENV === 'development' ? '/' : './'
});
</file>

<file path="renderer/vite.config.ts">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  build: {
    outDir: 'dist',
    emptyOutDir: true,
    // Ensure CSS is output as separate files
    cssCodeSplit: true,
    // Configure rollup options for better CSS handling
    rollupOptions: {
      output: {
        // Configure asset file names
        assetFileNames: (assetInfo) => {
          const name = assetInfo.name || '';
          if (/\.(css|scss|sass|less|styl)$/.test(name)) {
            return `assets/css/[name]-[hash][extname]`;
          }
          return `assets/[name]-[hash][extname]`;
        },
        // Configure chunk file names
        chunkFileNames: 'assets/js/[name]-[hash].js',
        // Configure entry file names
        entryFileNames: 'assets/js/[name]-[hash].js',
      }
    }
  },
  // Configure CSS options
  css: {
    // Ensure CSS modules work correctly
    modules: {
      localsConvention: 'camelCase',
      generateScopedName: '[name]__[local]___[hash:base64:5]',
    },
    // Ensure CSS is extracted
    devSourcemap: true,
    // Use postcss for processing
    postcss: './postcss.config.js',
  },
  server: {
    port: 5173,
    strictPort: true
  },
  base: process.env.NODE_ENV === 'development' ? '/' : './'
});
</file>

<file path="renderer/vitest.config.ts">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./src/tests/setup.ts'],
    include: ['src/**/*.test.{ts,tsx}'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      include: ['src/**/*.{ts,tsx}'],
      exclude: ['src/**/*.test.{ts,tsx}', 'src/tests/**/*']
    }
  }
});
</file>

<file path="scripts/consolidate-dependencies.js">
#!/usr/bin/env node
/**
 * This script analyzes all package.json files in the project and generates a report
 * of duplicate dependencies with different versions, helping to consolidate them.
 */
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
// Paths to check for package.json files
const rootDir = path.resolve(__dirname, '..');
const packageJsonPaths = [
  path.join(rootDir, 'package.json'),
  path.join(rootDir, 'electron-app', 'package.json'),
  path.join(rootDir, 'renderer', 'package.json'),
];
// Additional paths that might contain package.json files
const additionalDirs = [
  path.join(rootDir, 'packages'),
];
// Find all package.json files in additional directories
additionalDirs.forEach(dir => {
  if (fs.existsSync(dir)) {
    const subdirs = fs.readdirSync(dir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => path.join(dir, dirent.name));
    subdirs.forEach(subdir => {
      const packageJsonPath = path.join(subdir, 'package.json');
      if (fs.existsSync(packageJsonPath)) {
        packageJsonPaths.push(packageJsonPath);
      }
    });
  }
});
// Store all dependencies
const allDependencies = {};
const packageNames = {};
// Read all package.json files and collect dependencies
packageJsonPaths.forEach(packageJsonPath => {
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const packageName = packageJson.name || path.relative(rootDir, packageJsonPath);
      packageNames[packageJsonPath] = packageName;
      // Process dependencies
      ['dependencies', 'devDependencies'].forEach(depType => {
        if (packageJson[depType]) {
          Object.entries(packageJson[depType]).forEach(([dep, version]) => {
            if (!allDependencies[dep]) {
              allDependencies[dep] = [];
            }
            allDependencies[dep].push({
              package: packageName,
              path: packageJsonPath,
              version,
              type: depType
            });
          });
        }
      });
    } catch (error) {
      console.error(`Error processing ${packageJsonPath}:`, error.message);
    }
  }
});
// Find duplicates with different versions
const duplicatesWithDifferentVersions = {};
Object.entries(allDependencies).forEach(([dep, instances]) => {
  const versions = new Set(instances.map(i => i.version));
  if (versions.size > 1) {
    duplicatesWithDifferentVersions[dep] = instances;
  }
});
// Generate report
console.log('# Dependency Consolidation Report\n');
console.log('## Packages Analyzed\n');
Object.entries(packageNames).forEach(([path, name]) => {
  console.log(`- ${name} (${path})`);
});
console.log('\n## Dependencies with Different Versions\n');
if (Object.keys(duplicatesWithDifferentVersions).length === 0) {
  console.log('No dependencies with different versions found. Great job!');
} else {
  Object.entries(duplicatesWithDifferentVersions).forEach(([dep, instances]) => {
    console.log(`### ${dep}\n`);
    instances.forEach(instance => {
      console.log(`- ${instance.package}: ${instance.version} (${instance.type})`);
    });
    // Recommend latest version
    const versions = instances.map(i => i.version.replace(/[^0-9.]/g, ''));
    const latestVersion = versions.sort((a, b) => {
      const aParts = a.split('.').map(Number);
      const bParts = b.split('.').map(Number);
      for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
        const aPart = aParts[i] || 0;
        const bPart = bParts[i] || 0;
        if (aPart !== bPart) {
          return bPart - aPart;
        }
      }
      return 0;
    })[0];
    console.log(`\nRecommended version: ${latestVersion}\n`);
  });
}
// Save report to file
const reportPath = path.join(rootDir, 'dependency-report.md');
fs.writeFileSync(reportPath, 
  `# Dependency Consolidation Report
## Packages Analyzed
${Object.entries(packageNames).map(([path, name]) => `- ${name} (${path})`).join('\n')}
## Dependencies with Different Versions
${Object.keys(duplicatesWithDifferentVersions).length === 0 ? 
  'No dependencies with different versions found. Great job!' : 
  Object.entries(duplicatesWithDifferentVersions).map(([dep, instances]) => 
    `### ${dep}\n\n${instances.map(instance => 
      `- ${instance.package}: ${instance.version} (${instance.type})`
    ).join('\n')}\n\nRecommended version: ${
      instances.map(i => i.version.replace(/[^0-9.]/g, '')).sort((a, b) => {
        const aParts = a.split('.').map(Number);
        const bParts = b.split('.').map(Number);
        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
          const aPart = aParts[i] || 0;
          const bPart = bParts[i] || 0;
          if (aPart !== bPart) {
            return bPart - aPart;
          }
        }
        return 0;
      })[0]
    }`
  ).join('\n\n')
}`
);
console.log(`\nReport saved to ${reportPath}`);
// Make the script executable
try {
  execSync(`chmod +x "${path.join(__dirname, 'consolidate-dependencies.js')}"`);
} catch (error) {
  console.error('Failed to make script executable:', error.message);
}
</file>

<file path="scripts/test-build.sh">
#!/bin/bash
# Exit on error
set -e
echo "Starting full build test..."
# Clean previous build
echo "Cleaning previous build..."
rm -rf dist/
rm -rf node_modules/
# Install dependencies
echo "Installing dependencies..."
npm install
# Run type checking
echo "Running type checking..."
npm run type-check
# Run linting
echo "Running linting..."
npm run lint
# Run tests
echo "Running tests..."
npm test
# Build the application
echo "Building the application..."
npm run build
# Start the application in test mode
echo "Starting the application in test mode..."
npm run start:test &
# Wait for the application to start
sleep 5
# Check if the application is running
if ! pgrep -f "electron" > /dev/null; then
    echo "Error: Application failed to start"
    exit 1
fi
echo "Application started successfully"
# Test service status
echo "Testing service status..."
curl -s http://localhost:3000/api/health | grep -q "status"
# Test Ollama service
echo "Testing Ollama service..."
curl -s http://localhost:3000/api/ollama/status | grep -q "status"
# Kill the test process
pkill -f "electron"
echo "Full build test completed successfully!"
</file>

<file path="src/app/api/og/fetch/route.ts">
import { NextResponse } from "next/server";
export const runtime = "edge";
function decodeHTMLEntities(text: string): string {
  return text.replace(/&(#?[a-zA-Z0-9]+);/g, (match, entity) => {
    const entities: { [key: string]: string } = {
      amp: "&",
      lt: "<",
      gt: ">",
      quot: '"',
      apos: "'",
      "#x27": "'",
      "#39": "'",
      "#x26": "&",
      "#38": "&",
    };
    if (entity.startsWith("#")) {
      const code = entity.startsWith("#x")
        ? parseInt(entity.slice(2), 16)
        : parseInt(entity.slice(1), 10);
      return String.fromCharCode(code);
    }
    return entities[entity] || match;
  });
}
async function fetchWithTimeout(url: string, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, {
      signal: controller.signal,
      headers: {
        "User-Agent": "bot",
      },
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}
async function extractMetadata(html: string) {
  const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
  const descMatch =
    html.match(/<meta[^>]*name="description"[^>]*content="([^"]+)"[^>]*>/i) ||
    html.match(/<meta[^>]*content="([^"]+)"[^>]*name="description"[^>]*>/i) ||
    html.match(/<meta[^>]*property="og:description"[^>]*content="([^"]+)"[^>]*>/i);
  const imageMatch =
    html.match(/<meta[^>]*property="og:image"[^>]*content="([^"]+)"[^>]*>/i) ||
    html.match(/<meta[^>]*content="([^"]+)"[^>]*property="og:image"[^>]*>/i);
  const title = titleMatch?.[1]?.trim() || "";
  const description = descMatch?.[1]?.trim() || "";
  const image = imageMatch?.[1]?.trim() || "";
  return {
    title: decodeHTMLEntities(title),
    description: decodeHTMLEntities(description),
    image: image,
  };
}
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const url = searchParams.get("url");
  if (!url) {
    return NextResponse.json({ error: "URL is required" }, { status: 400 });
  }
  try {
    const response = await fetchWithTimeout(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch URL: ${response.status}`);
    }
    const html = await response.text();
    const metadata = await extractMetadata(html);
    return NextResponse.json({
      ...metadata,
      url,
    });
  } catch (error) {
    console.error(
      "Error fetching metadata:",
      error instanceof Error ? error.message : String(error),
    );
    return NextResponse.json(
      {
        error: "Failed to fetch metadata",
        message: error instanceof Error ? error.message : "Unknown error occurred",
      },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/og/proxy/route.ts">
import { NextRequest, NextResponse } from "next/server";
export async function GET(request: NextRequest) {
  try {
    // Get the URL parameter
    const url = new URL(request.url);
    const imageUrl = url.searchParams.get("url");
    if (!imageUrl) {
      return NextResponse.json({ error: "Missing URL parameter" }, { status: 400 });
    }
    // Fetch the image
    const response = await fetch(imageUrl, {
      headers: {
        "User-Agent": "Mozilla/5.0 (compatible; ImageProxy/1.0)",
      },
    });
    if (!response.ok) {
      return NextResponse.json(
        { error: `Failed to fetch image: ${response.status}` },
        { status: response.status },
      );
    }
    // Get the image data
    const contentType = response.headers.get("content-type") || "image/jpeg";
    const imageData = await response.arrayBuffer();
    // Return the image with appropriate headers
    return new NextResponse(imageData, {
      headers: {
        "Content-Type": contentType,
        "Cache-Control": "public, max-age=86400",
      },
    });
  } catch (error) {
    console.error("Error proxying image:", error);
    return NextResponse.json({ error: "Failed to proxy image" }, { status: 500 });
  }
}
</file>

<file path="src/app/resources/data.config.js">
const chart = {
  variant: "gradient", // flat | gradient | outline
  mode: "categorical", // categorical | divergent | sequential
  height: 24, // default chart height
  axisLine: {
    stroke: "var(--neutral-alpha-weak)",
  },
  tick: {
    fill: "var(--neutral-on-background-weak)",
    fontSize: 11,
  },
  tickLine: false,
};
export { chart };
</file>

<file path="src/app/resources/once-ui.config.js">
// IMPORTANT: Replace with your own domain address - it's used for SEO in meta tags and schema
const baseURL = "https://demo.once-ui.com";
// Import and set font for each variant
import { Geist } from "next/font/google";
import { Geist_Mono } from "next/font/google";
const primaryFont = Geist({
  variable: "--font-primary",
  subsets: ["latin"],
  display: "swap",
});
const monoFont = Geist_Mono({
  variable: "--font-code",
  subsets: ["latin"],
  display: "swap",
});
const font = {
  primary: primaryFont,
  secondary: primaryFont,
  tertiary: primaryFont,
  code: monoFont,
};
// default customization applied to the HTML in the main layout.tsx
const style = {
  theme: "dark", // dark | light - not needed when using ThemeProvider
  neutral: "gray", // sand | gray | slate
  brand: "blue", // blue | indigo | violet | magenta | pink | red | orange | yellow | moss | green | emerald | aqua | cyan
  accent: "indigo", // blue | indigo | violet | magenta | pink | red | orange | yellow | moss | green | emerald | aqua | cyan
  solid: "contrast", // color | contrast | inverse
  solidStyle: "flat", // flat | plastic
  border: "playful", // rounded | playful | conservative
  surface: "filled", // filled | translucent
  transition: "all", // all | micro | macro
  scaling: "100", // 90 | 95 | 100 | 105 | 110
};
const effects = {
  mask: {
    cursor: false,
    x: 50,
    y: 0,
    radius: 100,
  },
  gradient: {
    display: false,
    x: 50,
    y: 0,
    width: 100,
    height: 100,
    tilt: 0,
    colorStart: "brand-background-strong",
    colorEnd: "static-transparent",
    opacity: 50,
  },
  dots: {
    display: true,
    size: "2",
    color: "brand-on-background-weak",
    opacity: 40,
  },
  lines: {
    display: false,
    color: "neutral-alpha-weak",
    opacity: 100,
    thickness: 1,
    angle: 45,
    size: "8",
  },
  grid: {
    display: false,
    color: "neutral-alpha-weak",
    opacity: 100,
    width: "2",
    height: "2",
  },
};
// metadata for pages
const meta = {
  home: {
    path: "/",
    title: "Once UI for Next.js",
    description:
      "An open-source design system and component library for Next.js that emphasizes easy styling and accessibility in UI development.",
    image: "/og/home.jpg",
    canonical: "https://once-ui.com",
    robots: "index,follow",
    alternates: [{ href: "https://once-ui.com", hrefLang: "en" }],
  },
  // add more routes and reference them in page.tsx
};
// default schema data
const schema = {
  logo: "",
  type: "Organization",
  name: "Once UI",
  description: meta.home.description,
  email: "lorant@once-ui.com",
};
// social links
const social = {
  twitter: "https://www.twitter.com/_onceui",
  linkedin: "https://www.linkedin.com/company/once-ui/",
  discord: "https://discord.com/invite/5EyAQ4eNdS",
};
export { baseURL, font, style, meta, schema, social, effects };
</file>

<file path="src/config/embeddingPresets.d.ts">
import type { EmbeddingConfig } from '../services/EmbeddingService';
export declare const CHATGPT_PRESETS: {
    readonly BALANCED: EmbeddingConfig;
    readonly FOCUSED: EmbeddingConfig;
    readonly CREATIVE: EmbeddingConfig;
    readonly PRECISE: EmbeddingConfig;
};
</file>

<file path="src/config/embeddingPresets.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CHATGPT_PRESETS = void 0;
const BALANCED_PRESET = {
    model: 'nomic-embed-text',
    modelParameters: {
        temperature: 0.7,
        topK: 40,
        topP: 0.9,
        contextWindow: 4096,
        repeatPenalty: 1.1,
        presencePenalty: 0.0,
        frequencyPenalty: 0.0,
        mirostatMode: 1,
        mirostatTau: 5.0,
        mirostatEta: 0.1,
    },
    batchSize: 32,
    normalize: true,
    truncateStrategy: 'NONE',
    maxTokens: 4096,
    chunkSize: 1000,
    chunkOverlap: 200,
    chunkStrategy: 'SENTENCE',
    enableCache: true,
    cacheSize: 2000,
    cacheTTL: 3600,
    parallelProcessing: true,
    maxConcurrentRequests: 4,
    timeout: 30000,
    minSimilarityThreshold: 0.7,
    maxResults: 5,
    rerankResults: true,
};
exports.CHATGPT_PRESETS = {
    BALANCED: BALANCED_PRESET,
    FOCUSED: {
        ...BALANCED_PRESET,
        modelParameters: {
            ...BALANCED_PRESET.modelParameters,
            temperature: 0.3,
            topK: 20,
            topP: 0.95,
        },
        minSimilarityThreshold: 0.8,
        maxResults: 3,
    },
    CREATIVE: {
        ...BALANCED_PRESET,
        modelParameters: {
            ...BALANCED_PRESET.modelParameters,
            temperature: 0.9,
            topK: 60,
            topP: 0.85,
        },
        minSimilarityThreshold: 0.6,
        maxResults: 8,
    },
    PRECISE: {
        ...BALANCED_PRESET,
        modelParameters: {
            ...BALANCED_PRESET.modelParameters,
            temperature: 0.2,
            topK: 10,
            topP: 0.98,
        },
        minSimilarityThreshold: 0.9,
        maxResults: 2,
    },
};
//# sourceMappingURL=embeddingPresets.js.map
</file>

<file path="src/config/embeddingPresets.js.map">
{"version":3,"file":"embeddingPresets.js","sourceRoot":"","sources":["embeddingPresets.ts"],"names":[],"mappings":";;;AAEA,MAAM,eAAe,GAAoB;IACvC,KAAK,EAAE,kBAAkB;IACzB,eAAe,EAAE;QACf,WAAW,EAAE,GAAG;QAChB,IAAI,EAAE,EAAE;QACR,IAAI,EAAE,GAAG;QACT,aAAa,EAAE,IAAI;QACnB,aAAa,EAAE,GAAG;QAClB,eAAe,EAAE,GAAG;QACpB,gBAAgB,EAAE,GAAG;QACrB,YAAY,EAAE,CAAC;QACf,WAAW,EAAE,GAAG;QAChB,WAAW,EAAE,GAAG;KACjB;IACD,SAAS,EAAE,EAAE;IACb,SAAS,EAAE,IAAI;IACf,gBAAgB,EAAE,MAAM;IACxB,SAAS,EAAE,IAAI;IACf,SAAS,EAAE,IAAI;IACf,YAAY,EAAE,GAAG;IACjB,aAAa,EAAE,UAAU;IACzB,WAAW,EAAE,IAAI;IACjB,SAAS,EAAE,IAAI;IACf,QAAQ,EAAE,IAAI;IACd,kBAAkB,EAAE,IAAI;IACxB,qBAAqB,EAAE,CAAC;IACxB,OAAO,EAAE,KAAK;IACd,sBAAsB,EAAE,GAAG;IAC3B,UAAU,EAAE,CAAC;IACb,aAAa,EAAE,IAAI;CACpB,CAAC;AAEW,QAAA,eAAe,GAAG;IAC7B,QAAQ,EAAE,eAAe;IAEzB,OAAO,EAAE;QACP,GAAG,eAAe;QAClB,eAAe,EAAE;YACf,GAAG,eAAe,CAAC,eAAe;YAClC,WAAW,EAAE,GAAG;YAChB,IAAI,EAAE,EAAE;YACR,IAAI,EAAE,IAAI;SACX;QACD,sBAAsB,EAAE,GAAG;QAC3B,UAAU,EAAE,CAAC;KACK;IAEpB,QAAQ,EAAE;QACR,GAAG,eAAe;QAClB,eAAe,EAAE;YACf,GAAG,eAAe,CAAC,eAAe;YAClC,WAAW,EAAE,GAAG;YAChB,IAAI,EAAE,EAAE;YACR,IAAI,EAAE,IAAI;SACX;QACD,sBAAsB,EAAE,GAAG;QAC3B,UAAU,EAAE,CAAC;KACK;IAEpB,OAAO,EAAE;QACP,GAAG,eAAe;QAClB,eAAe,EAAE;YACf,GAAG,eAAe,CAAC,eAAe;YAClC,WAAW,EAAE,GAAG;YAChB,IAAI,EAAE,EAAE;YACR,IAAI,EAAE,IAAI;SACX;QACD,sBAAsB,EAAE,GAAG;QAC3B,UAAU,EAAE,CAAC;KACK;CACZ,CAAC"}
</file>

<file path="src/config/embeddingPresets.ts">
import type { EmbeddingConfig } from '../services/EmbeddingService';
const BALANCED_PRESET: EmbeddingConfig = {
  model: 'nomic-embed-text',
  modelParameters: {
    temperature: 0.7,
    topK: 40,
    topP: 0.9,
    contextWindow: 4096,
    repeatPenalty: 1.1,
    presencePenalty: 0.0,
    frequencyPenalty: 0.0,
    mirostatMode: 1,
    mirostatTau: 5.0,
    mirostatEta: 0.1,
  },
  batchSize: 32,
  normalize: true,
  truncateStrategy: 'NONE',
  maxTokens: 4096,
  chunkSize: 1000,
  chunkOverlap: 200,
  chunkStrategy: 'SENTENCE',
  enableCache: true,
  cacheSize: 2000,
  cacheTTL: 3600,
  parallelProcessing: true,
  maxConcurrentRequests: 4,
  timeout: 30000,
  minSimilarityThreshold: 0.7,
  maxResults: 5,
  rerankResults: true,
};
export const CHATGPT_PRESETS = {
  BALANCED: BALANCED_PRESET,
  FOCUSED: {
    ...BALANCED_PRESET,
    modelParameters: {
      ...BALANCED_PRESET.modelParameters,
      temperature: 0.3,
      topK: 20,
      topP: 0.95,
    },
    minSimilarityThreshold: 0.8,
    maxResults: 3,
  } as EmbeddingConfig,
  CREATIVE: {
    ...BALANCED_PRESET,
    modelParameters: {
      ...BALANCED_PRESET.modelParameters,
      temperature: 0.9,
      topK: 60,
      topP: 0.85,
    },
    minSimilarityThreshold: 0.6,
    maxResults: 8,
  } as EmbeddingConfig,
  PRECISE: {
    ...BALANCED_PRESET,
    modelParameters: {
      ...BALANCED_PRESET.modelParameters,
      temperature: 0.2,
      topK: 10,
      topP: 0.98,
    },
    minSimilarityThreshold: 0.9,
    maxResults: 2,
  } as EmbeddingConfig,
} as const;
</file>

<file path="src/config/services.d.ts">
export declare const SERVICE_CONFIG: {
    readonly ollama: {
        readonly basePath: string;
        readonly modelsPath: string;
        readonly configPath: string;
        readonly defaultModel: "llama2";
        readonly apiEndpoint: "http://localhost:11434";
        readonly timeout: 30000;
        readonly maxRetries: 3;
        readonly retryDelay: 1000;
        readonly healthCheckInterval: 5000;
    };
    readonly chroma: {
        readonly dataPath: string;
        readonly collectionName: "documents";
        readonly embeddingDimension: 1536;
        readonly apiEndpoint: "http://localhost:8000";
        readonly timeout: 30000;
        readonly healthCheckInterval: 5000;
    };
    readonly app: {
        readonly userData: string;
        readonly logs: string;
        readonly temp: string;
        readonly cache: string;
    };
    readonly status: {
        readonly checkInterval: 5000;
        readonly timeout: 5000;
        readonly maxRetries: 3;
    };
};
export type ServiceConfig = typeof SERVICE_CONFIG;
export declare const getServicePath: (service: keyof typeof SERVICE_CONFIG) => string;
export declare const ensureServiceDirectories: () => void;
export declare const HEALTH_CHECK_CONFIG: {
    readonly ollama: {
        readonly endpoint: "http://localhost:11434/api/health";
        readonly timeout: 30000;
    };
    readonly chroma: {
        readonly endpoint: "http://localhost:8000/api/v1/heartbeat";
        readonly timeout: 30000;
    };
};
export type ServiceHealthCheckConfig = typeof HEALTH_CHECK_CONFIG;
export type ServiceStatus = 'unknown' | 'running' | 'error' | 'stopped' | 'restarting' | 'stopping';
export interface ServiceStatusInfo {
    status: ServiceStatus;
    error?: string;
    lastUpdated: string;
    details?: Record<string, any>;
}
</file>

<file path="src/config/services.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HEALTH_CHECK_CONFIG = exports.ensureServiceDirectories = exports.getServicePath = exports.SERVICE_CONFIG = void 0;
const electron_1 = require("electron");
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const fs_1 = __importDefault(require("fs"));
// Base paths for different operating systems
const BASE_PATHS = {
    darwin: {
        ollama: path.join(os.homedir(), '.ollama'),
        chroma: path.join(os.homedir(), '.chroma'),
    },
    win32: {
        ollama: path.join(os.homedir(), 'AppData', 'Local', 'Ollama'),
        chroma: path.join(os.homedir(), 'AppData', 'Local', 'Chroma'),
    },
    linux: {
        ollama: path.join(os.homedir(), '.ollama'),
        chroma: path.join(os.homedir(), '.chroma'),
    },
};
// Service configuration
exports.SERVICE_CONFIG = {
    // Ollama configuration
    ollama: {
        basePath: process.platform === 'darwin'
            ? path.join(electron_1.app.getPath('home'), 'Library', 'Application Support', 'Ollama')
            : process.platform === 'win32'
                ? path.join(electron_1.app.getPath('appData'), 'Ollama')
                : path.join(electron_1.app.getPath('home'), '.ollama'),
        modelsPath: path.join(electron_1.app.getPath('userData'), 'models'),
        configPath: path.join(electron_1.app.getPath('userData'), 'config'),
        defaultModel: 'llama2',
        apiEndpoint: 'http://localhost:11434',
        timeout: 30000,
        maxRetries: 3,
        retryDelay: 1000,
        healthCheckInterval: 5000,
    },
    // Chroma configuration
    chroma: {
        dataPath: path.join(electron_1.app.getPath('userData'), 'chroma'),
        collectionName: 'documents',
        embeddingDimension: 1536,
        apiEndpoint: 'http://localhost:8000',
        timeout: 30000,
        healthCheckInterval: 5000,
    },
    // Application-specific paths
    app: {
        userData: electron_1.app.getPath('userData'),
        logs: path.join(electron_1.app.getPath('userData'), 'logs'),
        temp: path.join(electron_1.app.getPath('temp'), 'osipelican'),
        cache: path.join(electron_1.app.getPath('userData'), 'cache'),
    },
    // Service status tracking
    status: {
        checkInterval: 5000,
        timeout: 5000,
        maxRetries: 3,
    },
};
// Helper functions
const getServicePath = (service) => {
    const config = exports.SERVICE_CONFIG[service];
    if ('basePath' in config) {
        return config.basePath;
    }
    if ('dataPath' in config) {
        return config.dataPath;
    }
    throw new Error(`Invalid service: ${service}`);
};
exports.getServicePath = getServicePath;
const ensureServiceDirectories = () => {
    // Ensure Ollama directories exist
    fs_1.default.mkdirSync(exports.SERVICE_CONFIG.ollama.modelsPath, { recursive: true });
    fs_1.default.mkdirSync(exports.SERVICE_CONFIG.ollama.configPath, { recursive: true });
    // Ensure Chroma directory exists
    fs_1.default.mkdirSync(exports.SERVICE_CONFIG.chroma.dataPath, { recursive: true });
    // Ensure app directories exist
    fs_1.default.mkdirSync(exports.SERVICE_CONFIG.app.logs, { recursive: true });
    fs_1.default.mkdirSync(exports.SERVICE_CONFIG.app.temp, { recursive: true });
    fs_1.default.mkdirSync(exports.SERVICE_CONFIG.app.cache, { recursive: true });
};
exports.ensureServiceDirectories = ensureServiceDirectories;
// Service health check configuration
exports.HEALTH_CHECK_CONFIG = {
    ollama: {
        endpoint: `${exports.SERVICE_CONFIG.ollama.apiEndpoint}/api/health`,
        timeout: exports.SERVICE_CONFIG.ollama.timeout,
    },
    chroma: {
        endpoint: `${exports.SERVICE_CONFIG.chroma.apiEndpoint}/api/v1/heartbeat`,
        timeout: exports.SERVICE_CONFIG.chroma.timeout,
    },
};
//# sourceMappingURL=services.js.map
</file>

<file path="src/config/services.js.map">
{"version":3,"file":"services.js","sourceRoot":"","sources":["services.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/config/services.ts">
import { app } from 'electron';
import * as path from 'path';
import * as os from 'os';
import fs from 'fs';
// Base paths for different operating systems
const BASE_PATHS = {
  darwin: {
    ollama: path.join(os.homedir(), '.ollama'),
    chroma: path.join(os.homedir(), '.chroma'),
  },
  win32: {
    ollama: path.join(os.homedir(), 'AppData', 'Local', 'Ollama'),
    chroma: path.join(os.homedir(), 'AppData', 'Local', 'Chroma'),
  },
  linux: {
    ollama: path.join(os.homedir(), '.ollama'),
    chroma: path.join(os.homedir(), '.chroma'),
  },
} as const;
// Service configuration
export const SERVICE_CONFIG = {
  // Ollama configuration
  ollama: {
    basePath: process.platform === 'darwin' 
      ? path.join(app.getPath('home'), 'Library', 'Application Support', 'Ollama')
      : process.platform === 'win32'
        ? path.join(app.getPath('appData'), 'Ollama')
        : path.join(app.getPath('home'), '.ollama'),
    modelsPath: path.join(app.getPath('userData'), 'models'),
    configPath: path.join(app.getPath('userData'), 'config'),
    defaultModel: 'llama2',
    apiEndpoint: 'http://localhost:11434',
    timeout: 30000,
    maxRetries: 3,
    retryDelay: 1000,
    healthCheckInterval: 5000,
  },
  // Chroma configuration
  chroma: {
    dataPath: path.join(app.getPath('userData'), 'chroma'),
    collectionName: 'documents',
    embeddingDimension: 1536,
    apiEndpoint: 'http://localhost:8000',
    timeout: 30000,
    healthCheckInterval: 5000,
  },
  // Application-specific paths
  app: {
    userData: app.getPath('userData'),
    logs: path.join(app.getPath('userData'), 'logs'),
    temp: path.join(app.getPath('temp'), 'osipelican'),
    cache: path.join(app.getPath('userData'), 'cache'),
  },
  // Service status tracking
  status: {
    checkInterval: 5000,
    timeout: 5000,
    maxRetries: 3,
  },
} as const;
// Type for service configuration
export type ServiceConfig = typeof SERVICE_CONFIG;
// Helper functions
export const getServicePath = (service: keyof typeof SERVICE_CONFIG): string => {
  const config = SERVICE_CONFIG[service];
  if ('basePath' in config) {
    return config.basePath;
  }
  if ('dataPath' in config) {
    return config.dataPath;
  }
  throw new Error(`Invalid service: ${service}`);
};
export const ensureServiceDirectories = () => {
  // Ensure Ollama directories exist
  fs.mkdirSync(SERVICE_CONFIG.ollama.modelsPath, { recursive: true });
  fs.mkdirSync(SERVICE_CONFIG.ollama.configPath, { recursive: true });
  // Ensure Chroma directory exists
  fs.mkdirSync(SERVICE_CONFIG.chroma.dataPath, { recursive: true });
  // Ensure app directories exist
  fs.mkdirSync(SERVICE_CONFIG.app.logs, { recursive: true });
  fs.mkdirSync(SERVICE_CONFIG.app.temp, { recursive: true });
  fs.mkdirSync(SERVICE_CONFIG.app.cache, { recursive: true });
};
// Service health check configuration
export const HEALTH_CHECK_CONFIG = {
  ollama: {
    endpoint: `${SERVICE_CONFIG.ollama.apiEndpoint}/api/health`,
    timeout: SERVICE_CONFIG.ollama.timeout,
  },
  chroma: {
    endpoint: `${SERVICE_CONFIG.chroma.apiEndpoint}/api/v1/heartbeat`,
    timeout: SERVICE_CONFIG.chroma.timeout,
  },
} as const;
// Export types
export type ServiceHealthCheckConfig = typeof HEALTH_CHECK_CONFIG;
export type ServiceStatus = 
  | 'unknown'
  | 'running'
  | 'error'
  | 'stopped'
  | 'restarting'
  | 'stopping';
// Service status interface
export interface ServiceStatusInfo {
  status: ServiceStatus;
  error?: string;
  lastUpdated: string;
  details?: Record<string, any>;
}
</file>

<file path="src/database/migrations.d.ts">
export declare class MigrationManager {
    private static instance;
    private chatDb;
    private memoryDb;
    private isInitialized;
    private constructor();
    static getInstance(): MigrationManager;
    initialize(): Promise<void>;
    private runMigrations;
    private getAppliedMigrations;
    rollback(version: number): Promise<void>;
    cleanup(): Promise<void>;
}
</file>

<file path="src/database/migrations.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MigrationManager = void 0;
const electron_1 = require("electron");
const path = __importStar(require("path"));
const logger_1 = require("../utils/logger");
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
// Migration definitions
const migrations = [
    {
        version: 1,
        name: 'Initial schema',
        up: (db) => {
            // Chat tables
            db.exec(`
        CREATE TABLE IF NOT EXISTS conversations (
          id TEXT PRIMARY KEY,
          title TEXT NOT NULL,
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL,
          metadata TEXT
        );
        CREATE TABLE IF NOT EXISTS messages (
          id TEXT PRIMARY KEY,
          conversation_id TEXT NOT NULL,
          content TEXT NOT NULL,
          role TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          status TEXT NOT NULL,
          error TEXT,
          metadata TEXT,
          FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
        );
        CREATE INDEX IF NOT EXISTS idx_messages_conversation 
          ON messages(conversation_id, timestamp);
      `);
            // Memory tables
            db.exec(`
        CREATE TABLE IF NOT EXISTS memories (
          id TEXT PRIMARY KEY,
          content TEXT NOT NULL,
          metadata TEXT NOT NULL,
          embedding BLOB,
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL,
          importance REAL DEFAULT 1.0,
          expires_at INTEGER,
          compressed BOOLEAN DEFAULT FALSE
        );
        CREATE INDEX IF NOT EXISTS idx_memories_metadata 
          ON memories(metadata);
        CREATE INDEX IF NOT EXISTS idx_memories_timestamp 
          ON memories(created_at);
        CREATE INDEX IF NOT EXISTS idx_memories_importance 
          ON memories(importance);
        CREATE INDEX IF NOT EXISTS idx_memories_expires 
          ON memories(expires_at);
      `);
        },
        down: (db) => {
            db.exec(`
        DROP TABLE IF EXISTS messages;
        DROP TABLE IF EXISTS conversations;
        DROP TABLE IF EXISTS memories;
      `);
        }
    },
    {
        version: 2,
        name: 'Add message tags',
        up: (db) => {
            db.exec(`
        ALTER TABLE messages ADD COLUMN tags TEXT;
        CREATE INDEX IF NOT EXISTS idx_messages_tags ON messages(tags);
      `);
        },
        down: (db) => {
            // SQLite doesn't support dropping columns, so we need to recreate the table
            db.exec(`
        CREATE TABLE messages_new (
          id TEXT PRIMARY KEY,
          conversation_id TEXT NOT NULL,
          content TEXT NOT NULL,
          role TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          status TEXT NOT NULL,
          error TEXT,
          metadata TEXT,
          FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
        );
        INSERT INTO messages_new 
        SELECT id, conversation_id, content, role, timestamp, status, error, metadata 
        FROM messages;
        DROP TABLE messages;
        ALTER TABLE messages_new RENAME TO messages;
        CREATE INDEX IF NOT EXISTS idx_messages_conversation 
          ON messages(conversation_id, timestamp);
      `);
        }
    }
];
class MigrationManager {
    constructor() {
        this.isInitialized = false;
        const userDataPath = electron_1.app.getPath('userData');
        const chatDbPath = path.join(userDataPath, 'chat.db');
        const memoryDbPath = path.join(userDataPath, 'memory.db');
        this.chatDb = new better_sqlite3_1.default(chatDbPath);
        this.memoryDb = new better_sqlite3_1.default(memoryDbPath);
    }
    static getInstance() {
        if (!MigrationManager.instance) {
            MigrationManager.instance = new MigrationManager();
        }
        return MigrationManager.instance;
    }
    async initialize() {
        if (this.isInitialized)
            return;
        try {
            // Enable foreign keys
            this.chatDb.pragma('foreign_keys = ON');
            this.memoryDb.pragma('foreign_keys = ON');
            // Create migrations table if it doesn't exist
            this.chatDb.exec(`
        CREATE TABLE IF NOT EXISTS migrations (
          version INTEGER PRIMARY KEY,
          name TEXT NOT NULL,
          applied_at INTEGER NOT NULL
        );
      `);
            // Run migrations
            await this.runMigrations();
            this.isInitialized = true;
            logger_1.logger.info('Migration manager initialized successfully');
        }
        catch (error) {
            logger_1.logger.error('Failed to initialize migration manager:', error);
            throw error;
        }
    }
    async runMigrations() {
        const appliedMigrations = this.getAppliedMigrations();
        const pendingMigrations = migrations.filter(m => !appliedMigrations.includes(m.version));
        if (pendingMigrations.length === 0) {
            logger_1.logger.info('No pending migrations');
            return;
        }
        logger_1.logger.info(`Running ${pendingMigrations.length} pending migrations`);
        for (const migration of pendingMigrations) {
            try {
                // Start transaction
                this.chatDb.exec('BEGIN TRANSACTION');
                this.memoryDb.exec('BEGIN TRANSACTION');
                // Run migration
                migration.up(this.chatDb);
                migration.up(this.memoryDb);
                // Record migration
                this.chatDb.prepare(`
          INSERT INTO migrations (version, name, applied_at)
          VALUES (?, ?, ?)
        `).run(migration.version, migration.name, Date.now());
                // Commit transaction
                this.chatDb.exec('COMMIT');
                this.memoryDb.exec('COMMIT');
                logger_1.logger.info(`Applied migration ${migration.version}: ${migration.name}`);
            }
            catch (error) {
                // Rollback transaction
                this.chatDb.exec('ROLLBACK');
                this.memoryDb.exec('ROLLBACK');
                logger_1.logger.error(`Failed to apply migration ${migration.version}:`, error);
                throw error;
            }
        }
    }
    getAppliedMigrations() {
        const stmt = this.chatDb.prepare('SELECT version FROM migrations ORDER BY version');
        return stmt.all().map(row => row.version);
    }
    async rollback(version) {
        const appliedMigrations = this.getAppliedMigrations();
        const migrationsToRollback = migrations
            .filter(m => m.version <= version && appliedMigrations.includes(m.version))
            .sort((a, b) => b.version - a.version);
        if (migrationsToRollback.length === 0) {
            logger_1.logger.info('No migrations to rollback');
            return;
        }
        logger_1.logger.info(`Rolling back ${migrationsToRollback.length} migrations`);
        for (const migration of migrationsToRollback) {
            try {
                // Start transaction
                this.chatDb.exec('BEGIN TRANSACTION');
                this.memoryDb.exec('BEGIN TRANSACTION');
                // Run rollback
                migration.down(this.chatDb);
                migration.down(this.memoryDb);
                // Remove migration record
                this.chatDb.prepare('DELETE FROM migrations WHERE version = ?')
                    .run(migration.version);
                // Commit transaction
                this.chatDb.exec('COMMIT');
                this.memoryDb.exec('COMMIT');
                logger_1.logger.info(`Rolled back migration ${migration.version}: ${migration.name}`);
            }
            catch (error) {
                // Rollback transaction
                this.chatDb.exec('ROLLBACK');
                this.memoryDb.exec('ROLLBACK');
                logger_1.logger.error(`Failed to rollback migration ${migration.version}:`, error);
                throw error;
            }
        }
    }
    async cleanup() {
        this.chatDb.close();
        this.memoryDb.close();
        this.isInitialized = false;
    }
}
exports.MigrationManager = MigrationManager;
//# sourceMappingURL=migrations.js.map
</file>

<file path="src/database/migrations.js.map">
{"version":3,"file":"migrations.js","sourceRoot":"","sources":["migrations.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/database/migrations.ts">
import { app } from 'electron';
import * as path from 'path';
import * as fs from 'fs-extra';
import { logger } from '../utils/logger';
import Database from 'better-sqlite3';
interface Migration {
  version: number;
  name: string;
  up: (db: Database) => void;
  down: (db: Database) => void;
}
// Migration definitions
const migrations: Migration[] = [
  {
    version: 1,
    name: 'Initial schema',
    up: (db: Database) => {
      // Chat tables
      db.exec(`
        CREATE TABLE IF NOT EXISTS conversations (
          id TEXT PRIMARY KEY,
          title TEXT NOT NULL,
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL,
          metadata TEXT
        );
        CREATE TABLE IF NOT EXISTS messages (
          id TEXT PRIMARY KEY,
          conversation_id TEXT NOT NULL,
          content TEXT NOT NULL,
          role TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          status TEXT NOT NULL,
          error TEXT,
          metadata TEXT,
          FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
        );
        CREATE INDEX IF NOT EXISTS idx_messages_conversation 
          ON messages(conversation_id, timestamp);
      `);
      // Memory tables
      db.exec(`
        CREATE TABLE IF NOT EXISTS memories (
          id TEXT PRIMARY KEY,
          content TEXT NOT NULL,
          metadata TEXT NOT NULL,
          embedding BLOB,
          created_at INTEGER NOT NULL,
          updated_at INTEGER NOT NULL,
          importance REAL DEFAULT 1.0,
          expires_at INTEGER,
          compressed BOOLEAN DEFAULT FALSE
        );
        CREATE INDEX IF NOT EXISTS idx_memories_metadata 
          ON memories(metadata);
        CREATE INDEX IF NOT EXISTS idx_memories_timestamp 
          ON memories(created_at);
        CREATE INDEX IF NOT EXISTS idx_memories_importance 
          ON memories(importance);
        CREATE INDEX IF NOT EXISTS idx_memories_expires 
          ON memories(expires_at);
      `);
    },
    down: (db: Database) => {
      db.exec(`
        DROP TABLE IF EXISTS messages;
        DROP TABLE IF EXISTS conversations;
        DROP TABLE IF EXISTS memories;
      `);
    }
  },
  {
    version: 2,
    name: 'Add message tags',
    up: (db: Database) => {
      db.exec(`
        ALTER TABLE messages ADD COLUMN tags TEXT;
        CREATE INDEX IF NOT EXISTS idx_messages_tags ON messages(tags);
      `);
    },
    down: (db: Database) => {
      // SQLite doesn't support dropping columns, so we need to recreate the table
      db.exec(`
        CREATE TABLE messages_new (
          id TEXT PRIMARY KEY,
          conversation_id TEXT NOT NULL,
          content TEXT NOT NULL,
          role TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          status TEXT NOT NULL,
          error TEXT,
          metadata TEXT,
          FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
        );
        INSERT INTO messages_new 
        SELECT id, conversation_id, content, role, timestamp, status, error, metadata 
        FROM messages;
        DROP TABLE messages;
        ALTER TABLE messages_new RENAME TO messages;
        CREATE INDEX IF NOT EXISTS idx_messages_conversation 
          ON messages(conversation_id, timestamp);
      `);
    }
  }
];
export class MigrationManager {
  private static instance: MigrationManager;
  private chatDb: Database;
  private memoryDb: Database;
  private isInitialized = false;
  private constructor() {
    const userDataPath = app.getPath('userData');
    const chatDbPath = path.join(userDataPath, 'chat.db');
    const memoryDbPath = path.join(userDataPath, 'memory.db');
    this.chatDb = new Database(chatDbPath);
    this.memoryDb = new Database(memoryDbPath);
  }
  public static getInstance(): MigrationManager {
    if (!MigrationManager.instance) {
      MigrationManager.instance = new MigrationManager();
    }
    return MigrationManager.instance;
  }
  public async initialize(): Promise<void> {
    if (this.isInitialized) return;
    try {
      // Enable foreign keys
      this.chatDb.pragma('foreign_keys = ON');
      this.memoryDb.pragma('foreign_keys = ON');
      // Create migrations table if it doesn't exist
      this.chatDb.exec(`
        CREATE TABLE IF NOT EXISTS migrations (
          version INTEGER PRIMARY KEY,
          name TEXT NOT NULL,
          applied_at INTEGER NOT NULL
        );
      `);
      // Run migrations
      await this.runMigrations();
      this.isInitialized = true;
      logger.info('Migration manager initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize migration manager:', error);
      throw error;
    }
  }
  private async runMigrations(): Promise<void> {
    const appliedMigrations = this.getAppliedMigrations();
    const pendingMigrations = migrations.filter(
      m => !appliedMigrations.includes(m.version)
    );
    if (pendingMigrations.length === 0) {
      logger.info('No pending migrations');
      return;
    }
    logger.info(`Running ${pendingMigrations.length} pending migrations`);
    for (const migration of pendingMigrations) {
      try {
        // Start transaction
        this.chatDb.exec('BEGIN TRANSACTION');
        this.memoryDb.exec('BEGIN TRANSACTION');
        // Run migration
        migration.up(this.chatDb);
        migration.up(this.memoryDb);
        // Record migration
        this.chatDb.prepare(`
          INSERT INTO migrations (version, name, applied_at)
          VALUES (?, ?, ?)
        `).run(migration.version, migration.name, Date.now());
        // Commit transaction
        this.chatDb.exec('COMMIT');
        this.memoryDb.exec('COMMIT');
        logger.info(`Applied migration ${migration.version}: ${migration.name}`);
      } catch (error) {
        // Rollback transaction
        this.chatDb.exec('ROLLBACK');
        this.memoryDb.exec('ROLLBACK');
        logger.error(`Failed to apply migration ${migration.version}:`, error);
        throw error;
      }
    }
  }
  private getAppliedMigrations(): number[] {
    const stmt = this.chatDb.prepare('SELECT version FROM migrations ORDER BY version');
    return stmt.all().map(row => row.version);
  }
  public async rollback(version: number): Promise<void> {
    const appliedMigrations = this.getAppliedMigrations();
    const migrationsToRollback = migrations
      .filter(m => m.version <= version && appliedMigrations.includes(m.version))
      .sort((a, b) => b.version - a.version);
    if (migrationsToRollback.length === 0) {
      logger.info('No migrations to rollback');
      return;
    }
    logger.info(`Rolling back ${migrationsToRollback.length} migrations`);
    for (const migration of migrationsToRollback) {
      try {
        // Start transaction
        this.chatDb.exec('BEGIN TRANSACTION');
        this.memoryDb.exec('BEGIN TRANSACTION');
        // Run rollback
        migration.down(this.chatDb);
        migration.down(this.memoryDb);
        // Remove migration record
        this.chatDb.prepare('DELETE FROM migrations WHERE version = ?')
          .run(migration.version);
        // Commit transaction
        this.chatDb.exec('COMMIT');
        this.memoryDb.exec('COMMIT');
        logger.info(`Rolled back migration ${migration.version}: ${migration.name}`);
      } catch (error) {
        // Rollback transaction
        this.chatDb.exec('ROLLBACK');
        this.memoryDb.exec('ROLLBACK');
        logger.error(`Failed to rollback migration ${migration.version}:`, error);
        throw error;
      }
    }
  }
  public async cleanup(): Promise<void> {
    this.chatDb.close();
    this.memoryDb.close();
    this.isInitialized = false;
  }
}
</file>

<file path="src/electron-app/electron-builder.config.js">
module.exports = {
  appId: 'com.osipelican.app',
  productName: 'HelloGPT',
  directories: {
    output: 'dist',
    buildResources: 'buildResources'
  },
  files: [
    'dist/**/*',
    'package.json'
  ],
  mac: {
    category: 'public.app-category.developer-tools',
    target: ['dmg', 'zip'],
    icon: 'buildResources/icon.icns',
    darkModeSupport: true
  },
  win: {
    target: ['nsis', 'portable'],
    icon: 'buildResources/icon.png'
  },
  linux: {
    target: ['AppImage', 'deb'],
    category: 'Development',
    icon: 'buildResources/icon.png'
  },
  extraResources: [
    {
      from: 'buildResources',
      to: 'buildResources',
      filter: ['**/*']
    }
  ],
  publish: {
    provider: 'github',
    releaseType: 'release'
  }
};
</file>

<file path="src/electron-app/electron-builder.json5">
{
  "appId": "com.osipelican.app",
  "productName": "HelloGPT",
  "directories": {
    "output": "dist"
  },
  "files": [
    "packages/main/dist/**",
    "packages/preload/dist/**",
    "packages/renderer/dist/**",
    "!**/*.map"
  ],
  "extraResources": [
    {
      "from": "packages/renderer/dist",
      "to": "renderer",
      "filter": ["**/*"]
    }
  ],
  "mac": {
    "category": "public.app-category.developer-tools",
    "target": ["dmg", "zip"],
    "icon": "build/icon.icns"
  },
  "win": {
    "target": ["nsis", "portable"],
    "icon": "build/icon.ico"
  },
  "linux": {
    "target": ["AppImage", "deb"],
    "category": "Development"
  },
  "asar": true,
  "asarUnpack": [
    "node_modules/ffmpeg-static/*"
  ],
  "publish": {
    "provider": "github",
    "releaseType": "release"
  }
}
</file>

<file path="src/electron-app/electron-builder.mjs">
import pkg from './package.json' with {type: 'json'};
import mapWorkspaces from '@npmcli/map-workspaces';
import {join} from 'node:path';
import {pathToFileURL} from 'node:url';

export default /** @type import('electron-builder').Configuration */
({
  directories: {
    output: 'dist',
    buildResources: 'buildResources',
  },
  generateUpdatesFilesForAllChannels: true,
  linux: {
    target: ['deb'],
  },
  /**
   * It is recommended to avoid using non-standard characters such as spaces in artifact names,
   * as they can unpredictably change during deployment, making them impossible to locate and download for update.
   */
  artifactName: '${productName}-${version}-${os}-${arch}.${ext}',
  files: [
    'LICENSE*',
    pkg.main,
    '!node_modules/@app/**',
    '!dist/**',
    ...await getListOfFilesFromEachWorkspace(),
  ],
});

/**
 * By default, electron-builder copies each package into the output compilation entirety,
 * including the source code, tests, configuration, assets, and any other files.
 *
 * So you may get compiled app structure like this:
 * ```
 * app/
 *  node_modules/
 *     workspace-packages/
 *         package-a/
 *            src/            # Garbage. May be safely removed
 *            dist/
 *               index.js    # Runtime code
 *            vite.config.js  # Garbage
 *            .env            # some sensitive config
 *            package.json
 *         package-b/
 *         package-c/
 *         package-d/
 *  packages/
 *     entry-point.js
 *  package.json
 * ```
 *
 * To prevent this, we read the "files"
 * property from each package's package.json
 * and add all files that do not match the patterns to the exclusion list.
 *
 * This way,
 * each package independently determines which files will be included in the final compilation and which will not.
 *
 * So if `package-a` in its `package.json` describes
 * ```json
 * {
 *   "name": "package-a",
 *   "files": [
 *     "dist/**\/"
 *   ]
 * }
 * ```
 *
 * Then in the compilation only those files and `package.json` will be included:
 * ```
 * app/
 *  node_modules/
 *     workspace-packages/
 *         package-a/
 *            dist/
 *               index.js    # Runtime code
 *            package.json
 *         package-b/
 *         package-c/
 *         package-d/
 *  packages/
 *     entry-point.js
 *  package.json
 * ```
 */
async function getListOfFilesFromEachWorkspace() {

  /**
   * @type {Map<string, string>}
   */
  const workspaces = await mapWorkspaces({
    cwd: process.cwd(),
    pkg,
  });

  const allFilesToInclude = [];

  for (const [name, path] of workspaces) {
    const pkgPath = join(path, 'package.json');
    const {default: workspacePkg} = await import(pathToFileURL(pkgPath), {with: {type: 'json'}});

    let patterns = workspacePkg.files || ['dist/**', 'package.json'];

    patterns = patterns.map(p => join('node_modules', name, p));
    allFilesToInclude.push(...patterns);
  }

  return allFilesToInclude;
}
</file>

<file path="src/electron-app/eslint.config.cjs">
const tsPlugin = require('@typescript-eslint/eslint-plugin');
const tsParser = require('@typescript-eslint/parser');
const reactPlugin = require('eslint-plugin-react');

module.exports = [
  {
    files: ['**/*.ts', '**/*.tsx'],
    ignores: ['types/**/*.d.ts'],
    languageOptions: {
      parser: require('@typescript-eslint/parser'),
      parserOptions: {
        project: './tsconfig.json',
        tsconfigRootDir: __dirname,
        sourceType: 'module',
      },
    },
    plugins: {
      '@typescript-eslint': require('@typescript-eslint/eslint-plugin'),
    },
    rules: {
      // Add or override rules here
    },
  },
  {
    files: ['**/*.jsx', '**/*.tsx'],
    languageOptions: {
      parser: require('@babel/eslint-parser'),
      parserOptions: {
        requireConfigFile: false,
        babelOptions: {
          presets: ['@babel/preset-react'],
        },
      },
    },
    plugins: {
      react: require('eslint-plugin-react'),
    },
    rules: {
      // React specific rules
    },
  },
];
</file>

<file path="src/electron-app/eslint.config.js">
export default [
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: '@typescript-eslint/parser',
      parserOptions: {
        project: './tsconfig.json',
        tsconfigRootDir: process.cwd(),
        sourceType: 'module',
      },
    },
    plugins: {
      '@typescript-eslint': require('@typescript-eslint/eslint-plugin'),
    },
    rules: {
      // Add or override rules here
    },
  },
  {
    files: ['**/*.jsx', '**/*.tsx'],
    plugins: {
      react: require('eslint-plugin-react'),
    },
    rules: {
      // React specific rules
    },
  },
];
</file>

<file path="src/electron-app/LICENSE">
MIT License

Copyright (c) 2021 Alex Kozack

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/electron-app/node-upgrade-instructions.sh">
#!/bin/bash
# Instructions to upgrade Node.js to version 23 using nvm
echo "Checking current Node.js version:"
node -v
echo "Installing Node.js version 23 using nvm..."
nvm install 23
echo "Switching to Node.js version 23..."
nvm use 23
echo "Verifying Node.js version after upgrade:"
node -v
echo "Please restart your terminal and development server after this upgrade."
</file>

<file path="src/electron-app/package.json">
{
  "name": "osipelican",
  "version": "1.0.0",
  "description": "HelloGPT - A Desktop Chat Application",
  "private": true,
  "workspaces": [
    "electron-app",
    "renderer",
    "packages/*"
  ],
  "resolutions": {
    "@electron-app/types": "workspace:packages/main",
    "@electron-app/electron": "workspace:electron-app"
  },
  "scripts": {
    "dev": "cross-env NODE_OPTIONS='--max-old-space-size=4096 --expose-gc' electron-vite dev",
    "dev:main": "tsc -w -p electron-app/tsconfig.json",
    "dev:renderer": "vite",
    "build": "cross-env NODE_OPTIONS='--max-old-space-size=4096 --expose-gc' electron-vite build",
    "build:main": "tsc -p electron-app/tsconfig.json",
    "build:renderer": "vite build",
    "start": "cross-env NODE_OPTIONS='--max-old-space-size=4096 --expose-gc' electron .",
    "start:dev": "cross-env NODE_ENV=development NODE_OPTIONS='--max-old-space-size=4096 --expose-gc' electron .",
    "start:prod": "cross-env NODE_ENV=production NODE_OPTIONS='--max-old-space-size=4096 --expose-gc' electron .",
    "clean": "rimraf dist electron-app/dist renderer/dist",
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "type-check": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "debug": "cross-env DEBUG=* npm run start:dev",
    "debug:main": "cross-env DEBUG=electron-app:* npm run start:dev",
    "debug:renderer": "cross-env DEBUG=renderer:* npm run start:dev",
    "debug:ipc": "cross-env DEBUG=ipc:* npm run start:dev",
    "profile": "cross-env NODE_ENV=development ELECTRON_ENABLE_LOGGING=true ELECTRON_ENABLE_STACK_DUMPING=true npm run start:dev",
    "profile:memory": "cross-env NODE_ENV=development NODE_OPTIONS='--max-old-space-size=4096 --expose-gc --inspect' ELECTRON_ENABLE_LOGGING=true ELECTRON_ENABLE_STACK_DUMPING=true ELECTRON_ENABLE_MEMORY_PROFILING=true npm run start:dev",
    "profile:cpu": "cross-env NODE_ENV=development ELECTRON_ENABLE_LOGGING=true ELECTRON_ENABLE_STACK_DUMPING=true ELECTRON_ENABLE_CPU_PROFILING=true npm run start:dev",
    "profile:gpu": "cross-env NODE_ENV=development ELECTRON_ENABLE_LOGGING=true ELECTRON_ENABLE_STACK_DUMPING=true ELECTRON_ENABLE_GPU_PROFILING=true npm run start:dev",
    "profile:all": "cross-env NODE_ENV=development ELECTRON_ENABLE_LOGGING=true ELECTRON_ENABLE_STACK_DUMPING=true ELECTRON_ENABLE_MEMORY_PROFILING=true ELECTRON_ENABLE_CPU_PROFILING=true ELECTRON_ENABLE_GPU_PROFILING=true npm run start:dev",
    "check": "npm run lint && npm run type-check && npm run test",
    "precommit": "npm run check",
    "prepare": "husky install",
    "preview": "cross-env NODE_OPTIONS='--max-old-space-size=4096' electron-vite preview",
    "analyze-deps": "node scripts/consolidate-dependencies.js"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@types/express": "5.0.2",
    "@types/jsdom": "^21.1.7",
    "@types/lodash.debounce": "^4.0.9",
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^4.0.0",
    "autoprefixer": "^10.4.21",
    "concurrently": "^8.2.2",
    "cross-env": "^7.0.3",
    "electron-builder": "^24.0.0",
    "electron-vite": "^3.1.0",
    "happy-dom": "^17.6.3",
    "husky": "^9.1.7",
    "jsdom": "^26.1.0",
    "postcss": "^8.5.4",
    "tailwindcss": "^3.4.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.0",
    "@heroicons/react": "^2.2.0",
    "better-sqlite3": "^11.10.0",
    "date-fns": "^4.1.0",
    "electron": "^28.0.0",
    "hnswlib-node": "^3.0.0",
    "lodash.debounce": "^4.0.8",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-dropzone": "^14.3.8",
    "react-hot-toast": "^2.5.2",
    "react-syntax-highlighter": "^15.5.0",
    "uuid": "^11.1.0",
    "zustand": "^4.5.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="src/electron-app/README.md">
# HelloGPT Electron + Vite + Tailwind + IPC + Ollama Chat UI

## Project Overview

HelloGPT is a desktop chat application built using Electron, Vite, Tailwind CSS, and Ollama AI integration. The project is structured as a monorepo with separate packages for the Electron main process, preload scripts, and renderer (frontend UI). It leverages IPC (Inter-Process Communication) for communication between Electron processes and integrates Ollama for AI-powered chat functionality.

## Goals

- Provide a performant, low-latency chat UI experience using just-in-time (JIT) processing.
- Use modern frontend tooling with Vite and Tailwind CSS for fast builds and responsive styling.
- Maintain a clean, modular codebase with strict TypeScript typing and best practices.
- Ensure robust IPC communication between Electron main, preload, and renderer processes.
- Integrate Ollama AI models seamlessly for chat message processing.
- Provide thorough testing coverage including unit tests (Vitest) and end-to-end tests (Playwright).

## Project Structure

- `packages/main/`  
  Contains the Electron main process code, including app initialization, window management, auto-updater, and IPC handlers.  
  - `src/` - TypeScript source files for main process modules.  
  - `vite.config.js` - Vite config for building main process code.  
  - `tsconfig.json` - TypeScript config for main process.

- `packages/preload/`  
  Contains Electron preload scripts that expose safe APIs to the renderer process.  
  - `src/` - Preload script source files.  
  - `vite.config.js` - Vite config for preload build.  
  - `tsconfig.json` - TypeScript config for preload.

- `packages/renderer/`  
  Contains the frontend UI built with React, Vite, and Tailwind CSS.  
  - `src/` - React components, styles, and assets.  
  - `vite.config.js` - Vite config for frontend build.  
  - `tsconfig.json` - TypeScript config for renderer.  
  - `postcss.config.js` & `tailwind.config.js` - Tailwind CSS configuration.

- `packages/shared/`  
  Shared utilities and modules used across main, preload, and renderer packages.

- `tests/`  
  Contains end-to-end test specs using Playwright.

- `types/`  
  Custom TypeScript declaration files for environment variables and Electron devtools.

- `e2e/`  
  Playwright test configuration and specs for end-to-end testing.

## Tooling

- **Electron**: Desktop app framework for cross-platform native apps.
- **Vite**: Modern frontend build tool for fast development and optimized production builds.
- **Tailwind CSS**: Utility-first CSS framework for rapid UI styling.
- **TypeScript**: Strongly typed JavaScript superset for safer code.
- **Vitest**: Unit testing framework integrated with Vite for fast tests.
- **Playwright**: End-to-end testing framework for UI and integration tests.
- **Ollama**: AI platform integrated for chat message processing.
- **ESLint**: Linting and code style enforcement.
- **Electron Builder**: Packaging and distribution of Electron app.

## Development Workflow

- Use `npm run dev` or equivalent to start development servers for main, preload, and renderer.
- Use Vite's hot module replacement (HMR) for fast UI updates.
- Run unit tests with `npm run test:unit` (Vitest).
- Run end-to-end tests with `npm run test:e2e` (Playwright).
- Build production app with `npm run build`.
- Package app for distribution with Electron Builder.

## Key Features

- Modular Electron main process with window management, auto-updates, and security modules.
- Preload scripts exposing safe IPC APIs to renderer.
- React-based chat UI styled with Tailwind CSS.
- IPC handlers for chat message sending and app health checks.
- Ollama AI integration for chat response generation.
- Comprehensive testing setup with unit and e2e tests.

## Notes

- Ensure Playwright browsers are installed with `npx playwright install` before running e2e tests.
- Environment variables are typed and accessible via `import.meta.env` or `process.env` as appropriate.
- Follow best practices for security, performance, and maintainability throughout the codebase.


additional features:
RAG (Retrieval-Augmented Generation) setup is not implemented (chroma DB).

UI is designed with ultra-classy glass and matte light & dark modes.
Natural subtle animations and user experience implemented.
Local-only mode is functional with option to go online.
Upcoming features planned include:
Fast loading and additional tools.
Reimagined layouts and custom designs.
Expanded slide-out toolbar.
Model selector and LLM health status.
Training mode and more.


---

This README provides a high-level overview of the project files, tools, and goals to help developers understand and contribute effectively.
</file>

<file path="src/electron-app/tsconfig.base.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": false,
    "checkJs": false,
    "noEmit": false,
    "declaration": true,
    "sourceMap": true,
    "composite": true
  },
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/electron-app/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./electron-app" },
    { "path": "./renderer" },
    { "path": "./packages/shared" }
  ]
}
</file>

<file path="src/electron-app/vite.config.ts">
import { defineConfig } from 'vite';
import electronVite from 'electron-vite';
export default defineConfig({
  plugins: [electronVite.default ? electronVite.default() : electronVite()],
  build: {
    rollupOptions: {
      input: {
        main: 'packages/main/src/index.ts',
        renderer: 'packages/renderer/src/main.tsx',
      },
    },
  },
});
</file>

<file path="src/ipc/app.d.ts">
export {};
</file>

<file path="src/ipc/app.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
const logger_1 = require("../utils/logger");
const OllamaClient_1 = require("../shared/api/OllamaClient");
const client = OllamaClient_1.OllamaClient.getInstance();
electron_1.ipcMain.handle('app:health-check', async () => {
    try {
        const status = await client.checkConnection();
        return {
            status: status.status === 'connected' ? 'healthy' : 'unhealthy',
            timestamp: Date.now(),
            details: {
                ollamaConnected: status.status === 'connected',
                currentModel: client.getCurrentModel()
            }
        };
    }
    catch (error) {
        logger_1.logger.error('Health check failed:', error);
        return {
            status: 'unhealthy',
            timestamp: Date.now(),
            details: {
                ollamaConnected: false,
                currentModel: ''
            }
        };
    }
});
electron_1.ipcMain.handle('app:retry-service', async (_, { serviceName }) => {
    try {
        // Implement service retry logic here
        return true;
    }
    catch (error) {
        logger_1.logger.error(`Failed to retry service ${serviceName}:`, error);
        return false;
    }
});
electron_1.ipcMain.handle('app:show-setup-guide', () => {
    // Implement setup guide display logic
});
electron_1.ipcMain.handle('app:show-troubleshooter', () => {
    // Implement troubleshooter display logic
});
//# sourceMappingURL=app.js.map
</file>

<file path="src/ipc/app.js.map">
{"version":3,"file":"app.js","sourceRoot":"","sources":["app.ts"],"names":[],"mappings":";;AAAA,uCAAmC;AACnC,4CAAyC;AACzC,6DAA0D;AAE1D,MAAM,MAAM,GAAG,2BAAY,CAAC,WAAW,EAAE,CAAC;AAE1C,kBAAO,CAAC,MAAM,CAAC,kBAAkB,EAAE,KAAK,IAAI,EAAE;IAC5C,IAAI,CAAC;QACH,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,eAAe,EAAE,CAAC;QAC9C,OAAO;YACL,MAAM,EAAE,MAAM,CAAC,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,WAAW;YAC/D,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,OAAO,EAAE;gBACP,eAAe,EAAE,MAAM,CAAC,MAAM,KAAK,WAAW;gBAC9C,YAAY,EAAE,MAAM,CAAC,eAAe,EAAE;aACvC;SACF,CAAC;IACJ,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,eAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;QAC5C,OAAO;YACL,MAAM,EAAE,WAAW;YACnB,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,OAAO,EAAE;gBACP,eAAe,EAAE,KAAK;gBACtB,YAAY,EAAE,EAAE;aACjB;SACF,CAAC;IACJ,CAAC;AACH,CAAC,CAAC,CAAC;AAEH,kBAAO,CAAC,MAAM,CAAC,mBAAmB,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE;IAC/D,IAAI,CAAC;QACH,qCAAqC;QACrC,OAAO,IAAI,CAAC;IACd,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,eAAM,CAAC,KAAK,CAAC,2BAA2B,WAAW,GAAG,EAAE,KAAK,CAAC,CAAC;QAC/D,OAAO,KAAK,CAAC;IACf,CAAC;AACH,CAAC,CAAC,CAAC;AAEH,kBAAO,CAAC,MAAM,CAAC,sBAAsB,EAAE,GAAG,EAAE;IAC1C,sCAAsC;AACxC,CAAC,CAAC,CAAC;AAEH,kBAAO,CAAC,MAAM,CAAC,yBAAyB,EAAE,GAAG,EAAE;IAC7C,yCAAyC;AAC3C,CAAC,CAAC,CAAC"}
</file>

<file path="src/ipc/app.ts">
import { ipcMain } from 'electron';
import { logger } from '../utils/logger';
import { OllamaClient } from '@shared/src/api/OllamaClient';
const client = OllamaClient.getInstance();
ipcMain.handle('app:health-check', async () => {
  try {
    const status = await client.checkConnection();
    return {
      status: status.status === 'connected' ? 'healthy' : 'unhealthy',
      timestamp: Date.now(),
      details: {
        ollamaConnected: status.status === 'connected',
        currentModel: client.getCurrentModel()
      }
    };
  } catch (error) {
    logger.error('Health check failed:', error);
    return {
      status: 'unhealthy',
      timestamp: Date.now(),
      details: {
        ollamaConnected: false,
        currentModel: ''
      }
    };
  }
});
ipcMain.handle('app:retry-service', async (_, { serviceName }) => {
  try {
    // Implement service retry logic here
    return true;
  } catch (error) {
    logger.error(`Failed to retry service ${serviceName}:`, error);
    return false;
  }
});
ipcMain.handle('app:show-setup-guide', () => {
  // Implement setup guide display logic
});
ipcMain.handle('app:show-troubleshooter', () => {
  // Implement troubleshooter display logic
});
</file>

<file path="src/ipc/channels.d.ts">
export declare const IPC_CHANNELS: {
    readonly CHAT: {
        readonly SEND_MESSAGE: "chat:send-message";
        readonly SEND_MESSAGE_STREAM: "chat:send-message-stream";
        readonly STREAM_CHUNK: "chat:stream-chunk";
        readonly STREAM_END: "chat:stream-end";
        readonly STREAM_ERROR: "chat:stream-error";
        readonly GET_CONVERSATIONS: "chat:get-conversations";
        readonly GET_CONVERSATION: "chat:get-conversation";
        readonly CREATE_CONVERSATION: "chat:create-conversation";
        readonly UPDATE_CONVERSATION_TITLE: "chat:update-conversation-title";
        readonly MESSAGE_RECEIVED: "chat:message-received";
        readonly DELETE_CONVERSATION: "chat:delete-conversation";
    };
    readonly APP: {
        readonly HEALTH_CHECK: "app:health-check";
        readonly SERVICE_STATUS_CHANGED: "app:service-status-changed";
        readonly GET_THEME: "app:get-theme";
        readonly SET_THEME: "app:set-theme";
        readonly THEME_UPDATED: "app:theme-updated";
    };
    readonly OLLAMA: {
        readonly LIST_MODELS: "ollama:list-models";
        readonly SET_MODEL: "ollama:set-model";
        readonly CHECK_CONNECTION: "ollama:check-connection";
        readonly CANCEL_LOAD: "ollama:cancel-load";
        readonly MODEL_LOADING_STATE_CHANGED: "ollama:model-loading-state-changed";
        readonly SAVE_CONFIG: "ollama:save-config";
        readonly GET_CONNECTION_STATUS: "ollama:get-connection-status";
    };
    readonly MEMORY: {
        readonly INITIALIZE: "memory:initialize";
        readonly STORE: "memory:store";
        readonly SEARCH: "memory:search";
        readonly GET_RECENT: "memory:get-recent";
        readonly DELETE: "memory:delete";
        readonly CLEAR: "memory:clear";
    };
    readonly VECTOR: {
        readonly ADD_DOCUMENT: "vector:add-document";
        readonly SEARCH: "vector:search";
        readonly GET_DOCUMENTS: "vector:get-documents";
        readonly ADD: "vector:add";
        readonly DELETE: "vector:delete";
        readonly CLEAR: "vector:clear";
        readonly CHUNK: "vector:chunk";
        readonly MERGE: "vector:merge";
    };
    readonly EMBEDDING: {
        readonly GET_CONFIG: "embedding:get-config";
        readonly UPDATE_CONFIG: "embedding:update-config";
    };
};
export type IpcChannel = {
    [K in keyof typeof IPC_CHANNELS]: typeof IPC_CHANNELS[K][keyof typeof IPC_CHANNELS[K]];
}[keyof typeof IPC_CHANNELS];
</file>

<file path="src/ipc/channels.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IPC_CHANNELS = void 0;
exports.IPC_CHANNELS = {
    CHAT: {
        SEND_MESSAGE: 'chat:send-message',
        SEND_MESSAGE_STREAM: 'chat:send-message-stream',
        STREAM_CHUNK: 'chat:stream-chunk',
        STREAM_END: 'chat:stream-end',
        STREAM_ERROR: 'chat:stream-error',
        GET_CONVERSATIONS: 'chat:get-conversations',
        GET_CONVERSATION: 'chat:get-conversation',
        CREATE_CONVERSATION: 'chat:create-conversation',
        UPDATE_CONVERSATION_TITLE: 'chat:update-conversation-title',
        MESSAGE_RECEIVED: 'chat:message-received',
        DELETE_CONVERSATION: 'chat:delete-conversation',
    },
    APP: {
        HEALTH_CHECK: 'app:health-check',
        SERVICE_STATUS_CHANGED: 'app:service-status-changed',
        GET_THEME: 'app:get-theme',
        SET_THEME: 'app:set-theme',
        THEME_UPDATED: 'app:theme-updated'
    },
    OLLAMA: {
        LIST_MODELS: 'ollama:list-models',
        SET_MODEL: 'ollama:set-model',
        CHECK_CONNECTION: 'ollama:check-connection',
        CANCEL_LOAD: 'ollama:cancel-load',
        MODEL_LOADING_STATE_CHANGED: 'ollama:model-loading-state-changed',
        SAVE_CONFIG: 'ollama:save-config',
        GET_CONNECTION_STATUS: 'ollama:get-connection-status'
    },
    MEMORY: {
        INITIALIZE: 'memory:initialize',
        STORE: 'memory:store',
        SEARCH: 'memory:search',
        GET_RECENT: 'memory:get-recent',
        DELETE: 'memory:delete',
        CLEAR: 'memory:clear'
    },
    VECTOR: {
        ADD_DOCUMENT: 'vector:add-document',
        SEARCH: 'vector:search',
        GET_DOCUMENTS: 'vector:get-documents',
        ADD: 'vector:add',
        DELETE: 'vector:delete',
        CLEAR: 'vector:clear',
        CHUNK: 'vector:chunk',
        MERGE: 'vector:merge'
    },
    EMBEDDING: {
        GET_CONFIG: 'embedding:get-config',
        UPDATE_CONFIG: 'embedding:update-config',
    },
};
//# sourceMappingURL=channels.js.map
</file>

<file path="src/ipc/channels.js.map">
{"version":3,"file":"channels.js","sourceRoot":"","sources":["channels.ts"],"names":[],"mappings":";;;AAAa,QAAA,YAAY,GAAG;IAC1B,IAAI,EAAE;QACJ,YAAY,EAAE,mBAAmB;QACjC,mBAAmB,EAAE,0BAA0B;QAC/C,YAAY,EAAE,mBAAmB;QACjC,UAAU,EAAE,iBAAiB;QAC7B,YAAY,EAAE,mBAAmB;QACjC,iBAAiB,EAAE,wBAAwB;QAC3C,gBAAgB,EAAE,uBAAuB;QACzC,mBAAmB,EAAE,0BAA0B;QAC/C,yBAAyB,EAAE,gCAAgC;QAC3D,gBAAgB,EAAE,uBAAuB;QACzC,mBAAmB,EAAE,0BAA0B;KAChD;IACD,GAAG,EAAE;QACH,YAAY,EAAE,kBAAkB;QAChC,sBAAsB,EAAE,4BAA4B;QACpD,SAAS,EAAE,eAAe;QAC1B,SAAS,EAAE,eAAe;QAC1B,aAAa,EAAE,mBAAmB;KACnC;IACD,MAAM,EAAE;QACN,WAAW,EAAE,oBAAoB;QACjC,SAAS,EAAE,kBAAkB;QAC7B,gBAAgB,EAAE,yBAAyB;QAC3C,WAAW,EAAE,oBAAoB;QACjC,2BAA2B,EAAE,oCAAoC;QACjE,WAAW,EAAE,oBAAoB;QACjC,qBAAqB,EAAE,8BAA8B;KACtD;IACD,MAAM,EAAE;QACN,UAAU,EAAE,mBAAmB;QAC/B,KAAK,EAAE,cAAc;QACrB,MAAM,EAAE,eAAe;QACvB,UAAU,EAAE,mBAAmB;QAC/B,MAAM,EAAE,eAAe;QACvB,KAAK,EAAE,cAAc;KACtB;IACD,MAAM,EAAE;QACN,YAAY,EAAE,qBAAqB;QACnC,MAAM,EAAE,eAAe;QACvB,aAAa,EAAE,sBAAsB;QACrC,GAAG,EAAE,YAAY;QACjB,MAAM,EAAE,eAAe;QACvB,KAAK,EAAE,cAAc;QACrB,KAAK,EAAE,cAAc;QACrB,KAAK,EAAE,cAAc;KACtB;IACD,SAAS,EAAE;QACT,UAAU,EAAE,sBAAsB;QAClC,aAAa,EAAE,yBAAyB;KACzC;CACO,CAAC"}
</file>

<file path="src/ipc/channels.ts">
export const IPC_CHANNELS = {
  CHAT: {
    SEND_MESSAGE: 'chat:send-message',
    SEND_MESSAGE_STREAM: 'chat:send-message-stream',
    STREAM_CHUNK: 'chat:stream-chunk',
    STREAM_END: 'chat:stream-end',
    STREAM_ERROR: 'chat:stream-error',
    GET_CONVERSATIONS: 'chat:get-conversations',
    GET_CONVERSATION: 'chat:get-conversation',
    CREATE_CONVERSATION: 'chat:create-conversation',
    UPDATE_CONVERSATION_TITLE: 'chat:update-conversation-title',
    MESSAGE_RECEIVED: 'chat:message-received',
    DELETE_CONVERSATION: 'chat:delete-conversation',
  },
  APP: {
    HEALTH_CHECK: 'app:health-check',
    SERVICE_STATUS_CHANGED: 'app:service-status-changed',
    GET_THEME: 'app:get-theme',
    SET_THEME: 'app:set-theme',
    THEME_UPDATED: 'app:theme-updated'
  },
  OLLAMA: {
    LIST_MODELS: 'ollama:list-models',
    SET_MODEL: 'ollama:set-model',
    CHECK_CONNECTION: 'ollama:check-connection',
    CANCEL_LOAD: 'ollama:cancel-load',
    MODEL_LOADING_STATE_CHANGED: 'ollama:model-loading-state-changed',
    SAVE_CONFIG: 'ollama:save-config',
    GET_CONNECTION_STATUS: 'ollama:get-connection-status'
  },
  MEMORY: {
    INITIALIZE: 'memory:initialize',
    STORE: 'memory:store',
    SEARCH: 'memory:search',
    GET_RECENT: 'memory:get-recent',
    DELETE: 'memory:delete',
    CLEAR: 'memory:clear'
  },
  VECTOR: {
    ADD_DOCUMENT: 'vector:add-document',
    SEARCH: 'vector:search',
    GET_DOCUMENTS: 'vector:get-documents',
    ADD: 'vector:add',
    DELETE: 'vector:delete',
    CLEAR: 'vector:clear',
    CHUNK: 'vector:chunk',
    MERGE: 'vector:merge'
  },
  EMBEDDING: {
    GET_CONFIG: 'embedding:get-config',
    UPDATE_CONFIG: 'embedding:update-config',
  },
} as const;
// Type for IPC channel names
export type IpcChannel = {
  [K in keyof typeof IPC_CHANNELS]: typeof IPC_CHANNELS[K][keyof typeof IPC_CHANNELS[K]]
}[keyof typeof IPC_CHANNELS];
</file>

<file path="src/ipc/chat.d.ts">
import { ChatService } from '../services/ChatService';
export declare function registerChatHandlers(chatService: ChatService): void;
</file>

<file path="src/ipc/chat.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerChatHandlers = registerChatHandlers;
const electron_1 = require("electron");
const OllamaClient_1 = require("../shared/api/OllamaClient");
const logger_1 = require("../utils/logger");
const ipc_1 = require("../types/ipc");
const types_1 = require("./types");
const uuid_1 = require("uuid");
const client = OllamaClient_1.OllamaClient.getInstance();
electron_1.ipcMain.handle('chat:ask', async (event, prompt) => {
    return new Promise((resolve) => {
        let reply = '';
        const message = {
            id: crypto.randomUUID(),
            role: ipc_1.Role.User,
            content: prompt,
            timestamp: Date.now()
        };
        client.sendMessageStream(message, {
            onChunk: (token) => {
                reply += token;
                event.sender.send('chat:token', token);
            },
            onComplete: () => {
                resolve(reply);
            },
            onError: (error) => {
                logger_1.logger.error('Chat error:', error);
                event.sender.send('chat:error', error.message);
                resolve('');
            }
        });
    });
});
function registerChatHandlers(chatService) {
    // Send message handler
    electron_1.ipcMain.handle(types_1.CHANNELS.CHAT.SEND_MESSAGE, async (_, request) => {
        try {
            const message = {
                id: (0, uuid_1.v4)(),
                content: request.content,
                role: ipc_1.Role.User,
                timestamp: Date.now(),
            };
            const response = await chatService.sendMessage(message);
            return {
                success: true,
                data: response,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to send message:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Get conversations handler
    electron_1.ipcMain.handle(types_1.CHANNELS.CHAT.GET_CONVERSATIONS, async () => {
        try {
            const conversations = await chatService.listConversations();
            return {
                success: true,
                data: conversations,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to get conversations:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Get conversation handler
    electron_1.ipcMain.handle(types_1.CHANNELS.CHAT.GET_CONVERSATION, async (_, conversationId) => {
        try {
            const messages = await chatService.getConversation(conversationId);
            return {
                success: true,
                data: {
                    id: conversationId,
                    messages,
                    title: '', // TODO: Get title from conversation
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                },
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to get conversation:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Create conversation handler
    electron_1.ipcMain.handle(types_1.CHANNELS.CHAT.CREATE_CONVERSATION, async (_, title) => {
        try {
            const conversationId = await chatService.createConversation(title);
            return {
                success: true,
                data: {
                    id: conversationId,
                    title,
                    messages: [],
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                },
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to create conversation:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Update conversation title handler
    electron_1.ipcMain.handle(types_1.CHANNELS.CHAT.UPDATE_CONVERSATION_TITLE, async (_, conversationId, title) => {
        try {
            await chatService.updateConversationTitle(conversationId, title);
            return {
                success: true,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to update conversation title:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
}
//# sourceMappingURL=chat.js.map
</file>

<file path="src/ipc/chat.js.map">
{"version":3,"file":"chat.js","sourceRoot":"","sources":["chat.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/ipc/chat.ts">
import { ipcMain } from 'electron';
import { OllamaClient } from '@shared/src/api/OllamaClient';
import { logger } from '../utils/logger';
import type { ChatMessage } from '@shared/types/ipc';
import { Role } from '@shared/types/ipc';
import { CHANNELS, Chat } from './types';
import { ChatService } from '../services/ChatService';
import { v4 as uuidv4 } from 'uuid';
const client = OllamaClient.getInstance();
ipcMain.handle('chat:ask', async (event, prompt: string) => {
  return new Promise((resolve) => {
    let reply = '';
    const message: ChatMessage = {
      id: crypto.randomUUID(),
      role: Role.User,
      content: prompt,
      timestamp: Date.now()
    };
    client.sendMessageStream(message, {
      onChunk: (token: string) => {
        reply += token;
        event.sender.send('chat:token', token);
      },
      onComplete: () => {
        resolve(reply);
      },
      onError: (error: Error) => {
        logger.error('Chat error:', error);
        event.sender.send('chat:error', error.message);
        resolve('');
      }
    });
  });
});
export function registerChatHandlers(chatService: ChatService) {
  // Send message handler
  ipcMain.handle(CHANNELS.CHAT.SEND_MESSAGE, async (_, request: Chat.SendMessageRequest): Promise<Chat.SendMessageResponse> => {
    try {
      const message = {
        id: uuidv4(),
        content: request.content,
        role: Role.User,
        timestamp: Date.now(),
      };
      const response = await chatService.sendMessage(message);
      return {
        success: true,
        data: response,
      };
    } catch (error) {
      logger.error('Failed to send message:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Get conversations handler
  ipcMain.handle(CHANNELS.CHAT.GET_CONVERSATIONS, async (): Promise<Chat.GetConversationsResponse> => {
    try {
      const conversations = await chatService.listConversations();
      return {
        success: true,
        data: conversations,
      };
    } catch (error) {
      logger.error('Failed to get conversations:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Get conversation handler
  ipcMain.handle(CHANNELS.CHAT.GET_CONVERSATION, async (_, conversationId: string): Promise<Chat.GetConversationResponse> => {
    try {
      const messages = await chatService.getConversation(conversationId);
      return {
        success: true,
        data: {
          id: conversationId,
          messages,
          title: '', // TODO: Get title from conversation
          createdAt: Date.now(),
          updatedAt: Date.now(),
        },
      };
    } catch (error) {
      logger.error('Failed to get conversation:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Create conversation handler
  ipcMain.handle(CHANNELS.CHAT.CREATE_CONVERSATION, async (_, title: string): Promise<Chat.CreateConversationResponse> => {
    try {
      const conversationId = await chatService.createConversation(title);
      return {
        success: true,
        data: {
          id: conversationId,
          title,
          messages: [],
          createdAt: Date.now(),
          updatedAt: Date.now(),
        },
      };
    } catch (error) {
      logger.error('Failed to create conversation:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Update conversation title handler
  ipcMain.handle(
    CHANNELS.CHAT.UPDATE_CONVERSATION_TITLE,
    async (_, conversationId: string, title: string): Promise<Chat.UpdateConversationTitleResponse> => {
      try {
        await chatService.updateConversationTitle(conversationId, title);
        return {
          success: true,
        };
      } catch (error) {
        logger.error('Failed to update conversation title:', error);
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error occurred',
        };
      }
    }
  );
}
</file>

<file path="src/ipc/handlers.d.ts">
export declare function setupIpcHandlers(): Promise<void>;
</file>

<file path="src/ipc/handlers.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupIpcHandlers = setupIpcHandlers;
const electron_1 = require("electron");
const OllamaClient_1 = require("../shared/api/OllamaClient");
const MessageStore_1 = require("../services/MessageStore");
const MemoryService_1 = require("../services/MemoryService");
const channels_1 = require("./channels");
const OllamaService_1 = require("../services/OllamaService");
const VectorStoreService_1 = require("../services/VectorStoreService");
const logger_1 = require("../utils/logger");
const ChatService_1 = require("../services/ChatService");
const EmbeddingService_1 = require("../services/EmbeddingService");
const ServiceManager_1 = require("../services/ServiceManager");
const client = OllamaClient_1.OllamaClient.getInstance();
const messageStore = new MessageStore_1.MessageStore();
const serviceManager = ServiceManager_1.ServiceManager.getInstance();
// Initialize services
const ollamaService = OllamaService_1.OllamaService.getInstance();
const embeddingService = EmbeddingService_1.EmbeddingService.getInstance();
const vectorStoreService = VectorStoreService_1.VectorStoreService.getInstance();
const memoryService = MemoryService_1.MemoryService.getInstance();
const chatService = ChatService_1.ChatService.getInstance();
let isInitialized = false;
// Helper function to check service availability
const withServiceCheck = async (serviceName, fn) => {
    try {
        const result = await fn();
        return { success: true, result };
    }
    catch (error) {
        console.error(`Service ${serviceName} error:`, error);
        return {
            success: false,
            error: error instanceof Error ? error.message : `Service ${serviceName} error`
        };
    }
};
async function setupIpcHandlers() {
    if (isInitialized) {
        return;
    }
    isInitialized = true;
    // Initialize services
    await messageStore.initialize();
    await memoryService.initialize();
    await vectorStoreService.initialize();
    await ollamaService.initialize();
    await embeddingService.initialize();
    await chatService.initialize();
    // Chat message handler with RAG
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.CHAT.SEND_MESSAGE, async (_event, message) => {
        try {
            return await chatService.sendMessage(message);
        }
        catch (error) {
            logger_1.logger.error('Error sending message:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.CHAT.SEND_MESSAGE_STREAM, async (_event, message) => {
        try {
            await chatService.sendMessageStream(message);
        }
        catch (error) {
            logger_1.logger.error('Error sending message stream:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.CHAT.CREATE_CONVERSATION, async (_event, title) => {
        try {
            return await chatService.createConversation(title);
        }
        catch (error) {
            logger_1.logger.error('Error creating conversation:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.CHAT.GET_CONVERSATION, async (_event, id) => {
        try {
            return await chatService.getConversation(id);
        }
        catch (error) {
            logger_1.logger.error('Error getting conversation:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.CHAT.GET_CONVERSATIONS, async () => {
        try {
            return await chatService.listConversations();
        }
        catch (error) {
            logger_1.logger.error('Error listing conversations:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.CHAT.DELETE_CONVERSATION, async (_event, id) => {
        try {
            await chatService.deleteConversation(id);
        }
        catch (error) {
            logger_1.logger.error('Error deleting conversation:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.CHAT.UPDATE_CONVERSATION_TITLE, async (_event, id, title) => {
        try {
            await chatService.updateConversationTitle(id, title);
        }
        catch (error) {
            logger_1.logger.error('Error updating conversation title:', error);
            throw error;
        }
    });
    // Ollama model handlers
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.OLLAMA.LIST_MODELS, () => withServiceCheck('ollama', async () => {
        const service = OllamaService_1.OllamaService.getInstance();
        return service.listModels();
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.OLLAMA.SET_MODEL, (_, modelName) => withServiceCheck('ollama', async () => {
        const service = OllamaService_1.OllamaService.getInstance();
        return service.setModel(modelName);
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.OLLAMA.CHECK_CONNECTION, () => withServiceCheck('ollama', async () => {
        const service = OllamaService_1.OllamaService.getInstance();
        return service.checkConnection();
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.OLLAMA.CANCEL_LOAD, () => withServiceCheck('ollama', async () => {
        const service = OllamaService_1.OllamaService.getInstance();
        return service.cancelLoad();
    }));
    // Embedding configuration handlers
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.EMBEDDING.GET_CONFIG, () => withServiceCheck('embedding', async () => {
        const service = EmbeddingService_1.EmbeddingService.getInstance();
        return service.getConfig();
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.EMBEDDING.UPDATE_CONFIG, (_, config) => withServiceCheck('embedding', async () => {
        const service = EmbeddingService_1.EmbeddingService.getInstance();
        return service.updateConfig(config);
    }));
    // Vector store handlers
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.VECTOR.SEARCH, (_, query) => withServiceCheck('vectorStore', async () => {
        const service = VectorStoreService_1.VectorStoreService.getInstance();
        return service.searchSimilar(query);
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.VECTOR.ADD, (_, document) => withServiceCheck('vectorStore', async () => {
        const service = VectorStoreService_1.VectorStoreService.getInstance();
        return service.addDocument(document);
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.VECTOR.DELETE, (_, id) => withServiceCheck('vectorStore', async () => {
        const service = VectorStoreService_1.VectorStoreService.getInstance();
        return service.deleteDocument(id);
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.VECTOR.CLEAR, () => withServiceCheck('vectorStore', async () => {
        const service = VectorStoreService_1.VectorStoreService.getInstance();
        return service.clear();
    }));
    // Memory service handlers
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.MEMORY.INITIALIZE, () => withServiceCheck('memory', async () => {
        const service = MemoryService_1.MemoryService.getInstance();
        return service.initialize();
    }));
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.MEMORY.STORE, async (_, chunk) => {
        try {
            const memoryService = MemoryService_1.MemoryService.getInstance();
            await memoryService.store(chunk);
            return { success: true };
        }
        catch (error) {
            console.error('Failed to store memory:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to store memory'
            };
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.MEMORY.SEARCH, async (_, query) => {
        try {
            const memoryService = MemoryService_1.MemoryService.getInstance();
            const results = await memoryService.search(query);
            return { success: true, results };
        }
        catch (error) {
            console.error('Failed to search memories:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to search memories'
            };
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.MEMORY.GET_RECENT, async (_, limit = 10) => {
        try {
            const memoryService = MemoryService_1.MemoryService.getInstance();
            const results = await memoryService.getRecent(limit);
            return { success: true, results };
        }
        catch (error) {
            console.error('Failed to get recent memories:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to get recent memories'
            };
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.MEMORY.DELETE, async (_, id) => {
        try {
            const memoryService = MemoryService_1.MemoryService.getInstance();
            await memoryService.delete(id);
            return { success: true };
        }
        catch (error) {
            console.error('Failed to delete memory:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to delete memory'
            };
        }
    });
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.MEMORY.CLEAR, async () => {
        try {
            const memoryService = MemoryService_1.MemoryService.getInstance();
            await memoryService.clear();
            return { success: true };
        }
        catch (error) {
            console.error('Failed to clear memories:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to clear memories'
            };
        }
    });
    // Memory service event listeners
    memoryService.on('initialized', () => {
        // Notify all windows
        electron_1.BrowserWindow.getAllWindows().forEach((window) => {
            window.webContents.send(channels_1.IPC_CHANNELS.MEMORY.INITIALIZE);
        });
    });
    memoryService.on('stored', (memory) => {
        electron_1.BrowserWindow.getAllWindows().forEach((window) => {
            window.webContents.send(channels_1.IPC_CHANNELS.MEMORY.STORE, memory);
        });
    });
    memoryService.on('searched', (memories) => {
        electron_1.BrowserWindow.getAllWindows().forEach((window) => {
            window.webContents.send(channels_1.IPC_CHANNELS.MEMORY.SEARCH, memories);
        });
    });
    memoryService.on('recent', (memories) => {
        electron_1.BrowserWindow.getAllWindows().forEach((window) => {
            window.webContents.send(channels_1.IPC_CHANNELS.MEMORY.GET_RECENT, memories);
        });
    });
    memoryService.on('deleted', (id) => {
        electron_1.BrowserWindow.getAllWindows().forEach((window) => {
            window.webContents.send(channels_1.IPC_CHANNELS.MEMORY.DELETE, id);
        });
    });
    memoryService.on('cleared', () => {
        electron_1.BrowserWindow.getAllWindows().forEach((window) => {
            window.webContents.send(channels_1.IPC_CHANNELS.MEMORY.CLEAR);
        });
    });
    // Service status handlers
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.APP.HEALTH_CHECK, () => {
        const statuses = serviceManager.getAllServiceStatuses();
        return Object.fromEntries(statuses);
    });
    // Setup event listeners for service status changes
    serviceManager.on('serviceStatusChanged', ({ serviceName, status, error }) => {
        electron_1.BrowserWindow.getAllWindows().forEach((window) => {
            window.webContents.send(channels_1.IPC_CHANNELS.APP.SERVICE_STATUS_CHANGED, {
                serviceName,
                status,
                error,
            });
        });
    });
    // Start health check monitoring
    client.startHealthCheck();
    // Cleanup on app quit
    process.on('exit', () => {
        client.stopHealthCheck();
    });
}
//# sourceMappingURL=handlers.js.map
</file>

<file path="src/ipc/handlers.js.map">
{"version":3,"file":"handlers.js","sourceRoot":"","sources":["handlers.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/ipc/handlers.ts">
import { ipcMain, BrowserWindow } from 'electron';
import type { IpcMessageMap } from '@shared/types/ipc';
import { OllamaClient } from '@shared/src/api/OllamaClient';
import { MessageStore } from '../services/MessageStore';
import { MemoryService, MemoryChunk } from '../services/MemoryService';
import { IPC_CHANNELS } from './channels';
import { OllamaService } from '../services/OllamaService';
import { VectorStoreService } from '../services/VectorStoreService';
import { logger } from '../utils/logger';
import type { ChatMessage } from '@shared/types/ipc';
import { ChatService } from '../services/ChatService';
import { EmbeddingService } from '../services/EmbeddingService';
import { ServiceManager } from '../services/ServiceManager';
import type { EmbeddingConfig } from '../services/EmbeddingService';
const client = OllamaClient.getInstance();
const messageStore = new MessageStore();
const serviceManager = ServiceManager.getInstance();
// Initialize services
const ollamaService = OllamaService.getInstance();
const embeddingService = EmbeddingService.getInstance();
const vectorStoreService = VectorStoreService.getInstance();
const memoryService = MemoryService.getInstance();
const chatService = ChatService.getInstance();
let isInitialized = false;
// Helper function to check service availability
const withServiceCheck = async <T>(
  serviceName: string,
  fn: () => Promise<T>
): Promise<{ success: boolean; error?: string; result?: T }> => {
  try {
    const result = await fn();
    return { success: true, result };
  } catch (error) {
    console.error(`Service ${serviceName} error:`, error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : `Service ${serviceName} error` 
    };
  }
};
export async function setupIpcHandlers(): Promise<void> {
  if (isInitialized) {
    return;
  }
  isInitialized = true;
  // Initialize services
  await messageStore.initialize();
  await memoryService.initialize();
  await vectorStoreService.initialize();
  await ollamaService.initialize();
  await embeddingService.initialize();
  await chatService.initialize();
  // Chat message handler with RAG
  ipcMain.handle(IPC_CHANNELS.CHAT.SEND_MESSAGE, async (_event, message) => {
    try {
      return await chatService.sendMessage(message);
    } catch (error) {
      logger.error('Error sending message:', error);
      throw error;
    }
  });
  ipcMain.handle(IPC_CHANNELS.CHAT.SEND_MESSAGE_STREAM, async (_event, message) => {
    try {
      await chatService.sendMessageStream(message);
    } catch (error) {
      logger.error('Error sending message stream:', error);
      throw error;
    }
  });
  ipcMain.handle(IPC_CHANNELS.CHAT.CREATE_CONVERSATION, async (_event, title) => {
    try {
      return await chatService.createConversation(title);
    } catch (error) {
      logger.error('Error creating conversation:', error);
      throw error;
    }
  });
  ipcMain.handle(IPC_CHANNELS.CHAT.GET_CONVERSATION, async (_event, id) => {
    try {
      return await chatService.getConversation(id);
    } catch (error) {
      logger.error('Error getting conversation:', error);
      throw error;
    }
  });
  ipcMain.handle(IPC_CHANNELS.CHAT.GET_CONVERSATIONS, async () => {
    try {
      return await chatService.listConversations();
    } catch (error) {
      logger.error('Error listing conversations:', error);
      throw error;
    }
  });
  ipcMain.handle(IPC_CHANNELS.CHAT.DELETE_CONVERSATION, async (_event, id) => {
    try {
      await chatService.deleteConversation(id);
    } catch (error) {
      logger.error('Error deleting conversation:', error);
      throw error;
    }
  });
  ipcMain.handle(IPC_CHANNELS.CHAT.UPDATE_CONVERSATION_TITLE, async (_event, id, title) => {
    try {
      await chatService.updateConversationTitle(id, title);
    } catch (error) {
      logger.error('Error updating conversation title:', error);
      throw error;
    }
  });
  // Ollama model handlers
  ipcMain.handle(IPC_CHANNELS.OLLAMA.LIST_MODELS, () =>
    withServiceCheck('ollama', async () => {
      const service = OllamaService.getInstance();
      return service.listModels();
    })
  );
  ipcMain.handle(IPC_CHANNELS.OLLAMA.SET_MODEL, (_, modelName: string) =>
    withServiceCheck('ollama', async () => {
      const service = OllamaService.getInstance();
      return service.setModel(modelName);
    })
  );
  ipcMain.handle(IPC_CHANNELS.OLLAMA.CHECK_CONNECTION, () =>
    withServiceCheck('ollama', async () => {
      const service = OllamaService.getInstance();
      return service.checkConnection();
    })
  );
  ipcMain.handle(IPC_CHANNELS.OLLAMA.CANCEL_LOAD, () =>
    withServiceCheck('ollama', async () => {
      const service = OllamaService.getInstance();
      return service.cancelLoad();
    })
  );
  // Embedding configuration handlers
  ipcMain.handle(IPC_CHANNELS.EMBEDDING.GET_CONFIG, () =>
    withServiceCheck('embedding', async () => {
      const service = EmbeddingService.getInstance();
      return service.getConfig();
    })
  );
  ipcMain.handle(IPC_CHANNELS.EMBEDDING.UPDATE_CONFIG, (_, config: Partial<EmbeddingConfig>) =>
    withServiceCheck('embedding', async () => {
      const service = EmbeddingService.getInstance();
      return service.updateConfig(config);
    })
  );
  // Vector store handlers
  ipcMain.handle(IPC_CHANNELS.VECTOR.SEARCH, (_, query: string) =>
    withServiceCheck('vectorStore', async () => {
      const service = VectorStoreService.getInstance();
      return service.searchSimilar(query);
    })
  );
  ipcMain.handle(IPC_CHANNELS.VECTOR.ADD, (_, document: any) =>
    withServiceCheck('vectorStore', async () => {
      const service = VectorStoreService.getInstance();
      return service.addDocument(document);
    })
  );
  ipcMain.handle(IPC_CHANNELS.VECTOR.DELETE, (_, id: string) =>
    withServiceCheck('vectorStore', async () => {
      const service = VectorStoreService.getInstance();
      return service.deleteDocument(id);
    })
  );
  ipcMain.handle(IPC_CHANNELS.VECTOR.CLEAR, () =>
    withServiceCheck('vectorStore', async () => {
      const service = VectorStoreService.getInstance();
      return service.clear();
    })
  );
  // Memory service handlers
  ipcMain.handle(IPC_CHANNELS.MEMORY.INITIALIZE, () =>
    withServiceCheck('memory', async () => {
      const service = MemoryService.getInstance();
      return service.initialize();
    })
  );
  ipcMain.handle(IPC_CHANNELS.MEMORY.STORE, async (_, chunk: MemoryChunk) => {
    try {
      const memoryService = MemoryService.getInstance();
      await memoryService.store(chunk);
      return { success: true };
    } catch (error) {
      console.error('Failed to store memory:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to store memory' 
      };
    }
  });
  ipcMain.handle(IPC_CHANNELS.MEMORY.SEARCH, async (_, query: string) => {
    try {
      const memoryService = MemoryService.getInstance();
      const results = await memoryService.search(query);
      return { success: true, results };
    } catch (error) {
      console.error('Failed to search memories:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to search memories' 
      };
    }
  });
  ipcMain.handle(IPC_CHANNELS.MEMORY.GET_RECENT, async (_, limit: number = 10) => {
    try {
      const memoryService = MemoryService.getInstance();
      const results = await memoryService.getRecent(limit);
      return { success: true, results };
    } catch (error) {
      console.error('Failed to get recent memories:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to get recent memories' 
      };
    }
  });
  ipcMain.handle(IPC_CHANNELS.MEMORY.DELETE, async (_, id: string) => {
    try {
      const memoryService = MemoryService.getInstance();
      await memoryService.delete(id);
      return { success: true };
    } catch (error) {
      console.error('Failed to delete memory:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to delete memory' 
      };
    }
  });
  ipcMain.handle(IPC_CHANNELS.MEMORY.CLEAR, async () => {
    try {
      const memoryService = MemoryService.getInstance();
      await memoryService.clear();
      return { success: true };
    } catch (error) {
      console.error('Failed to clear memories:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to clear memories' 
      };
    }
  });
  // Memory service event listeners
  memoryService.on('initialized', () => {
    // Notify all windows
    BrowserWindow.getAllWindows().forEach((window: BrowserWindow) => {
      window.webContents.send(IPC_CHANNELS.MEMORY.INITIALIZE);
    });
  });
  memoryService.on('stored', (memory: MemoryChunk) => {
    BrowserWindow.getAllWindows().forEach((window: BrowserWindow) => {
      window.webContents.send(IPC_CHANNELS.MEMORY.STORE, memory);
    });
  });
  memoryService.on('searched', (memories: MemoryChunk[]) => {
    BrowserWindow.getAllWindows().forEach((window: BrowserWindow) => {
      window.webContents.send(IPC_CHANNELS.MEMORY.SEARCH, memories);
    });
  });
  memoryService.on('recent', (memories: MemoryChunk[]) => {
    BrowserWindow.getAllWindows().forEach((window: BrowserWindow) => {
      window.webContents.send(IPC_CHANNELS.MEMORY.GET_RECENT, memories);
    });
  });
  memoryService.on('deleted', (id: string) => {
    BrowserWindow.getAllWindows().forEach((window: BrowserWindow) => {
      window.webContents.send(IPC_CHANNELS.MEMORY.DELETE, id);
    });
  });
  memoryService.on('cleared', () => {
    BrowserWindow.getAllWindows().forEach((window: BrowserWindow) => {
      window.webContents.send(IPC_CHANNELS.MEMORY.CLEAR);
    });
  });
  // Service status handlers
  ipcMain.handle(IPC_CHANNELS.APP.HEALTH_CHECK, () => {
    const statuses = serviceManager.getAllServiceStatuses();
    return Object.fromEntries(statuses);
  });
  // Setup event listeners for service status changes
  serviceManager.on('serviceStatusChanged', ({ serviceName, status, error }) => {
    BrowserWindow.getAllWindows().forEach((window) => {
      window.webContents.send(IPC_CHANNELS.APP.SERVICE_STATUS_CHANGED, {
        serviceName,
        status,
        error,
      });
    });
  });
  // Start health check monitoring
  client.startHealthCheck();
  // Cleanup on app quit
  process.on('exit', () => {
    client.stopHealthCheck();
  });
}
</file>

<file path="src/ipc/memory.d.ts">
import { MemoryService } from '../services/MemoryService';
export declare function registerMemoryHandlers(memoryService: MemoryService): void;
</file>

<file path="src/ipc/memory.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerMemoryHandlers = registerMemoryHandlers;
const electron_1 = require("electron");
const types_1 = require("./types");
const logger_1 = require("../utils/logger");
const uuid_1 = require("uuid");
function registerMemoryHandlers(memoryService) {
    // Get recent memories handler
    electron_1.ipcMain.handle(types_1.CHANNELS.MEMORY.GET_RECENT, async (_, limit = 10) => {
        try {
            const memories = await memoryService.getRecent(limit);
            return {
                success: true,
                data: memories,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to get recent memories:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Store memory handler
    electron_1.ipcMain.handle(types_1.CHANNELS.MEMORY.STORE, async (_, memory) => {
        try {
            const memoryWithId = {
                ...memory,
                id: (0, uuid_1.v4)(),
            };
            await memoryService.store(memoryWithId);
            return {
                success: true,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to store memory:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Delete memory handler
    electron_1.ipcMain.handle(types_1.CHANNELS.MEMORY.DELETE, async (_, id) => {
        try {
            await memoryService.delete(id);
            return {
                success: true,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to delete memory:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Clear memories handler
    electron_1.ipcMain.handle(types_1.CHANNELS.MEMORY.CLEAR, async () => {
        try {
            await memoryService.clear();
            return {
                success: true,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to clear memories:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Get stats handler
    electron_1.ipcMain.handle(types_1.CHANNELS.MEMORY.GET_STATS, async () => {
        try {
            const stats = await memoryService.getStats();
            return {
                success: true,
                data: stats,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to get memory stats:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
}
//# sourceMappingURL=memory.js.map
</file>

<file path="src/ipc/memory.js.map">
{"version":3,"file":"memory.js","sourceRoot":"","sources":["memory.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/ipc/memory.ts">
import { ipcMain } from 'electron';
import { CHANNELS, Memory } from './types';
import { MemoryService } from '../services/MemoryService';
import { logger } from '../utils/logger';
import { v4 as uuidv4 } from 'uuid';
export function registerMemoryHandlers(memoryService: MemoryService) {
  // Get recent memories handler
  ipcMain.handle(CHANNELS.MEMORY.GET_RECENT, async (_, limit: number = 10): Promise<Memory.GetRecentResponse> => {
    try {
      const memories = await memoryService.getRecent(limit);
      return {
        success: true,
        data: memories,
      };
    } catch (error) {
      logger.error('Failed to get recent memories:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Store memory handler
  ipcMain.handle(CHANNELS.MEMORY.STORE, async (_, memory: Omit<Memory.MemoryChunk, 'id'>): Promise<Memory.StoreResponse> => {
    try {
      const memoryWithId = {
        ...memory,
        id: uuidv4(),
      };
      await memoryService.store(memoryWithId);
      return {
        success: true,
      };
    } catch (error) {
      logger.error('Failed to store memory:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Delete memory handler
  ipcMain.handle(CHANNELS.MEMORY.DELETE, async (_, id: string): Promise<Memory.DeleteResponse> => {
    try {
      await memoryService.delete(id);
      return {
        success: true,
      };
    } catch (error) {
      logger.error('Failed to delete memory:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Clear memories handler
  ipcMain.handle(CHANNELS.MEMORY.CLEAR, async (): Promise<Memory.ClearResponse> => {
    try {
      await memoryService.clear();
      return {
        success: true,
      };
    } catch (error) {
      logger.error('Failed to clear memories:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Get stats handler
  ipcMain.handle(CHANNELS.MEMORY.GET_STATS, async (): Promise<Memory.StatsResponse> => {
    try {
      const stats = await memoryService.getStats();
      return {
        success: true,
        data: stats,
      };
    } catch (error) {
      logger.error('Failed to get memory stats:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
}
</file>

<file path="src/ipc/model.d.ts">
export {};
</file>

<file path="src/ipc/model.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
const OllamaClient_1 = require("../shared/api/OllamaClient");
const logger_1 = require("../utils/logger");
const client = OllamaClient_1.OllamaClient.getInstance();
electron_1.ipcMain.handle('model:list', async () => {
    try {
        return await client.listModels();
    }
    catch (error) {
        logger_1.logger.error('Error listing models:', error);
        throw error;
    }
});
electron_1.ipcMain.handle('model:set', async (_, name) => {
    try {
        await client.setModel(name);
        return true;
    }
    catch (error) {
        logger_1.logger.error('Error setting model:', error);
        throw error;
    }
});
electron_1.ipcMain.handle('model:get', () => {
    return client.getCurrentModel();
});
//# sourceMappingURL=model.js.map
</file>

<file path="src/ipc/model.js.map">
{"version":3,"file":"model.js","sourceRoot":"","sources":["model.ts"],"names":[],"mappings":";;AAAA,uCAAmC;AACnC,6DAA0D;AAC1D,4CAAyC;AAEzC,MAAM,MAAM,GAAG,2BAAY,CAAC,WAAW,EAAE,CAAC;AAE1C,kBAAO,CAAC,MAAM,CAAC,YAAY,EAAE,KAAK,IAAI,EAAE;IACtC,IAAI,CAAC;QACH,OAAO,MAAM,MAAM,CAAC,UAAU,EAAE,CAAC;IACnC,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,eAAM,CAAC,KAAK,CAAC,uBAAuB,EAAE,KAAK,CAAC,CAAC;QAC7C,MAAM,KAAK,CAAC;IACd,CAAC;AACH,CAAC,CAAC,CAAC;AAEH,kBAAO,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,EAAE,CAAC,EAAE,IAAY,EAAE,EAAE;IACpD,IAAI,CAAC;QACH,MAAM,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC;IACd,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,eAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;QAC5C,MAAM,KAAK,CAAC;IACd,CAAC;AACH,CAAC,CAAC,CAAC;AAEH,kBAAO,CAAC,MAAM,CAAC,WAAW,EAAE,GAAG,EAAE;IAC/B,OAAO,MAAM,CAAC,eAAe,EAAE,CAAC;AAClC,CAAC,CAAC,CAAC"}
</file>

<file path="src/ipc/model.ts">
import { ipcMain } from 'electron';
import { OllamaClient } from '@shared/src/api/OllamaClient';
import { logger } from '../utils/logger';
const client = OllamaClient.getInstance();
ipcMain.handle('model:list', async () => {
  try {
    return await client.listModels();
  } catch (error) {
    logger.error('Error listing models:', error);
    throw error;
  }
});
ipcMain.handle('model:set', async (_, name: string) => {
  try {
    await client.setModel(name);
    return true;
  } catch (error) {
    logger.error('Error setting model:', error);
    throw error;
  }
});
ipcMain.handle('model:get', () => {
  return client.getCurrentModel();
});
</file>

<file path="src/ipc/ollama.d.ts">
import { OllamaService } from '../services/OllamaService';
export declare function registerOllamaHandlers(ollamaService: OllamaService): void;
</file>

<file path="src/ipc/ollama.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerOllamaHandlers = registerOllamaHandlers;
const electron_1 = require("electron");
const types_1 = require("./types");
const logger_1 = require("../utils/logger");
function registerOllamaHandlers(ollamaService) {
    // List models handler
    electron_1.ipcMain.handle(types_1.CHANNELS.OLLAMA.LIST_MODELS, async () => {
        try {
            const { models } = await ollamaService.listModels();
            return {
                success: true,
                data: { models },
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to list models:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Set model handler
    electron_1.ipcMain.handle(types_1.CHANNELS.OLLAMA.SET_MODEL, async (_, modelName) => {
        try {
            await ollamaService.setModel(modelName);
            return {
                success: true,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to set model:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Check connection handler
    electron_1.ipcMain.handle(types_1.CHANNELS.OLLAMA.CHECK_CONNECTION, async () => {
        try {
            const status = await ollamaService.getStatus();
            const connectionStatus = {
                connected: status === 'running',
                error: status === 'error' ? 'Service error' : undefined,
            };
            return {
                success: true,
                data: connectionStatus,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to check connection:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
    // Save config handler
    electron_1.ipcMain.handle(types_1.CHANNELS.OLLAMA.SAVE_CONFIG, async (_, config) => {
        try {
            if ('model' in config && typeof config.model === 'string') {
                await ollamaService.setModel(config.model);
            }
            return {
                success: true,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to save config:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred',
            };
        }
    });
}
//# sourceMappingURL=ollama.js.map
</file>

<file path="src/ipc/ollama.js.map">
{"version":3,"file":"ollama.js","sourceRoot":"","sources":["ollama.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/ipc/ollama.ts">
import { ipcMain } from 'electron';
import { CHANNELS, Ollama } from './types';
import { OllamaService } from '../services/OllamaService';
import { logger } from '../utils/logger';
import type { OllamaConnectionStatus } from '../types/ollama';
export function registerOllamaHandlers(ollamaService: OllamaService) {
  // List models handler
  ipcMain.handle(CHANNELS.OLLAMA.LIST_MODELS, async (): Promise<Ollama.ListModelsResponse> => {
    try {
      const { models } = await ollamaService.listModels();
      return {
        success: true,
        data: { models },
      };
    } catch (error) {
      logger.error('Failed to list models:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Set model handler
  ipcMain.handle(CHANNELS.OLLAMA.SET_MODEL, async (_, modelName: string): Promise<Ollama.SetModelResponse> => {
    try {
      await ollamaService.setModel(modelName);
      return {
        success: true,
      };
    } catch (error) {
      logger.error('Failed to set model:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Check connection handler
  ipcMain.handle(CHANNELS.OLLAMA.CHECK_CONNECTION, async (): Promise<Ollama.CheckConnectionResponse> => {
    try {
      const status = await ollamaService.getStatus();
      const connectionStatus: OllamaConnectionStatus = {
        connected: status === 'running',
        error: status === 'error' ? 'Service error' : undefined,
      };
      return {
        success: true,
        data: connectionStatus,
      };
    } catch (error) {
      logger.error('Failed to check connection:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
  // Save config handler
  ipcMain.handle(CHANNELS.OLLAMA.SAVE_CONFIG, async (_, config: Record<string, unknown>): Promise<Ollama.SaveConfigResponse> => {
    try {
      if ('model' in config && typeof config.model === 'string') {
        await ollamaService.setModel(config.model);
      }
      return {
        success: true,
      };
    } catch (error) {
      logger.error('Failed to save config:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    }
  });
}
</file>

<file path="src/ipc/theme.d.ts">
/**
 * Sets up IPC handlers for theme-related operations
 */
export declare function setupThemeHandlers(): void;
</file>

<file path="src/ipc/theme.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupThemeHandlers = setupThemeHandlers;
const electron_1 = require("electron");
const logger_1 = require("../utils/logger");
const channels_1 = require("./channels");
/**
 * Sets up IPC handlers for theme-related operations
 */
function setupThemeHandlers() {
    // Get current theme
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.APP.GET_THEME, () => {
        return electron_1.nativeTheme.themeSource;
    });
    // Set theme
    electron_1.ipcMain.handle(channels_1.IPC_CHANNELS.APP.SET_THEME, (_event, theme) => {
        try {
            logger_1.logger.info(`Setting theme to: ${theme}`);
            electron_1.nativeTheme.themeSource = theme;
            return true;
        }
        catch (error) {
            logger_1.logger.error('Error setting theme:', error);
            throw error;
        }
    });
    // Listen for native theme changes and notify renderer
    electron_1.nativeTheme.on('updated', () => {
        const windows = electron_1.BrowserWindow.getAllWindows();
        windows.forEach(window => {
            window.webContents.send(channels_1.IPC_CHANNELS.APP.THEME_UPDATED, {
                theme: electron_1.nativeTheme.themeSource,
                shouldUseDarkColors: electron_1.nativeTheme.shouldUseDarkColors
            });
        });
        logger_1.logger.info(`Native theme updated: ${electron_1.nativeTheme.themeSource}, shouldUseDarkColors: ${electron_1.nativeTheme.shouldUseDarkColors}`);
    });
}
//# sourceMappingURL=theme.js.map
</file>

<file path="src/ipc/theme.js.map">
{"version":3,"file":"theme.js","sourceRoot":"","sources":["theme.ts"],"names":[],"mappings":";;AAOA,gDA6BC;AApCD,uCAA+D;AAC/D,4CAAyC;AACzC,yCAA0C;AAE1C;;GAEG;AACH,SAAgB,kBAAkB;IAChC,oBAAoB;IACpB,kBAAO,CAAC,MAAM,CAAC,uBAAY,CAAC,GAAG,CAAC,SAAS,EAAE,GAAG,EAAE;QAC9C,OAAO,sBAAW,CAAC,WAAW,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,YAAY;IACZ,kBAAO,CAAC,MAAM,CAAC,uBAAY,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,MAAM,EAAE,KAAkC,EAAE,EAAE;QACxF,IAAI,CAAC;YACH,eAAM,CAAC,IAAI,CAAC,qBAAqB,KAAK,EAAE,CAAC,CAAC;YAC1C,sBAAW,CAAC,WAAW,GAAG,KAAK,CAAC;YAChC,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;YAC5C,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,sDAAsD;IACtD,sBAAW,CAAC,EAAE,CAAC,SAAS,EAAE,GAAG,EAAE;QAC7B,MAAM,OAAO,GAAG,wBAAa,CAAC,aAAa,EAAE,CAAC;QAC9C,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YACvB,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,uBAAY,CAAC,GAAG,CAAC,aAAa,EAAE;gBACtD,KAAK,EAAE,sBAAW,CAAC,WAAW;gBAC9B,mBAAmB,EAAE,sBAAW,CAAC,mBAAmB;aACrD,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,eAAM,CAAC,IAAI,CAAC,yBAAyB,sBAAW,CAAC,WAAW,0BAA0B,sBAAW,CAAC,mBAAmB,EAAE,CAAC,CAAC;IAC3H,CAAC,CAAC,CAAC;AACL,CAAC"}
</file>

<file path="src/ipc/theme.ts">
import { ipcMain, nativeTheme, BrowserWindow } from 'electron';
import { logger } from '../utils/logger';
import { IPC_CHANNELS } from './channels';
/**
 * Sets up IPC handlers for theme-related operations
 */
export function setupThemeHandlers(): void {
  // Get current theme
  ipcMain.handle(IPC_CHANNELS.APP.GET_THEME, () => {
    return nativeTheme.themeSource;
  });
  // Set theme
  ipcMain.handle(IPC_CHANNELS.APP.SET_THEME, (_event, theme: 'light' | 'dark' | 'system') => {
    try {
      logger.info(`Setting theme to: ${theme}`);
      nativeTheme.themeSource = theme;
      return true;
    } catch (error) {
      logger.error('Error setting theme:', error);
      throw error;
    }
  });
  // Listen for native theme changes and notify renderer
  nativeTheme.on('updated', () => {
    const windows = BrowserWindow.getAllWindows();
    windows.forEach(window => {
      window.webContents.send(IPC_CHANNELS.APP.THEME_UPDATED, {
        theme: nativeTheme.themeSource,
        shouldUseDarkColors: nativeTheme.shouldUseDarkColors
      });
    });
    logger.info(`Native theme updated: ${nativeTheme.themeSource}, shouldUseDarkColors: ${nativeTheme.shouldUseDarkColors}`);
  });
}
</file>

<file path="src/ipc/types.d.ts">
import { z } from 'zod';
import type { OllamaModel, OllamaConnectionStatus, ModelLoadingState } from '../types/ollama';
import type { ServiceStatus } from '../config/services';
export interface IpcResponse<T = void> {
    success: boolean;
    error?: string;
    data?: T;
}
export declare namespace Chat {
    const MessageSchema: any;
    const ConversationSchema: any;
    type Message = z.infer<typeof MessageSchema>;
    type Conversation = z.infer<typeof ConversationSchema>;
    interface SendMessageRequest {
        content: string;
        conversationId?: string;
        metadata?: Record<string, unknown>;
    }
    interface SendMessageResponse extends IpcResponse<Message> {
    }
    interface GetConversationsResponse extends IpcResponse<Conversation[]> {
    }
    interface GetConversationResponse extends IpcResponse<Conversation> {
    }
    interface CreateConversationResponse extends IpcResponse<Conversation> {
    }
    interface UpdateConversationTitleResponse extends IpcResponse<void> {
    }
}
export declare namespace Ollama {
    interface ListModelsResponse extends IpcResponse<{
        models: OllamaModel[];
    }> {
    }
    interface SetModelResponse extends IpcResponse<void> {
    }
    interface CheckConnectionResponse extends IpcResponse<OllamaConnectionStatus> {
    }
    interface SaveConfigResponse extends IpcResponse<void> {
    }
}
export declare namespace Memory {
    interface MemoryChunk {
        id: string;
        content: string;
        metadata: {
            timestamp: number;
            source?: string;
            type?: string;
            tags?: string[];
            importance?: number;
            context?: Record<string, unknown>;
        };
        vector?: number[];
        similarity?: number;
        importance?: number;
        expiresAt?: number;
    }
    interface GetRecentResponse extends IpcResponse<MemoryChunk[]> {
    }
    interface SearchResponse extends IpcResponse<MemoryChunk[]> {
    }
    interface StoreResponse extends IpcResponse<void> {
    }
    interface DeleteResponse extends IpcResponse<void> {
    }
    interface ClearResponse extends IpcResponse<void> {
    }
    interface StatsResponse extends IpcResponse<{
        total: number;
        active: number;
        expired: number;
        averageImportance: number;
        cacheSize: number;
    }> {
    }
}
export declare namespace Service {
    interface GetStatusResponse extends IpcResponse<ServiceStatus> {
    }
    interface GetAllStatusResponse extends IpcResponse<Record<string, ServiceStatus>> {
    }
    interface RestartResponse extends IpcResponse<void> {
    }
    interface StopResponse extends IpcResponse<void> {
    }
}
export declare namespace Events {
    interface ServiceStatusChanged {
        serviceName: string;
        status: ServiceStatus;
        error?: string;
        details?: Record<string, unknown>;
    }
    interface ModelLoadingStateChanged {
        state: ModelLoadingState;
        progress?: number;
        error?: string;
    }
    interface MemoryStored {
        memory: Memory.MemoryChunk;
    }
    interface MemoryDeleted {
        id: string;
    }
    interface MemoryCleared {
    }
}
export declare const CHANNELS: {
    readonly CHAT: {
        readonly SEND_MESSAGE: "chat:send-message";
        readonly GET_CONVERSATIONS: "chat:get-conversations";
        readonly GET_CONVERSATION: "chat:get-conversation";
        readonly CREATE_CONVERSATION: "chat:create-conversation";
        readonly UPDATE_CONVERSATION_TITLE: "chat:update-conversation-title";
    };
    readonly OLLAMA: {
        readonly LIST_MODELS: "ollama:list-models";
        readonly SET_MODEL: "ollama:set-model";
        readonly CHECK_CONNECTION: "ollama:check-connection";
        readonly SAVE_CONFIG: "ollama:save-config";
    };
    readonly MEMORY: {
        readonly GET_RECENT: "memory:get-recent";
        readonly SEARCH: "memory:search";
        readonly STORE: "memory:store";
        readonly DELETE: "memory:delete";
        readonly CLEAR: "memory:clear";
        readonly GET_STATS: "memory:get-stats";
    };
    readonly SERVICE: {
        readonly GET_STATUS: "service:get-status";
        readonly GET_ALL_STATUS: "service:get-all-status";
        readonly RESTART: "service:restart";
        readonly STOP: "service:stop";
    };
    readonly EVENTS: {
        readonly SERVICE_STATUS_CHANGED: "events:service-status-changed";
        readonly MODEL_LOADING_STATE_CHANGED: "events:model-loading-state-changed";
        readonly MEMORY_STORED: "events:memory-stored";
        readonly MEMORY_DELETED: "events:memory-deleted";
        readonly MEMORY_CLEARED: "events:memory-cleared";
    };
};
export type ChannelMap = {
    [K in typeof CHANNELS[keyof typeof CHANNELS][keyof typeof CHANNELS[keyof typeof CHANNELS]]]: {
        request: unknown;
        response: IpcResponse<unknown>;
    };
};
</file>

<file path="src/ipc/types.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CHANNELS = exports.Chat = void 0;
const zod_1 = require("zod");
// Domain-specific request/response types
var Chat;
(function (Chat) {
    Chat.MessageSchema = zod_1.z.object({
        id: zod_1.z.string(),
        content: zod_1.z.string(),
        role: zod_1.z.enum(['user', 'assistant', 'system']),
        timestamp: zod_1.z.number(),
        metadata: zod_1.z.record(zod_1.z.unknown()).optional(),
    });
    Chat.ConversationSchema = zod_1.z.object({
        id: zod_1.z.string(),
        title: zod_1.z.string(),
        messages: zod_1.z.array(Chat.MessageSchema),
        createdAt: zod_1.z.number(),
        updatedAt: zod_1.z.number(),
        metadata: zod_1.z.record(zod_1.z.unknown()).optional(),
    });
})(Chat || (exports.Chat = Chat = {}));
// Channel names with type safety
exports.CHANNELS = {
    CHAT: {
        SEND_MESSAGE: 'chat:send-message',
        GET_CONVERSATIONS: 'chat:get-conversations',
        GET_CONVERSATION: 'chat:get-conversation',
        CREATE_CONVERSATION: 'chat:create-conversation',
        UPDATE_CONVERSATION_TITLE: 'chat:update-conversation-title',
    },
    OLLAMA: {
        LIST_MODELS: 'ollama:list-models',
        SET_MODEL: 'ollama:set-model',
        CHECK_CONNECTION: 'ollama:check-connection',
        SAVE_CONFIG: 'ollama:save-config',
    },
    MEMORY: {
        GET_RECENT: 'memory:get-recent',
        SEARCH: 'memory:search',
        STORE: 'memory:store',
        DELETE: 'memory:delete',
        CLEAR: 'memory:clear',
        GET_STATS: 'memory:get-stats',
    },
    SERVICE: {
        GET_STATUS: 'service:get-status',
        GET_ALL_STATUS: 'service:get-all-status',
        RESTART: 'service:restart',
        STOP: 'service:stop',
    },
    EVENTS: {
        SERVICE_STATUS_CHANGED: 'events:service-status-changed',
        MODEL_LOADING_STATE_CHANGED: 'events:model-loading-state-changed',
        MEMORY_STORED: 'events:memory-stored',
        MEMORY_DELETED: 'events:memory-deleted',
        MEMORY_CLEARED: 'events:memory-cleared',
    },
};
//# sourceMappingURL=types.js.map
</file>

<file path="src/ipc/types.js.map">
{"version":3,"file":"types.js","sourceRoot":"","sources":["types.ts"],"names":[],"mappings":";;;AAAA,6BAAwB;AAiBxB,yCAAyC;AACzC,IAAiB,IAAI,CAgCpB;AAhCD,WAAiB,IAAI;IACN,kBAAa,GAAG,OAAC,CAAC,MAAM,CAAC;QACpC,EAAE,EAAE,OAAC,CAAC,MAAM,EAAE;QACd,OAAO,EAAE,OAAC,CAAC,MAAM,EAAE;QACnB,IAAI,EAAE,OAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC;QAC7C,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE;QACrB,QAAQ,EAAE,OAAC,CAAC,MAAM,CAAC,OAAC,CAAC,OAAO,EAAE,CAAC,CAAC,QAAQ,EAAE;KAC3C,CAAC,CAAC;IAEU,uBAAkB,GAAG,OAAC,CAAC,MAAM,CAAC;QACzC,EAAE,EAAE,OAAC,CAAC,MAAM,EAAE;QACd,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE;QACjB,QAAQ,EAAE,OAAC,CAAC,KAAK,CAAC,KAAA,aAAa,CAAC;QAChC,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE;QACrB,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE;QACrB,QAAQ,EAAE,OAAC,CAAC,MAAM,CAAC,OAAC,CAAC,OAAO,EAAE,CAAC,CAAC,QAAQ,EAAE;KAC3C,CAAC,CAAC;AAgBL,CAAC,EAhCgB,IAAI,oBAAJ,IAAI,QAgCpB;AA0ED,iCAAiC;AACpB,QAAA,QAAQ,GAAG;IACtB,IAAI,EAAE;QACJ,YAAY,EAAE,mBAAmB;QACjC,iBAAiB,EAAE,wBAAwB;QAC3C,gBAAgB,EAAE,uBAAuB;QACzC,mBAAmB,EAAE,0BAA0B;QAC/C,yBAAyB,EAAE,gCAAgC;KAC5D;IACD,MAAM,EAAE;QACN,WAAW,EAAE,oBAAoB;QACjC,SAAS,EAAE,kBAAkB;QAC7B,gBAAgB,EAAE,yBAAyB;QAC3C,WAAW,EAAE,oBAAoB;KAClC;IACD,MAAM,EAAE;QACN,UAAU,EAAE,mBAAmB;QAC/B,MAAM,EAAE,eAAe;QACvB,KAAK,EAAE,cAAc;QACrB,MAAM,EAAE,eAAe;QACvB,KAAK,EAAE,cAAc;QACrB,SAAS,EAAE,kBAAkB;KAC9B;IACD,OAAO,EAAE;QACP,UAAU,EAAE,oBAAoB;QAChC,cAAc,EAAE,wBAAwB;QACxC,OAAO,EAAE,iBAAiB;QAC1B,IAAI,EAAE,cAAc;KACrB;IACD,MAAM,EAAE;QACN,sBAAsB,EAAE,+BAA+B;QACvD,2BAA2B,EAAE,oCAAoC;QACjE,aAAa,EAAE,sBAAsB;QACrC,cAAc,EAAE,uBAAuB;QACvC,cAAc,EAAE,uBAAuB;KACxC;CACO,CAAC"}
</file>

<file path="src/ipc/types.ts">
import { z } from 'zod';
import type { 
  OllamaModel, 
  OllamaConnectionStatus,
  ModelLoadingState,
  OllamaRequestOptions,
  OllamaResponse
} from '../types/ollama';
import type { ServiceStatus } from '../config/services';
// Base response type for all IPC calls
export interface IpcResponse<T = void> {
  success: boolean;
  error?: string;
  data?: T;
}
// Domain-specific request/response types
export namespace Chat {
  export const MessageSchema = z.object({
    id: z.string(),
    content: z.string(),
    role: z.enum(['user', 'assistant', 'system']),
    timestamp: z.number(),
    metadata: z.record(z.unknown()).optional(),
  });
  export const ConversationSchema = z.object({
    id: z.string(),
    title: z.string(),
    messages: z.array(MessageSchema),
    createdAt: z.number(),
    updatedAt: z.number(),
    metadata: z.record(z.unknown()).optional(),
  });
  export type Message = z.infer<typeof MessageSchema>;
  export type Conversation = z.infer<typeof ConversationSchema>;
  export interface SendMessageRequest {
    content: string;
    conversationId?: string;
    metadata?: Record<string, unknown>;
  }
  export interface SendMessageResponse extends IpcResponse<Message> {}
  export interface GetConversationsResponse extends IpcResponse<Conversation[]> {}
  export interface GetConversationResponse extends IpcResponse<Conversation> {}
  export interface CreateConversationResponse extends IpcResponse<Conversation> {}
  export interface UpdateConversationTitleResponse extends IpcResponse<void> {}
}
export namespace Ollama {
  export interface ListModelsResponse extends IpcResponse<{ models: OllamaModel[] }> {}
  export interface SetModelResponse extends IpcResponse<void> {}
  export interface CheckConnectionResponse extends IpcResponse<OllamaConnectionStatus> {}
  export interface SaveConfigResponse extends IpcResponse<void> {}
}
export namespace Memory {
  export interface MemoryChunk {
    id: string;
    content: string;
    metadata: {
      timestamp: number;
      source?: string;
      type?: string;
      tags?: string[];
      importance?: number;
      context?: Record<string, unknown>;
    };
    vector?: number[];
    similarity?: number;
    importance?: number;
    expiresAt?: number;
  }
  export interface GetRecentResponse extends IpcResponse<MemoryChunk[]> {}
  export interface SearchResponse extends IpcResponse<MemoryChunk[]> {}
  export interface StoreResponse extends IpcResponse<void> {}
  export interface DeleteResponse extends IpcResponse<void> {}
  export interface ClearResponse extends IpcResponse<void> {}
  export interface StatsResponse extends IpcResponse<{
    total: number;
    active: number;
    expired: number;
    averageImportance: number;
    cacheSize: number;
  }> {}
}
export namespace Service {
  export interface GetStatusResponse extends IpcResponse<ServiceStatus> {}
  export interface GetAllStatusResponse extends IpcResponse<Record<string, ServiceStatus>> {}
  export interface RestartResponse extends IpcResponse<void> {}
  export interface StopResponse extends IpcResponse<void> {}
}
// Event types for real-time updates
export namespace Events {
  export interface ServiceStatusChanged {
    serviceName: string;
    status: ServiceStatus;
    error?: string;
    details?: Record<string, unknown>;
  }
  export interface ModelLoadingStateChanged {
    state: ModelLoadingState;
    progress?: number;
    error?: string;
  }
  export interface MemoryStored {
    memory: Memory.MemoryChunk;
  }
  export interface MemoryDeleted {
    id: string;
  }
  export interface MemoryCleared {}
}
// Channel names with type safety
export const CHANNELS = {
  CHAT: {
    SEND_MESSAGE: 'chat:send-message',
    GET_CONVERSATIONS: 'chat:get-conversations',
    GET_CONVERSATION: 'chat:get-conversation',
    CREATE_CONVERSATION: 'chat:create-conversation',
    UPDATE_CONVERSATION_TITLE: 'chat:update-conversation-title',
  },
  OLLAMA: {
    LIST_MODELS: 'ollama:list-models',
    SET_MODEL: 'ollama:set-model',
    CHECK_CONNECTION: 'ollama:check-connection',
    SAVE_CONFIG: 'ollama:save-config',
  },
  MEMORY: {
    GET_RECENT: 'memory:get-recent',
    SEARCH: 'memory:search',
    STORE: 'memory:store',
    DELETE: 'memory:delete',
    CLEAR: 'memory:clear',
    GET_STATS: 'memory:get-stats',
  },
  SERVICE: {
    GET_STATUS: 'service:get-status',
    GET_ALL_STATUS: 'service:get-all-status',
    RESTART: 'service:restart',
    STOP: 'service:stop',
  },
  EVENTS: {
    SERVICE_STATUS_CHANGED: 'events:service-status-changed',
    MODEL_LOADING_STATE_CHANGED: 'events:model-loading-state-changed',
    MEMORY_STORED: 'events:memory-stored',
    MEMORY_DELETED: 'events:memory-deleted',
    MEMORY_CLEARED: 'events:memory-cleared',
  },
} as const;
// Type-safe channel map
export type ChannelMap = {
  [K in typeof CHANNELS[keyof typeof CHANNELS][keyof typeof CHANNELS[keyof typeof CHANNELS]]]: {
    request: unknown;
    response: IpcResponse<unknown>;
  };
};
</file>

<file path="src/ipc/vector.d.ts">
export declare function setupVectorIpcHandlers(): void;
</file>

<file path="src/ipc/vector.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupVectorIpcHandlers = setupVectorIpcHandlers;
const electron_1 = require("electron");
const VectorStore_1 = require("../services/VectorStore");
const logger_1 = require("../utils/logger");
function setupVectorIpcHandlers() {
    electron_1.ipcMain.handle('vector:search', async (_, query) => {
        try {
            return await VectorStore_1.vectorStore.search(query);
        }
        catch (error) {
            logger_1.logger.error('Error searching vectors:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle('vector:add', async (_, doc) => {
        try {
            await VectorStore_1.vectorStore.add(doc);
        }
        catch (error) {
            logger_1.logger.error('Error adding vector:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle('vector:delete', async (_, id) => {
        try {
            await VectorStore_1.vectorStore.delete(id);
        }
        catch (error) {
            logger_1.logger.error('Error deleting vector:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle('vector:clear', async () => {
        try {
            await VectorStore_1.vectorStore.clear();
        }
        catch (error) {
            logger_1.logger.error('Error clearing vectors:', error);
            throw error;
        }
    });
    electron_1.ipcMain.handle('vector:stats', async () => {
        try {
            return await VectorStore_1.vectorStore.stats();
        }
        catch (error) {
            logger_1.logger.error('Error getting vector stats:', error);
            throw error;
        }
    });
}
//# sourceMappingURL=vector.js.map
</file>

<file path="src/ipc/vector.js.map">
{"version":3,"file":"vector.js","sourceRoot":"","sources":["vector.ts"],"names":[],"mappings":";;AAIA,wDA6CC;AAjDD,uCAAmC;AACnC,yDAAsD;AACtD,4CAAyC;AAEzC,SAAgB,sBAAsB;IACpC,kBAAO,CAAC,MAAM,CAAC,eAAe,EAAE,KAAK,EAAE,CAAC,EAAE,KAAa,EAAE,EAAE;QACzD,IAAI,CAAC;YACH,OAAO,MAAM,yBAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACzC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,0BAA0B,EAAE,KAAK,CAAC,CAAC;YAChD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,kBAAO,CAAC,MAAM,CAAC,YAAY,EAAE,KAAK,EAAE,CAAC,EAAE,GAAoC,EAAE,EAAE;QAC7E,IAAI,CAAC;YACH,MAAM,yBAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC7B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;YAC5C,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,kBAAO,CAAC,MAAM,CAAC,eAAe,EAAE,KAAK,EAAE,CAAC,EAAE,EAAU,EAAE,EAAE;QACtD,IAAI,CAAC;YACH,MAAM,yBAAW,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAC/B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,wBAAwB,EAAE,KAAK,CAAC,CAAC;YAC9C,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,kBAAO,CAAC,MAAM,CAAC,cAAc,EAAE,KAAK,IAAI,EAAE;QACxC,IAAI,CAAC;YACH,MAAM,yBAAW,CAAC,KAAK,EAAE,CAAC;QAC5B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,yBAAyB,EAAE,KAAK,CAAC,CAAC;YAC/C,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,kBAAO,CAAC,MAAM,CAAC,cAAc,EAAE,KAAK,IAAI,EAAE;QACxC,IAAI,CAAC;YACH,OAAO,MAAM,yBAAW,CAAC,KAAK,EAAE,CAAC;QACnC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,6BAA6B,EAAE,KAAK,CAAC,CAAC;YACnD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC"}
</file>

<file path="src/ipc/vector.ts">
import { ipcMain } from 'electron';
import { vectorStore } from '../services/VectorStore';
import { logger } from '../utils/logger';
export function setupVectorIpcHandlers(): void {
  ipcMain.handle('vector:search', async (_, query: string) => {
    try {
      return await vectorStore.search(query);
    } catch (error) {
      logger.error('Error searching vectors:', error);
      throw error;
    }
  });
  ipcMain.handle('vector:add', async (_, doc: { id: string; content: string }) => {
    try {
      await vectorStore.add(doc);
    } catch (error) {
      logger.error('Error adding vector:', error);
      throw error;
    }
  });
  ipcMain.handle('vector:delete', async (_, id: string) => {
    try {
      await vectorStore.delete(id);
    } catch (error) {
      logger.error('Error deleting vector:', error);
      throw error;
    }
  });
  ipcMain.handle('vector:clear', async () => {
    try {
      await vectorStore.clear();
    } catch (error) {
      logger.error('Error clearing vectors:', error);
      throw error;
    }
  });
  ipcMain.handle('vector:stats', async () => {
    try {
      return await vectorStore.stats();
    } catch (error) {
      logger.error('Error getting vector stats:', error);
      throw error;
    }
  });
}
</file>

<file path="src/main/ipc/chatHandlers.d.ts">
export declare function setupChatHandlers(): void;
</file>

<file path="src/main/ipc/chatHandlers.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupChatHandlers = setupChatHandlers;
const electron_1 = require("electron");
const OllamaClient_1 = require("../../services/OllamaClient");
const DatabaseService_1 = require("../../services/DatabaseService");
const ollamaClient = new OllamaClient_1.OllamaClient();
const dbService = new DatabaseService_1.DatabaseService();
function setupChatHandlers() {
    // Send a message and get a response
    electron_1.ipcMain.handle('chat:send-message', async (_, message) => {
        try {
            const messageId = `msg-${Date.now()}`;
            // Add user message to database
            const userMessage = {
                id: messageId,
                content: message,
                role: 'user',
                timestamp: Date.now(),
                status: 'sending'
            };
            await dbService.saveMessage(userMessage);
            // Update message status to sent
            userMessage.status = 'sent';
            await dbService.saveMessage(userMessage);
            // Generate response using Ollama with streaming
            let assistantMessage = {
                id: `msg-${Date.now()}`,
                content: '',
                role: 'assistant',
                timestamp: Date.now(),
                status: 'sending'
            };
            await dbService.saveMessage(assistantMessage);
            const response = await ollamaClient.generateResponse(message, async (chunk) => {
                assistantMessage.content += chunk;
                await dbService.saveMessage(assistantMessage);
            });
            // Update final message status
            assistantMessage.status = 'sent';
            await dbService.saveMessage(assistantMessage);
            return assistantMessage;
        }
        catch (error) {
            console.error('Error in chat:send-message:', error);
            throw error;
        }
    });
    // Get chat history
    electron_1.ipcMain.handle('chat:get-history', async () => {
        return await dbService.getMessages();
    });
    // Clear chat history
    electron_1.ipcMain.handle('chat:clear-history', async () => {
        await dbService.clearMessages();
        return { success: true };
    });
    // Delete a message
    electron_1.ipcMain.handle('chat:delete-message', async (_, messageId) => {
        await dbService.deleteMessage(messageId);
        return { success: true };
    });
    // Get available models
    electron_1.ipcMain.handle('chat:get-models', async () => {
        return await ollamaClient.listModels();
    });
    // Set current model
    electron_1.ipcMain.handle('chat:set-model', async (_, modelName) => {
        ollamaClient.setModel(modelName);
        return { success: true };
    });
    // Pull a new model
    electron_1.ipcMain.handle('chat:pull-model', async (_, modelName) => {
        await ollamaClient.pullModel(modelName, (progress) => {
            // Send progress updates to renderer
            electron_1.ipcMain.emit('model-pull-progress', { modelName, progress });
        });
        return { success: true };
    });
}
//# sourceMappingURL=chatHandlers.js.map
</file>

<file path="src/main/ipc/chatHandlers.js.map">
{"version":3,"file":"chatHandlers.js","sourceRoot":"","sources":["chatHandlers.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/main/ipc/chatHandlers.ts">
import { ipcMain } from 'electron';
import { OllamaClient } from '../../services/OllamaClient';
import { DatabaseService } from '../../services/DatabaseService';
interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: number;
  status: 'sending' | 'sent' | 'error';
  error?: string;
}
const ollamaClient = new OllamaClient();
const dbService = new DatabaseService();
export function setupChatHandlers() {
  // Send a message and get a response
  ipcMain.handle('chat:send-message', async (_, message: string) => {
    try {
      const messageId = `msg-${Date.now()}`;
      // Add user message to database
      const userMessage: ChatMessage = {
        id: messageId,
        content: message,
        role: 'user',
        timestamp: Date.now(),
        status: 'sending'
      };
      await dbService.saveMessage(userMessage);
      // Update message status to sent
      userMessage.status = 'sent';
      await dbService.saveMessage(userMessage);
      // Generate response using Ollama with streaming
      let assistantMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        content: '',
        role: 'assistant',
        timestamp: Date.now(),
        status: 'sending'
      };
      await dbService.saveMessage(assistantMessage);
      const response = await ollamaClient.generateResponse(message, async (chunk: string) => {
        assistantMessage.content += chunk;
        await dbService.saveMessage(assistantMessage);
      });
      // Update final message status
      assistantMessage.status = 'sent';
      await dbService.saveMessage(assistantMessage);
      return assistantMessage;
    } catch (error) {
      console.error('Error in chat:send-message:', error);
      throw error;
    }
  });
  // Get chat history
  ipcMain.handle('chat:get-history', async () => {
    return await dbService.getMessages();
  });
  // Clear chat history
  ipcMain.handle('chat:clear-history', async () => {
    await dbService.clearMessages();
    return { success: true };
  });
  // Delete a message
  ipcMain.handle('chat:delete-message', async (_, messageId: string) => {
    await dbService.deleteMessage(messageId);
    return { success: true };
  });
  // Get available models
  ipcMain.handle('chat:get-models', async () => {
    return await ollamaClient.listModels();
  });
  // Set current model
  ipcMain.handle('chat:set-model', async (_, modelName: string) => {
    ollamaClient.setModel(modelName);
    return { success: true };
  });
  // Pull a new model
  ipcMain.handle('chat:pull-model', async (_, modelName: string) => {
    await ollamaClient.pullModel(modelName, (progress: number) => {
      // Send progress updates to renderer
      ipcMain.emit('model-pull-progress', { modelName, progress });
    });
    return { success: true };
  });
}
</file>

<file path="src/main/ipc/memoryHandlers.d.ts">
export declare function setupMemoryHandlers(): void;
</file>

<file path="src/main/ipc/memoryHandlers.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMemoryHandlers = setupMemoryHandlers;
const electron_1 = require("electron");
// In-memory storage for memory nodes
const memoryNodes = new Map();
function setupMemoryHandlers() {
    // Create a new memory node
    electron_1.ipcMain.handle('memory:create', async (_, node) => {
        try {
            memoryNodes.set(node.id, node);
            return { success: true, node };
        }
        catch (error) {
            console.error('Failed to create memory node:', error);
            throw error;
        }
    });
    // Delete a memory node
    electron_1.ipcMain.handle('memory:delete', async (_, { id }) => {
        try {
            const node = memoryNodes.get(id);
            if (!node) {
                throw new Error('Memory node not found');
            }
            memoryNodes.delete(id);
            return { success: true };
        }
        catch (error) {
            console.error('Failed to delete memory node:', error);
            throw error;
        }
    });
    // Show message selection dialog
    electron_1.ipcMain.handle('memory:select-message', async () => {
        try {
            // TODO: Implement message selection dialog
            // For now, return a mock message ID
            return { messageId: 'msg-' + Date.now() };
        }
        catch (error) {
            console.error('Failed to select message:', error);
            throw error;
        }
    });
    // Get all memory nodes
    electron_1.ipcMain.handle('memory:get-all', async () => {
        try {
            return Array.from(memoryNodes.values());
        }
        catch (error) {
            console.error('Failed to get memory nodes:', error);
            throw error;
        }
    });
}
//# sourceMappingURL=memoryHandlers.js.map
</file>

<file path="src/main/ipc/memoryHandlers.js.map">
{"version":3,"file":"memoryHandlers.js","sourceRoot":"","sources":["memoryHandlers.ts"],"names":[],"mappings":";;AAcA,kDAgDC;AA9DD,uCAAmC;AAWnC,qCAAqC;AACrC,MAAM,WAAW,GAAG,IAAI,GAAG,EAAsB,CAAC;AAElD,SAAgB,mBAAmB;IACjC,2BAA2B;IAC3B,kBAAO,CAAC,MAAM,CAAC,eAAe,EAAE,KAAK,EAAE,CAAC,EAAE,IAAgB,EAAE,EAAE;QAC5D,IAAI,CAAC;YACH,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;YAC/B,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;QACjC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,+BAA+B,EAAE,KAAK,CAAC,CAAC;YACtD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,uBAAuB;IACvB,kBAAO,CAAC,MAAM,CAAC,eAAe,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE,EAAE,EAAkB,EAAE,EAAE;QAClE,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,WAAW,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YACjC,IAAI,CAAC,IAAI,EAAE,CAAC;gBACV,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;YAC3C,CAAC;YACD,WAAW,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACvB,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;QAC3B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,+BAA+B,EAAE,KAAK,CAAC,CAAC;YACtD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,gCAAgC;IAChC,kBAAO,CAAC,MAAM,CAAC,uBAAuB,EAAE,KAAK,IAAI,EAAE;QACjD,IAAI,CAAC;YACH,2CAA2C;YAC3C,oCAAoC;YACpC,OAAO,EAAE,SAAS,EAAE,MAAM,GAAG,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;QAC5C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,2BAA2B,EAAE,KAAK,CAAC,CAAC;YAClD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,uBAAuB;IACvB,kBAAO,CAAC,MAAM,CAAC,gBAAgB,EAAE,KAAK,IAAI,EAAE;QAC1C,IAAI,CAAC;YACH,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC;QAC1C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,6BAA6B,EAAE,KAAK,CAAC,CAAC;YACpD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC"}
</file>

<file path="src/main/ipc/memoryHandlers.ts">
import { ipcMain } from 'electron';
import { dialog } from 'electron';
interface MemoryNode {
  id: string;
  title: string;
  model: string;
  isLinked: boolean;
  linkedMessageId?: string;
}
// In-memory storage for memory nodes
const memoryNodes = new Map<string, MemoryNode>();
export function setupMemoryHandlers() {
  // Create a new memory node
  ipcMain.handle('memory:create', async (_, node: MemoryNode) => {
    try {
      memoryNodes.set(node.id, node);
      return { success: true, node };
    } catch (error) {
      console.error('Failed to create memory node:', error);
      throw error;
    }
  });
  // Delete a memory node
  ipcMain.handle('memory:delete', async (_, { id }: { id: string }) => {
    try {
      const node = memoryNodes.get(id);
      if (!node) {
        throw new Error('Memory node not found');
      }
      memoryNodes.delete(id);
      return { success: true };
    } catch (error) {
      console.error('Failed to delete memory node:', error);
      throw error;
    }
  });
  // Show message selection dialog
  ipcMain.handle('memory:select-message', async () => {
    try {
      // TODO: Implement message selection dialog
      // For now, return a mock message ID
      return { messageId: 'msg-' + Date.now() };
    } catch (error) {
      console.error('Failed to select message:', error);
      throw error;
    }
  });
  // Get all memory nodes
  ipcMain.handle('memory:get-all', async () => {
    try {
      return Array.from(memoryNodes.values());
    } catch (error) {
      console.error('Failed to get memory nodes:', error);
      throw error;
    }
  });
}
</file>

<file path="src/main/index.d.ts">
export {};
</file>

<file path="src/main/index.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
const memoryHandlers_1 = require("./ipc/memoryHandlers");
electron_1.app.whenReady().then(() => {
    (0, memoryHandlers_1.setupMemoryHandlers)();
});
//# sourceMappingURL=index.js.map
</file>

<file path="src/main/index.js.map">
{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";;AAAA,uCAA+B;AAC/B,yDAA2D;AAE3D,cAAG,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE;IACxB,IAAA,oCAAmB,GAAE,CAAC;AACxB,CAAC,CAAC,CAAC"}
</file>

<file path="src/main/index.ts">
import { app } from 'electron';
import { setupMemoryHandlers } from './ipc/memoryHandlers';
app.whenReady().then(() => {
  setupMemoryHandlers();
});
</file>

<file path="src/main/WindowManager.d.ts">
import { BrowserWindow } from 'electron';
export declare class WindowManager {
    private static instance;
    private mainWindow;
    private isDevelopment;
    private errorHandler;
    private windowState;
    private readonly stateFilePath;
    private constructor();
    private loadWindowState;
    private saveWindowState;
    static getInstance(): WindowManager;
    createMainWindow(): Promise<BrowserWindow>;
    private setupWindowEvents;
    private loadApp;
    private getWindowIcon;
    private updateWindowIcon;
    getMainWindow(): BrowserWindow | null;
    minimize(): Promise<void>;
    maximize(): Promise<void>;
    close(): Promise<void>;
    isMaximized(): Promise<boolean>;
    private recoverRenderer;
    private recreateWindow;
}
</file>

<file path="src/main/WindowManager.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowManager = void 0;
const electron_1 = require("electron");
const logger_1 = require("../utils/logger");
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const errors_1 = require("../utils/errors");
class WindowManager {
    constructor() {
        this.mainWindow = null;
        this.isDevelopment = process.env.NODE_ENV === 'development';
        this.errorHandler = errors_1.ErrorHandler.getInstance();
        this.stateFilePath = path.join(electron_1.app.getPath('userData'), 'window-state.json');
        this.windowState = this.loadWindowState();
    }
    loadWindowState() {
        try {
            if (fs.existsSync(this.stateFilePath)) {
                const data = fs.readFileSync(this.stateFilePath, 'utf8');
                return JSON.parse(data);
            }
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to load window state', errors_1.ErrorSeverity.LOW, { originalError: error }));
        }
        // Default state
        const { width, height } = electron_1.screen.getPrimaryDisplay().workAreaSize;
        return {
            bounds: {
                x: Math.floor(width * 0.1),
                y: Math.floor(height * 0.1),
                width: Math.floor(width * 0.8),
                height: Math.floor(height * 0.8),
            },
            isMaximized: false,
            isFullScreen: false,
        };
    }
    saveWindowState() {
        if (!this.mainWindow)
            return;
        try {
            const state = {
                bounds: this.mainWindow.getBounds(),
                isMaximized: this.mainWindow.isMaximized(),
                isFullScreen: this.mainWindow.isFullScreen(),
            };
            fs.writeFileSync(this.stateFilePath, JSON.stringify(state, null, 2));
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to save window state', errors_1.ErrorSeverity.LOW, { originalError: error }));
        }
    }
    static getInstance() {
        if (!WindowManager.instance) {
            WindowManager.instance = new WindowManager();
        }
        return WindowManager.instance;
    }
    async createMainWindow() {
        if (this.mainWindow) {
            return this.mainWindow;
        }
        try {
            // Create the browser window with optimized settings
            this.mainWindow = new electron_1.BrowserWindow({
                ...this.windowState.bounds,
                webPreferences: {
                    nodeIntegration: false,
                    contextIsolation: true,
                    sandbox: true,
                    preload: path.join(__dirname, '../preload.js'),
                    webSecurity: true,
                    allowRunningInsecureContent: false,
                },
                show: false,
                backgroundColor: '#1a1a1a',
                icon: this.getWindowIcon(),
                titleBarStyle: 'hidden',
                titleBarOverlay: {
                    color: '#2f3241',
                    symbolColor: '#74b1be',
                    height: 30
                },
                frame: false,
            });
            // Restore window state
            if (this.windowState.isMaximized) {
                this.mainWindow.maximize();
            }
            if (this.windowState.isFullScreen) {
                this.mainWindow.setFullScreen(true);
            }
            // Setup window events
            this.setupWindowEvents();
            // Load the app
            await this.loadApp();
            return this.mainWindow;
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to create main window', errors_1.ErrorSeverity.HIGH, { originalError: error }));
            throw error;
        }
    }
    setupWindowEvents() {
        if (!this.mainWindow)
            return;
        // Show window when ready
        this.mainWindow.once('ready-to-show', () => {
            logger_1.logger.debug('Window ready to show');
            setTimeout(() => {
                if (this.mainWindow && !this.mainWindow.isDestroyed()) {
                    this.mainWindow.show();
                }
            }, 50);
        });
        // Handle window state changes
        this.mainWindow.on('maximize', () => {
            logger_1.logger.debug('Window maximized');
            this.saveWindowState();
        });
        this.mainWindow.on('unmaximize', () => {
            logger_1.logger.debug('Window unmaximized');
            this.saveWindowState();
        });
        this.mainWindow.on('move', () => {
            this.saveWindowState();
        });
        this.mainWindow.on('resize', () => {
            this.saveWindowState();
        });
        this.mainWindow.on('enter-full-screen', () => {
            this.saveWindowState();
        });
        this.mainWindow.on('leave-full-screen', () => {
            this.saveWindowState();
        });
        // Handle window close
        this.mainWindow.on('close', (event) => {
            // Save state before closing
            this.saveWindowState();
        });
        this.mainWindow.on('closed', () => {
            this.mainWindow = null;
        });
        // Handle renderer process crashes
        this.mainWindow.webContents.on('crashed', () => {
            this.errorHandler.handleError(new errors_1.WindowError('Renderer process crashed', errors_1.ErrorSeverity.HIGH, { windowId: this.mainWindow?.id }));
            this.recoverRenderer();
        });
        // Handle renderer process hangs
        this.mainWindow.webContents.on('unresponsive', () => {
            this.errorHandler.handleError(new errors_1.WindowError('Renderer process became unresponsive', errors_1.ErrorSeverity.HIGH, { windowId: this.mainWindow?.id }));
            this.recoverRenderer();
        });
        // Handle renderer load failures
        this.mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription) => {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to load renderer', errors_1.ErrorSeverity.MEDIUM, { errorCode, errorDescription }));
            this.recoverRenderer();
        });
        // Handle theme changes
        electron_1.nativeTheme.on('updated', () => {
            if (this.mainWindow) {
                this.updateWindowIcon();
            }
        });
    }
    async loadApp() {
        if (!this.mainWindow)
            return;
        try {
            if (this.isDevelopment) {
                const devUrl = 'http://localhost:5173';
                logger_1.logger.debug('Loading renderer from:', devUrl);
                await this.mainWindow.loadURL(devUrl);
                this.mainWindow.webContents.openDevTools();
            }
            else {
                const prodPath = path.join(__dirname, '../../renderer/dist/index.html');
                logger_1.logger.debug('Loading renderer from:', prodPath);
                await this.mainWindow.loadFile(prodPath);
            }
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to load app', errors_1.ErrorSeverity.HIGH, { originalError: error }));
            throw error;
        }
    }
    getWindowIcon() {
        try {
            const defaultIcon = path.join(__dirname, '../assets/icon.png');
            const logoPath = path.join(process.cwd(), 'buildResources', 'logo-DARK.png');
            const iconPath = fs.existsSync(logoPath) ? logoPath : defaultIcon;
            return electron_1.nativeImage.createFromPath(iconPath);
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to load window icon', errors_1.ErrorSeverity.LOW, { originalError: error }));
            // Return a default icon or throw if critical
            throw error;
        }
    }
    updateWindowIcon() {
        if (!this.mainWindow)
            return;
        try {
            this.mainWindow.setIcon(this.getWindowIcon());
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to update window icon', errors_1.ErrorSeverity.LOW, { originalError: error }));
        }
    }
    getMainWindow() {
        return this.mainWindow;
    }
    async minimize() {
        try {
            if (this.mainWindow && !this.mainWindow.isDestroyed()) {
                this.mainWindow.minimize();
            }
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to minimize window', errors_1.ErrorSeverity.LOW, { originalError: error }));
        }
    }
    async maximize() {
        try {
            if (this.mainWindow && !this.mainWindow.isDestroyed()) {
                if (this.mainWindow.isMaximized()) {
                    this.mainWindow.unmaximize();
                }
                else {
                    this.mainWindow.maximize();
                }
            }
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to maximize/unmaximize window', errors_1.ErrorSeverity.LOW, { originalError: error }));
        }
    }
    async close() {
        try {
            if (this.mainWindow && !this.mainWindow.isDestroyed()) {
                this.mainWindow.close();
            }
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to close window', errors_1.ErrorSeverity.MEDIUM, { originalError: error }));
        }
    }
    async isMaximized() {
        try {
            return this.mainWindow?.isMaximized() ?? false;
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to check window maximized state', errors_1.ErrorSeverity.LOW, { originalError: error }));
            return false;
        }
    }
    async recoverRenderer() {
        if (!this.mainWindow || this.mainWindow.isDestroyed()) {
            return;
        }
        try {
            // Attempt to reload the window
            await this.mainWindow.loadURL(this.mainWindow.webContents.getURL());
            logger_1.logger.info('Renderer recovered successfully');
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.WindowError('Failed to recover renderer', errors_1.ErrorSeverity.HIGH, { originalError: error }));
            // If recovery fails, try recreating the window
            try {
                await this.recreateWindow();
            }
            catch (recreateError) {
                this.errorHandler.handleError(new errors_1.WindowError('Failed to recreate window after renderer crash', errors_1.ErrorSeverity.CRITICAL, { originalError: recreateError }));
            }
        }
    }
    async recreateWindow() {
        if (this.mainWindow) {
            const oldWindow = this.mainWindow;
            this.mainWindow = null;
            oldWindow.destroy();
        }
        await this.createMainWindow();
    }
}
exports.WindowManager = WindowManager;
//# sourceMappingURL=WindowManager.js.map
</file>

<file path="src/main/WindowManager.js.map">
{"version":3,"file":"WindowManager.js","sourceRoot":"","sources":["WindowManager.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/main/WindowManager.ts">
import { BrowserWindow, nativeTheme, nativeImage, screen, app } from 'electron';
import { logger } from '../utils/logger';
import * as path from 'path';
import * as fs from 'fs';
import { ErrorHandler, WindowError, ErrorCategory, ErrorSeverity } from '../utils/errors';
interface WindowState {
  bounds: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  isMaximized: boolean;
  isFullScreen: boolean;
}
export class WindowManager {
  private static instance: WindowManager;
  private mainWindow: BrowserWindow | null = null;
  private isDevelopment = process.env.NODE_ENV === 'development';
  private errorHandler: ErrorHandler;
  private windowState: WindowState;
  private readonly stateFilePath: string;
  private constructor() {
    this.errorHandler = ErrorHandler.getInstance();
    this.stateFilePath = path.join(app.getPath('userData'), 'window-state.json');
    this.windowState = this.loadWindowState();
  }
  private loadWindowState(): WindowState {
    try {
      if (fs.existsSync(this.stateFilePath)) {
        const data = fs.readFileSync(this.stateFilePath, 'utf8');
        return JSON.parse(data);
      }
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to load window state',
          ErrorSeverity.LOW,
          { originalError: error }
        )
      );
    }
    // Default state
    const { width, height } = screen.getPrimaryDisplay().workAreaSize;
    return {
      bounds: {
        x: Math.floor(width * 0.1),
        y: Math.floor(height * 0.1),
        width: Math.floor(width * 0.8),
        height: Math.floor(height * 0.8),
      },
      isMaximized: false,
      isFullScreen: false,
    };
  }
  private saveWindowState(): void {
    if (!this.mainWindow) return;
    try {
      const state: WindowState = {
        bounds: this.mainWindow.getBounds(),
        isMaximized: this.mainWindow.isMaximized(),
        isFullScreen: this.mainWindow.isFullScreen(),
      };
      fs.writeFileSync(this.stateFilePath, JSON.stringify(state, null, 2));
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to save window state',
          ErrorSeverity.LOW,
          { originalError: error }
        )
      );
    }
  }
  public static getInstance(): WindowManager {
    if (!WindowManager.instance) {
      WindowManager.instance = new WindowManager();
    }
    return WindowManager.instance;
  }
  public async createMainWindow(): Promise<BrowserWindow> {
    if (this.mainWindow) {
      return this.mainWindow;
    }
    try {
      // Create the browser window with optimized settings
      this.mainWindow = new BrowserWindow({
        ...this.windowState.bounds,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true,
          sandbox: true,
          preload: path.join(__dirname, '../preload.js'),
          webSecurity: true,
          allowRunningInsecureContent: false,
        },
        show: false,
        backgroundColor: '#1a1a1a',
        icon: this.getWindowIcon(),
        titleBarStyle: 'hidden',
        titleBarOverlay: {
          color: '#2f3241',
          symbolColor: '#74b1be',
          height: 30
        },
        frame: false,
      });
      // Restore window state
      if (this.windowState.isMaximized) {
        this.mainWindow.maximize();
      }
      if (this.windowState.isFullScreen) {
        this.mainWindow.setFullScreen(true);
      }
      // Setup window events
      this.setupWindowEvents();
      // Load the app
      await this.loadApp();
      return this.mainWindow;
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to create main window',
          ErrorSeverity.HIGH,
          { originalError: error }
        )
      );
      throw error;
    }
  }
  private setupWindowEvents(): void {
    if (!this.mainWindow) return;
    // Show window when ready
    this.mainWindow.once('ready-to-show', () => {
      logger.debug('Window ready to show');
      setTimeout(() => {
        if (this.mainWindow && !this.mainWindow.isDestroyed()) {
          this.mainWindow.show();
        }
      }, 50);
    });
    // Handle window state changes
    this.mainWindow.on('maximize', () => {
      logger.debug('Window maximized');
      this.saveWindowState();
    });
    this.mainWindow.on('unmaximize', () => {
      logger.debug('Window unmaximized');
      this.saveWindowState();
    });
    this.mainWindow.on('move', () => {
      this.saveWindowState();
    });
    this.mainWindow.on('resize', () => {
      this.saveWindowState();
    });
    this.mainWindow.on('enter-full-screen', () => {
      this.saveWindowState();
    });
    this.mainWindow.on('leave-full-screen', () => {
      this.saveWindowState();
    });
    // Handle window close
    this.mainWindow.on('close', (event) => {
      // Save state before closing
      this.saveWindowState();
    });
    this.mainWindow.on('closed', () => {
      this.mainWindow = null;
    });
    // Handle renderer process crashes
    this.mainWindow.webContents.on('crashed', () => {
      this.errorHandler.handleError(
        new WindowError(
          'Renderer process crashed',
          ErrorSeverity.HIGH,
          { windowId: this.mainWindow?.id }
        )
      );
      this.recoverRenderer();
    });
    // Handle renderer process hangs
    this.mainWindow.webContents.on('unresponsive', () => {
      this.errorHandler.handleError(
        new WindowError(
          'Renderer process became unresponsive',
          ErrorSeverity.HIGH,
          { windowId: this.mainWindow?.id }
        )
      );
      this.recoverRenderer();
    });
    // Handle renderer load failures
    this.mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription) => {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to load renderer',
          ErrorSeverity.MEDIUM,
          { errorCode, errorDescription }
        )
      );
      this.recoverRenderer();
    });
    // Handle theme changes
    nativeTheme.on('updated', () => {
      if (this.mainWindow) {
        this.updateWindowIcon();
      }
    });
  }
  private async loadApp(): Promise<void> {
    if (!this.mainWindow) return;
    try {
      if (this.isDevelopment) {
        const devUrl = 'http://localhost:5173';
        logger.debug('Loading renderer from:', devUrl);
        await this.mainWindow.loadURL(devUrl);
        this.mainWindow.webContents.openDevTools();
      } else {
        const prodPath = path.join(__dirname, '../../renderer/dist/index.html');
        logger.debug('Loading renderer from:', prodPath);
        await this.mainWindow.loadFile(prodPath);
      }
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to load app',
          ErrorSeverity.HIGH,
          { originalError: error }
        )
      );
      throw error;
    }
  }
  private getWindowIcon(): Electron.NativeImage {
    try {
      const defaultIcon = path.join(__dirname, '../assets/icon.png');
      const logoPath = path.join(process.cwd(), 'buildResources', 'logo-DARK.png');
      const iconPath = fs.existsSync(logoPath) ? logoPath : defaultIcon;
      return nativeImage.createFromPath(iconPath);
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to load window icon',
          ErrorSeverity.LOW,
          { originalError: error }
        )
      );
      // Return a default icon or throw if critical
      throw error;
    }
  }
  private updateWindowIcon(): void {
    if (!this.mainWindow) return;
    try {
      this.mainWindow.setIcon(this.getWindowIcon());
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to update window icon',
          ErrorSeverity.LOW,
          { originalError: error }
        )
      );
    }
  }
  public getMainWindow(): BrowserWindow | null {
    return this.mainWindow;
  }
  public async minimize(): Promise<void> {
    try {
      if (this.mainWindow && !this.mainWindow.isDestroyed()) {
        this.mainWindow.minimize();
      }
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to minimize window',
          ErrorSeverity.LOW,
          { originalError: error }
        )
      );
    }
  }
  public async maximize(): Promise<void> {
    try {
      if (this.mainWindow && !this.mainWindow.isDestroyed()) {
        if (this.mainWindow.isMaximized()) {
          this.mainWindow.unmaximize();
        } else {
          this.mainWindow.maximize();
        }
      }
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to maximize/unmaximize window',
          ErrorSeverity.LOW,
          { originalError: error }
        )
      );
    }
  }
  public async close(): Promise<void> {
    try {
      if (this.mainWindow && !this.mainWindow.isDestroyed()) {
        this.mainWindow.close();
      }
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to close window',
          ErrorSeverity.MEDIUM,
          { originalError: error }
        )
      );
    }
  }
  public async isMaximized(): Promise<boolean> {
    try {
      return this.mainWindow?.isMaximized() ?? false;
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to check window maximized state',
          ErrorSeverity.LOW,
          { originalError: error }
        )
      );
      return false;
    }
  }
  private async recoverRenderer(): Promise<void> {
    if (!this.mainWindow || this.mainWindow.isDestroyed()) {
      return;
    }
    try {
      // Attempt to reload the window
      await this.mainWindow.loadURL(this.mainWindow.webContents.getURL());
      logger.info('Renderer recovered successfully');
    } catch (error) {
      this.errorHandler.handleError(
        new WindowError(
          'Failed to recover renderer',
          ErrorSeverity.HIGH,
          { originalError: error }
        )
      );
      // If recovery fails, try recreating the window
      try {
        await this.recreateWindow();
      } catch (recreateError) {
        this.errorHandler.handleError(
          new WindowError(
            'Failed to recreate window after renderer crash',
            ErrorSeverity.CRITICAL,
            { originalError: recreateError }
          )
        );
      }
    }
  }
  private async recreateWindow(): Promise<void> {
    if (this.mainWindow) {
      const oldWindow = this.mainWindow;
      this.mainWindow = null;
      oldWindow.destroy();
    }
    await this.createMainWindow();
  }
}
</file>

<file path="src/once-ui/components/Accordion.module.scss">
.accordion {
    &:hover {
        background: var(--neutral-alpha-weak);
    }
}
</file>

<file path="src/once-ui/components/Accordion.tsx">
"use client";
import React, { useState, forwardRef, useImperativeHandle, useEffect, useCallback } from "react";
import { Flex, Icon, Text, Column, Grid } from ".";
import styles from "./Accordion.module.scss";
import classNames from "classnames";
export interface AccordionHandle extends HTMLDivElement {
  toggle: () => void;
  open: () => void;
  close: () => void;
}
interface AccordionProps extends Omit<React.ComponentProps<typeof Flex>, "title"> {
  title: React.ReactNode;
  children: React.ReactNode;
  icon?: string;
  iconRotation?: number;
  size?: "s" | "m" | "l";
  radius?: "xs" | "s" | "m" | "l" | "xl" | "full";
  open?: boolean;
  className?: string;
  style?: React.CSSProperties;
}
const Accordion = forwardRef<AccordionHandle, AccordionProps>(
  (
    {
      title,
      children,
      open = false,
      iconRotation = 180,
      radius,
      icon = "chevronDown",
      size = "m",
      className,
      style,
      ...rest
    },
    ref,
  ) => {
    const [isOpen, setIsOpen] = useState(open);
    useEffect(() => {
      setIsOpen(open);
    }, [open]);
    const toggleAccordion = useCallback(() => {
      setIsOpen((prev) => !prev);
    }, []);
    useImperativeHandle(
      ref,
      () => {
        const methods = {
          toggle: toggleAccordion,
          open: () => setIsOpen(true),
          close: () => setIsOpen(false),
        };
        return Object.assign(document.createElement("div"), methods) as unknown as AccordionHandle;
      },
      [toggleAccordion],
    );
    return (
      <Column fillWidth>
        <Flex
          tabIndex={0}
          className={classNames(styles.accordion, className)}
          style={style}
          cursor="pointer"
          transition="macro-medium"
          paddingY={size === "s" ? "8" : size === "m" ? "12" : "16"}
          paddingX={size === "s" ? "12" : size === "m" ? "16" : "20"}
          vertical="center"
          horizontal="space-between"
          onClick={toggleAccordion}
          onKeyDown={(e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              toggleAccordion();
            }
          }}
          aria-expanded={isOpen}
          aria-controls="accordion-content"
          radius={radius}
          role="button"
        >
          <Text variant="heading-strong-s">{title}</Text>
          <Icon
            name={icon}
            size={size === "s" ? "xs" : "s"}
            onBackground={isOpen ? "neutral-strong" : "neutral-weak"}
            style={{
              display: "flex",
              transform: isOpen ? `rotate(${iconRotation}deg)` : "rotate(0deg)",
              transition: "var(--transition-micro-medium)",
            }}
          />
        </Flex>
        <Grid
          id="accordion-content"
          fillWidth
          style={{
            gridTemplateRows: isOpen ? "1fr" : "0fr",
            transition:
              "grid-template-rows var(--transition-duration-macro-medium) var(--transition-eased)",
          }}
          aria-hidden={!isOpen}
        >
          <Flex fillWidth minHeight={0} overflow="hidden">
            <Column
              fillWidth
              paddingX={size === "s" ? "12" : size === "m" ? "16" : "20"}
              paddingTop="8"
              paddingBottom="16"
              {...rest}
            >
              {children}
            </Column>
          </Flex>
        </Grid>
      </Column>
    );
  },
);
Accordion.displayName = "Accordion";
export { Accordion };
</file>

<file path="src/once-ui/components/AccordionGroup.tsx">
import React from "react";
import { Column, Accordion, Line, Flex } from ".";
export type AccordionItem = {
  title: React.ReactNode;
  content: React.ReactNode;
};
export interface AccordionGroupProps extends React.ComponentProps<typeof Flex> {
  items: AccordionItem[];
  size?: "s" | "m" | "l";
  className?: string;
  style?: React.CSSProperties;
}
const AccordionGroup: React.FC<AccordionGroupProps> = ({
  items,
  size = "m",
  style,
  className,
  ...rest
}) => {
  if (!items || items.length === 0) {
    return null;
  }
  return (
    <Column
      fillWidth
      radius="m"
      border="neutral-alpha-medium"
      overflow="hidden"
      style={style}
      className={className || ""}
      {...rest}
    >
      {items.map((item, index) => (
        <React.Fragment key={index}>
          <Accordion title={item.title} size={size}>
            {item.content}
          </Accordion>
          {index < items.length - 1 && <Line background="neutral-alpha-medium" />}
        </React.Fragment>
      ))}
    </Column>
  );
};
AccordionGroup.displayName = "AccordionGroup";
export { AccordionGroup };
</file>

<file path="src/once-ui/components/Arrow.module.scss">
.arrowContainer {
    transition: var(--transition-micro-medium);
    height: var(--static-space-16);
    width: var(--static-space-0);
    visibility: hidden;
}
.arrowHead {
    transition: var(--transition-micro-medium);
    width: var(--static-space-0);
    right: 0;
    transform-origin: right center;
    transform: rotate(0);
}
.active {
    width: var(--static-space-16);
    visibility: visible;
    .arrowHead {
        width: var(--static-space-8);
    }
    .arrowHead:nth-child(1) {
        transform: rotate(45deg);
    }
    .arrowHead:nth-child(2) {
        transform: rotate(-45deg);
    }
}
.onSolid {
    background: var(--brand-on-solid-strong);
}
.onBackground {
    background: var(--brand-on-background-strong);
}
</file>

<file path="src/once-ui/components/Arrow.tsx">
"use client";
import { useEffect, useRef } from "react";
import classNames from "classnames";
import styles from "./Arrow.module.scss";
import { Flex } from ".";
interface ArrowProps extends React.ComponentProps<typeof Flex> {
  trigger: string;
  scale?: number;
  color?: "onBackground" | "onSolid";
  style?: React.CSSProperties;
  className?: string;
}
const Arrow: React.FC<ArrowProps> = ({
  trigger,
  scale = 0.8,
  color = "onBackground",
  style,
  className,
  ...flex
}) => {
  const ref = useRef<HTMLDivElement>(null);
  useEffect(() => {
    const triggerElement = document.querySelector(trigger);
    if (triggerElement && ref.current) {
      const handleMouseOver = () => {
        ref.current?.classList.add(styles.active);
      };
      const handleMouseOut = () => {
        ref.current?.classList.remove(styles.active);
      };
      triggerElement.addEventListener("mouseenter", handleMouseOver);
      triggerElement.addEventListener("mouseleave", handleMouseOut);
      return () => {
        triggerElement.removeEventListener("mouseenter", handleMouseOver);
        triggerElement.removeEventListener("mouseleave", handleMouseOut);
      };
    }
  }, [trigger]);
  return (
    <Flex
      ref={ref}
      center
      className={classNames(styles.arrowContainer, className)}
      style={{
        transform: `scale(${scale})`,
        ...style,
      }}
      {...flex}
    >
      <Flex
        radius="full"
        position="absolute"
        className={classNames(styles.arrowHead, styles[color])}
        height={0.0875}
      />
      <Flex
        radius="full"
        position="absolute"
        className={classNames(styles.arrowHead, styles[color])}
        height={0.0875}
      />
    </Flex>
  );
};
Arrow.displayName = "Arrow";
export { Arrow };
</file>

<file path="src/once-ui/components/AutoScroll.module.scss">
.marqueeWrapper {
  animation: marquee 20s linear infinite;
  will-change: transform;
}
.marqueeContent {
  display: flex;
  white-space: nowrap;
  flex-shrink: 0;
  width: 100%;
  &:nth-child(2) {
    position: absolute;
    left: 100%; 
  }
}
/* Speed variations */
.slow {
  animation-duration: 40s;
}
.medium {
  animation-duration: 20s;
}
.fast {
  animation-duration: 10s;
}
.paused {
  animation-play-state: paused;
}
@keyframes marquee {
  0% { transform: translateX(0); }
  100% { transform: translateX(-100%); }
}
</file>

<file path="src/once-ui/components/Avatar.module.scss">
.xs {
    width: var(--static-space-20);
    height: var(--static-space-20);
    min-width: var(--static-space-20);
    min-height: var(--static-space-20);
}
.s {
    width: var(--static-space-24);
    height: var(--static-space-24);
    min-width: var(--static-space-24);
    min-height: var(--static-space-24);
}
.m {
    width: var(--static-space-32);
    height: var(--static-space-32);
    min-width: var(--static-space-32);
    min-height: var(--static-space-32);
}
.l {
    width: var(--static-space-48);
    height: var(--static-space-48);
    min-width: var(--static-space-48);
    min-height: var(--static-space-48);
}
.xl {
    width: var(--static-space-160);
    height: var(--static-space-160);
    min-width: var(--static-space-160);
    min-height: var(--static-space-160);
    .position {
        bottom: var(--static-space-16);
        right: var(--static-space-16);
    }
}
.value {
    white-space: nowrap;
    overflow: hidden;
    user-select: none;
}
.indicator {
    box-sizing: content-box;
    bottom: 0;
    right: 0;
    transform: translateX(var(--static-space-2)) translateY(var(--static-space-2));
}
.image {
    object-position: center;
}
</file>

<file path="src/once-ui/components/Avatar.tsx">
"use client";
import React, { forwardRef } from "react";
import { Skeleton, Icon, Text, StatusIndicator, Flex, Media } from ".";
import styles from "./Avatar.module.scss";
interface AvatarProps extends React.ComponentProps<typeof Flex> {
  size?: "xs" | "s" | "m" | "l" | "xl" | number;
  value?: string;
  src?: string;
  loading?: boolean;
  empty?: boolean;
  statusIndicator?: {
    color: "green" | "yellow" | "red" | "gray";
  };
  style?: React.CSSProperties;
  className?: string;
}
const sizeMapping: Record<"xs" | "s" | "m" | "l" | "xl", number> = {
  xs: 20,
  s: 24,
  m: 32,
  l: 48,
  xl: 160,
};
const statusIndicatorSizeMapping: Record<"xs" | "s" | "m" | "l" | "xl", "s" | "m" | "l"> = {
  xs: "s",
  s: "s",
  m: "m",
  l: "m",
  xl: "l",
};
const Avatar = forwardRef<HTMLDivElement, AvatarProps>(
  (
    { size = "m", value, src, loading, empty, statusIndicator, className, style = {}, ...rest },
    ref,
  ) => {
    const sizeInRem = typeof size === "number" ? `${size}rem` : undefined;
    const sizeStyle = sizeInRem
      ? {
          width: sizeInRem,
          height: sizeInRem,
          minWidth: sizeInRem,
          minHeight: sizeInRem,
          ...style,
        }
      : style;
    const isEmpty = empty || (!src && !value);
    if (value && src) {
      throw new Error("Avatar cannot have both 'value' and 'src' props.");
    }
    if (loading) {
      return (
        <Skeleton
          {...rest}
          border="neutral-medium"
          shape="circle"
          width={typeof size === "number" ? "m" : size}
          height={typeof size === "number" ? "m" : size}
          className={`${styles.avatar} ${className}`}
          aria-busy="true"
          aria-label="Loading avatar"
        />
      );
    }
    const renderContent = () => {
      if (isEmpty) {
        return (
          <Icon
            onBackground="neutral-medium"
            name="person"
            size="m"
            style={typeof size === "number" ? { fontSize: `${size / 3}rem` } : undefined}
            className={styles.icon}
            aria-label="Empty avatar"
          />
        );
      }
      if (src) {
        return (
          <Media
            radius="full"
            src={src}
            fill
            alt="Avatar"
            sizes={typeof size === "string" ? `${sizeMapping[size]}px` : `${size * 16}px`}
            className={styles.image}
          />
        );
      }
      if (value) {
        return (
          <Text
            as="span"
            onBackground="neutral-weak"
            variant={`body-default-${typeof size === "string" ? size : "m"}`}
            className={styles.value}
            aria-label={`Avatar with initials ${value}`}
          >
            {value}
          </Text>
        );
      }
      return null;
    };
    return (
      <Flex
        ref={ref}
        role="img"
        horizontal="center"
        vertical="center"
        radius="full"
        border="neutral-strong"
        background="surface"
        style={sizeStyle}
        className={`${styles.avatar} ${typeof size === "string" ? styles[size] : ""} ${className || ""}`}
        {...rest}
      >
        {renderContent()}
        {statusIndicator && (
          <StatusIndicator
            position="absolute"
            size={typeof size === "string" ? statusIndicatorSizeMapping[size] : "l"}
            color={statusIndicator.color}
            className={`${styles.className || ""} ${styles.indicator} ${size === "xl" || (typeof size === "number" && size >= 10) ? styles.position : ""}`}
            aria-label={`Status: ${statusIndicator.color}`}
          />
        )}
      </Flex>
    );
  },
);
Avatar.displayName = "Avatar";
export { Avatar };
export type { AvatarProps };
</file>

<file path="src/once-ui/components/AvatarGroup.module.scss">
.avatarGroup {
    z-index: 0;
}
.avatar {
    margin-left: calc(-1 * var(--static-space-8));
    &:first-child {
        margin-left: 0;
    }
}
</file>

<file path="src/once-ui/components/AvatarGroup.tsx">
"use client";
import React, { forwardRef } from "react";
import { Avatar, AvatarProps, Flex } from ".";
import styles from "./AvatarGroup.module.scss";
import classNames from "classnames";
interface AvatarGroupProps extends React.ComponentProps<typeof Flex> {
  avatars: AvatarProps[];
  size?: "xs" | "s" | "m" | "l" | "xl";
  reverse?: boolean;
  limit?: number;
  className?: string;
  style?: React.CSSProperties;
}
const AvatarGroup = forwardRef<HTMLDivElement, AvatarGroupProps>(
  ({ avatars, size = "m", reverse = false, limit, className, style, ...rest }, ref) => {
    const displayedAvatars = limit ? avatars.slice(0, limit) : avatars;
    const remainingCount = limit && avatars.length > limit ? avatars.length - limit : 0;
    return (
      <Flex
        vertical="center"
        ref={ref}
        className={classNames(styles.avatarGroup, className)}
        style={style}
        zIndex={0}
        {...rest}
      >
        {displayedAvatars.map((avatarProps, index) => (
          <Avatar
            key={index}
            size={size}
            {...avatarProps}
            className={styles.avatar}
            style={{
              ...avatarProps.style,
              zIndex: reverse ? displayedAvatars.length - index : index + 1,
            }}
          />
        ))}
        {remainingCount > 0 && (
          <Avatar
            value={`+${remainingCount}`}
            className={styles.avatar}
            size={size}
            style={{
              ...style,
              zIndex: reverse ? -1 : displayedAvatars.length + 1,
            }}
          />
        )}
      </Flex>
    );
  },
);
AvatarGroup.displayName = "AvatarGroup";
export { AvatarGroup };
export type { AvatarGroupProps };
</file>

<file path="src/once-ui/components/Background.module.scss">
.gradient {
  background: radial-gradient(
        ellipse var(--gradient-width) var(--gradient-height) at var(--gradient-position-x) var(--gradient-position-y),
        var(--gradient-color-start),
        var(--gradient-color-end)
      );
  width: 400%;
  height: 400%;
  left: -150%;
  top: -150%;
  transform: rotate(var(--gradient-tilt));
  transform-origin: center;
}
.lines {
  background-size: var(--lines-size) var(--lines-size);
  background-position: center;
}
.dots {
  background-image: radial-gradient(var(--dots-color) 1px, var(--static-transparent) 1px);
  background-size: var(--dots-size) var(--dots-size);
}
</file>

<file path="src/once-ui/components/Badge.module.scss">
.animation {
    position: relative;
    overflow: hidden;
    &::before {
        content: '';
        opacity: 0;
        border-radius: var(--radius-full);
        position: absolute;
        width: 100%;
        height: 100%;
        background: linear-gradient(
            120deg,
            transparent 20%,
            var(--brand-alpha-medium) 50%,
            transparent 80%
        );
        transform: skewX(-20deg);
        animation: shineDefault 9s ease-in-out infinite;
    }
    &:hover {
        &::before {
            animation: shineHover 3s ease-in-out infinite;
        }
    }
}
@keyframes shineDefault {
    0% {
        left: -100%;
    }
    1% {
        left: -100%;
        opacity: 1;
    }
    15% {
        left: 100%;
        opacity: 1;
    }
    16% {
        opacity: 0;
    }
    100% {
        left: -100%;
    }
}
@keyframes shineHover {
    0% {
        left: -100%;
    }
    1% {
        left: -100%;
        opacity: 1;
    }
    45% {
        left: 100%;
        opacity: 1;
    }
    46% {
        opacity: 0;
    }
    100% {
        left: -100%;
    }
}
</file>

<file path="src/once-ui/components/Badge.tsx">
"use client";
import React, { forwardRef } from "react";
import { Arrow, Flex, Icon, SmartLink } from ".";
import styles from "./Badge.module.scss";
import { IconName } from "../icons";
import classNames from "classnames";
export interface BadgeProps extends React.ComponentProps<typeof Flex> {
  title?: string;
  icon?: IconName;
  arrow?: boolean;
  children?: React.ReactNode;
  href?: string;
  effect?: boolean;
  className?: string;
  style?: React.CSSProperties;
  id?: string;
}
const Badge = forwardRef<HTMLDivElement | HTMLAnchorElement, BadgeProps>(
  (
    {
      title,
      icon,
      href,
      arrow = href ? true : false,
      children,
      effect = true,
      className,
      style,
      id,
      ...rest
    },
    ref,
  ) => {
    const content = (
      <Flex
        id={id || "badge"}
        paddingX="20"
        paddingY="12"
        fitWidth
        className={classNames(effect ? styles.animation : undefined, className)}
        style={style}
        vertical="center"
        radius="full"
        background="neutral-weak"
        onBackground="brand-strong"
        border="brand-alpha-medium"
        textVariant="label-strong-s"
        shadow="l"
        {...rest}
      >
        {icon && <Icon marginRight="8" size="s" name={icon} onBackground="brand-medium" />}
        {title}
        {children}
        {arrow && <Arrow trigger={`#${id || "badge"}`} />}
      </Flex>
    );
    if (href) {
      return (
        <SmartLink
          unstyled
          className={className}
          style={{
            borderRadius: "var(--radius-full)",
            ...style,
          }}
          href={href}
          ref={ref as React.Ref<HTMLAnchorElement>}
        >
          {content}
        </SmartLink>
      );
    }
    return React.cloneElement(content, {
      ref: ref as React.Ref<HTMLDivElement>,
    });
  },
);
Badge.displayName = "Badge";
export { Badge };
</file>

<file path="src/once-ui/components/Button.tsx">
"use client";
import React, { ReactNode, forwardRef } from "react";
import { ElementType } from "./ElementType";
import classNames from "classnames";
import { Spinner, Icon, Arrow, Flex } from ".";
import styles from "./Button.module.scss";
import { IconName } from "../icons";
interface CommonProps {
  variant?: "primary" | "secondary" | "tertiary" | "danger";
  size?: "s" | "m" | "l";
  radius?:
    | "none"
    | "top"
    | "right"
    | "bottom"
    | "left"
    | "top-left"
    | "top-right"
    | "bottom-right"
    | "bottom-left";
  label?: string;
  weight?: "default" | "strong";
  prefixIcon?: IconName;
  suffixIcon?: IconName;
  loading?: boolean;
  fillWidth?: boolean;
  horizontal?: "start" | "center" | "end" | "space-between";
  children?: ReactNode;
  href?: string;
  className?: string;
  style?: React.CSSProperties;
  id?: string;
  arrowIcon?: boolean;
}
export type ButtonProps = CommonProps & React.ButtonHTMLAttributes<HTMLButtonElement>;
export type AnchorProps = CommonProps & React.AnchorHTMLAttributes<HTMLAnchorElement>;
const Button = forwardRef<HTMLButtonElement, ButtonProps | AnchorProps>(
  (
    {
      variant = "primary",
      size = "m",
      radius,
      label,
      weight = "strong",
      children,
      prefixIcon,
      suffixIcon,
      loading = false,
      fillWidth = false,
      horizontal = "center",
      href,
      id,
      arrowIcon = false,
      className,
      style,
      ...props
    },
    ref,
  ) => {
    const iconSize = size === "l" ? "s" : size === "m" ? "s" : "xs";
    const radiusSize = size === "s" || size === "m" ? "m" : "l";
    return (
      <ElementType
        id={id}
        href={href}
        ref={ref}
        className={classNames(
          styles.button,
          styles[variant],
          styles[size],
          radius === "none"
            ? "radius-none"
            : radius
              ? `radius-${radiusSize}-${radius}`
              : `radius-${radiusSize}`,
          "text-decoration-none",
          "button",
          "cursor-interactive",
          {
            ["fill-width"]: fillWidth,
            ["fit-width"]: !fillWidth,
            ["justify-" + horizontal]: horizontal,
          },
          className,
        )}
        style={style}
        {...props}
      >
        {prefixIcon && !loading && <Icon name={prefixIcon} size={iconSize} />}
        {loading && <Spinner size={size} />}
        {(label || children) && (
          <Flex
            paddingX="4"
            paddingY="0"
            textWeight={weight}
            textSize={size}
            className="font-label"
          >
            {label || children}
          </Flex>
        )}
        {arrowIcon && (
          <Arrow
            style={{
              marginLeft: "calc(-1 * var(--static-space-4))",
            }}
            trigger={"#" + id}
            scale={size === "s" ? 0.8 : size === "m" ? 0.9 : 1}
            color={variant === "primary" ? "onSolid" : "onBackground"}
          />
        )}
        {suffixIcon && <Icon name={suffixIcon} size={iconSize} />}
      </ElementType>
    );
  },
);
Button.displayName = "Button";
export { Button };
</file>

<file path="src/once-ui/components/Card.module.scss">
.card {
    &:hover {
        background-color: var(--neutral-alpha-weak);
    }
}
</file>

<file path="src/once-ui/components/Carousel.tsx">
"use client";
import { Flex, RevealFx, Scroller, Media } from ".";
import { useEffect, useState, useRef } from "react";
interface Image {
  src: string;
  alt: string;
}
interface CarouselProps extends React.ComponentProps<typeof Flex> {
  images: Image[];
  indicator?: "line" | "thumbnail";
  aspectRatio?: string;
  sizes?: string;
  revealedByDefault?: boolean;
}
const Carousel: React.FC<CarouselProps> = ({
  images = [],
  indicator = "line",
  aspectRatio = "16 / 9",
  sizes,
  revealedByDefault = false,
  ...rest
}) => {
  const [activeIndex, setActiveIndex] = useState<number>(0);
  const [isTransitioning, setIsTransitioning] = useState(revealedByDefault);
  const [initialTransition, setInitialTransition] = useState(revealedByDefault);
  const nextImageRef = useRef<HTMLImageElement | null>(null);
  const transitionTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const preloadNextImage = (nextIndex: number) => {
    if (nextIndex >= 0 && nextIndex < images.length) {
      nextImageRef.current = new Image();
      nextImageRef.current.src = images[nextIndex].src;
    }
  };
  const handleImageClick = () => {
    if (images.length > 1) {
      const nextIndex = (activeIndex + 1) % images.length;
      handleControlClick(nextIndex);
    }
  };
  const handleControlClick = (nextIndex: number) => {
    if (nextIndex !== activeIndex && !transitionTimeoutRef.current) {
      preloadNextImage(nextIndex);
      setIsTransitioning(false);
      transitionTimeoutRef.current = setTimeout(() => {
        setActiveIndex(nextIndex);
        setTimeout(() => {
          setIsTransitioning(true);
          transitionTimeoutRef.current = undefined;
        }, 300);
      }, 800);
    }
  };
  useEffect(() => {
    if (!revealedByDefault && !initialTransition) {
      setIsTransitioning(true);
      setInitialTransition(true);
    }
    return () => {
      if (transitionTimeoutRef.current) {
        clearTimeout(transitionTimeoutRef.current);
      }
    };
  }, [revealedByDefault, initialTransition]);
  if (images.length === 0) {
    return null;
  }
  return (
    <Flex fillWidth gap="12" direction="column" {...rest}>
      <RevealFx
        onClick={handleImageClick}
        fillWidth
        trigger={isTransitioning}
        translateY="16"
        aspectRatio={aspectRatio}
        speed="fast"
      >
        <Media
          sizes={sizes}
          priority
          radius="l"
          border="neutral-alpha-weak"
          alt={images[activeIndex]?.alt}
          aspectRatio={aspectRatio}
          src={images[activeIndex]?.src}
          style={{
            ...(images.length > 1 && {
              cursor: "pointer",
            }),
          }}
        />
      </RevealFx>
      {images.length > 1 && (
        <>
          {indicator === "line" ? (
            <Flex gap="4" paddingX="s" fillWidth horizontal="center">
              {images.map((_, index) => (
                <Flex
                  radius="full"
                  key={index}
                  onClick={() => handleControlClick(index)}
                  style={{
                    background:
                      activeIndex === index
                        ? "var(--neutral-on-background-strong)"
                        : "var(--neutral-alpha-medium)",
                    transition: "background 0.3s ease",
                  }}
                  cursor="interactive"
                  fillWidth
                  height="2"
                ></Flex>
              ))}
            </Flex>
          ) : (
            <Scroller fillWidth gap="4" onItemClick={handleControlClick}>
              {images.map((image, index) => (
                <Flex
                  key={index}
                  style={{
                    border: activeIndex === index ? "2px solid var(--brand-solid-strong)" : "none",
                    borderRadius: "var(--radius-m-nest-4)",
                    transition: "border 0.3s ease",
                  }}
                  cursor="interactive"
                  padding="4"
                  aspectRatio={aspectRatio}
                  height="80"
                >
                  <Media
                    alt={image.alt}
                    aspectRatio="1 / 1"
                    sizes="120px"
                    src={image.src}
                    cursor="interactive"
                    radius="m"
                    transition="macro-medium"
                  />
                </Flex>
              ))}
            </Scroller>
          )}
        </>
      )}
    </Flex>
  );
};
Carousel.displayName = "Carousel";
export { Carousel };
</file>

<file path="src/once-ui/components/Checkbox.tsx">
"use client";
import React, { useState, useEffect, forwardRef } from "react";
import classNames from "classnames";
import { Flex, Icon, InteractiveDetails, InteractiveDetailsProps } from ".";
import styles from "./SharedInteractiveStyles.module.scss";
interface CheckboxProps
  extends Omit<InteractiveDetailsProps, "onClick">,
    React.InputHTMLAttributes<HTMLInputElement> {
  isChecked?: boolean;
  isIndeterminate?: boolean;
  onToggle?: () => void;
}
const generateId = () => `checkbox-${Math.random().toString(36).substring(2, 9)}`;
const Checkbox: React.FC<CheckboxProps> = forwardRef<HTMLInputElement, CheckboxProps>(
  (
    {
      style,
      className,
      isChecked: controlledIsChecked,
      isIndeterminate = false,
      onToggle,
      disabled,
      ...props
    },
    ref,
  ) => {
    const [isChecked, setIsChecked] = useState(controlledIsChecked || false);
    const [checkboxId] = useState(generateId());
    useEffect(() => {
      if (controlledIsChecked !== undefined) {
        setIsChecked(controlledIsChecked);
      }
    }, [controlledIsChecked]);
    const toggleItem = () => {
      if (disabled) return;
      if (onToggle) {
        onToggle();
      } else {
        setIsChecked(!isChecked);
      }
    };
    const handleKeyDown = (event: React.KeyboardEvent) => {
      if (disabled) return;
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        toggleItem();
      }
    };
    return (
      <Flex
        vertical="center"
        gap="16"
        className={classNames(styles.container, className, {
          [styles.disabled]: disabled,
        })}
        style={style}
      >
        <input
          type="checkbox"
          ref={ref}
          aria-checked={
            isIndeterminate
              ? "mixed"
              : controlledIsChecked !== undefined
                ? controlledIsChecked
                : isChecked
          }
          checked={controlledIsChecked !== undefined ? controlledIsChecked : isChecked}
          onChange={toggleItem}
          disabled={disabled}
          className={styles.hidden}
          tabIndex={-1}
        />
        <Flex
          style={{
            borderRadius: "min(var(--static-space-4), var(--radius-xs))",
          }}
          role="checkbox"
          tabIndex={0}
          cursor={disabled ? "not-allowed" : undefined}
          horizontal="center"
          vertical="center"
          radius="xs"
          aria-checked={
            isIndeterminate
              ? "mixed"
              : controlledIsChecked !== undefined
                ? controlledIsChecked
                : isChecked
          }
          aria-labelledby={checkboxId}
          onClick={toggleItem}
          onKeyDown={handleKeyDown}
          className={classNames(styles.element, {
            [styles.checked]:
              controlledIsChecked !== undefined
                ? controlledIsChecked || isIndeterminate
                : isChecked,
            [styles.disabled]: disabled,
          })}
        >
          {(controlledIsChecked !== undefined ? controlledIsChecked : isChecked) &&
            !isIndeterminate && (
              <Flex className={styles.icon}>
                <Icon onSolid="brand-strong" name="checkbox" size="xs" />
              </Flex>
            )}
          {isIndeterminate && (
            <Flex className={styles.icon}>
              <Icon onSolid="brand-strong" name="minus" size="xs" />
            </Flex>
          )}
        </Flex>
        {props.label && (
          <InteractiveDetails disabled={disabled} id={checkboxId} {...props} onClick={toggleItem} />
        )}
      </Flex>
    );
  },
);
Checkbox.displayName = "Checkbox";
export { Checkbox };
export type { CheckboxProps };
</file>

<file path="src/once-ui/components/Chip.module.scss">
.chip {
    white-space: nowrap;
    user-select: none;
    &.selected {
        background: var(--brand-alpha-medium);
        color: var(--brand-on-background-medium);
        &:hover,
        &:focus {
            background: var(--brand-alpha-medium);
        }
        &:active {
            background: var(--brand-alpha-weak);
            color: var(--brand-on-background-weak);
        }
    }
    &.unselected {
        background: var(--neutral-alpha-weak);
        color: var(--neutral-on-background-medium);
        &:hover,
        &:focus {
            background: var(--neutral-alpha-medium);
        }
        &:active {
            background: var(--neutral-alpha-weak);
            color: var(--neutral-on-background-weak);
        }
    }
    &:disabled {
        background: var(--neutral-solid-weak);
        cursor: not-allowed;
    }
}
</file>

<file path="src/once-ui/components/Chip.tsx">
"use client";
import React, { ReactNode, MouseEventHandler, forwardRef } from "react";
import classNames from "classnames";
import { Text, Icon, IconButton, IconButtonProps, Flex } from ".";
import styles from "./Chip.module.scss";
import { IconName } from "../icons";
interface ChipProps extends React.ComponentProps<typeof Flex> {
  label: string;
  selected?: boolean;
  prefixIcon?: IconName;
  onRemove?: () => void;
  onClick?: MouseEventHandler<HTMLDivElement>;
  children?: ReactNode;
  iconButtonProps?: Partial<IconButtonProps>;
  style?: React.CSSProperties;
  className?: string;
}
const Chip: React.FC<ChipProps> = forwardRef<HTMLDivElement, ChipProps>(
  (
    {
      label,
      selected = true,
      prefixIcon,
      onRemove,
      onClick,
      children,
      iconButtonProps = {},
      ...rest
    },
    ref,
  ) => {
    const defaultIconButtonProps: IconButtonProps = {
      icon: "close",
      variant: "ghost",
      size: "s",
      tooltip: "Remove",
      onClick: (e) => {
        e.stopPropagation();
        if (onRemove) onRemove();
      },
    };
    const combinedIconButtonProps = {
      ...defaultIconButtonProps,
      ...iconButtonProps,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        defaultIconButtonProps.onClick?.(e);
        iconButtonProps.onClick?.(e);
      },
    };
    const handleKeyDown: React.KeyboardEventHandler<HTMLDivElement> = (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        if (onClick) onClick(e as unknown as React.MouseEvent<HTMLDivElement>);
      }
    };
    return (
      <Flex
        ref={ref}
        fit
        vertical="center"
        radius="full"
        paddingX="8"
        paddingY="4"
        role="button"
        tabIndex={0}
        onClick={onClick}
        onKeyDown={handleKeyDown}
        aria-pressed={selected}
        cursor="interactive"
        transition="micro-medium"
        className={classNames(styles.chip, {
          [styles.selected]: selected,
          [styles.unselected]: !selected,
        })}
        {...rest}
      >
        {prefixIcon && <Icon name={prefixIcon} size="s" />}
        <Flex paddingX="8" paddingY="2">
          <Text variant="body-default-s">{label || children}</Text>
        </Flex>
        {onRemove && (
          <IconButton
            style={{
              color: "inherit",
            }}
            {...combinedIconButtonProps}
          />
        )}
      </Flex>
    );
  },
);
Chip.displayName = "Chip";
export { Chip };
</file>

<file path="src/once-ui/components/ColorInput.tsx">
"use client";
import React, { useRef, forwardRef } from "react";
import { Flex, Input, InputProps, IconButton, Icon } from ".";
interface ColorInputProps extends Omit<InputProps, "onChange" | "value"> {
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}
const ColorInput = forwardRef<HTMLInputElement, ColorInputProps>(
  ({ label, id, value, onChange, ...props }, ref) => {
    const colorInputRef = useRef<HTMLInputElement>(null);
    const handleHexClick = () => {
      if (colorInputRef.current) {
        colorInputRef.current.click();
      }
    };
    const handleReset = () => {
      onChange({
        target: { value: "" },
      } as React.ChangeEvent<HTMLInputElement>);
    };
    return (
      <Input
        style={{ cursor: "pointer" }}
        id={id}
        ref={colorInputRef}
        label={label}
        type="color"
        value={value}
        {...props}
        hasPrefix={
          <Flex>
            <Flex
              style={{
                width: value ? "var(--static-space-0)" : "var(--static-space-20)",
                transform: value ? "scale(0)" : "scale(1)",
                opacity: value ? "0" : "1",
                transition: "0.2s ease-in-out all",
              }}
            >
              <Flex padding="2">
                <Icon size="xs" name="eyeDropper" onBackground="neutral-medium" />
              </Flex>
            </Flex>
            <Flex
              border="neutral-strong"
              className={`prefix ${value ? "" : "hidden"}`}
              onClick={handleHexClick}
              height="20"
              radius="xs"
              style={{
                backgroundColor: value,
                cursor: "pointer",
                width: value ? "var(--static-space-20)" : "var(--static-space-0)",
                transform: value ? "scale(1)" : "scale(0)",
                opacity: value ? "1" : "0",
                transition: "0.2s ease-in-out all",
              }}
            ></Flex>
          </Flex>
        }
        hasSuffix={
          <Flex
            className={`suffix ${value ? "" : "hidden"}`}
            position="absolute"
            style={{
              left: "var(--static-space-48)",
              cursor: "pointer",
              width: "calc(100% - var(--static-space-48))",
            }}
          >
            <Flex
              onClick={handleHexClick}
              fillWidth
              style={{
                opacity: value ? "1" : "0",
                transition: "opacity 0.2s ease-in-out",
              }}
            >
              {value}
            </Flex>
            {value && (
              <IconButton
                onClick={handleReset}
                variant="secondary"
                tooltip="Remove"
                tooltipPosition="left"
                icon="close"
                style={{
                  position: "absolute",
                  right: "var(--static-space-12)",
                  transform: "translateY(-50%)",
                }}
              />
            )}
          </Flex>
        }
        onChange={onChange}
      />
    );
  },
);
ColorInput.displayName = "ColorInput";
export { ColorInput };
</file>

<file path="src/once-ui/components/Column.tsx">
"use client";
import { forwardRef } from "react";
import { Flex } from ".";
interface ColumnProps extends React.ComponentProps<typeof Flex> {
  children?: React.ReactNode;
}
const Column = forwardRef<HTMLDivElement, ColumnProps>(({ children, ...rest }, ref) => {
  return (
    <Flex direction="column" ref={ref} {...rest}>
      {children}
    </Flex>
  );
});
Column.displayName = "Column";
export { Column };
</file>

<file path="src/once-ui/components/CompareImage.module.scss">
.hitArea {
  cursor: col-resize;
  transform: translateX(-50%);
}
.dragIcon {
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  cursor: col-resize;
  z-index: 2;
  transition: none;
  pointer-events: auto;
}
</file>

<file path="src/once-ui/components/CompareImage.tsx">
"use client";
import { useState, useRef, useEffect } from "react";
import { Flex, Media, IconButton } from ".";
import styles from "./CompareImage.module.scss";
interface SideContent {
  src: string | React.ReactNode;
  alt?: string;
}
interface CompareImageProps extends React.ComponentProps<typeof Flex> {
  leftContent: SideContent;
  rightContent: SideContent;
}
const renderContent = (content: SideContent, clipPath: string) => {
  if (typeof content.src === "string") {
    return (
      <Media
        src={content.src}
        alt={content.alt || ""}
        fill
        position="absolute"
        style={{ clipPath }}
      />
    );
  }
  return (
    <Flex fill position="absolute" style={{ clipPath }}>
      {content.src}
    </Flex>
  );
};
const CompareImage = ({ leftContent, rightContent, ...rest }: CompareImageProps) => {
  const [position, setPosition] = useState(50);
  const containerRef = useRef<HTMLDivElement>(null);
  const isDragging = useRef(false);
  const handleMouseDown = () => {
    isDragging.current = true;
  };
  const handleMouseUp = () => {
    isDragging.current = false;
  };
  const updatePosition = (clientX: number) => {
    if (!isDragging.current || !containerRef.current) return;
    const rect = containerRef.current.getBoundingClientRect();
    const x = clientX - rect.left;
    const containerWidth = rect.width;
    // Calculate percentage (constrained between 0 and 100)
    const newPosition = Math.max(0, Math.min(100, (x / containerWidth) * 100));
    setPosition(newPosition);
  };
  const handleMouseMove = (e: MouseEvent) => {
    updatePosition(e.clientX);
  };
  const handleTouchMove = (e: TouchEvent) => {
    updatePosition(e.touches[0].clientX);
  };
  useEffect(() => {
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    document.addEventListener("touchmove", handleTouchMove);
    document.addEventListener("touchend", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      document.removeEventListener("touchmove", handleTouchMove);
      document.removeEventListener("touchend", handleMouseUp);
    };
  }, []);
  return (
    <Flex ref={containerRef} aspectRatio="16/9" fillWidth style={{ touchAction: "none" }} {...rest}>
      {renderContent(leftContent, `inset(0 ${100 - position}% 0 0)`)}
      {renderContent(rightContent, `inset(0 0 0 ${position}%)`)}
      {/* Hit area and visible line */}
      <Flex
        position="absolute"
        horizontal="center"
        width={3}
        className={styles.hitArea}
        top="0"
        bottom="0"
        style={{
          left: `${position}%`,
        }}
        onMouseDown={handleMouseDown}
        onTouchStart={handleMouseDown}
      >
        <Flex width="1" fillHeight background="neutral-strong" zIndex={2} />
      </Flex>
      <IconButton
        icon="chevronsLeftRight"
        variant="secondary"
        className={styles.dragIcon}
        style={{
          left: `${position}%`,
        }}
        onMouseDown={handleMouseDown}
        onTouchStart={handleMouseDown}
      />
    </Flex>
  );
};
CompareImage.displayName = "CompareImage";
export { CompareImage };
</file>

<file path="src/once-ui/components/CursorCard.module.scss">
.fadeIn {
  animation: fadeIn 0.2s ease-in-out;
}
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
</file>

<file path="src/once-ui/components/CursorCard.tsx">
"use client";
import React, {
  useState,
  useRef,
  useEffect,
  ReactNode,
  forwardRef,
  useImperativeHandle,
  useCallback,
} from "react";
import { createPortal } from "react-dom";
import { Placement } from "@floating-ui/react-dom";
import { Flex } from ".";
import styles from "./CursorCard.module.scss";
export interface CursorCardProps extends React.ComponentProps<typeof Flex> {
  trigger?: ReactNode;
  overlay?: ReactNode;
  placement?: Placement;
  className?: string;
  style?: React.CSSProperties;
}
const CursorCard = forwardRef<HTMLDivElement, CursorCardProps>(
  ({ trigger, overlay, placement = "bottom-left", className, style, ...flex }, ref) => {
    const [isHovering, setIsHovering] = useState(false);
    const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
    const [isTouchDevice, setIsTouchDevice] = useState(false);
    const cardRef = useRef<HTMLDivElement | null>(null);
    const triggerRef = useRef<HTMLDivElement | null>(null);
    useImperativeHandle(ref, () => cardRef.current as HTMLDivElement);
    useEffect(() => {
      const checkTouchDevice = () => {
        return "ontouchstart" in window || navigator.maxTouchPoints > 0;
      };
      setIsTouchDevice(checkTouchDevice());
    }, []);
    const handleMouseMove = useCallback(
      (e: MouseEvent) => {
        if (isHovering && !isTouchDevice) {
          setMousePosition({ x: e.clientX, y: e.clientY });
        }
      },
      [isHovering, isTouchDevice],
    );
    useEffect(() => {
      if (!isTouchDevice) {
        document.addEventListener("mousemove", handleMouseMove);
        return () => {
          document.removeEventListener("mousemove", handleMouseMove);
        };
      }
    }, [handleMouseMove, isTouchDevice]);
    // Create a portal container if it doesn't exist
    useEffect(() => {
      if (typeof document !== "undefined") {
        let portalContainer = document.getElementById("cursor-card-portal");
        if (!portalContainer) {
          portalContainer = document.createElement("div");
          portalContainer.id = "cursor-card-portal";
          document.body.appendChild(portalContainer);
        }
      }
      return () => {
        if (typeof document !== "undefined") {
          const portalContainer = document.getElementById("cursor-card-portal");
          if (portalContainer && portalContainer.childNodes.length === 0) {
            document.body.removeChild(portalContainer);
          }
        }
      };
    }, []);
    return (
      <>
        {trigger && (
          <Flex
            ref={triggerRef}
            onMouseEnter={() => !isTouchDevice && setIsHovering(true)}
            onMouseLeave={() => !isTouchDevice && setIsHovering(false)}
          >
            {trigger}
          </Flex>
        )}
        {isHovering &&
          !isTouchDevice &&
          typeof document !== "undefined" &&
          createPortal(
            <Flex
              zIndex={10}
              position="fixed"
              top="0"
              left="0"
              pointerEvents="none"
              ref={cardRef}
              className={`${styles.fadeIn} ${className || ""}`}
              style={{
                isolation: "isolate",
                transform: `translate(calc(${mousePosition.x}px ${placement.includes("left") ? "- 100%" : placement.includes("right") ? "" : "- 50%"}), calc(${mousePosition.y}px ${placement.includes("top") ? "- 100%" : placement.includes("bottom") ? "" : "- 50%"}))`,
                ...style,
              }}
              {...flex}
            >
              {overlay}
            </Flex>,
            document.getElementById("cursor-card-portal") || document.body,
          )}
      </>
    );
  },
);
CursorCard.displayName = "CursorCard";
export { CursorCard };
</file>

<file path="src/once-ui/components/DateInput.tsx">
"use client";
import React, { useState, useCallback, useEffect } from "react";
import { Input, DropdownWrapper, Flex, DatePicker } from ".";
interface DateInputProps extends Omit<React.ComponentProps<typeof Input>, "onChange" | "value"> {
  id: string;
  label?: string;
  placeholder?: string;
  value?: Date;
  onChange?: (date: Date) => void;
  minHeight?: number;
  className?: string;
  style?: React.CSSProperties;
  timePicker?: boolean;
}
const formatDate = (date: Date, timePicker: boolean) => {
  const options: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "short",
    day: "numeric",
    ...(timePicker && {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    }),
  };
  return date.toLocaleString("en-US", options);
};
export const DateInput: React.FC<DateInputProps> = ({
  id,
  label,
  placeholder,
  value,
  onChange,
  error,
  minHeight,
  className,
  style,
  timePicker = false,
  ...rest
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState(value ? formatDate(value, timePicker) : "");
  useEffect(() => {
    if (value) {
      setInputValue(formatDate(value, timePicker));
    }
  }, [value, timePicker]);
  const handleDateChange = useCallback(
    (date: Date) => {
      setInputValue(formatDate(date, timePicker));
      onChange?.(date);
      if (!timePicker) {
        setIsOpen(false);
      }
    },
    [onChange, timePicker],
  );
  const handleInputClick = useCallback(() => {
    setIsOpen(true);
  }, []);
  const trigger = (
    <Input
      style={{
        textOverflow: "ellipsis",
      }}
      id={id}
      label={label}
      placeholder={placeholder}
      value={inputValue}
      error={error}
      readOnly
      onClick={handleInputClick}
      {...rest}
    />
  );
  const dropdown = (
    <Flex padding="20">
      <DatePicker value={value} onChange={handleDateChange} timePicker={timePicker} />
    </Flex>
  );
  return (
    <DropdownWrapper
      fillWidth
      trigger={trigger}
      minHeight={minHeight}
      dropdown={dropdown}
      isOpen={isOpen}
      onOpenChange={setIsOpen}
      className={className}
      closeAfterClick={!timePicker}
      style={{ ...style }}
    />
  );
};
</file>

<file path="src/once-ui/components/DatePicker.module.scss">
.calendar {
    &.xs {
      --calendar-padding: var(--static-space-8);
      --calendar-gap: var(--static-space-4);
      --calendar-button-size: var(--static-space-24);
      --calendar-font-size: var(--font-size-xs);
    }
    &.s {
      --calendar-padding: var(--static-space-12);
      --calendar-gap: var(--static-space-8);
      --calendar-button-size: var(--static-space-28);
      --calendar-font-size: var(--font-size-s);
    }
    &.m {
      --calendar-padding: var(--static-space-16);
      --calendar-gap: var(--static-space-12);
      --calendar-button-size: var(--static-space-32);
      --calendar-font-size: var(--font-size-m);
    }
    &.l {
      --calendar-padding: var(--static-space-20);
      --calendar-gap: var(--static-space-16);
      --calendar-button-size: var(--static-space-36);
      --calendar-font-size: var(--font-size-l);
    }
    &.xl {
      --calendar-padding: var(--static-space-24);
      --calendar-gap: var(--static-space-20);
      --calendar-button-size: var(--static-space-40);
      --calendar-font-size: var(--font-size-xl);
    }
  }
  .monthButton {
      &:hover {
          transform: scale(1.10);
          background: var(--neutral-background-medium);
      }
      &:disabled {
          opacity: 0.5;
          cursor: not-allowed;
          transform: none;
      }
  }
  .dayButton {
    aspect-ratio: 1;
    width: var(--calendar-button-size);
    height: var(--calendar-button-size);
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: var(--calendar-font-size);
    transition: all 0.2s ease-in-out;
    border-radius: var(--radius-m);
    background-color: transparent;
    border: 0.5px solid var(--neutral-background-medium);
    color: var(--neutral-on-background-weak);
    &:hover {
      color: var(--neutral-background-weak);
      transform: scale(1.10);
      background: var(--neutral-background-strong);
    }
    &:active {
      background-color: var(--brand-background-strong);
      color: white;
      transform: scale(0.95);
    }
    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
  }
  .timeSelector {
    background: var(--neutral-background-medium);
    border-radius: var(--radius-m);
    border: 1px solid var(--neutral-background-medium);
    padding: var(--calendar-padding);
    font-size: var(--calendar-font-size);
    &:focus-within {
      border: 1px solid var(--neutral-border-strong);
    }
  }
  .timeInput {
    width: var(--static-space-40);
    height: var(--static-space-32);
    border: 1px solid var(--neutral-border-medium);
    border-radius: var(--radius-m);
    background: var(--neutral-background-strong);
    color: var(--neutral-on-background-strong);
    text-align: center;
    font-size: var(--calendar-font-size);
    outline: none;
    transition: all 0.2s ease-in-out;
    &:focus {
      border-color: var(--brand-border-medium);
      box-shadow: 0 0 0 2px var(--brand-alpha-weak);
    }
    &:invalid {
      border-color: var(--danger-border-medium);
    }
    &::-webkit-inner-spin-button,
    &::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
  }
  .ampmSelector {
    min-width: var(--static-space-80);
    height: var(--static-space-32);
    font-size: var(--calendar-font-size);
    button {
      min-width: var(--static-space-40);
    }
  }
  .monthTransition {
    transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
  }
  .slideLeft {
    transform: translateX(-20px);
    opacity: 0;
  }
  .slideRight {
    transform: translateX(20px);
    opacity: 0;
  }
  .timeWrapper {
      &.vertical {
        align-items: flex-start;
      }
    }
    .verticalTimeLabel {
      writing-mode: vertical-lr;
      transform: rotate(180deg);
      margin-right: var(--static-space-8);
    }
    .timeSelector {
      &.vertical {
        flex-direction: column;
        align-items: flex-start;
      }
    }
    .ampmSelector {
      min-width: var(--static-space-80);
      height: var(--static-space-32);
      font-size: var(--calendar-font-size);
      &.vertical {
        min-width: var(--static-space-32);
        height: auto;
        button {
          min-width: var(--static-space-32);
          height: var(--static-space-40);
        }
      }
    }
  .grid {
    display: grid;
    > div {
      overflow: hidden;
    }
  }
</file>

<file path="src/once-ui/components/DatePicker.tsx">
"use client";
import React, { useState, forwardRef, useEffect } from "react";
import classNames from "classnames";
import { Flex, Text, Button, Grid, SegmentedControl, IconButton, RevealFx, NumberInput } from ".";
import styles from "./DatePicker.module.scss";
export interface DatePickerProps extends Omit<React.ComponentProps<typeof Flex>, "onChange"> {
  value?: Date;
  onChange?: (date: Date) => void;
  minDate?: Date;
  maxDate?: Date;
  previousMonth?: boolean;
  nextMonth?: boolean;
  timePicker?: boolean;
  defaultDate?: Date;
  defaultTime?: {
    hours: number;
    minutes: number;
  };
  size?: "s" | "m" | "l";
  className?: string;
  style?: React.CSSProperties;
  currentMonth?: number;
  currentYear?: number;
  onMonthChange?: (increment: number) => void;
  range?: {
    startDate?: Date;
    endDate?: Date;
  };
  onHover?: (date: Date | null) => void;
}
const DatePicker = forwardRef<HTMLDivElement, DatePickerProps>(
  (
    {
      value,
      onChange,
      timePicker = false,
      previousMonth = true,
      nextMonth = true,
      minDate,
      maxDate,
      defaultDate,
      defaultTime,
      size = "m",
      className,
      style,
      currentMonth: propCurrentMonth,
      currentYear: propCurrentYear,
      onMonthChange,
      range,
      onHover,
      ...rest
    },
    ref,
  ) => {
    const today = new Date();
    const [selectedDate, setSelectedDate] = useState<Date | undefined>(value);
    const [selectedTime, setSelectedTime] = useState<
      | {
          hours: number;
          minutes: number;
        }
      | undefined
    >(defaultTime);
    const [isPM, setIsPM] = useState(defaultTime?.hours ? defaultTime.hours >= 12 : false);
    const [isTimeSelector, setIsTimeSelector] = useState(false);
    const [isTransitioning, setIsTransitioning] = useState(true);
    const [currentMonth, setCurrentMonth] = useState<number>(
      value ? value.getMonth() : today.getMonth(),
    );
    const [currentYear, setCurrentYear] = useState<number>(
      value ? value.getFullYear() : today.getFullYear(),
    );
    useEffect(() => {
      if (typeof propCurrentMonth === "number") {
        setCurrentMonth(propCurrentMonth);
      }
      if (typeof propCurrentYear === "number") {
        setCurrentYear(propCurrentYear);
      }
    }, [propCurrentMonth, propCurrentYear]);
    useEffect(() => {
      setSelectedDate(value);
      if (value) {
        setSelectedTime({
          hours: value.getHours(),
          minutes: value.getMinutes(),
        });
        setIsPM(value.getHours() >= 12);
      }
    }, [value]);
    useEffect(() => {
      const timer = setTimeout(() => {
        setIsTransitioning(true);
      }, 100);
      return () => clearTimeout(timer);
    }, []);
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ];
    const dayNames = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
    const handleTimeToggle = (show: boolean) => {
      setIsTransitioning(false);
      setTimeout(() => {
        setIsTimeSelector(show);
        setIsTransitioning(true);
      }, 400);
    };
    const handleDateSelect = (date: Date) => {
      const newDate = new Date(date);
      if (timePicker && selectedDate && selectedTime) {
        newDate.setHours(selectedTime.hours);
        newDate.setMinutes(selectedTime.minutes);
      }
      setSelectedDate(newDate);
      if (timePicker) {
        handleTimeToggle(true);
      } else {
        onChange?.(newDate);
      }
    };
    const handleMonthChange = (increment: number) => {
      if (onMonthChange) {
        // Delegate to external handler
        onMonthChange(increment);
      } else {
        // Fallback to internal state management
        const newMonth = currentMonth + increment;
        if (newMonth < 0) {
          setCurrentMonth(11); // December
          setCurrentYear(currentYear - 1);
        } else if (newMonth > 11) {
          setCurrentMonth(0); // January
          setCurrentYear(currentYear + 1);
        } else {
          setCurrentMonth(newMonth);
        }
      }
    };
    const convert24to12 = (hour24: number) => {
      if (hour24 === 0) return 12;
      if (hour24 > 12) return hour24 - 12;
      return hour24;
    };
    const handleTimeChange = (hours: number, minutes: number, pm: boolean = isPM) => {
      if (!selectedDate) return;
      const newTime = {
        hours: pm ? (hours === 12 ? 12 : hours + 12) : hours === 12 ? 0 : hours,
        minutes,
      };
      setSelectedTime(newTime);
      setIsPM(pm);
      const newDate = new Date(selectedDate);
      newDate.setHours(newTime.hours);
      newDate.setMinutes(minutes);
      onChange?.(newDate);
    };
    const isInRange = (date: Date) => {
      if (!range?.startDate) return false;
      if (!range?.endDate) return false;
      return date >= range.startDate && date <= range.endDate;
    };
    const renderCalendarGrid = () => {
      const firstDay = new Date(currentYear, currentMonth, 1).getDay();
      const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
      const daysInPrevMonth = new Date(currentYear, currentMonth, 0).getDate();
      // Calculate total number of weeks needed
      const totalDaysShown = firstDay + daysInMonth;
      const numberOfWeeks = Math.ceil(totalDaysShown / 7);
      const totalGridSpots = numberOfWeeks * 7;
      const days = [];
      // Previous month's days
      for (let i = 0; i < firstDay; i++) {
        const prevMonthDay = daysInPrevMonth - firstDay + i + 1;
        days.push(
          <Flex
            paddingY="2"
            width={size === "s" ? "32" : size === "m" ? "40" : "48"}
            height={size === "s" ? "32" : size === "m" ? "40" : "48"}
            key={`prev-${currentYear}-${currentMonth}-${i}`}
          >
            <Button
              fillWidth
              weight="default"
              variant="tertiary"
              size={size}
              type="button"
              disabled
            >
              {prevMonthDay}
            </Button>
          </Flex>,
        );
      }
      // Current month's days
      for (let day = 1; day <= daysInMonth; day++) {
        const currentDate = new Date(currentYear, currentMonth, day);
        const isSelected =
          (selectedDate?.getDate() === day &&
            selectedDate?.getMonth() === currentMonth &&
            selectedDate?.getFullYear() === currentYear) ||
          (value instanceof Date && value.getTime() === currentDate.getTime()) ||
          range?.startDate?.getTime() === currentDate.getTime() ||
          range?.endDate?.getTime() === currentDate.getTime();
        const isFirstInRange =
          range?.startDate && currentDate.getTime() === range.startDate.getTime();
        const isLastInRange = range?.endDate && currentDate.getTime() === range.endDate.getTime();
        // Check if the current date is out of the minDate and maxDate range
        const isDisabled = (minDate && currentDate < minDate) || (maxDate && currentDate > maxDate);
        days.push(
          <Flex paddingY="2" key={`day-${currentYear}-${currentMonth}-${day}`}>
            <Flex
              width={size === "s" ? "32" : size === "m" ? "40" : "48"}
              height={size === "s" ? "32" : size === "m" ? "40" : "48"}
              background={isInRange(currentDate) ? "neutral-alpha-weak" : undefined}
              borderTop={isInRange(currentDate) ? "neutral-alpha-weak" : "transparent"}
              borderBottom={isInRange(currentDate) ? "neutral-alpha-weak" : "transparent"}
              leftRadius={isFirstInRange ? "m" : undefined}
              rightRadius={isLastInRange ? "m" : undefined}
            >
              <Button
                fillWidth
                weight={isSelected ? "strong" : "default"}
                variant={isSelected ? "primary" : "tertiary"}
                size={size}
                onClick={(e: React.MouseEvent) => {
                  if (!isDisabled) {
                    if (timePicker) {
                      // Stop propagation to prevent DropdownWrapper from closing
                      e.stopPropagation();
                    }
                    handleDateSelect(currentDate);
                  }
                }}
                onMouseEnter={() => onHover?.(currentDate)}
                onMouseLeave={() => onHover?.(null)}
                disabled={isDisabled}
              >
                {day}
              </Button>
            </Flex>
          </Flex>,
        );
      }
      const remainingDays = totalGridSpots - days.length;
      for (let i = 1; i <= remainingDays; i++) {
        days.push(
          <Flex
            marginTop="2"
            width={size === "s" ? "32" : size === "m" ? "40" : "48"}
            height={size === "s" ? "32" : size === "m" ? "40" : "48"}
            key={`next-${currentYear}-${currentMonth}-${i}`}
          >
            <Button
              fillWidth
              weight="default"
              variant="tertiary"
              size={size}
              type="button"
              disabled
            >
              {i}
            </Button>
          </Flex>,
        );
      }
      return days;
    };
    return (
      <Flex
        ref={ref}
        className={classNames(styles.calendar, className)}
        style={style}
        direction="column"
        fillWidth
        horizontal="center"
        gap={size}
        {...rest}
      >
        <Flex fillWidth center>
          {isTimeSelector ? (
            <Flex horizontal="center" fillWidth direction="column" gap="8">
              <Text variant={`label-default-${size}`} onBackground="neutral-strong">
                {monthNames[currentMonth]} {currentYear}
              </Text>
              <Text
                className="cursor-interactive"
                variant="label-default-s"
                onBackground="brand-weak"
                onClick={() => handleTimeToggle(false)}
              >
                Back to calendar
              </Text>
            </Flex>
          ) : (
            <>
              {previousMonth && (
                <IconButton
                  variant="tertiary"
                  size={size}
                  icon="chevronLeft"
                  onClick={(event: any) => {
                    event.preventDefault();
                    event.stopPropagation();
                    handleMonthChange(-1);
                  }}
                />
              )}
              <Flex fillWidth direction="column" horizontal="center" gap="8">
                <Text variant={`body-default-${size}`} onBackground="neutral-strong">
                  {monthNames[currentMonth]} {currentYear}
                </Text>
                {timePicker && selectedTime && (
                  <Text variant="label-default-s" onBackground="neutral-weak">
                    {`${selectedTime.hours.toString().padStart(2, "0")}:${selectedTime.minutes.toString().padStart(2, "0")} ${isPM ? "PM" : "AM"}`}
                  </Text>
                )}
              </Flex>
              {nextMonth && (
                <IconButton
                  variant="tertiary"
                  size={size}
                  icon="chevronRight"
                  onClick={(event: any) => {
                    event.preventDefault();
                    event.stopPropagation();
                    handleMonthChange(1);
                  }}
                />
              )}
            </>
          )}
        </Flex>
        <RevealFx
          fillWidth
          horizontal="center"
          vertical="center"
          key={isTimeSelector ? "time" : "date"}
          trigger={isTransitioning}
          speed="fast"
        >
          {isTimeSelector ? (
            <Flex
              maxWidth={24}
              horizontal="center"
              vertical="center"
              direction="column"
              padding="32"
              gap="32"
            >
              <SegmentedControl
                buttons={[
                  {
                    value: "AM",
                    label: "AM",
                  },
                  {
                    value: "PM",
                    label: "PM",
                  },
                ]}
                selected={isPM ? "PM" : "AM"}
                onToggle={(value) =>
                  handleTimeChange(
                    selectedTime?.hours ?? 0,
                    selectedTime?.minutes ?? 0,
                    value === "PM",
                  )
                }
              />
              <Flex fillWidth gap="16" vertical="center" data-scaling="110">
                <NumberInput
                  id="hours"
                  placeholder="Hours"
                  min={1}
                  max={12}
                  value={selectedTime?.hours ? convert24to12(selectedTime.hours) : 12}
                  onChange={(value) => {
                    if (value >= 1 && value <= 12) {
                      handleTimeChange(value, selectedTime?.minutes ?? 0);
                    }
                  }}
                  aria-label="Hours"
                />
                :
                <NumberInput
                  id="minutes"
                  placeholder="Minutes"
                  min={0}
                  max={59}
                  padStart={2}
                  value={selectedTime?.minutes ?? 0}
                  onChange={(value) => {
                    if (value >= 0 && value <= 59) {
                      handleTimeChange(selectedTime?.hours ?? 0, value);
                    }
                  }}
                  aria-label="Minutes"
                />
              </Flex>
            </Flex>
          ) : (
            <Grid fitWidth columns="7">
              {dayNames.map((day) => (
                <Text
                  marginBottom="16"
                  key={day}
                  variant="label-default-m"
                  onBackground="neutral-medium"
                  align="center"
                >
                  {day}
                </Text>
              ))}
              {renderCalendarGrid()}
            </Grid>
          )}
        </RevealFx>
      </Flex>
    );
  },
);
DatePicker.displayName = "DatePicker";
export { DatePicker };
</file>

<file path="src/once-ui/components/DateRangePicker.tsx">
"use client";
import React, { useState, useEffect } from "react";
import { Flex, DatePicker } from ".";
export interface DateRange {
  startDate: Date | undefined;
  endDate: Date | undefined;
}
export interface DateRangePickerProps extends Omit<React.ComponentProps<typeof Flex>, "onChange"> {
  value?: DateRange;
  onChange?: (range: DateRange) => void;
  minDate?: Date;
  maxDate?: Date;
  dual?: boolean;
  size?: "s" | "m" | "l";
}
const DateRangePicker: React.FC<DateRangePickerProps> = ({
  value,
  onChange,
  minDate,
  maxDate,
  size = "m",
  dual,
  ...rest
}) => {
  const [internalValue, setInternalValue] = useState<DateRange>({
    startDate: value?.startDate || undefined,
    endDate: value?.endDate || undefined,
  });
  const [hoveredDate, setHoveredDate] = useState<Date | null>(null);
  // Initialize with the startDate's month and year if available, otherwise use current date
  const [currentMonth, setCurrentMonth] = useState(
    value?.startDate ? value.startDate.getMonth() : new Date().getMonth(),
  );
  const [currentYear, setCurrentYear] = useState(
    value?.startDate ? value.startDate.getFullYear() : new Date().getFullYear(),
  );
  useEffect(() => {
    if (value) {
      setInternalValue({
        startDate: value.startDate,
        endDate: value.endDate,
      });
      // Update the current month and year when value changes and has a startDate
      if (value.startDate) {
        setCurrentMonth(value.startDate.getMonth());
        setCurrentYear(value.startDate.getFullYear());
      }
    }
  }, [value]);
  const handleDateChange = (date: Date) => {
    if (!internalValue.startDate || (internalValue.startDate && internalValue.endDate)) {
      // Start new selection
      const newRange = {
        startDate: date,
        endDate: undefined,
      };
      setInternalValue(newRange);
      onChange?.(newRange);
    } else {
      const newRange = {
        startDate: internalValue.startDate,
        endDate: date,
      };
      if (newRange.startDate > date) {
        newRange.startDate = date;
        newRange.endDate = internalValue.startDate;
      }
      setInternalValue(newRange);
      onChange?.(newRange);
    }
  };
  const handleMonthChange = (increment: number) => {
    const newDate = new Date(currentYear, currentMonth + increment, 1);
    setCurrentMonth(newDate.getMonth());
    setCurrentYear(newDate.getFullYear());
    setInternalValue({
      startDate: internalValue.startDate,
      endDate: internalValue.endDate,
    });
  };
  const getSecondMonth = () => {
    const firstMonth = new Date(currentYear, currentMonth, 1);
    const secondMonth = new Date(firstMonth);
    secondMonth.setMonth(secondMonth.getMonth() + 1);
    return secondMonth;
  };
  const getPreviewRange = () => {
    if (!internalValue.startDate || internalValue.endDate || !hoveredDate) return null;
    return {
      startDate: internalValue.startDate,
      endDate: hoveredDate > internalValue.startDate ? hoveredDate : internalValue.startDate,
      isPreview: true,
    };
  };
  return (
    <Flex gap="24" {...rest}>
      <DatePicker
        value={internalValue.startDate}
        onChange={handleDateChange}
        range={getPreviewRange() || internalValue}
        minDate={minDate}
        maxDate={maxDate}
        size={size}
        nextMonth={dual ? false : true}
        currentMonth={currentMonth}
        currentYear={currentYear}
        onMonthChange={handleMonthChange}
        onHover={setHoveredDate}
      />
      {dual && (
        <DatePicker
          value={internalValue.endDate}
          onChange={handleDateChange}
          range={getPreviewRange() || internalValue}
          minDate={minDate}
          maxDate={maxDate}
          previousMonth={false}
          size={size}
          currentMonth={getSecondMonth().getMonth()}
          currentYear={getSecondMonth().getFullYear()}
          onMonthChange={handleMonthChange}
          onHover={setHoveredDate}
        />
      )}
    </Flex>
  );
};
DateRangePicker.displayName = "DateRangePicker";
export { DateRangePicker };
</file>

<file path="src/once-ui/components/Dialog.module.scss">
.overlay {
    opacity: 0;
    visibility: hidden;
    &.open {
        opacity: 1;
        visibility: visible;
    }
}
.dialog {
    max-width: 40rem;
    max-height: 100%;
    transform: scale(0.2);
    opacity: 0;
    &.open {
        transform: scale(1);
        opacity: 1;
        visibility: visible;
    }
    @media (--m) {
        position: fixed;
        bottom: var(--static-space-8);
        left: var(--static-space-8);
        right: var(--static-space-8);
        top: var(--static-space-8);
        max-width: calc(100% - var(--static-space-16)) !important;
    }
}
</file>

<file path="src/once-ui/components/Dialog.tsx">
"use client";
import React, {
  ReactNode,
  useEffect,
  useCallback,
  useRef,
  forwardRef,
  useState,
  useContext,
} from "react";
import ReactDOM from "react-dom";
import classNames from "classnames";
import { Flex, Heading, IconButton, Text } from ".";
import styles from "./Dialog.module.scss";
interface DialogProps extends Omit<React.ComponentProps<typeof Flex>, "title"> {
  isOpen: boolean;
  onClose: () => void;
  title: ReactNode | string;
  description?: ReactNode;
  children?: ReactNode;
  footer?: ReactNode;
  base?: boolean;
  stack?: boolean;
  onHeightChange?: (height: number) => void;
  minHeight?: number;
}
const DialogContext = React.createContext<{
  stackedDialogOpen: boolean;
  setStackedDialogOpen: (open: boolean) => void;
}>({
  stackedDialogOpen: false,
  setStackedDialogOpen: () => {},
});
export const DialogProvider: React.FC<{
  children: React.ReactNode;
}> = ({ children }) => {
  const [stackedDialogOpen, setStackedDialogOpen] = useState(false);
  return (
    <DialogContext.Provider
      value={{
        stackedDialogOpen,
        setStackedDialogOpen,
      }}
    >
      {children}
    </DialogContext.Provider>
  );
};
const Dialog: React.FC<DialogProps> = forwardRef<HTMLDivElement, DialogProps>(
  (
    {
      isOpen,
      onClose,
      title,
      description,
      children,
      stack,
      base,
      footer,
      onHeightChange,
      minHeight,
      ...rest
    },
    ref,
  ) => {
    const dialogRef = useRef<HTMLDivElement>(null);
    const [isVisible, setIsVisible] = useState(isOpen);
    const [isAnimating, setIsAnimating] = useState(false);
    const { stackedDialogOpen, setStackedDialogOpen } = useContext(DialogContext);
    useEffect(() => {
      if (stack) {
        setStackedDialogOpen(isOpen);
      }
    }, [stack, isOpen, setStackedDialogOpen]);
    useEffect(() => {
      if (dialogRef.current && isVisible) {
        const height = dialogRef.current.offsetHeight;
        onHeightChange?.(height);
      }
    }, [isVisible, onHeightChange]);
    useEffect(() => {
      if (isOpen) {
        setIsVisible(true);
        setTimeout(() => {
          setIsAnimating(true);
        }, 0);
      } else {
        setIsAnimating(false);
        setTimeout(() => {
          setIsVisible(false);
        }, 300);
      }
    }, [isOpen]);
    const handleKeyDown = useCallback(
      (event: KeyboardEvent) => {
        if (event.key === "Escape" && !base) {
          onClose();
        }
        if (event.key === "Tab" && dialogRef.current) {
          const focusableElements = dialogRef.current.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
          );
          if (focusableElements.length > 0) {
            const firstElement = focusableElements[0] as HTMLElement;
            const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
            if (event.shiftKey && document.activeElement === firstElement) {
              event.preventDefault();
              lastElement.focus();
            } else if (!event.shiftKey && document.activeElement === lastElement) {
              event.preventDefault();
              firstElement.focus();
            }
          }
        }
      },
      [onClose, base],
    );
    useEffect(() => {
      if (isOpen) {
        document.addEventListener("keydown", handleKeyDown);
        return () => {
          document.removeEventListener("keydown", handleKeyDown);
        };
      }
    }, [isOpen, handleKeyDown]);
    useEffect(() => {
      if (isOpen) {
        document.body.style.overflow = "hidden";
        // Make everything outside the dialog inert
        document.body.childNodes.forEach((node) => {
          if (node instanceof HTMLElement && node !== document.getElementById("portal-root")) {
            node.inert = true;
          }
        });
        // If this is a stacked dialog, make the base dialog inert too
        if (stack) {
          const dialogs = document.querySelectorAll('[role="dialog"]');
          dialogs.forEach((dialog) => {
            if (dialog instanceof HTMLElement && !dialog.contains(dialogRef.current)) {
              dialog.inert = true;
            }
          });
        }
      } else {
        // If this is a stacked dialog closing, restore interactivity to base dialog
        if (stack) {
          const dialogs = document.querySelectorAll('[role="dialog"]');
          dialogs.forEach((dialog) => {
            if (dialog instanceof HTMLElement) {
              dialog.inert = false;
            }
          });
        } else {
          // If base dialog is closing, restore everything
          document.body.childNodes.forEach((node) => {
            if (node instanceof HTMLElement) {
              node.inert = false;
            }
          });
          document.body.style.overflow = "unset";
        }
      }
    }, [isOpen, stack]);
    useEffect(() => {
      if (isOpen && dialogRef.current) {
        const focusableElements = dialogRef.current.querySelectorAll<HTMLElement>(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
        );
        const firstElement = focusableElements[0];
        firstElement.focus();
      }
    }, [isOpen]);
    useEffect(() => {
      const handleClickOutside = (event: MouseEvent) => {
        // Only handle left clicks (button 0), ignore right clicks
        if (event.button !== 0) return;
        event.stopPropagation();
        if (!dialogRef.current?.contains(event.target as Node)) {
          if (stack || !base) {
            // Prevent default to avoid triggering any links behind the dialog
            event.preventDefault();
            onClose();
          }
        }
      };
      if (isVisible) {
        document.addEventListener("mousedown", handleClickOutside, { capture: true });
        return () => {
          document.removeEventListener("mousedown", handleClickOutside, { capture: true });
        };
      }
    }, [isVisible, onClose, stack, base]);
    if (!isVisible) return null;
    return ReactDOM.createPortal(
      <Flex
        ref={ref}
        transition="macro-medium"
        background="overlay"
        position="fixed"
        zIndex={base ? 8 : 9}
        top="0"
        left="0"
        right="0"
        bottom="0"
        className={classNames(styles.overlay, {
          [styles.open]: isAnimating,
        })}
        center
        padding="l"
        role="dialog"
        aria-modal="true"
        aria-labelledby="dialog-title"
      >
        <Flex
          fill
          center
          transition="macro-medium"
          style={{
            transform: base ? "scale(0.94) translateY(-1.25rem)" : "",
          }}
        >
          <Flex
            position="unset"
            className={classNames(styles.dialog, {
              [styles.open]: isAnimating,
            })}
            style={{
              minHeight: minHeight ? `${minHeight}px` : undefined,
            }}
            ref={dialogRef}
            fillWidth
            transition="macro-medium"
            shadow="xl"
            radius="xl"
            border="neutral-medium"
            background="neutral-weak"
            direction="column"
            tabIndex={-1}
            onKeyDown={(e) => {
              if (e.key === "Tab") {
                const focusableElements = Array.from(
                  dialogRef.current?.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                  ) || [],
                );
                if (focusableElements.length === 0) return;
                const firstElement = focusableElements[0] as HTMLElement;
                const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
                if (e.shiftKey && document.activeElement === firstElement) {
                  e.preventDefault();
                  lastElement.focus();
                } else if (!e.shiftKey && document.activeElement === lastElement) {
                  e.preventDefault();
                  firstElement.focus();
                }
              }
            }}
            {...rest}
          >
            <Flex
              as="header"
              direction="column"
              paddingX="24"
              paddingTop="24"
              paddingBottom="s"
              gap="4"
            >
              <Flex fillWidth horizontal="space-between" gap="8">
                {typeof title === "string" ? (
                  <Heading id="dialog-title" variant="heading-strong-l">
                    {title}
                  </Heading>
                ) : (
                  title
                )}
                <IconButton
                  icon="close"
                  size="m"
                  variant="tertiary"
                  tooltip="Close"
                  onClick={onClose}
                />
              </Flex>
              {description && (
                <Text variant="body-default-s" onBackground="neutral-weak">
                  {description}
                </Text>
              )}
            </Flex>
            <Flex
              as="section"
              paddingX="24"
              paddingBottom="24"
              flex={1}
              overflowY="auto"
              direction="column"
            >
              {children}
            </Flex>
            {footer && (
              <Flex borderTop="neutral-medium" as="footer" horizontal="end" padding="12" gap="8">
                {footer}
              </Flex>
            )}
          </Flex>
        </Flex>
      </Flex>,
      document.body,
    );
  },
);
Dialog.displayName = "Dialog";
export { Dialog };
</file>

<file path="src/once-ui/components/Dropdown.tsx">
"use client";
import React, { ReactNode, forwardRef, SyntheticEvent } from "react";
import { Flex } from ".";
interface DropdownProps extends Omit<React.ComponentProps<typeof Flex>, "onSelect"> {
  selectedOption?: string;
  children?: ReactNode;
  onEscape?: () => void;
  onSelect?: (event: string) => void;
}
const Dropdown = forwardRef<HTMLDivElement, DropdownProps>(
  ({ selectedOption, className, children, onEscape, onSelect, ...rest }, ref) => {
    const handleSelect = (event: SyntheticEvent<HTMLDivElement>) => {
      const value = event.currentTarget.getAttribute("data-value");
      if (onSelect && value) {
        onSelect(value);
      }
    };
    return (
      <Flex
        ref={ref}
        role="listbox"
        onClick={handleSelect}
        flex={1}
        border="neutral-medium"
        background="surface"
        overflow="hidden"
        {...rest}
      >
        <Flex flex={1} overflowY="auto" direction="column" gap="2">
          {children}
        </Flex>
      </Flex>
    );
  },
);
Dropdown.displayName = "Dropdown";
export { Dropdown };
export type { DropdownProps };
</file>

<file path="src/once-ui/components/DropdownWrapper.module.scss">
@keyframes fadeIn {
  from {
      opacity: 0;
      transform: scale(0.9);
  }
  to {
      opacity: 1;
      transform: scale(1);
  }
}
.fadeIn {
  transform-origin: top right;
  animation: fadeIn var(--transition-duration-micro-medium) var(--transition-eased);
}
</file>

<file path="src/once-ui/components/ElementType.tsx">
import Link from "next/link";
import React, { ReactNode, forwardRef } from "react";
import { Flex } from "./Flex";
interface ElementTypeProps {
  href?: string;
  onClick?: () => void;
  onLinkClick?: () => void;
  children: ReactNode;
  className?: string;
  style?: React.CSSProperties;
  [key: string]: any;
}
const isExternalLink = (url: string) => /^https?:\/\//.test(url);
const ElementType = forwardRef<HTMLElement, ElementTypeProps>(
  ({ href, type, onClick, onLinkClick, children, className, style, ...props }, ref) => {
    if (href) {
      const isExternal = isExternalLink(href);
      if (isExternal) {
        return (
          <a
            href={href}
            target="_blank"
            rel="noreferrer"
            ref={ref as React.Ref<HTMLAnchorElement>}
            className={className}
            style={style}
            onClick={() => onLinkClick?.()}
            {...(props as React.AnchorHTMLAttributes<HTMLAnchorElement>)}
          >
            {children}
          </a>
        );
      }
      return (
        <Link
          href={href}
          ref={ref as React.Ref<HTMLAnchorElement>}
          className={className}
          style={style}
          onClick={() => onLinkClick?.()}
          {...(props as React.AnchorHTMLAttributes<HTMLAnchorElement>)}
        >
          {children}
        </Link>
      );
    }
    if (onClick || type === "submit" || type === "button") {
      return (
        <button
          ref={ref as React.Ref<HTMLButtonElement>}
          className={className}
          onClick={onClick}
          style={style}
          {...(props as React.ButtonHTMLAttributes<HTMLButtonElement>)}
        >
          {children}
        </button>
      );
    }
    return (
      <Flex
        ref={ref as React.Ref<HTMLDivElement>}
        className={className}
        style={style}
        {...(props as React.HTMLAttributes<HTMLDivElement>)}
      >
        {children}
      </Flex>
    );
  },
);
ElementType.displayName = "ElementType";
export { ElementType };
</file>

<file path="src/once-ui/components/Fade.module.scss">
.mask {
    backdrop-filter: blur(0.5rem);
    background: linear-gradient(var(--gradient-direction), var(--base-color), transparent);
    mask-image: linear-gradient(var(--gradient-direction), black 20%, transparent 100%);
    mask-size: 100% 100%;
}
</file>

<file path="src/once-ui/components/Fade.tsx">
"use client";
import React, { forwardRef, ReactNode } from "react";
import styles from "./Fade.module.scss";
import { Flex } from ".";
import { ColorScheme, ColorWeight, SpacingToken } from "../types";
export type BaseColor =
  | `${ColorScheme}-${ColorWeight}`
  | `${ColorScheme}-alpha-${ColorWeight}`
  | "surface"
  | "overlay"
  | "page"
  | "transparent";
interface FadeProps extends React.ComponentProps<typeof Flex> {
  className?: string;
  to?: "bottom" | "top" | "left" | "right";
  base?: BaseColor;
  blur?: number;
  pattern?: {
    display?: boolean;
    size?: SpacingToken;
  };
  style?: React.CSSProperties;
  children?: ReactNode;
}
const Fade = forwardRef<HTMLDivElement, FadeProps>(
  (
    {
      to = "bottom",
      base = "page",
      pattern = {
        display: false,
        size: "4",
      },
      blur = 0.5,
      children,
      ...rest
    },
    ref,
  ) => {
    const getBaseVar = (base: BaseColor) => {
      if (base === "page") return "var(--page-background)";
      if (base === "surface") return "var(--surface-background)";
      if (base === "overlay") return "var(--backdrop)";
      if (base === "transparent") return "var(--static-transparent)";
      const [scheme, weight] = base.includes("alpha") ? base.split("-alpha-") : base.split("-");
      return base.includes("alpha")
        ? `var(--${scheme}-alpha-${weight})`
        : `var(--${scheme}-background-${weight})`;
    };
    return (
      <Flex
        ref={ref}
        fillWidth
        style={
          {
            "--base-color": getBaseVar(base),
            "--gradient-direction":
              to === "top"
                ? "0deg"
                : to === "right"
                  ? "90deg"
                  : to === "bottom"
                    ? "180deg"
                    : "270deg",
            ...(pattern.display && {
              backgroundImage: `linear-gradient(var(--gradient-direction), var(--base-color), transparent), radial-gradient(transparent 1px, var(--base-color) 1px)`,
              backgroundSize: `100% 100%, var(--static-space-${pattern.size}) var(--static-space-${pattern.size})`,
              backdropFilter: `blur(${blur}rem)`,
            }),
          } as React.CSSProperties
        }
        className={styles.mask}
        {...rest}
      >
        {children}
      </Flex>
    );
  },
);
Fade.displayName = "Fade";
export { Fade };
</file>

<file path="src/once-ui/components/Feedback.tsx">
"use client";
import React, { forwardRef, ReactNode } from "react";
import { IconButton, Button, Icon, Flex, Text, Column } from ".";
interface FeedbackProps extends Omit<React.ComponentProps<typeof Flex>, "title"> {
  variant?: "info" | "danger" | "warning" | "success";
  icon?: boolean;
  title?: string;
  description?: string;
  showCloseButton?: boolean;
  onClose?: () => void;
  className?: string;
  style?: React.CSSProperties;
  children?: ReactNode;
}
const variantIconMap: {
  [key in "info" | "danger" | "warning" | "success"]: string;
} = {
  info: "info",
  danger: "danger",
  warning: "warning",
  success: "check",
};
const Feedback = forwardRef<HTMLDivElement, FeedbackProps>(
  (
    {
      variant = "info",
      icon = true,
      title,
      description,
      showCloseButton = false,
      onClose,
      className,
      style,
      children,
      ...rest
    },
    ref,
  ) => {
    return (
      <Flex
        fillWidth
        radius="l"
        ref={ref}
        border={`${variant}-medium`}
        background={`${variant}-medium`}
        vertical="start"
        role="alert"
        aria-live="assertive"
        className={className}
        style={style}
        {...rest}
      >
        {icon && (
          <Flex paddingY="16" paddingLeft="16">
            <Icon
              padding="4"
              radius="m"
              border={`${variant}-medium`}
              onBackground={`${variant}-medium`}
              name={variantIconMap[variant]}
              aria-hidden="true"
            />
          </Flex>
        )}
        <Column fillWidth padding="16" gap="24" vertical="center">
          {(title || description) && (
            <Column fillWidth gap="4">
              {title && (
                <Flex fillWidth gap="16">
                  <Flex fillWidth paddingY="4">
                    <Text
                      variant="heading-strong-m"
                      onBackground={`${variant}-medium`}
                      role="heading"
                      aria-level={2}
                    >
                      {title}
                    </Text>
                  </Flex>
                  {showCloseButton && (
                    <IconButton
                      onClick={onClose}
                      icon="close"
                      size="m"
                      tooltip="Hide"
                      tooltipPosition="top"
                      variant="ghost"
                      aria-label="Close alert"
                    />
                  )}
                </Flex>
              )}
              {description && (
                <Text variant="body-default-s" onBackground={`${variant}-strong`}>
                  {description}
                </Text>
              )}
            </Column>
          )}
          {children}
        </Column>
      </Flex>
    );
  },
);
Feedback.displayName = "Feedback";
export { Feedback };
</file>

<file path="src/once-ui/components/Flex.tsx">
"use client";
import classNames from "classnames";
import { CSSProperties, forwardRef } from "react";
import {
  CommonProps,
  ConditionalProps,
  DisplayProps,
  FlexProps,
  SizeProps,
  SpacingProps,
  StyleProps,
} from "../interfaces";
import { ColorScheme, ColorWeight, SpacingToken, TextVariant } from "../types";
interface ComponentProps
  extends FlexProps,
    SpacingProps,
    SizeProps,
    StyleProps,
    CommonProps,
    DisplayProps,
    ConditionalProps {}
const Flex = forwardRef<HTMLDivElement, ComponentProps>(
  (
    {
      as: Component = "div",
      inline,
      dark,
      light,
      direction,
      tabletDirection,
      mobileDirection,
      wrap = false,
      horizontal,
      vertical,
      flex,
      textVariant,
      textSize,
      textWeight,
      textType,
      onBackground,
      onSolid,
      align,
      top,
      right,
      bottom,
      left,
      padding,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      paddingX,
      paddingY,
      margin,
      marginLeft,
      marginRight,
      marginTop,
      marginBottom,
      marginX,
      marginY,
      gap,
      position = "relative",
      center,
      width,
      height,
      maxWidth,
      minWidth,
      minHeight,
      maxHeight,
      fit = false,
      fitWidth = false,
      fitHeight = false,
      fill = false,
      fillWidth = false,
      fillHeight = false,
      aspectRatio,
      hide,
      show,
      transition,
      background,
      solid,
      opacity,
      pointerEvents,
      border,
      borderTop,
      borderRight,
      borderBottom,
      borderLeft,
      borderStyle,
      borderWidth,
      radius,
      topRadius,
      rightRadius,
      bottomRadius,
      leftRadius,
      topLeftRadius,
      topRightRadius,
      bottomLeftRadius,
      bottomRightRadius,
      overflow,
      overflowX,
      overflowY,
      zIndex,
      shadow,
      cursor,
      className,
      style,
      children,
      ...rest
    },
    ref,
  ) => {
    if (onBackground && onSolid) {
      console.warn(
        "You cannot use both 'onBackground' and 'onSolid' props simultaneously. Only one will be applied.",
      );
    }
    if (background && solid) {
      console.warn(
        "You cannot use both 'background' and 'solid' props simultaneously. Only one will be applied.",
      );
    }
    const getVariantClasses = (variant: TextVariant) => {
      const [fontType, weight, size] = variant.split("-");
      return [`font-${fontType}`, `font-${weight}`, `font-${size}`];
    };
    const sizeClass = textSize ? `font-${textSize}` : "";
    const weightClass = textWeight ? `font-${textWeight}` : "";
    const variantClasses = textVariant ? getVariantClasses(textVariant) : [sizeClass, weightClass];
    let colorClass = "";
    if (onBackground) {
      const [scheme, weight] = onBackground.split("-") as [ColorScheme, ColorWeight];
      colorClass = `${scheme}-on-background-${weight}`;
    } else if (onSolid) {
      const [scheme, weight] = onSolid.split("-") as [ColorScheme, ColorWeight];
      colorClass = `${scheme}-on-solid-${weight}`;
    }
    const generateDynamicClass = (type: string, value: string | undefined) => {
      if (!value) return undefined;
      if (value === "transparent") {
        return `transparent-border`;
      }
      if (["surface", "page", "overlay"].includes(value)) {
        return `${value}-${type}`;
      }
      const parts = value.split("-");
      if (parts.includes("alpha")) {
        const [scheme, , weight] = parts;
        return `${scheme}-${type}-alpha-${weight}`;
      }
      const [scheme, weight] = value.split("-") as [ColorScheme, ColorWeight];
      return `${scheme}-${type}-${weight}`;
    };
    const classes = classNames(
      inline ? "display-inline-flex" : "display-flex",
      padding && `p-${padding}`,
      paddingLeft && `pl-${paddingLeft}`,
      paddingRight && `pr-${paddingRight}`,
      paddingTop && `pt-${paddingTop}`,
      paddingBottom && `pb-${paddingBottom}`,
      paddingX && `px-${paddingX}`,
      paddingY && `py-${paddingY}`,
      margin && `m-${margin}`,
      marginLeft && `ml-${marginLeft}`,
      marginRight && `mr-${marginRight}`,
      marginTop && `mt-${marginTop}`,
      marginBottom && `mb-${marginBottom}`,
      marginX && `mx-${marginX}`,
      marginY && `my-${marginY}`,
      gap === "-1"
        ? direction === "column" || direction === "column-reverse"
          ? "g-vertical--1"
          : "g-horizontal--1"
        : gap && `g-${gap}`,
      top && `top-${top}`,
      right && `right-${right}`,
      bottom && `bottom-${bottom}`,
      left && `left-${left}`,
      generateDynamicClass("background", background),
      generateDynamicClass("solid", solid),
      generateDynamicClass(
        "border",
        border || borderTop || borderRight || borderBottom || borderLeft,
      ),
      (border || borderTop || borderRight || borderBottom || borderLeft) &&
        !borderStyle &&
        "border-solid",
      border && !borderWidth && "border-1",
      (borderTop || borderRight || borderBottom || borderLeft) && "border-reset",
      borderTop && "border-top-1",
      borderRight && "border-right-1",
      borderBottom && "border-bottom-1",
      borderLeft && "border-left-1",
      borderWidth && `border-${borderWidth}`,
      borderStyle && `border-${borderStyle}`,
      radius === "full" ? "radius-full" : radius && `radius-${radius}`,
      topRadius && `radius-${topRadius}-top`,
      rightRadius && `radius-${rightRadius}-right`,
      bottomRadius && `radius-${bottomRadius}-bottom`,
      leftRadius && `radius-${leftRadius}-left`,
      topLeftRadius && `radius-${topLeftRadius}-top-left`,
      topRightRadius && `radius-${topRightRadius}-top-right`,
      bottomLeftRadius && `radius-${bottomLeftRadius}-bottom-left`,
      bottomRightRadius && `radius-${bottomRightRadius}-bottom-right`,
      direction && `flex-${direction}`,
      tabletDirection && `m-flex-${tabletDirection}`,
      mobileDirection && `s-flex-${mobileDirection}`,
      pointerEvents && `pointer-events-${pointerEvents}`,
      transition && `transition-${transition}`,
      hide && `${hide}-flex-hide`,
      show && `${show}-flex-show`,
      opacity && `opacity-${opacity}`,
      wrap && "flex-wrap",
      overflow && `overflow-${overflow}`,
      overflowX && `overflow-x-${overflowX}`,
      overflowY && `overflow-y-${overflowY}`,
      flex && `flex-${flex}`,
      horizontal &&
        (direction === "row" || direction === "row-reverse" || direction === undefined
          ? `justify-${horizontal}`
          : `align-${horizontal}`),
      vertical &&
        (direction === "row" || direction === "row-reverse" || direction === undefined
          ? `align-${vertical}`
          : `justify-${vertical}`),
      center && "center",
      fit && "fit",
      fitWidth && "fit-width",
      fitHeight && "fit-height",
      fill && "fill",
      fillWidth && !minWidth && "min-width-0",
      fillHeight && !minHeight && "min-height-0",
      fill && "min-height-0",
      fill && "min-width-0",
      (fillWidth || maxWidth) && "fill-width",
      (fillHeight || maxHeight) && "fill-height",
      shadow && `shadow-${shadow}`,
      position && `position-${position}`,
      zIndex && `z-index-${zIndex}`,
      textType && `font-${textType}`,
      cursor && `cursor-${cursor}`,
      dark && "dark-flex",
      light && "light-flex",
      colorClass,
      className,
      ...variantClasses,
    );
    const parseDimension = (
      value: number | SpacingToken | undefined,
      type: "width" | "height",
    ): string | undefined => {
      if (value === undefined) return undefined;
      if (typeof value === "number") return `${value}rem`;
      if (
        [
          "0",
          "1",
          "2",
          "4",
          "8",
          "12",
          "16",
          "20",
          "24",
          "32",
          "40",
          "48",
          "56",
          "64",
          "80",
          "104",
          "128",
          "160",
        ].includes(value)
      ) {
        return `var(--static-space-${value})`;
      }
      if (["xs", "s", "m", "l", "xl"].includes(value)) {
        return `var(--responsive-${type}-${value})`;
      }
      return undefined;
    };
    const combinedStyle: CSSProperties = {
      maxWidth: parseDimension(maxWidth, "width"),
      minWidth: parseDimension(minWidth, "width"),
      minHeight: parseDimension(minHeight, "height"),
      maxHeight: parseDimension(maxHeight, "height"),
      width: parseDimension(width, "width"),
      height: parseDimension(height, "height"),
      aspectRatio: aspectRatio,
      textAlign: align,
      ...style,
    };
    return (
      <Component ref={ref} className={classes} style={combinedStyle} {...rest}>
        {children}
      </Component>
    );
  },
);
Flex.displayName = "Flex";
export { Flex };
</file>

<file path="src/once-ui/components/GlitchFx.module.scss">
.glitchLayer {
    pointer-events: none;
}
.blueShift {
    filter: hue-rotate(260deg);
    animation: glitch-blue 2.5s infinite;
    z-index: 1;
}
.redShift {
    filter: hue-rotate(120deg);
    animation: glitch-red 2.5s infinite;
    z-index: 1;
}
@keyframes glitch-blue {
    6%, 14%, 70%, 78% {
        transform: none;
        opacity: 0.25;
        clip-path: inset(0 0 0 0);
    }
    10%, 12% {
        transform: translate(-5px, -3px) skew(1deg, -2deg);
        opacity: 0.5;
        clip-path: inset(50% 0 25% 0);
    }
    11%, 13% {
        transform: translate(4px, -7px) skew(-1deg) scaleX(1.5) scaleY(1.25);
        opacity: 0.7;
        clip-path: inset(0 35% 40% 0);
    }
    14%, 82% {
        transform: translate(-5px, -3px) skew(1deg, -1deg);
        opacity: 0.3;
        clip-path: inset(30% 5% 25% 40%);
    }
    75%, 83% {
        transform: translate(-9px, 2px) skew(-1deg, 0);
        opacity: 0.2;
        clip-path: inset(0 35% 45% 10%);
    }
}
@keyframes glitch-red {
    6%, 14%, 70%, 78% {
        transform: none;
        opacity: 0;
        clip-path: inset(0 0 0 0);
    }
    10%, 12% {
        transform: translate(6px, 4px) skew(1deg);
        opacity: 0.5;
        clip-path: inset(5% 0 10% 0);
    }
    11%, 13% {
        transform: translate(-4px, 5px) skew(0, -1deg);
        opacity: 0.7;
        clip-path: inset(5% 0 10% 0);
    }
    14%, 82% {
        transform: translate(-7px, -4px) skew(1deg, -1deg);
        opacity: 0.2;
        clip-path: inset(50% 25% 25% 0);
    }
    75%, 80% {
        transform: translate(4px, -6px) skew(-1deg) scaleX(2) scaleY(1.25);
        opacity: 0.3;
        clip-path: inset(0 0 20% 50%);
    }
}
.slow {
    animation-duration: 3.5s;
}
.medium {
    animation-duration: 2.5s;
}
.fast {
    animation-duration: 1.5s;
}
.active .blueShift, .active .redShift {
    animation-play-state: running;
}
.glitchFx:not(.active) .blueShift,
.glitchFx:not(.active) .redShift {
    animation-play-state: paused;
}
</file>

<file path="src/once-ui/components/GlitchFx.tsx">
"use client";
import React, { useEffect, useState, forwardRef, useCallback } from "react";
import styles from "./GlitchFx.module.scss";
import { Flex } from ".";
import classNames from "classnames";
interface GlitchFxProps extends React.ComponentProps<typeof Flex> {
  children: React.ReactNode;
  speed?: "slow" | "medium" | "fast";
  interval?: number;
  trigger?: "instant" | "hover" | "custom";
  continuous?: boolean;
}
const GlitchFx = forwardRef<HTMLDivElement, GlitchFxProps>(
  (
    {
      children,
      speed = "medium",
      interval = 2500,
      trigger = "instant",
      continuous = true,
      ...rest
    },
    ref,
  ) => {
    const [isGlitching, setIsGlitching] = useState(continuous || trigger === "instant");
    useEffect(() => {
      if (continuous || trigger === "instant") {
        setIsGlitching(true);
      }
    }, [continuous, trigger]);
    const handleMouseEnter = () => {
      if (trigger === "hover") {
        setIsGlitching(true);
      }
    };
    const handleMouseLeave = () => {
      if (trigger === "hover") {
        setIsGlitching(false);
      }
    };
    const triggerGlitch = useCallback(() => {
      if (trigger === "custom") {
        setIsGlitching(true);
        setTimeout(() => setIsGlitching(false), 500);
      }
    }, [trigger]);
    useEffect(() => {
      if (trigger === "custom") {
        const glitchInterval = setInterval(triggerGlitch, interval);
        return () => clearInterval(glitchInterval);
      }
    }, [trigger, interval, triggerGlitch]);
    const speedClass = styles[speed];
    return (
      <Flex
        ref={ref}
        inline
        zIndex={0}
        className={classNames(speedClass, isGlitching && styles.active)}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        {...rest}
      >
        <Flex fillWidth inline zIndex={1}>
          {children}
        </Flex>
        <Flex
          inline
          position="absolute"
          top="0"
          left="0"
          fill
          zIndex={0}
          opacity={50}
          className={classNames(styles.glitchLayer, styles.blueShift)}
        >
          {children}
        </Flex>
        <Flex
          inline
          position="absolute"
          top="0"
          left="0"
          fill
          zIndex={0}
          opacity={50}
          className={classNames(styles.glitchLayer, styles.redShift)}
        >
          {children}
        </Flex>
      </Flex>
    );
  },
);
GlitchFx.displayName = "GlitchFx";
export { GlitchFx };
</file>

<file path="src/once-ui/components/Grid.tsx">
"use client";
import React, { CSSProperties, forwardRef } from "react";
import classNames from "classnames";
import {
  GridProps,
  SpacingProps,
  SizeProps,
  StyleProps,
  CommonProps,
  DisplayProps,
  ConditionalProps,
} from "../interfaces";
import { SpacingToken, ColorScheme, ColorWeight } from "../types";
interface ComponentProps
  extends GridProps,
    SpacingProps,
    SizeProps,
    StyleProps,
    CommonProps,
    DisplayProps,
    ConditionalProps {}
const Grid = forwardRef<HTMLDivElement, ComponentProps>(
  (
    {
      as: Component = "div",
      inline,
      columns,
      gap,
      position = "relative",
      aspectRatio,
      align,
      textVariant,
      textSize,
      textWeight,
      textType,
      tabletColumns,
      mobileColumns,
      padding,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      paddingX,
      paddingY,
      margin,
      marginLeft,
      marginRight,
      marginTop,
      marginBottom,
      marginX,
      marginY,
      dark,
      light,
      width,
      height,
      maxWidth,
      minWidth,
      minHeight,
      maxHeight,
      top,
      right,
      bottom,
      left,
      fit,
      fill,
      fillWidth = false,
      fillHeight = false,
      fitWidth,
      fitHeight,
      hide,
      show,
      background,
      solid,
      opacity,
      transition,
      pointerEvents,
      border,
      borderTop,
      borderRight,
      borderBottom,
      borderLeft,
      borderStyle,
      borderWidth,
      radius,
      topRadius,
      rightRadius,
      bottomRadius,
      leftRadius,
      topLeftRadius,
      topRightRadius,
      bottomLeftRadius,
      bottomRightRadius,
      overflow,
      overflowX,
      overflowY,
      cursor,
      zIndex,
      shadow,
      className,
      style,
      children,
      ...rest
    },
    ref,
  ) => {
    const generateDynamicClass = (type: string, value: string | "-1" | undefined) => {
      if (!value) return undefined;
      if (value === "transparent") {
        return `transparent-border`;
      }
      if (value === "surface" || value === "page" || value === "transparent") {
        return `${value}-${type}`;
      }
      const parts = value.split("-");
      if (parts.includes("alpha")) {
        const [scheme, , weight] = parts;
        return `${scheme}-${type}-alpha-${weight}`;
      }
      const [scheme, weight] = value.split("-") as [ColorScheme, ColorWeight];
      return `${scheme}-${type}-${weight}`;
    };
    const parseDimension = (
      value: number | SpacingToken | undefined,
      type: "width" | "height",
    ): string | undefined => {
      if (value === undefined) return undefined;
      if (typeof value === "number") return `${value}rem`;
      if (
        [
          "0",
          "1",
          "2",
          "4",
          "8",
          "12",
          "16",
          "20",
          "24",
          "32",
          "40",
          "48",
          "56",
          "64",
          "80",
          "104",
          "128",
          "160",
        ].includes(value)
      ) {
        return `var(--static-space-${value})`;
      }
      if (["xs", "s", "m", "l", "xl"].includes(value)) {
        return `var(--responsive-${type}-${value})`;
      }
      return undefined;
    };
    const classes = classNames(
      inline ? "display-inline-grid" : "display-grid",
      fit && "fit",
      fitWidth && "fit-width",
      fitHeight && "fit-height",
      fill && "fill",
      (fillWidth || maxWidth) && "fill-width",
      (fillHeight || maxHeight) && "fill-height",
      columns && `columns-${columns}`,
      tabletColumns && `tablet-columns-${tabletColumns}`,
      mobileColumns && `mobile-columns-${mobileColumns}`,
      overflow && `overflow-${overflow}`,
      overflowX && `overflow-x-${overflowX}`,
      overflowY && `overflow-y-${overflowY}`,
      padding && `p-${padding}`,
      paddingLeft && `pl-${paddingLeft}`,
      paddingRight && `pr-${paddingRight}`,
      paddingTop && `pt-${paddingTop}`,
      paddingBottom && `pb-${paddingBottom}`,
      paddingX && `px-${paddingX}`,
      paddingY && `py-${paddingY}`,
      margin && `m-${margin}`,
      marginLeft && `ml-${marginLeft}`,
      marginRight && `mr-${marginRight}`,
      marginTop && `mt-${marginTop}`,
      marginBottom && `mb-${marginBottom}`,
      marginX && `mx-${marginX}`,
      marginY && `my-${marginY}`,
      gap && `g-${gap}`,
      top && `top-${top}`,
      right && `right-${right}`,
      bottom && `bottom-${bottom}`,
      left && `left-${left}`,
      generateDynamicClass("background", background),
      generateDynamicClass("solid", solid),
      generateDynamicClass(
        "border",
        border || borderTop || borderRight || borderBottom || borderLeft,
      ),
      (border || borderTop || borderRight || borderBottom || borderLeft) &&
        !borderStyle &&
        "border-solid",
      border && !borderWidth && `border-1`,
      (borderTop || borderRight || borderBottom || borderLeft) && "border-reset",
      borderTop && "border-top-1",
      borderRight && "border-right-1",
      borderBottom && "border-bottom-1",
      borderLeft && "border-left-1",
      borderWidth && `border-${borderWidth}`,
      borderStyle && `border-${borderStyle}`,
      radius === "full" ? "radius-full" : radius && `radius-${radius}`,
      topRadius && `radius-${topRadius}-top`,
      rightRadius && `radius-${rightRadius}-right`,
      bottomRadius && `radius-${bottomRadius}-bottom`,
      leftRadius && `radius-${leftRadius}-left`,
      topLeftRadius && `radius-${topLeftRadius}-top-left`,
      topRightRadius && `radius-${topRightRadius}-top-right`,
      bottomLeftRadius && `radius-${bottomLeftRadius}-bottom-left`,
      bottomRightRadius && `radius-${bottomRightRadius}-bottom-right`,
      hide === "s" && `${hide}-grid-hide`,
      show === "s" && `${show}-grid-show`,
      pointerEvents && `pointer-events-${pointerEvents}`,
      transition && `transition-${transition}`,
      shadow && `shadow-${shadow}`,
      position && `position-${position}`,
      zIndex && `z-index-${zIndex}`,
      textType && `font-${textType}`,
      cursor && `cursor-${cursor}`,
      dark && "dark-grid",
      light && "light-grid",
      className,
    );
    const combinedStyle: CSSProperties = {
      maxWidth: parseDimension(maxWidth, "width"),
      minWidth: parseDimension(minWidth, "width"),
      minHeight: parseDimension(minHeight, "height"),
      maxHeight: parseDimension(maxHeight, "height"),
      width: parseDimension(width, "width"),
      height: parseDimension(height, "height"),
      aspectRatio: aspectRatio,
      textAlign: align,
      ...style,
    };
    return (
      <Component ref={ref} className={classes} style={combinedStyle} {...rest}>
        {children}
      </Component>
    );
  },
);
Grid.displayName = "Grid";
export { Grid };
export type { GridProps };
</file>

<file path="src/once-ui/components/HoloFx.module.scss">
.overlay {
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
    pointer-events: none;
}
.holoFx {
    isolation: isolate;
    z-index: 0;
    &:hover {
        .burn {
            transform: translateX(1px) translateY(1px);
            opacity: var(--burn-opacity);
            z-index: 1;
        }
        .shine {
            transform: translateX(-1px) translateY(-1px);
            opacity: var(--light-opacity);
            z-index: 2;
        }
        .texture {
            opacity: var(--texture-opacity);
            transform: translateX(calc(var(--gradient-pos-x) / 50)) scale(1.1);
            background-size: 150% 150%;
            background-position: center;
            z-index: 3;
        }
    }
}
</file>

<file path="src/once-ui/components/HoloFx.tsx">
"use client";
import React, { useEffect, useRef } from "react";
import styles from "./HoloFx.module.scss";
import { Flex } from ".";
import { CSSProperties } from "react";
import classNames from "classnames";
interface MaskOptions {
  maskPosition?: string;
}
interface HoloFxProps extends React.ComponentProps<typeof Flex> {
  children: React.ReactNode;
  shine?: {
    opacity?: number;
    filter?: string;
    blending?: CSSProperties["mixBlendMode"];
    mask?: MaskOptions;
  };
  burn?: {
    opacity?: number;
    filter?: string;
    blending?: CSSProperties["mixBlendMode"];
    mask?: MaskOptions;
  };
  texture?: {
    opacity?: number;
    filter?: string;
    blending?: CSSProperties["mixBlendMode"];
    image?: string;
    mask?: MaskOptions;
  };
}
const formatMask = (maskPosition: string = "100 200"): string => {
  const [x, y] = maskPosition.split(" ");
  const formattedX = `${x}%`;
  const formattedY = `${y ? y : x}%`;
  return `radial-gradient(ellipse ${formattedX} ${formattedY} at var(--gradient-pos-x, 50%) var(--gradient-pos-y, 50%), black 50%, transparent 100%)`;
};
const getMaskStyle = (mask?: MaskOptions): string => {
  return mask?.maskPosition ? formatMask(mask.maskPosition) : formatMask();
};
const HoloFx: React.FC<HoloFxProps> = ({ children, shine, burn, texture, ...rest }) => {
  const ref = useRef<HTMLDivElement>(null);
  const lastCallRef = useRef<number>(0);
  const shineDefaults = {
    opacity: 30,
    blending: "color-dodge" as CSSProperties["mixBlendMode"],
    mask: getMaskStyle(shine?.mask),
    ...shine,
  };
  const burnDefaults = {
    opacity: 30,
    filter: "brightness(0.2) contrast(2)",
    blending: "color-dodge" as CSSProperties["mixBlendMode"],
    mask: getMaskStyle(burn?.mask),
    ...burn,
  };
  const textureDefaults = {
    opacity: 10,
    blending: "color-dodge" as CSSProperties["mixBlendMode"],
    image:
      "repeating-linear-gradient(-45deg, var(--static-white) 0, var(--static-white) 1px, transparent 3px, transparent 2px)",
    mask: getMaskStyle(texture?.mask),
    ...texture,
  };
  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      const now = Date.now();
      if (now - lastCallRef.current < 16) return;
      lastCallRef.current = now;
      const element = ref.current;
      if (!element) return;
      const rect = element.getBoundingClientRect();
      const offsetX = event.clientX - rect.left;
      const offsetY = event.clientY - rect.top;
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;
      const deltaX = ((offsetX - centerX) / centerX) * 100;
      const deltaY = ((offsetY - centerY) / centerY) * 100;
      element.style.setProperty("--gradient-pos-x", `${deltaX}%`);
      element.style.setProperty("--gradient-pos-y", `${deltaY}%`);
    };
    document.addEventListener("mousemove", handleMouseMove);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
    };
  }, []);
  return (
    <Flex overflow="hidden" className={styles.holoFx} ref={ref} {...rest}>
      <Flex fill className={styles.base}>
        {children}
      </Flex>
      <Flex
        hide="m"
        position="absolute"
        fill
        pointerEvents="none"
        className={classNames(styles.overlay, styles.burn)}
        style={{
          ["--burn-opacity" as any]: burnDefaults.opacity + "%",
          filter: burnDefaults.filter,
          mixBlendMode: burnDefaults.blending,
          maskImage: burnDefaults.mask as string,
        }}
      >
        {children}
      </Flex>
      <Flex
        hide="m"
        position="absolute"
        fill
        pointerEvents="none"
        className={classNames(styles.overlay, styles.shine)}
        style={{
          ["--shine-opacity" as any]: shineDefaults.opacity + "%",
          filter: shineDefaults.filter,
          mixBlendMode: shineDefaults.blending,
          maskImage: shineDefaults.mask as string,
        }}
      >
        {children}
      </Flex>
      <Flex
        hide="m"
        position="absolute"
        fill
        pointerEvents="none"
        className={classNames(styles.overlay, styles.texture)}
        style={{
          ["--texture-opacity" as any]: textureDefaults.opacity + "%",
          backgroundImage: textureDefaults.image,
          filter: textureDefaults.filter,
          mixBlendMode: textureDefaults.blending,
          maskImage: textureDefaults.mask as string,
        }}
      ></Flex>
    </Flex>
  );
};
HoloFx.displayName = "HoloFx";
export { HoloFx };
</file>

<file path="src/once-ui/components/Icon.module.scss">
.xs { 
    font-size: var(--static-space-16)
}
.s { 
    font-size: var(--static-space-20)
}
.m { 
    font-size: var(--static-space-24)
}
.l { 
    font-size: var(--static-space-32)
}
.xl { 
    font-size: var(--static-space-40)
}
</file>

<file path="src/once-ui/components/Icon.tsx">
"use client";
import React, { forwardRef, useState, useEffect, ReactNode } from "react";
import classNames from "classnames";
import { IconType } from "react-icons";
import { iconLibrary, IconName } from "../icons";
import { ColorScheme, ColorWeight } from "../types";
import { Flex, Tooltip } from ".";
import styles from "./Icon.module.scss";
import iconStyles from "./IconButton.module.scss";
interface IconProps extends React.ComponentProps<typeof Flex> {
  name: IconName;
  onBackground?: `${ColorScheme}-${ColorWeight}`;
  onSolid?: `${ColorScheme}-${ColorWeight}`;
  size?: "xs" | "s" | "m" | "l" | "xl";
  decorative?: boolean;
  tooltip?: ReactNode;
  tooltipPosition?: "top" | "bottom" | "left" | "right";
  className?: string;
  style?: React.CSSProperties;
}
const Icon = forwardRef<HTMLDivElement, IconProps>(
  (
    {
      name,
      onBackground,
      onSolid,
      size = "m",
      decorative = true,
      tooltip,
      tooltipPosition = "top",
      className,
      style,
      ...rest
    },
    ref,
  ) => {
    const [isTooltipVisible, setTooltipVisible] = useState(false);
    const [isHover, setIsHover] = useState(false);
    useEffect(() => {
      let timer: NodeJS.Timeout;
      if (isHover) {
        timer = setTimeout(() => {
          setTooltipVisible(true);
        }, 400);
      } else {
        setTooltipVisible(false);
      }
      return () => clearTimeout(timer);
    }, [isHover]);
    const IconComponent: IconType | undefined = iconLibrary[name];
    if (!IconComponent) {
      console.warn(`Icon "${name}" does not exist in the library.`);
      return null;
    }
    if (onBackground && onSolid) {
      console.warn(
        "You cannot use both 'onBackground' and 'onSolid' props simultaneously. Only one will be applied.",
      );
    }
    let colorClass = "color-inherit";
    if (onBackground) {
      const [scheme, weight] = onBackground.split("-") as [ColorScheme, ColorWeight];
      colorClass = `${scheme}-on-background-${weight}`;
    } else if (onSolid) {
      const [scheme, weight] = onSolid.split("-") as [ColorScheme, ColorWeight];
      colorClass = `${scheme}-on-solid-${weight}`;
    }
    return (
      <Flex
        inline
        fit
        as="span"
        ref={ref}
        className={classNames(colorClass, styles.icon, styles[size], className)}
        aria-hidden={decorative ? "true" : undefined}
        aria-label={decorative ? undefined : name}
        onMouseEnter={() => setIsHover(true)}
        onMouseLeave={() => setIsHover(false)}
        style={style}
        {...rest}
      >
        <IconComponent />
        {tooltip && isTooltipVisible && (
          <Flex position="absolute" zIndex={1} className={iconStyles[tooltipPosition]}>
            <Tooltip label={tooltip} />
          </Flex>
        )}
      </Flex>
    );
  },
);
Icon.displayName = "Icon";
export { Icon };
</file>

<file path="src/once-ui/components/IconButton.module.scss">
.top {
	bottom: calc(100% + var(--static-space-2));
	left: 50%;
	transform: translateX(-50%);
}
.bottom {
	top: calc(100% + var(--static-space-2));
	left: 50%;
	transform: translateX(-50%);
}
.left {
	right: calc(100% + var(--static-space-2));
	top: 50%;
	transform: translateY(-50%);
}
.right {
	left: calc(100% + var(--static-space-2));
	top: 50%;
	transform: translateY(-50%);
}
.s {
	min-height: var(--static-space-24);
	min-width: var(--static-space-24);
	height: var(--static-space-24);
	width: var(--static-space-24);
}
.m {
	min-height: var(--static-space-32);
	min-width: var(--static-space-32);
	height: var(--static-space-32);
	width: var(--static-space-32);
}
.l {
	min-height: var(--static-space-40);
	min-width: var(--static-space-40);
	height: var(--static-space-40);
	width: var(--static-space-40);
}
</file>

<file path="src/once-ui/components/IconButton.tsx">
"use client";
import React, { forwardRef, useState, useEffect, ReactNode } from "react";
import { ElementType } from "./ElementType";
import { Flex, Icon, Tooltip } from ".";
import buttonStyles from "./Button.module.scss";
import iconStyles from "./IconButton.module.scss";
import classNames from "classnames";
import { IconName } from "../icons";
interface CommonProps {
  icon?: IconName;
  id?: string;
  size?: "s" | "m" | "l";
  radius?:
    | "none"
    | "top"
    | "right"
    | "bottom"
    | "left"
    | "top-left"
    | "top-right"
    | "bottom-right"
    | "bottom-left";
  tooltip?: string;
  tooltipPosition?: "top" | "bottom" | "left" | "right";
  variant?: "primary" | "secondary" | "tertiary" | "danger" | "ghost";
  className?: string;
  style?: React.CSSProperties;
  href?: string;
  children?: ReactNode;
}
export type IconButtonProps = CommonProps & React.ButtonHTMLAttributes<HTMLButtonElement>;
type AnchorProps = CommonProps & React.AnchorHTMLAttributes<HTMLAnchorElement>;
const IconButton = forwardRef<HTMLButtonElement, IconButtonProps | AnchorProps>(
  (
    {
      icon = "refresh",
      size = "m",
      id,
      radius,
      tooltip,
      tooltipPosition = "top",
      variant = "primary",
      href,
      children,
      className,
      style,
      ...props
    },
    ref,
  ) => {
    const [isTooltipVisible, setTooltipVisible] = useState(false);
    const [isHover, setIsHover] = useState(false);
    useEffect(() => {
      let timer: NodeJS.Timeout;
      if (isHover) {
        timer = setTimeout(() => {
          setTooltipVisible(true);
        }, 400);
      } else {
        setTooltipVisible(false);
      }
      return () => clearTimeout(timer);
    }, [isHover]);
    const content = (
      <>
        {children ? children : <Icon name={icon} size="s" />}
        {tooltip && isTooltipVisible && (
          <Flex position="absolute" zIndex={1} className={iconStyles[tooltipPosition]}>
            <Tooltip label={tooltip} />
          </Flex>
        )}
      </>
    );
    const radiusSize = size === "s" || size === "m" ? "m" : "l";
    return (
      <ElementType
        id={id}
        href={href}
        ref={ref}
        className={classNames(
          buttonStyles.button,
          buttonStyles[variant],
          iconStyles[size],
          className,
          radius === "none"
            ? "radius-none"
            : radius
              ? `radius-${radiusSize}-${radius}`
              : `radius-${radiusSize}`,
          "text-decoration-none",
          "button",
          "cursor-interactive",
          className,
        )}
        style={style}
        onMouseEnter={() => setIsHover(true)}
        onMouseLeave={() => setIsHover(false)}
        aria-label={tooltip || icon}
        {...props}
      >
        <Flex fill center>
          {content}
        </Flex>
      </ElementType>
    );
  },
);
IconButton.displayName = "IconButton";
export { IconButton };
</file>

<file path="src/once-ui/components/InlineCode.module.scss">
.inlineCode {
    font-size: 80%;
    line-height: 125%;
    vertical-align: middle;
}
</file>

<file path="src/once-ui/components/InlineCode.tsx">
"use client";
import React, { forwardRef, ReactNode } from "react";
import styles from "./InlineCode.module.scss";
import { Flex } from ".";
import classNames from "classnames";
interface InlineCodeProps extends React.ComponentProps<typeof Flex> {
  children: ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
const InlineCode = forwardRef<HTMLDivElement, InlineCodeProps>(
  ({ children, className, style, ...rest }, ref) => {
    return (
      <Flex
        as="span"
        inline
        fit
        ref={ref}
        radius="s"
        vertical="center"
        paddingX="4"
        paddingY="1"
        textType="code"
        background="neutral-alpha-weak"
        border="neutral-alpha-medium"
        className={classNames(styles.inlineCode, className)}
        style={style}
        {...rest}
      >
        {children}
      </Flex>
    );
  },
);
InlineCode.displayName = "InlineCode";
export { InlineCode };
</file>

<file path="src/once-ui/components/Input.module.scss">
.base {
    backdrop-filter: var(--backdrop-filter);
    min-height: var(--static-space-56);
    &.focused, &.filled {
        border-color: var(--neutral-border-medium);
    }
    &:has(.placeholder) {
        min-height: var(--static-space-48);
    }
}
.textareaBase {
    &::after {
        pointer-events: none;
        content: '';
        position: absolute;
        right: 0;
        bottom: 0;
        width: var(--static-space-32);
        height: var(--static-space-32);
        border: 1px solid var(--neutral-border-strong);
        transform: translateX(50%) translateY(50%) rotate(45deg);
        background-color: var(--neutral-alpha-weak);
    }
    ::-webkit-resizer {
        display: none;
    }
}
.label {
    position: absolute;
    left: var(--static-space-16);
    transition: transform 0.3s, top 0.3s, left 0.3s;
    color: var(--neutral-on-background-medium);
    pointer-events: none;
    transform-origin: left;
}
.inputLabel {
    top: 50%;
    transform: translateY(-50%);
    &.floating {
        transform: scale(0.75);
    }
}
.textareaLabel {
    top: var(--static-space-16);
    &.floating {
        transform: scale(0.75) translateY(calc(-1 * var(--static-space-16)));
    }
}
.s {
    min-height: var(--static-space-48);
    &:has(.placeholder) {
        min-height: var(--static-space-40);
    }
    .label {
        &.floating {
            top: var(--static-space-4);
        }
    }
}
.m {
    .label {
        &.floating {
            top: calc(var(--static-space-8) - var(--static-space-2));
        }
    }
}
.input {
    width: 100%;
    height: 100%;
    border: none;
    background: none;
    color: var(--neutral-on-background-strong);
    padding: 0 var(--static-space-16);
    outline: none;
    &.placeholder {
        padding-top: 0;
    }
    &.textarea.placeholder {
        padding-top: var(--static-space-12);
        padding-bottom: var(--static-space-12);
    }
    &:not(.placeholder) {
        padding-top: var(--static-space-16);
    }
    &.placeholder.hasChildren {
        padding-top: var(--static-space-16);
    }
    &::placeholder {
        color: var(--neutral-on-background-weak);
    }
    &:disabled {
        background-color: var(--neutral-solid-strong);
        color: var(--neutral-on-solid-weak);
    }
    &:autofill, &:-webkit-autofill {
        background-color: var(--static-transparent) !important;
        -webkit-box-shadow: 0 0 0 var(--static-space-32) var(--neutral-background-medium) inset !important;
        -webkit-text-fill-color: var(--neutral-on-background-strong) !important;
    }
}
.error {
    .base {
        background-color: var(--danger-background-medium);
        border-color: var(--danger-border-medium);
    }
    .input, .prefix, .suffix {
        color: var(--danger-on-background-medium);
    }
    .label {
        color: var(--danger-on-background-weak);
    }
}
.prefix, .suffix {
    align-self: center;
}
.input[type="color"] {
    opacity: 0;
}
</file>

<file path="src/once-ui/components/Input.tsx">
"use client";
import React, {
  useState,
  useEffect,
  forwardRef,
  InputHTMLAttributes,
  useCallback,
  ReactNode,
} from "react";
import classNames from "classnames";
import { Column, Flex, Text } from ".";
import styles from "./Input.module.scss";
import useDebounce from "../hooks/useDebounce";
interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  id: string;
  label?: string;
  placeholder?: string;
  height?: "s" | "m";
  error?: boolean;
  errorMessage?: ReactNode;
  description?: ReactNode;
  radius?:
    | "none"
    | "top"
    | "right"
    | "bottom"
    | "left"
    | "top-left"
    | "top-right"
    | "bottom-right"
    | "bottom-left";
  className?: string;
  style?: React.CSSProperties;
  hasPrefix?: ReactNode;
  hasSuffix?: ReactNode;
  cursor?: undefined | "interactive";
  validate?: (value: ReactNode) => ReactNode | null;
}
const Input = forwardRef<HTMLInputElement, InputProps>(
  (
    {
      id,
      label,
      placeholder,
      height = "m",
      error = false,
      errorMessage,
      description,
      radius,
      className,
      style,
      hasPrefix,
      hasSuffix,
      children,
      onFocus,
      onBlur,
      validate,
      cursor,
      ...props
    },
    ref,
  ) => {
    const [isFocused, setIsFocused] = useState(false);
    const [isFilled, setIsFilled] = useState(!!props.value);
    const [validationError, setValidationError] = useState<ReactNode | null>(null);
    const debouncedValue = useDebounce(props.value, 1000);
    const handleFocus = (event: React.FocusEvent<HTMLInputElement>) => {
      setIsFocused(true);
      if (onFocus) onFocus(event);
    };
    const handleBlur = (event: React.FocusEvent<HTMLInputElement>) => {
      setIsFocused(false);
      if (event.target.value) {
        setIsFilled(true);
      } else {
        setIsFilled(false);
      }
      if (onBlur) onBlur(event);
    };
    useEffect(() => {
      setIsFilled(!!props.value);
    }, [props.value]);
    const validateInput = useCallback(() => {
      if (!debouncedValue) {
        setValidationError(null);
        return;
      }
      if (validate) {
        const error = validate(debouncedValue);
        if (error) {
          setValidationError(error);
        } else {
          setValidationError(errorMessage || null);
        }
      } else {
        setValidationError(null);
      }
    }, [debouncedValue, validate, errorMessage]);
    useEffect(() => {
      validateInput();
    }, [debouncedValue, validateInput]);
    const displayError = validationError || errorMessage;
    const inputClassNames = classNames(
      styles.input,
      "font-body",
      "font-default",
      "font-m",
      cursor === "interactive" ? "cursor-interactive" : undefined,
      {
        [styles.filled]: isFilled,
        [styles.focused]: isFocused,
        [styles.withPrefix]: hasPrefix,
        [styles.withSuffix]: hasSuffix,
        [styles.placeholder]: placeholder,
        [styles.hasChildren]: children,
        [styles.error]: displayError && debouncedValue !== "",
      },
    );
    return (
      <Column
        gap="8"
        style={style}
        fillWidth
        fitHeight
        className={classNames(className, {
          [styles.error]: (error || (displayError && debouncedValue !== "")) && props.value !== "",
        })}
      >
        <Flex
          transition="micro-medium"
          border="neutral-medium"
          background="neutral-alpha-weak"
          overflow="hidden"
          vertical="stretch"
          className={classNames(
            styles.base,
            {
              [styles.s]: height === "s",
            },
            {
              [styles.m]: height === "m",
            },
            radius === "none" ? "radius-none" : radius ? `radius-l-${radius}` : "radius-l",
          )}
        >
          {hasPrefix && (
            <Flex paddingLeft="12" className={styles.prefix} position="static">
              {hasPrefix}
            </Flex>
          )}
          <Column fillWidth>
            <input
              {...props}
              ref={ref}
              id={id}
              placeholder={placeholder}
              onFocus={handleFocus}
              onBlur={handleBlur}
              className={inputClassNames}
              aria-describedby={displayError ? `${id}-error` : undefined}
              aria-invalid={!!displayError}
            />
            {label && (
              <Text
                as="label"
                variant="label-default-m"
                htmlFor={id}
                className={classNames(styles.label, styles.inputLabel, {
                  [styles.floating]: isFocused || isFilled || placeholder,
                })}
              >
                {label}
              </Text>
            )}
            {children}
          </Column>
          {hasSuffix && (
            <Flex paddingRight="12" className={styles.suffix} position="static">
              {hasSuffix}
            </Flex>
          )}
        </Flex>
        {displayError && errorMessage !== false && (
          <Flex paddingX="16">
            <Text as="span" id={`${id}-error`} variant="body-default-s" onBackground="danger-weak">
              {validationError || errorMessage}
            </Text>
          </Flex>
        )}
        {description && (
          <Flex
            paddingX="16"
            fillWidth
            id={`${id}-description`}
            textVariant="body-default-s"
            onBackground="neutral-weak"
          >
            {description}
          </Flex>
        )}
      </Column>
    );
  },
);
Input.displayName = "Input";
export { Input };
export type { InputProps };
</file>

<file path="src/once-ui/components/InteractiveDetails.tsx">
"use client";
import React, { forwardRef } from "react";
import { Text, Column, IconButton, IconButtonProps, Row } from ".";
interface InteractiveDetailsProps {
  label?: React.ReactNode;
  description?: React.ReactNode;
  disabled?: boolean;
  iconButtonProps?: IconButtonProps;
  onClick: () => void;
  className?: string;
  id?: string;
}
const InteractiveDetails: React.FC<InteractiveDetailsProps> = forwardRef<
  HTMLDivElement,
  InteractiveDetailsProps
>(({ label, description, iconButtonProps, onClick, className, id, disabled }, ref) => {
  return (
    <Column
      ref={ref}
      cursor={disabled ? "not-allowed" : undefined}
      className={className}
      onClick={onClick}
      id={id}
    >
      <Row gap="4" vertical="center">
        <Text
          as="span"
          variant="label-default-m"
          onBackground={disabled ? "neutral-weak" : "neutral-strong"}
        >
          {label}
        </Text>
        {iconButtonProps?.tooltip && (
          <div onClick={(e) => e.stopPropagation()}>
            <IconButton size="s" variant="ghost" icon="help" {...iconButtonProps} />
          </div>
        )}
      </Row>
      {description && (
        <Text as="span" variant="body-default-s" onBackground="neutral-weak">
          {description}
        </Text>
      )}
    </Column>
  );
});
InteractiveDetails.displayName = "InteractiveDetails";
export { InteractiveDetails };
export type { InteractiveDetailsProps };
</file>

<file path="src/once-ui/components/Kbd.tsx">
"use client";
import React, { ReactNode, forwardRef } from "react";
import { Flex, Text } from ".";
interface KbdProps extends React.ComponentProps<typeof Flex> {
  label?: string;
  children?: ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
const Kbd = forwardRef<HTMLDivElement, KbdProps>(
  ({ label, children, className, style, ...rest }, ref) => (
    <Flex
      as="kbd"
      ref={ref}
      horizontal="center"
      minWidth="32"
      background="neutral-strong"
      radius="s"
      paddingX="4"
      paddingY="2"
      onBackground="neutral-medium"
      border="neutral-strong"
      className={className}
      style={style}
      {...rest}
    >
      <Text as="span" variant="label-default-s">
        {label || children}
      </Text>
    </Flex>
  ),
);
Kbd.displayName = "Kbd";
export { Kbd };
export type { KbdProps };
</file>

<file path="src/once-ui/components/LetterFx.tsx">
"use client";
import React, { useState, useRef, useCallback, useEffect, forwardRef, ReactNode } from "react";
import classNames from "classnames";
const defaultCharset = ["X", "$", "@", "a", "H", "z", "o", "0", "y", "#", "?", "*", "0", "1", "+"];
function getRandomCharacter(charset: string[]): string {
  const randomIndex = Math.floor(Math.random() * charset.length);
  return charset[randomIndex];
}
function createEventHandler(
  originalText: string,
  setText: React.Dispatch<React.SetStateAction<string>>,
  inProgress: boolean,
  setInProgress: React.Dispatch<React.SetStateAction<boolean>>,
  speed: "fast" | "medium" | "slow",
  charset: string[],
  setHasAnimated?: React.Dispatch<React.SetStateAction<boolean>>,
) {
  const speedSettings = {
    fast: {
      BASE_DELAY: 10,
      REVEAL_DELAY: 10,
      INITIAL_RANDOM_DURATION: 100,
    },
    medium: {
      BASE_DELAY: 30,
      REVEAL_DELAY: 30,
      INITIAL_RANDOM_DURATION: 300,
    },
    slow: {
      BASE_DELAY: 60,
      REVEAL_DELAY: 60,
      INITIAL_RANDOM_DURATION: 600,
    },
  };
  const { BASE_DELAY, REVEAL_DELAY, INITIAL_RANDOM_DURATION } = speedSettings[speed];
  const generateRandomText = () =>
    originalText
      .split("")
      .map((char) => (char === " " ? " " : getRandomCharacter(charset)))
      .join("");
  return async () => {
    if (inProgress) return;
    setInProgress(true);
    let randomizedText = generateRandomText();
    const endTime = Date.now() + INITIAL_RANDOM_DURATION;
    while (Date.now() < endTime) {
      setText(randomizedText);
      await new Promise((resolve) => setTimeout(resolve, BASE_DELAY));
      randomizedText = generateRandomText();
    }
    for (let i = 0; i < originalText.length; i++) {
      await new Promise((resolve) => setTimeout(resolve, REVEAL_DELAY));
      setText(`${originalText.substring(0, i + 1)}${randomizedText.substring(i + 1)}`);
    }
    setInProgress(false);
    if (setHasAnimated) {
      setHasAnimated(true);
    }
  };
}
type LetterFxProps = {
  children: ReactNode;
  trigger?: "hover" | "instant" | "custom";
  speed?: "fast" | "medium" | "slow";
  charset?: string[];
  onTrigger?: (triggerFn: () => void) => void;
  className?: string;
  style?: React.CSSProperties;
};
const LetterFx = forwardRef<HTMLSpanElement, LetterFxProps>(
  (
    {
      children,
      trigger = "hover",
      speed = "medium",
      charset = defaultCharset,
      onTrigger,
      className,
      style,
    },
    ref,
  ) => {
    const [text, setText] = useState<string>(typeof children === "string" ? children : "");
    const [inProgress, setInProgress] = useState<boolean>(false);
    const [hasAnimated, setHasAnimated] = useState<boolean>(false);
    const originalText = useRef<string>(typeof children === "string" ? children : "");
    const eventHandler = useCallback(() => {
      createEventHandler(
        originalText.current,
        setText,
        inProgress,
        setInProgress,
        speed,
        charset,
        trigger === "instant" ? setHasAnimated : undefined,
      )();
    }, [inProgress, speed, charset, trigger, setHasAnimated]);
    useEffect(() => {
      if (typeof children === "string") {
        setText(children);
        originalText.current = children;
        if (trigger === "instant" && !hasAnimated) {
          eventHandler();
        }
      }
    }, [children, trigger, eventHandler, hasAnimated]);
    useEffect(() => {
      if (trigger === "custom" && onTrigger) {
        onTrigger(eventHandler);
      }
    }, [trigger, onTrigger, eventHandler]);
    return (
      <span
        ref={ref}
        className={classNames(className)}
        style={style}
        onMouseOver={trigger === "hover" ? eventHandler : undefined}
      >
        {text}
      </span>
    );
  },
);
LetterFx.displayName = "LetterFx";
export { LetterFx };
</file>

<file path="src/once-ui/components/Line.tsx">
"use client";
import React, { forwardRef } from "react";
import { Flex } from ".";
interface LineProps extends React.ComponentProps<typeof Flex> {
  vert?: boolean;
  style?: React.CSSProperties;
}
const Line = forwardRef<HTMLDivElement, LineProps>(({ vert, className, style, ...rest }, ref) => {
  return (
    <Flex
      ref={ref}
      minWidth={(vert && "1") || undefined}
      minHeight={(!vert && "1") || undefined}
      width={(vert && "1") || undefined}
      height={(!vert && "1") || undefined}
      fillWidth={!vert}
      fillHeight={vert}
      background="neutral-strong"
      direction={vert ? "column" : "row"}
      className={className}
      style={style}
      {...rest}
    />
  );
});
Line.displayName = "Line";
export { Line };
</file>

<file path="src/once-ui/components/Logo.module.scss">
.type {
	content: var(--type);
}
.icon {
	content: var(--icon);
}
.type, .icon {
    user-select: none;
    display: block;
}
</file>

<file path="src/once-ui/components/Logo.tsx">
"use client";
import React, { useEffect } from "react";
import Link from "next/link";
import classNames from "classnames";
import styles from "./Logo.module.scss";
import { SpacingToken } from "../types";
import { Flex } from ".";
const sizeMap: Record<string, SpacingToken> = {
  xs: "20",
  s: "24",
  m: "32",
  l: "40",
  xl: "48",
};
interface LogoProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
  className?: string;
  size?: "xs" | "s" | "m" | "l" | "xl";
  style?: React.CSSProperties;
  wordmark?: boolean;
  icon?: boolean;
  iconSrc?: string;
  wordmarkSrc?: string;
  href?: string;
}
const Logo: React.FC<LogoProps> = ({
  size = "m",
  wordmark = true,
  icon = true,
  href,
  iconSrc,
  wordmarkSrc,
  className,
  style,
  ...props
}) => {
  useEffect(() => {
    if (!icon && !wordmark) {
      console.warn(
        "Both 'icon' and 'wordmark' props are set to false. The logo will not render any content.",
      );
    }
  }, [icon, wordmark]);
  const content = (
    <>
      {icon && !iconSrc && (
        <div
          style={{
            height: `var(--static-space-${sizeMap[size]})`,
          }}
          className={styles.icon}
        />
      )}
      {iconSrc && (
        // @ts-ignore
        <img
          style={{
            height: `var(--static-space-${sizeMap[size]})`,
            width: "auto",
          }}
          alt="Trademark"
          src={iconSrc}
        />
      )}
      {wordmark && !wordmarkSrc && (
        <div
          style={{
            height: `var(--static-space-${sizeMap[size]})`,
          }}
          className={styles.type}
        />
      )}
      {wordmarkSrc && (
        // @ts-ignore
        <img
          style={{
            height: `var(--static-space-${sizeMap[size]})`,
            width: "auto",
          }}
          alt="Trademark"
          src={wordmarkSrc}
        />
      )}
    </>
  );
  return href ? (
    <Link
      className={classNames("radius-l", "display-flex", "fit-height", className)}
      style={style}
      href={href}
      aria-label="Trademark"
      {...props}
    >
      {content}
    </Link>
  ) : (
    <Flex
      className={classNames(className)}
      radius="l"
      fitHeight
      style={style}
      aria-label="Trademark"
    >
      {content}
    </Flex>
  );
};
Logo.displayName = "Logo";
export { Logo };
</file>

<file path="src/once-ui/components/LogoCloud.module.scss">
.logo {
    animation: fadeInOut 5s ease-out both;
    will-change: opacity, filter, transform;
    transform-origin: center;
}
.staticLogo {
    animation: fadeIn 1s ease-out forwards;
    will-change: opacity, filter, transform;
    transform-origin: center;
}
@keyframes fadeIn {
    0% {
        opacity: 0;
        filter: blur(1.5rem);
        transform: scale(0.2);
    }
    100% {
        opacity: 1;
        filter: blur(0);
        transform: scale(1);
    }
}
@keyframes fadeInOut {
    0% {
        opacity: 0;
        filter: blur(1.5rem);
        transform: scale(0.2);
    }
    4%, 96% {
        opacity: 1;
        filter: blur(0);
        transform: scale(1);
    }
    100% {
        opacity: 0;
        filter: blur(1.5rem);
        transform: scale(0.2);
    }
}
</file>

<file path="src/once-ui/components/LogoCloud.tsx">
"use client";
import React, { forwardRef, useState, useEffect } from "react";
import classNames from "classnames";
import { Grid, Flex, Logo } from ".";
import styles from "./LogoCloud.module.scss";
import type { ComponentProps } from "react";
type LogoProps = ComponentProps<typeof Logo>;
interface LogoCloudProps extends React.ComponentProps<typeof Grid> {
  logos: LogoProps[];
  className?: string;
  style?: React.CSSProperties;
  limit?: number;
  rotationInterval?: number;
}
const ANIMATION_DURATION = 5000;
const STAGGER_DELAY = 25;
const LogoCloud = forwardRef<HTMLDivElement, LogoCloudProps>(
  ({ logos, className, style, limit = 6, rotationInterval = ANIMATION_DURATION, ...rest }, ref) => {
    const [visibleLogos, setVisibleLogos] = useState<LogoProps[]>(() => logos.slice(0, limit));
    const [key, setKey] = useState(0);
    const shouldRotate = logos.length > limit;
    useEffect(() => {
      if (!shouldRotate) {
        setVisibleLogos(logos);
        return;
      }
      const interval = setInterval(
        () => {
          setVisibleLogos((currentLogos) => {
            const currentIndices = currentLogos.map((logo) => logos.findIndex((l) => l === logo));
            const nextIndices = currentIndices
              .map((index) => (index + 1) % logos.length)
              .sort((a, b) => a - b);
            const nextLogos = nextIndices.map((index) => logos[index]);
            setKey((k) => k + 1);
            return nextLogos;
          });
        },
        rotationInterval + STAGGER_DELAY * limit,
      );
      return () => clearInterval(interval);
    }, [logos, limit, rotationInterval, shouldRotate]);
    return (
      <Grid ref={ref} className={classNames(styles.container, className)} style={style} {...rest}>
        {visibleLogos.map((logo, index) => (
          <Flex
            key={`${key}-${index}`}
            vertical="center"
            horizontal="center"
            paddingX="24"
            paddingY="20"
            radius="l"
          >
            <Logo
              className={shouldRotate ? styles.logo : styles.staticLogo}
              style={{
                ...logo.style,
                animationDelay: `${index * STAGGER_DELAY}ms`,
              }}
              {...logo}
            />
          </Flex>
        ))}
      </Grid>
    );
  },
);
LogoCloud.displayName = "LogoCloud";
export { LogoCloud };
</file>

<file path="src/once-ui/components/Mask.module.scss">
.mask {
  mask-size: 100% 100%;
  mask-image: radial-gradient(
    var(--mask-radius) at var(--mask-position-x) var(--mask-position-y),
    black 0%,
    transparent 100%
  );
}
</file>

<file path="src/once-ui/components/Media.tsx">
"use client";
import React, { CSSProperties, useState, useRef, useEffect } from "react";
import Image from "next/image";
import { Flex, Skeleton } from ".";
export interface MediaProps extends React.ComponentProps<typeof Flex> {
  aspectRatio?: string;
  height?: number;
  alt?: string;
  loading?: boolean;
  objectFit?: CSSProperties["objectFit"];
  enlarge?: boolean;
  src: string;
  unoptimized?: boolean;
  sizes?: string;
  priority?: boolean;
}
const Media: React.FC<MediaProps> = ({
  aspectRatio,
  height,
  alt = "",
  loading = false,
  objectFit = "cover",
  enlarge = false,
  src,
  unoptimized = false,
  priority,
  sizes = "100vw",
  ...rest
}) => {
  const [isEnlarged, setIsEnlarged] = useState(false);
  const imageRef = useRef<HTMLDivElement>(null);
  const handleClick = () => {
    if (enlarge) {
      setIsEnlarged(!isEnlarged);
    }
  };
  useEffect(() => {
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === "Escape" && isEnlarged) {
        setIsEnlarged(false);
      }
    };
    const handleWheel = (event: WheelEvent) => {
      if (isEnlarged) {
        setIsEnlarged(false);
      }
    };
    document.addEventListener("keydown", handleEscape);
    window.addEventListener("wheel", handleWheel, { passive: true });
    return () => {
      document.removeEventListener("keydown", handleEscape);
      window.removeEventListener("wheel", handleWheel);
    };
  }, [isEnlarged]);
  useEffect(() => {
    if (isEnlarged) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "auto";
    }
    return () => {
      document.body.style.overflow = "auto";
    };
  }, [isEnlarged]);
  const calculateTransform = () => {
    if (!imageRef.current) return {};
    const rect = imageRef.current.getBoundingClientRect();
    const scaleX = window.innerWidth / rect.width;
    const scaleY = window.innerHeight / rect.height;
    const scale = Math.min(scaleX, scaleY) * 0.9;
    const translateX = (window.innerWidth - rect.width) / 2 - rect.left;
    const translateY = (window.innerHeight - rect.height) / 2 - rect.top;
    return {
      transform: isEnlarged
        ? `translate(${translateX}px, ${translateY}px) scale(${scale})`
        : "translate(0, 0) scale(1)",
      transition: "all 0.3s ease-in-out",
      zIndex: isEnlarged ? 10 : undefined,
    };
  };
  const isYouTubeVideo = (url: string) => {
    const youtubeRegex =
      /(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
    return youtubeRegex.test(url);
  };
  const getYouTubeEmbedUrl = (url: string) => {
    const match = url.match(
      /(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/,
    );
    return match
      ? `https://www.youtube.com/embed/${match[1]}?controls=0&rel=0&modestbranding=1`
      : "";
  };
  const isVideo = src?.endsWith(".mp4");
  const isYouTube = isYouTubeVideo(src);
  return (
    <>
      <Flex
        ref={imageRef}
        fillWidth
        overflow="hidden"
        zIndex={0}
        cursor={enlarge ? "interactive" : ""}
        style={{
          outline: "none",
          isolation: "isolate",
          height: aspectRatio ? "" : height ? `${height}rem` : "100%",
          aspectRatio,
          borderRadius: isEnlarged ? "0" : undefined,
          ...calculateTransform(),
        }}
        onClick={handleClick}
        {...rest}
      >
        {loading && <Skeleton shape="block" />}
        {!loading && isVideo && (
          <video
            src={src}
            autoPlay
            loop
            muted
            playsInline
            style={{
              width: "100%",
              height: "100%",
              objectFit: objectFit,
            }}
          />
        )}
        {!loading && isYouTube && (
          <iframe
            width="100%"
            height="100%"
            src={getYouTubeEmbedUrl(src)}
            frameBorder="0"
            allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
            style={{
              objectFit: objectFit,
            }}
          />
        )}
        {!loading && !isVideo && !isYouTube && (
          <Image
            src={src}
            alt={alt}
            priority={priority}
            sizes={sizes}
            unoptimized={unoptimized}
            fill
            style={{
              objectFit: objectFit,
            }}
          />
        )}
      </Flex>
      {isEnlarged && enlarge && (
        <Flex
          horizontal="center"
          vertical="center"
          position="fixed"
          background="overlay"
          pointerEvents="none"
          onClick={handleClick}
          top="0"
          left="0"
          zIndex={isEnlarged ? 9 : undefined}
          opacity={isEnlarged ? 100 : 0}
          cursor="interactive"
          transition="macro-medium"
          style={{
            backdropFilter: isEnlarged ? "var(--backdrop-filter)" : "0px",
            width: "100vw",
            height: "100vh",
          }}
        >
          <Flex
            style={{
              height: "100vh",
              transform: "translate(-50%, -50%)",
            }}
            onClick={(e) => e.stopPropagation()}
          >
            {isVideo ? (
              <video
                src={src}
                autoPlay
                loop
                muted
                playsInline
                style={{
                  width: "90vw",
                  height: "auto",
                  objectFit: "contain",
                }}
              />
            ) : (
              <Image
                src={src}
                alt={alt}
                fill
                sizes="90vw"
                unoptimized={unoptimized}
                style={{
                  objectFit: "contain",
                }}
              />
            )}
          </Flex>
        </Flex>
      )}
    </>
  );
};
Media.displayName = "Media";
export { Media };
</file>

<file path="src/once-ui/components/NavIcon.module.scss">
.line {
    background-color: var(--neutral-on-background-strong);
    height: 1px;
    width: var(--static-space-24);
    transition: transform 0.3s ease;
    position: absolute;
    left: 50%;
    top: 50%;
    &:first-child {
        transform: translateX(-50%) translateY(calc(-1 * var(--static-space-4)));
    }
    &:last-child {
        transform: translateX(-50%) translateY(var(--static-space-4));
    }    
}
.active:first-child {
    transform: translateX(-50%) translateY(0) rotate(45deg);
}
.active:last-child {
    transform: translateX(-50%) translateY(0) rotate(-45deg);
}
</file>

<file path="src/once-ui/components/NavIcon.tsx">
import React, { forwardRef } from "react";
import styles from "./NavIcon.module.scss";
import { Flex } from ".";
import classNames from "classnames";
interface NavIconProps extends React.ComponentProps<typeof Flex> {
  className?: string;
  style?: React.CSSProperties;
  onClick?: () => void;
  isActive: boolean;
}
const NavIcon = forwardRef<HTMLDivElement, Partial<NavIconProps>>(
  ({ className, isActive, style, onClick, ...rest }, ref) => {
    return (
      <Flex
        ref={ref}
        tabIndex={0}
        radius="m"
        cursor="interactive"
        width="40"
        height="40"
        minHeight="40"
        minWidth="40"
        className={className}
        style={style}
        onClick={onClick}
        {...rest}
      >
        <div className={classNames(styles.line, isActive && styles.active)} />
        <div className={classNames(styles.line, isActive && styles.active)} />
      </Flex>
    );
  },
);
NavIcon.displayName = "NavIcon";
export { NavIcon };
</file>

<file path="src/once-ui/components/NumberInput.module.scss">
.numberInput {
  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  input[type="number"] {
    -moz-appearance: textfield;
  }
}
.stepper {
  pointer-events: visibleFill;
  &:hover {
    background-color: var(--neutral-alpha-medium);
  }
}
</file>

<file path="src/once-ui/components/NumberInput.tsx">
"use client";
import React, { forwardRef, useState } from "react";
import { Input, Flex, IconButton } from ".";
import styles from "./NumberInput.module.scss";
import classNames from "classnames";
interface NumberInputProps
  extends Omit<React.ComponentProps<typeof Input>, "type" | "value" | "onChange"> {
  value?: number;
  onChange?: (value: number) => void;
  min?: number;
  max?: number;
  step?: number;
  padStart?: number;
}
const NumberInput = forwardRef<HTMLInputElement, NumberInputProps>(
  ({ value, onChange, min, max, step = 1, padStart, ...props }, ref) => {
    const [localValue, setLocalValue] = useState<string>(
      padStart && value !== undefined
        ? value.toString().padStart(padStart, "0")
        : (value?.toString() ?? ""),
    );
    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const newValue = e.target.value;
      setLocalValue(newValue);
      const numValue = parseFloat(newValue);
      if (!isNaN(numValue) && onChange) {
        onChange(numValue);
      }
    };
    const updateValue = (newValue: number) => {
      const formattedValue = padStart
        ? newValue.toString().padStart(padStart, "0")
        : newValue.toString();
      setLocalValue(formattedValue);
      onChange?.(newValue);
    };
    const increment = () => {
      const currentValue = parseFloat(localValue) || 0;
      const newValue = currentValue + step;
      if (max === undefined || newValue <= max) {
        updateValue(newValue);
      }
    };
    const decrement = () => {
      const currentValue = parseFloat(localValue) || 0;
      const newValue = currentValue - step;
      if (min === undefined || newValue >= min) {
        updateValue(newValue);
      }
    };
    return (
      <Input
        {...props}
        ref={ref}
        type="number"
        value={localValue}
        onChange={handleChange}
        min={min}
        max={max}
        step={step}
        hasSuffix={
          <>
            <Flex position="static" minWidth={1.25}></Flex>
            <Flex
              position="absolute"
              right="0"
              top="0"
              direction="column"
              borderLeft="neutral-medium"
              fillHeight
              background="neutral-alpha-weak"
            >
              <Flex
                fillHeight
                position="static"
                borderBottom="neutral-medium"
                paddingX="4"
                className={classNames(styles.stepper, "transition-micro-medium")}
              >
                <IconButton
                  icon="chevronUp"
                  variant="ghost"
                  size="s"
                  onClick={increment}
                  aria-label="Increment value"
                />
              </Flex>
              <Flex
                fillHeight
                position="static"
                paddingX="4"
                className={classNames(styles.stepper, "transition-micro-medium")}
              >
                <IconButton
                  icon="chevronDown"
                  variant="ghost"
                  size="s"
                  onClick={decrement}
                  aria-label="Decrement value"
                />
              </Flex>
            </Flex>
          </>
        }
        className={styles.numberInput}
      />
    );
  },
);
NumberInput.displayName = "NumberInput";
export { NumberInput };
</file>

<file path="src/once-ui/components/OgCard.tsx">
"use client";
import { Column, Media, Text, Row, Card } from ".";
import { useOgData } from "../hooks/useFetchOg";
import { useMemo } from "react";
export interface OgData {
  title: string;
  description: string;
  faviconUrl: string;
  image: string;
  url: string;
}
export interface OgDisplayOptions {
  favicon?: boolean;
  domain?: boolean;
  title?: boolean;
  description?: boolean;
  image?: boolean;
}
interface OgCardProps extends React.ComponentProps<typeof Card> {
  url?: string;
  ogData?: Partial<OgData> | null;
  direction?: "column" | "row" | "column-reverse" | "row-reverse";
  display?: OgDisplayOptions;
}
const getProxiedImageUrl = (imageUrl: string | undefined): string => {
  if (!imageUrl) return "";
  if (imageUrl.startsWith("/")) {
    return imageUrl;
  }
  return `/api/og/proxy?url=${encodeURIComponent(imageUrl)}`;
};
const formatDisplayUrl = (url: string | undefined): string => {
  if (!url) return "";
  try {
    const urlObj = new URL(url);
    let domain = urlObj.hostname;
    domain = domain.replace(/^www\./, "");
    return domain;
  } catch (error) {
    let formattedUrl = url.replace(/^https?:\/\//, "");
    formattedUrl = formattedUrl.replace(/^www\./, "");
    formattedUrl = formattedUrl.split("/")[0];
    return formattedUrl;
  }
};
const getFaviconUrl = (url: string | undefined): string => {
  if (!url) return "";
  try {
    const urlObj = new URL(url);
    const domain = urlObj.hostname;
    const faviconSourceUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=64`;
    return `/api/og/proxy?url=${encodeURIComponent(faviconSourceUrl)}`;
  } catch (error) {
    return "";
  }
};
const OgCard = ({
  url,
  ogData: providedOgData,
  direction = "column",
  display,
  ...card
}: OgCardProps) => {
  // Merge with defaults
  const displayOptions = {
    favicon: true,
    domain: true,
    title: true,
    description: true,
    image: true,
    ...display,
  };
  const { ogData: fetchedOgData, loading } = useOgData(url || null);
  const data = providedOgData || fetchedOgData;
  const proxiedImageUrl = useMemo(() => {
    return getProxiedImageUrl(data?.image);
  }, [data?.image]);
  const faviconUrl = useMemo(() => {
    return data?.faviconUrl || getFaviconUrl(data?.url);
  }, [data?.faviconUrl, data?.url]);
  if (!data || (!data.image && !data.title)) {
    return null;
  }
  return (
    <Card
      href={data.url}
      direction={direction}
      fillWidth
      vertical={direction === "row" || direction === "row-reverse" ? "center" : undefined}
      gap="4"
      radius="l"
      background="surface"
      border="neutral-alpha-medium"
      {...card}
    >
      {displayOptions.image && (proxiedImageUrl || loading) && (
        <Media
          minWidth={direction === "row" || direction === "row-reverse" ? 16 : undefined}
          maxWidth={direction === "row" || direction === "row-reverse" ? 24 : undefined}
          loading={loading}
          radius="l"
          sizes="320px"
          aspectRatio="16/9"
          border="neutral-alpha-weak"
          src={proxiedImageUrl}
        />
      )}
      <Column fillWidth paddingX="12" paddingY="12" gap="8">
        {(displayOptions.favicon || displayOptions.domain) && (
          <Row fillWidth gap="8" vertical="center">
            {displayOptions.favicon && (faviconUrl || loading) && (
              <Media
                aspectRatio="1/1"
                src={faviconUrl}
                loading={loading}
                minWidth="16"
                maxWidth="16"
                radius="xs"
                border="neutral-alpha-weak"
                unoptimized={true}
              />
            )}
            {displayOptions.domain && data.url && (
              <Text variant="label-default-s" onBackground="neutral-weak">
                {formatDisplayUrl(data.url)}
              </Text>
            )}
          </Row>
        )}
        <Column fillWidth gap="2">
          {displayOptions.title && data.title && (
            <Text variant="label-default-s">{data.title}</Text>
          )}
          {displayOptions.description && data.description && (
            <Text variant="label-default-s" onBackground="neutral-weak">
              {data.description}
            </Text>
          )}
        </Column>
      </Column>
    </Card>
  );
};
OgCard.displayName = "OgCard";
export { OgCard };
</file>

<file path="src/once-ui/components/Option.module.scss">
.option {
    border-color: var(--static-transparent);
    &:hover, &:focus {
        background: var(--neutral-alpha-weak);
        border-color: var(--neutral-alpha-medium);
    }
    &.selected {
        background: var(--neutral-alpha-medium);
        border-color: var(--neutral-alpha-medium);
    }
    &.highlighted {
        background: var(--static-transparent);
        border-color: var(--neutral-alpha-medium);
    }
    &.danger {
        color: var(--danger-on-background-medium);
        &:hover, &:focus {
            background: var(--danger-solid-strong);
            color: var(--danger-on-solid-strong);
            border-color: var(--danger-border-strong);
        }
    }
  }
  .focused {
    background: var(--neutral-background-strong);
  }
</file>

<file path="src/once-ui/components/OTPInput.module.scss">
.inputs {
  font-size: var(--font-size-heading-xl);
  transition: border-color 0.2s, box-shadow 0.2s;
  min-width: var(--static-space-48);
  max-width: var(--static-space-48);
  input {
    text-align: center;
  }
  &:focus-within {
    animation: focusAnimation 0.3s forwards;
  }
}
@keyframes focusAnimation {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}
</file>

<file path="src/once-ui/components/OTPInput.tsx">
"use client";
import React, { useState, useRef, forwardRef, useEffect } from "react";
import { Column, Flex, Input, Text } from ".";
import styles from "./OTPInput.module.scss";
interface OTPInputProps extends React.HTMLAttributes<HTMLDivElement> {
  length?: number;
  onComplete?: (code: string) => void;
  error?: boolean;
  errorMessage?: React.ReactNode;
  disabled?: boolean;
  autoFocus?: boolean;
}
const OTPInput = forwardRef<HTMLDivElement, OTPInputProps>(
  (
    {
      length = 4,
      onComplete,
      error = false,
      errorMessage,
      disabled = false,
      autoFocus = false,
      className,
      ...props
    },
    ref,
  ) => {
    const [values, setValues] = useState<string[]>(Array(length).fill(""));
    const inputsRef = useRef<Array<HTMLInputElement | null>>([]);
    useEffect(() => {
      if (autoFocus && inputsRef.current[0]) {
        inputsRef.current[0].focus();
      }
    }, [autoFocus]);
    const handleChange = (index: number, value: string) => {
      if (disabled) return;
      if (value === "" || /^[0-9]$/.test(value)) {
        const newValues = [...values];
        newValues[index] = value;
        setValues(newValues);
        if (value && index < length - 1) {
          inputsRef.current[index + 1]?.focus();
        }
        if (newValues.every((val) => val !== "") && onComplete) {
          onComplete(newValues.join(""));
        }
      }
    };
    const handleKeyDown = (index: number, event: React.KeyboardEvent<HTMLInputElement>) => {
      if (disabled) return;
      if (event.key === "Backspace") {
        event.preventDefault();
        if (values[index]) {
          const newValues = [...values];
          newValues[index] = "";
          setValues(newValues);
        } else if (index > 0) {
          inputsRef.current[index - 1]?.focus();
          const newValues = [...values];
          newValues[index - 1] = "";
          setValues(newValues);
        }
      } else if (event.key === "ArrowLeft" && index > 0) {
        event.preventDefault();
        inputsRef.current[index - 1]?.focus();
      } else if (event.key === "ArrowRight" && index < length - 1) {
        event.preventDefault();
        inputsRef.current[index + 1]?.focus();
      }
    };
    const handleContainerClick = () => {
      if (disabled) return;
      if (values.every((val) => val !== "")) return;
      const firstEmptyIndex = values.findIndex((val) => val === "");
      if (firstEmptyIndex >= 0) {
        inputsRef.current[firstEmptyIndex]?.focus();
      }
    };
    return (
      <Column gap="8" ref={ref}>
        <Flex gap="8" center onClick={handleContainerClick}>
          {Array.from({ length }, (_, index) => (
            <Input
              key={index}
              ref={(el) => {
                inputsRef.current[index] = el;
              }}
              id={`otp-${index}`}
              type="text"
              placeholder=" "
              inputMode="numeric"
              maxLength={1}
              error={error}
              value={values[index]}
              onChange={(e) => handleChange(index, e.target.value)}
              onKeyDown={(e) => handleKeyDown(index, e)}
              aria-label={`OTP digit ${index + 1} of ${length}`}
              className={styles.inputs}
              {...props}
            />
          ))}
        </Flex>
        {error && errorMessage && (
          <Flex paddingX="8">
            <Text variant="body-default-s" onBackground="danger-weak">
              {errorMessage}
            </Text>
          </Flex>
        )}
      </Column>
    );
  },
);
OTPInput.displayName = "OTPInput";
export { OTPInput };
export type { OTPInputProps };
</file>

<file path="src/once-ui/components/PasswordInput.tsx">
"use client";
import React, { useState, forwardRef } from "react";
import { Input, InputProps, IconButton } from ".";
export const PasswordInput = forwardRef<HTMLInputElement, InputProps>((props, ref) => {
  const [showPassword, setShowPassword] = useState(false);
  return (
    <Input
      {...props}
      ref={ref}
      type={showPassword ? "text" : "password"}
      hasSuffix={
        <IconButton
          onClick={() => {
            setShowPassword(!showPassword);
          }}
          variant="ghost"
          icon={showPassword ? "eyeOff" : "eye"}
          size="s"
          type="button"
        />
      }
    />
  );
});
PasswordInput.displayName = "PasswordInput";
</file>

<file path="src/once-ui/components/RadioButton.tsx">
"use client";
import React, { useState, useEffect, forwardRef } from "react";
import classNames from "classnames";
import { Flex, InteractiveDetails, InteractiveDetailsProps } from ".";
import styles from "./SharedInteractiveStyles.module.scss";
interface RadioButtonProps
  extends Omit<InteractiveDetailsProps, "onClick">,
    React.InputHTMLAttributes<HTMLInputElement> {
  style?: React.CSSProperties;
  className?: string;
  isChecked?: boolean;
  name?: string;
  value?: string;
  disabled?: boolean;
  onToggle?: () => void;
}
const generateId = () => `radio-${Math.random().toString(36).substring(2, 9)}`;
const RadioButton: React.FC<RadioButtonProps> = forwardRef<HTMLInputElement, RadioButtonProps>(
  (
    { style, className, isChecked: controlledIsChecked, name, value, onToggle, disabled, ...props },
    ref,
  ) => {
    const [isChecked, setIsChecked] = useState(controlledIsChecked || false);
    const [radioId] = useState(generateId());
    useEffect(() => {
      if (controlledIsChecked !== undefined) {
        setIsChecked(controlledIsChecked);
      }
    }, [controlledIsChecked]);
    const toggleItem = () => {
      if (disabled) return;
      if (onToggle) {
        onToggle();
      } else {
        setIsChecked(!isChecked);
      }
    };
    const handleKeyDown = (event: React.KeyboardEvent) => {
      if (disabled) return;
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        toggleItem();
      }
    };
    return (
      <Flex
        vertical="center"
        gap="16"
        zIndex={1}
        className={classNames(styles.container, className, {
          [styles.disabled]: disabled,
        })}
        style={style}
      >
        <input
          type="radio"
          ref={ref}
          name={name}
          value={value}
          checked={controlledIsChecked !== undefined ? controlledIsChecked : isChecked}
          onChange={toggleItem}
          disabled={disabled}
          className={styles.hidden}
          tabIndex={-1}
        />
        <Flex
          role="radio"
          aria-checked={controlledIsChecked !== undefined ? controlledIsChecked : isChecked}
          aria-labelledby={radioId}
          aria-disabled={disabled}
          horizontal="center"
          vertical="center"
          radius="full"
          onClick={toggleItem}
          onKeyDown={handleKeyDown}
          tabIndex={disabled ? -1 : 0}
          cursor={disabled ? "not-allowed" : undefined}
          className={classNames(styles.element, {
            [styles.checked]: controlledIsChecked !== undefined ? controlledIsChecked : isChecked,
            [styles.disabled]: disabled,
          })}
        >
          {(controlledIsChecked !== undefined ? controlledIsChecked : isChecked) && (
            <Flex
              style={{
                backgroundColor: "var(--neutral-on-solid-strong)",
              }}
              radius="full"
              width="12"
              height="12"
              className={styles.icon}
            />
          )}
        </Flex>
        {props.label && (
          <InteractiveDetails disabled={disabled} id={radioId} {...props} onClick={toggleItem} />
        )}
      </Flex>
    );
  },
);
RadioButton.displayName = "RadioButton";
export { RadioButton };
export type { RadioButtonProps };
</file>

<file path="src/once-ui/components/RevealFx.module.scss">
.revealFx {
    mask-size: 400% 100%;
    transition: all ease-in-out;
    mask-image: linear-gradient(to right, black 0%, black 25%, transparent 50%);
    &.hidden {
      mask-position: 100% 0;
      filter: blur(0.5rem);
    }
    &.revealed {
      mask-position: 0 0;
      filter: blur(0);
    }
}
.hiddenNoMask {
  transition: all ease-in-out;
  filter: blur(0.5rem);
  opacity: 0;
}
.revealedNoMask {
  transition: all ease-in-out;
  filter: blur(0);
  opacity: 1;
}
</file>

<file path="src/once-ui/components/Row.tsx">
"use client";
import { forwardRef } from "react";
import { Flex } from ".";
interface RowProps extends React.ComponentProps<typeof Flex> {
  children?: React.ReactNode;
}
const Row = forwardRef<HTMLDivElement, RowProps>(({ children, ...rest }, ref) => {
  return (
    <Flex ref={ref} {...rest}>
      {children}
    </Flex>
  );
});
Row.displayName = "Row";
export { Row };
</file>

<file path="src/once-ui/components/Scroller.module.scss">
.container {
    isolation: isolate;
}
.scroller {
    scrollbar-width: none;
    isolation: isolate;
    &::-webkit-scrollbar {
        display: none;
    }
}
.row {
    overflow-x: auto;
}
.column {
    overflow-y: auto;
}
</file>

<file path="src/once-ui/components/Scroller.tsx">
"use client";
import React, { useEffect, useRef, useState } from "react";
import classNames from "classnames";
import { Flex, IconButton, BaseColor, Fade } from ".";
import styles from "./Scroller.module.scss";
interface ScrollerProps extends React.ComponentProps<typeof Flex> {
  children?: React.ReactNode;
  direction?: "row" | "column";
  fadeColor?: BaseColor;
  onItemClick?: (index: number) => void;
}
interface ScrollableChildProps {
  onClick?: (e: React.MouseEvent) => void;
  onKeyDown?: (e: React.KeyboardEvent) => void;
}
const Scroller: React.FC<ScrollerProps> = ({
  children,
  direction = "row",
  fadeColor,
  className,
  style,
  onItemClick,
  ...rest
}) => {
  const scrollerRef = useRef<HTMLDivElement>(null);
  const [showPrevButton, setShowPrevButton] = useState<boolean>(false);
  const [showNextButton, setShowNextButton] = useState<boolean>(false);
  // Function to check and update scroll buttons visibility
  const updateScrollButtonsVisibility = () => {
    const scroller = scrollerRef.current;
    if (scroller) {
      const scrollPosition = direction === "row" ? scroller.scrollLeft : scroller.scrollTop;
      const maxScrollPosition =
        direction === "row"
          ? scroller.scrollWidth - scroller.clientWidth
          : scroller.scrollHeight - scroller.clientHeight;
      // Check if content is scrollable
      const isScrollable =
        direction === "row"
          ? scroller.scrollWidth > scroller.clientWidth
          : scroller.scrollHeight > scroller.clientHeight;
      setShowPrevButton(isScrollable && scrollPosition > 0);
      setShowNextButton(isScrollable && scrollPosition < maxScrollPosition - 1);
    }
  };
  // Handle scroll events
  useEffect(() => {
    const scroller = scrollerRef.current;
    if (scroller) {
      // Initial check
      updateScrollButtonsVisibility();
      // Add scroll event listener
      scroller.addEventListener("scroll", updateScrollButtonsVisibility);
      return () => scroller.removeEventListener("scroll", updateScrollButtonsVisibility);
    }
  }, [direction]);
  // Re-check when children change
  useEffect(() => {
    // Use setTimeout to ensure DOM has updated
    const timer = setTimeout(() => {
      updateScrollButtonsVisibility();
    }, 100);
    return () => clearTimeout(timer);
  }, [children]);
  const handleScrollNext = () => {
    const scroller = scrollerRef.current;
    if (scroller) {
      const scrollAmount =
        direction === "row" ? scroller.clientWidth / 2 : scroller.clientHeight / 2;
      scroller.scrollBy({
        [direction === "row" ? "left" : "top"]: scrollAmount,
        behavior: "smooth",
      });
    }
  };
  const handleScrollPrev = () => {
    const scroller = scrollerRef.current;
    if (scroller) {
      const scrollAmount =
        direction === "row" ? scroller.clientWidth / 2 : scroller.clientHeight / 2;
      scroller.scrollBy({
        [direction === "row" ? "left" : "top"]: -scrollAmount,
        behavior: "smooth",
      });
    }
  };
  const wrappedChildren = React.Children.map(children, (child, index) => {
    if (React.isValidElement<ScrollableChildProps>(child)) {
      const { onClick: childOnClick, onKeyDown: childOnKeyDown, ...otherProps } = child.props;
      return React.cloneElement(child, {
        ...otherProps,
        onClick: (e: React.MouseEvent) => {
          childOnClick?.(e);
          onItemClick?.(index);
        },
        onKeyDown: (e: React.KeyboardEvent) => {
          childOnKeyDown?.(e);
          if (e.key === "Enter" || e.key === " ") {
            childOnClick?.(e as any);
            onItemClick?.(index);
          }
        },
      });
    }
    return child;
  });
  return (
    <Flex fillWidth className={classNames(styles.container, className)} style={style} {...rest}>
      {showPrevButton && (
        <Fade
          base={fadeColor}
          position="absolute"
          padding="4"
          horizontal={direction === "column" ? "center" : undefined}
          vertical={direction === "column" ? "start" : "center"}
          to={direction === "row" ? "right" : "bottom"}
          width={direction === "row" ? 4 : undefined}
          height={direction === "column" ? 4 : undefined}
          fillHeight={direction === "row"}
          fillWidth={direction === "column"}
          left={direction === "row" ? "0" : undefined}
          top={direction === "column" ? "0" : undefined}
          zIndex={1}
        >
          <IconButton
            icon={direction === "row" ? "chevronLeft" : "chevronUp"}
            onClick={handleScrollPrev}
            onKeyDown={(e: React.KeyboardEvent) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                handleScrollPrev();
              }
            }}
            size="s"
            variant="secondary"
            aria-label="Scroll Previous"
          />
        </Fade>
      )}
      <Flex
        fillWidth
        zIndex={0}
        radius="m"
        direction={direction}
        className={classNames(styles.scroller, styles[direction])}
        ref={scrollerRef}
      >
        {wrappedChildren}
      </Flex>
      {showNextButton && (
        <Fade
          base={fadeColor}
          padding="4"
          position="absolute"
          horizontal={direction === "column" ? "center" : "end"}
          vertical={direction === "column" ? "end" : "center"}
          to={direction === "row" ? "left" : "top"}
          width={direction === "row" ? 4 : undefined}
          height={direction === "column" ? 4 : undefined}
          fillHeight={direction === "row"}
          fillWidth={direction === "column"}
          right={direction === "row" ? "0" : undefined}
          bottom={direction === "column" ? "0" : undefined}
          zIndex={1}
        >
          <IconButton
            icon={direction === "row" ? "chevronRight" : "chevronDown"}
            onClick={handleScrollNext}
            onKeyDown={(e: React.KeyboardEvent) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                handleScrollNext();
              }
            }}
            size="s"
            variant="secondary"
            aria-label="Scroll Next"
          />
        </Fade>
      )}
    </Flex>
  );
};
Scroller.displayName = "Scroller";
export { Scroller };
export type { ScrollerProps };
</file>

<file path="src/once-ui/components/ScrollToTop.module.scss">
.scrollToTop {
  opacity: 0;
  visibility: hidden;
  transition: opacity 200ms ease-in-out, visibility 0ms linear 200ms;
  &[data-visible="true"] {
    opacity: 1;
    visibility: visible;
    transition: opacity 200ms ease-in-out, visibility 0ms linear;
  }
}
</file>

<file path="src/once-ui/components/ScrollToTop.tsx">
"use client";
import { useState, useEffect } from "react";
import { Flex } from ".";
import styles from "./ScrollToTop.module.scss";
import classNames from "classnames";
interface ScrollToTopProps extends React.ComponentProps<typeof Flex> {
  offset?: number;
}
export const ScrollToTop = ({ children, offset = 300, className, ...rest }: ScrollToTopProps) => {
  const [isVisible, setIsVisible] = useState(false);
  const handleScroll = () => {
    setIsVisible(window.scrollY > offset);
  };
  const scrollToTop = () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth",
    });
  };
  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);
  return (
    <Flex
      onClick={scrollToTop}
      aria-hidden={!isVisible}
      position="fixed"
      bottom="16"
      right="16"
      className={classNames(styles.scrollToTop, className)}
      data-visible={isVisible}
      tabIndex={isVisible ? 0 : -1}
      zIndex={isVisible ? 8 : 0}
      cursor="pointer"
      {...rest}
    >
      {children}
    </Flex>
  );
};
</file>

<file path="src/once-ui/components/SegmentedControl.tsx">
"use client";
import { useState, useEffect, useRef } from "react";
import { ToggleButton, Scroller, Flex, ToggleButtonProps } from ".";
interface ButtonOption extends Omit<ToggleButtonProps, "selected"> {
  value: string;
}
interface SegmentedControlProps extends Omit<React.ComponentProps<typeof Scroller>, "onToggle"> {
  buttons: ButtonOption[];
  onToggle: (value: string, event?: React.MouseEvent<HTMLButtonElement>) => void;
  defaultSelected?: string;
  fillWidth?: boolean;
  selected?: string;
  className?: string;
  style?: React.CSSProperties;
}
const SegmentedControl: React.FC<SegmentedControlProps> = ({
  buttons,
  onToggle,
  defaultSelected,
  fillWidth = true,
  selected,
  className,
  style,
  ...scrollerProps
}) => {
  const [internalSelected, setInternalSelected] = useState<string>(() => {
    if (selected !== undefined) return selected;
    if (defaultSelected !== undefined) return defaultSelected;
    return buttons[0]?.value || "";
  });
  const buttonRefs = useRef<(HTMLButtonElement | null)[]>([]);
  useEffect(() => {
    if (selected !== undefined) {
      setInternalSelected(selected);
    }
  }, [selected]);
  const handleButtonClick = (
    clickedButton: ButtonOption,
    event: React.MouseEvent<HTMLButtonElement>,
  ) => {
    event.stopPropagation();
    const newSelected = clickedButton.value;
    setInternalSelected(newSelected);
    onToggle(newSelected, event);
  };
  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
    const focusedIndex = buttonRefs.current.findIndex((ref) => ref === document.activeElement);
    switch (event.key) {
      case "ArrowLeft":
      case "ArrowUp":
        event.preventDefault();
        const prevIndex =
          focusedIndex === -1
            ? buttons.length - 1 // If nothing is focused, focus the last item
            : focusedIndex > 0
              ? focusedIndex - 1
              : buttons.length - 1;
        buttonRefs.current[prevIndex]?.focus();
        break;
      case "ArrowRight":
      case "ArrowDown":
        event.preventDefault();
        const nextIndex =
          focusedIndex === -1
            ? 0 // If nothing is focused, focus the first item
            : focusedIndex < buttons.length - 1
              ? focusedIndex + 1
              : 0;
        buttonRefs.current[nextIndex]?.focus();
        break;
      case "Enter":
      case " ": // Space key
        event.preventDefault();
        if (focusedIndex >= 0 && focusedIndex < buttons.length) {
          const focusedButton = buttons[focusedIndex];
          setInternalSelected(focusedButton.value);
          onToggle(focusedButton.value);
        }
        break;
      default:
        return;
    }
  };
  const selectedIndex = buttons.findIndex((button) => button.value === internalSelected);
  return (
    <Scroller
      direction="row"
      fillWidth={fillWidth}
      minWidth={0}
      {...scrollerProps}
      role="tablist"
      aria-orientation="horizontal"
      onKeyDown={handleKeyDown}
    >
      <Flex fillWidth={fillWidth} gap="-1">
        {buttons.map((button, index) => {
          return (
            <ToggleButton
              ref={(el) => {
                buttonRefs.current[index] = el as HTMLButtonElement;
              }}
              variant="outline"
              radius={index === 0 ? "left" : index === buttons.length - 1 ? "right" : "none"}
              key={button.value}
              selected={index === selectedIndex}
              onClick={(event) => handleButtonClick(button, event)}
              role="tab"
              className={className}
              style={style}
              aria-selected={index === selectedIndex}
              aria-controls={`panel-${button.value}`}
              tabIndex={index === selectedIndex ? 0 : -1}
              fillWidth={fillWidth}
              {...button}
            />
          );
        })}
      </Flex>
    </Scroller>
  );
};
SegmentedControl.displayName = "SegmentedControl";
export { SegmentedControl };
export type { SegmentedControlProps, ButtonOption };
</file>

<file path="src/once-ui/components/SharedInteractiveStyles.module.scss">
.container {
    cursor: var(--cursor-interactive);
    isolation: isolate;
    &:hover, &:focus {
        .element.checked .element::before {
            display: none;
        }
    }
}
.element {
    box-shadow: inset 0 0 0 var(--solid-inset-color-brand);
    border-color: var(--solid-border-color-neutral);
    border-style: solid;
    border-width: 1px;
    width: var(--static-space-20);
    height: var(--static-space-20);
    min-width: var(--static-space-20);
    min-height: var(--static-space-20);
    transition: var(--transition-micro-medium);
    background-color: var(--background-surface);
    outline: none;
    &.checked {
        box-shadow: inset 0 var(--solid-inset-distance) var(--solid-inset-size) var(--solid-inset-color-brand);
        background-color: var(--brand-solid-medium);
        border-color: var(--solid-border-color-brand);
    }
}
.disabled {
    .element {
        opacity: 0.6;
    }
    .element::before {
        display: none;
    }
}
.container:hover .element::before,
.element:focus-within::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: var(--static-space-40);
    height: var(--static-space-40);
    background-color: var(--brand-alpha-medium);
    border-radius: var(--radius-full);
    z-index: -1;
    animation: scaleInCenter 0.2s forwards;
}
@keyframes scaleInCenter {
    from {
        transform: translate(-50%, -50%) scale(0);
    }
    to {
        transform: translate(-50%, -50%) scale(1);
    }
}
.icon {
    animation: scaleIn 0.2s forwards;
    animation-delay: 0.1s;
    transform: scale(0);
}
@keyframes scaleIn {
    from {
        transform: scale(0);
    }
    to {
        transform: scale(1);
    }
}
.hidden {
    position: absolute;
    opacity: 0;
    pointer-events: none;
}
.indeterminate {
    background: var(--brand-on-solid-strong);
    width: var(--static-space-12);
    height: var(--static-space-2);
}
</file>

<file path="src/once-ui/components/Skeleton.module.scss">
@keyframes skeleton-loading {
    0% {
        background-color: var(--neutral-background-strong);
    }
    50% {
        background-color: var(--neutral-background-medium);
    }
    100% {
        background-color: var(--neutral-background-strong);
    }
}
.delay-1 {
    animation-delay: 0.1s;
}
.delay-2 {
    animation-delay: 0.2s;
}
.delay-3 {
    animation-delay: 0.3s;
}
.delay-4 {
    animation-delay: 0.4s;
}
.delay-5 {
    animation-delay: 0.5s;
}
.delay-6 {
    animation-delay: 0.6s;
}
.skeleton {
    animation-name: skeleton-loading;
    animation-duration: 1.5s;
    animation-iteration-count: infinite;
    &.block {
        width: 100%;
        height: 100%;
    }
    &.line {
        &.h-xs {
            height: var(--static-space-8);
            min-height: var(--static-space-8);
        }
        &.h-s {
            height: var(--static-space-12);
            min-height: var(--static-space-12);
        }
        &.h-m {
            height: var(--static-space-16);
            min-height: var(--static-space-16);
        }
        &.h-l {
            height: var(--static-space-20);
            min-height: var(--static-space-20);
        }
        &.h-xl {
            height: var(--static-space-24);
            min-height: var(--static-space-24);
        }
        &.w-xs {
            width: 25%;
        }
        &.w-s {
            width: 33%;
        }
        &.w-m {
            width: 50%;
        }
        &.w-l {
            width: 75%;
        }
        &.w-xl {
            width: 100%;
        }
    }
    &.circle {
        border-radius: var(--radius-full);
        &.w-xs {
            width: var(--static-space-20);
            min-width: var(--static-space-20);
            height: var(--static-space-20);
            min-height: var(--static-space-20);
        }
        &.w-s {
            width: var(--static-space-24);
            min-width: var(--static-space-24);
            height: var(--static-space-24);
            min-height: var(--static-space-24);
        }
        &.w-m {
            width: var(--static-space-32);
            min-width: var(--static-space-32);
            height: var(--static-space-32);
            min-height: var(--static-space-32);
        }
        &.w-l {
            width: var(--static-space-40);
            min-width: var(--static-space-40);
            height: var(--static-space-40);
            min-height: var(--static-space-40);
        }
        &.w-xl {
            width: var(--static-space-160);
            min-width: var(--static-space-160);
            height: var(--static-space-160);
            min-height: var(--static-space-160);
        }
    }
}
</file>

<file path="src/once-ui/components/Skeleton.tsx">
"use client";
import React, { forwardRef } from "react";
import classNames from "classnames";
import styles from "./Skeleton.module.scss";
import { Flex } from ".";
interface SkeletonProps extends React.ComponentProps<typeof Flex> {
  shape: "line" | "circle" | "block";
  width?: "xl" | "l" | "m" | "s" | "xs";
  height?: "xl" | "l" | "m" | "s" | "xs";
  delay?: "1" | "2" | "3" | "4" | "5" | "6";
  style?: React.CSSProperties;
  className?: string;
}
const Skeleton: React.FC<SkeletonProps> = forwardRef<HTMLDivElement, SkeletonProps>(
  ({ shape = "line", width = "m", height = "m", delay, style, className, ...props }, ref) => {
    return (
      <Flex
        {...props}
        ref={ref}
        style={style}
        radius={shape === "line" || shape === "circle" ? "full" : undefined}
        inline
        className={classNames(
          styles.skeleton,
          styles[shape],
          width && styles["w-" + width],
          height && styles["h-" + height],
          delay && styles["delay-" + delay],
          className,
        )}
      />
    );
  },
);
Skeleton.displayName = "Skeleton";
export { Skeleton };
</file>

<file path="src/once-ui/components/Spinner.module.scss">
@keyframes spin {
    0% {
        transform: rotate(0deg);
        animation-timing-function: cubic-bezier(0.5, 0.2, 0.7, 0.5);
        opacity: 0;
    }
    80% {
        opacity: 1;
    }
    100% {
        transform: rotate(360deg);
        animation-timing-function: cubic-bezier(0.5, 0.2, 0.7, 0.5);
        opacity: 0;
    }
}
.spinner {
    animation: spin 1.5s infinite;
    border-color: transparent;
    border-top-color: currentColor;
}
.xs {
    width: var(--static-space-16);
    height: var(--static-space-16);
    padding: 2px;
    .size {
        border-width: 2px;
    }
}
.s {
    width: var(--static-space-20);
    height: var(--static-space-20);
    padding: 2px;
    .size {
        border-width: 2px;
    }
}
.m {
    width: var(--static-space-24);
    height: var(--static-space-24);
    padding: 3px;
    .size {
        border-width: 2px;
    }
}
.l {
    width: var(--static-space-32);
    height: var(--static-space-32);
    padding: 4px;
    .size {
        border-width: 3px;
    }
}
.xl {
    width: var(--static-space-40);
    height: var(--static-space-40);
    padding: 8px;
    .size {
        border-width: 3px;
    }
}
</file>

<file path="src/once-ui/components/Spinner.tsx">
import React, { forwardRef } from "react";
import styles from "./Spinner.module.scss";
import { Flex } from ".";
import classNames from "classnames";
interface SpinnerProps extends React.ComponentProps<typeof Flex> {
  size?: "xs" | "s" | "m" | "l" | "xl";
  ariaLabel?: string;
  className?: string;
  style?: React.CSSProperties;
}
const Spinner = forwardRef<HTMLDivElement, SpinnerProps>(
  ({ size = "m", ariaLabel = "Loading", className, style, ...rest }, ref) => {
    return (
      <Flex center style={style} className={className} {...rest}>
        <Flex ref={ref} center className={styles[size]} role="status" aria-label={ariaLabel}>
          <Flex fill>
            <Flex
              className={classNames(styles.size)}
              borderStyle="solid"
              fill
              radius="full"
              border="neutral-alpha-medium"
              position="absolute"
            />
            <Flex
              className={classNames(styles.spinner, styles.size)}
              borderStyle="solid"
              fill
              radius="full"
            />
          </Flex>
        </Flex>
      </Flex>
    );
  },
);
Spinner.displayName = "Spinner";
export { Spinner };
</file>

<file path="src/once-ui/components/StatusIndicator.module.scss">
.statusIndicator {
    &.s {
        width: var(--static-space-4);
        height: var(--static-space-4);
    }
    &.m {
        width: var(--static-space-8);
        height: var(--static-space-8);
    }
    &.l {
        width: var(--static-space-16);
        height: var(--static-space-16);
    }
    &.gray {
        background-color: var(--scheme-gray-700);
    }
    &.blue {
        background-color: var(--scheme-blue-700);
    }
    &.indigo {
        background-color: var(--scheme-indigo-700);
    }
    &.violet {
        background-color: var(--scheme-violet-700);
    }
    &.magenta {
        background-color: var(--scheme-magenta-700);
    }
    &.pink {
        background-color: var(--scheme-pink-700);
    }
    &.red {
        background-color: var(--scheme-red-700);
    }
    &.orange {
        background-color: var(--scheme-orange-700);
    }
    &.yellow {
        background-color: var(--scheme-yellow-700);
    }
    &.moss {
        background-color: var(--scheme-moss-700);
    }
    &.green {
        background-color: var(--scheme-green-700);
    }
    &.emerald {
        background-color: var(--scheme-emerald-700);
    }
    &.aqua {
        background-color: var(--scheme-aqua-700);
    }
    &.cyan {
        background-color: var(--scheme-cyan-700);
    }
}
</file>

<file path="src/once-ui/components/StatusIndicator.tsx">
"use client";
import React, { forwardRef } from "react";
import classNames from "classnames";
import styles from "./StatusIndicator.module.scss";
import { Flex } from ".";
interface StatusIndicatorProps extends React.ComponentProps<typeof Flex> {
  size?: "s" | "m" | "l";
  color:
    | "blue"
    | "indigo"
    | "violet"
    | "magenta"
    | "pink"
    | "red"
    | "orange"
    | "yellow"
    | "moss"
    | "green"
    | "emerald"
    | "aqua"
    | "cyan"
    | "gray";
  ariaLabel?: string;
  className?: string;
  style?: React.CSSProperties;
}
const StatusIndicator = forwardRef<HTMLDivElement, StatusIndicatorProps>(
  (
    {
      size = "m",
      color = "blue",
      ariaLabel = `${color} status indicator`,
      className,
      style,
      ...rest
    },
    ref,
  ) => {
    return (
      <Flex
        ref={ref}
        style={style}
        className={classNames(styles.statusIndicator, styles[size], styles[color], className)}
        aria-label={ariaLabel}
        radius="full"
        {...rest}
      />
    );
  },
);
StatusIndicator.displayName = "StatusIndicator";
export { StatusIndicator };
</file>

<file path="src/once-ui/components/StyleOverlay.module.scss">
.panel {
    visibility: hidden;
    opacity: 0;
    z-index: -1;
    transform: scale(0.2);
    transform-origin: top right;
    &.open {
        transform: scale(1);
        visibility: visible;
        opacity: 1;
    }
    &:not(.open) {
        z-index: -1;
        filter: blur(0.25rem);
    }
}
</file>

<file path="src/once-ui/components/StyleOverlay.tsx">
"use client";
import { forwardRef, useState } from "react";
import { IconButton, StylePanel, Flex, Background } from ".";
import styles from "./StyleOverlay.module.scss";
interface StyleOverlayProps extends React.ComponentProps<typeof Flex> {
  iconButtonProps?: Partial<React.ComponentProps<typeof IconButton>>;
  children: React.ReactNode;
}
const StyleOverlay = forwardRef<HTMLDivElement, StyleOverlayProps>(
  ({ iconButtonProps, children, ...rest }, ref) => {
    const [isOpen, setIsOpen] = useState(false);
    const togglePanel = () => {
      setIsOpen(!isOpen);
    };
    return (
      <Flex ref={ref} position="static">
        {!isOpen && <Flex onClick={togglePanel}>{children}</Flex>}
        <Flex
          as="aside"
          zIndex={3}
          className={`${styles.panel} ${isOpen && styles.open}`}
          maxWidth={28}
          style={{
            maxHeight: "calc(100% - var(--static-space-4))",
          }}
          fillHeight
          position="absolute"
          shadow="xl"
          top="2"
          right="2"
          transition="macro-medium"
          background="page"
          overflow="hidden"
          radius="xl"
          border="neutral-medium"
          {...rest}
        >
          <StylePanel fill overflowY="scroll" padding="8" />
          <Flex position="absolute" paddingTop="8" paddingRight="12" top="0" right="0">
            <Background
              position="absolute"
              top="0"
              right="8"
              left={undefined}
              width={8}
              height={4}
              mask={{ x: 100, y: 0, radius: 7 }}
              dots={{ display: true, size: "2", color: "page-background" }}
            />
            <IconButton
              variant="secondary"
              onClick={togglePanel}
              icon="close"
              {...iconButtonProps}
            />
          </Flex>
        </Flex>
      </Flex>
    );
  },
);
StyleOverlay.displayName = "StyleOverlay";
export { StyleOverlay };
</file>

<file path="src/once-ui/components/StylePanel.module.scss">
.select {
    min-width: var(--static-space-40);
    min-height: var(--static-space-40);
    border-radius: var(--radius-m-nest-4);
    border-color: var(--static-transparent);
    border-width: 1px;
    border-style: solid;
    background: var(--static-transparent);
    &:hover {
		background: var(--neutral-alpha-medium);
		border-color: var(--neutral-alpha-medium);
    }
    &.selected {
		background: var(--neutral-alpha-strong);
		border-color: var(--neutral-alpha-strong);
    }
}
.swatch {
    width: 100%;
    height: 100%;
    border-radius: var(--radius-m);
    border-width: 1px;
    border-style: solid;
}
.slate {
    background: var(--scheme-slate-500);
    border-color: var(--scheme-slate-700);
}
.gray {
    background: var(--scheme-gray-500);
    border-color: var(--scheme-gray-700);
}
.sand {
    background: var(--scheme-sand-500);
    border-color: var(--scheme-sand-700);
}
.blue {
    background: var(--scheme-blue-500);
    border-color: var(--scheme-blue-700);
}
.cyan {
    background: var(--scheme-cyan-500);
    border-color: var(--scheme-cyan-700);
}
.indigo {
    background: var(--scheme-indigo-500);
    border-color: var(--scheme-indigo-700);
}
.violet {
    background: var(--scheme-violet-500);
    border-color: var(--scheme-violet-700);
}
.magenta {
    background: var(--scheme-magenta-500);
    border-color: var(--scheme-magenta-700);
}
.pink {
    background: var(--scheme-pink-500);
    border-color: var(--scheme-pink-700);
}
.yellow {
    background: var(--scheme-yellow-500);
    border-color: var(--scheme-yellow-700);
}
.orange {
    background: var(--scheme-orange-500);
    border-color: var(--scheme-orange-700);
}
.red {
    background: var(--scheme-red-500);
    border-color: var(--scheme-red-700);
}
.moss {
    background: var(--scheme-moss-500);
    border-color: var(--scheme-moss-700);
}
.green {
    background: var(--scheme-green-500);
    border-color: var(--scheme-green-700);
}
.emerald {
    background: var(--scheme-emerald-500);
    border-color: var(--scheme-emerald-700);
}
.aqua {
    background: var(--scheme-aqua-500);
    border-color: var(--scheme-aqua-700);
}
.neutral {
    background: var(--neutral-solid-medium);
    border-color: var(--neutral-alpha-strong);
}
</file>

<file path="src/once-ui/components/StylePanel.tsx">
"use client";
import { forwardRef, useState, useEffect } from "react";
import { Flex, Text, SegmentedControl, IconButton, Scroller, Column } from ".";
import styles from "./StylePanel.module.scss";
import classNames from "classnames";
import { style } from "@/app/resources/once-ui.config";
interface StylePanelProps extends React.ComponentProps<typeof Flex> {
  style?: React.CSSProperties;
  className?: string;
}
const shapes = ["conservative", "playful", "rounded"];
const colorOptions = {
  brand: [
    "cyan",
    "blue",
    "indigo",
    "violet",
    "magenta",
    "pink",
    "red",
    "orange",
    "yellow",
    "moss",
    "green",
    "emerald",
    "aqua",
  ],
  accent: [
    "cyan",
    "blue",
    "indigo",
    "violet",
    "magenta",
    "pink",
    "red",
    "orange",
    "yellow",
    "moss",
    "green",
    "emerald",
    "aqua",
  ],
  neutral: ["sand", "gray", "slate"],
};
const StylePanel = forwardRef<HTMLDivElement, StylePanelProps>(({ ...rest }, ref) => {
  const [selectedShape, setSelectedShape] = useState(style.border);
  const [brandColor, setBrandColor] = useState(style.brand);
  const [accentColor, setAccentColor] = useState(style.accent);
  const [neutralColor, setNeutralColor] = useState(style.neutral);
  const [theme, setTheme] = useState(style.theme);
  const [solid, setSolid] = useState(style.solid);
  const [solidStyle, setSolidStyle] = useState(style.solidStyle);
  const [transition, setTransition] = useState(style.transition);
  const [scaling, setScaling] = useState(style.scaling);
  const [surface, setSurface] = useState(style.surface);
  useEffect(() => {
    const root = document.documentElement;
    root.setAttribute("data-border", selectedShape);
    root.setAttribute("data-brand", brandColor);
    root.setAttribute("data-accent", accentColor);
    root.setAttribute("data-neutral", neutralColor);
    root.setAttribute("data-solid", solid);
    root.setAttribute("data-solid-style", solidStyle);
    root.setAttribute("data-theme", theme);
    root.setAttribute("data-transition", transition);
    root.setAttribute("data-scaling", scaling);
    root.setAttribute("data-surface", surface);
    root.setAttribute("data-transition", transition);
  }, [
    selectedShape,
    brandColor,
    accentColor,
    neutralColor,
    solid,
    solidStyle,
    theme,
    transition,
    surface,
    scaling,
  ]);
  return (
    <Column fillWidth gap="16" ref={ref} {...rest}>
      <Column fillWidth paddingTop="12" paddingLeft="16" gap="4">
        <Text variant="heading-strong-s">Page</Text>
        <Text variant="body-default-s" onBackground="neutral-weak">
          Customize global design settings
        </Text>
      </Column>
      <Column fillWidth border="neutral-alpha-medium" radius="l-4">
        <Flex
          borderBottom="neutral-alpha-medium"
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Text variant="label-default-s">Theme</Text>
          <SegmentedControl
            maxWidth={22}
            buttons={[
              { size: "l", label: "Light", value: "light", prefixIcon: "light" },
              { size: "l", label: "Dark", value: "dark", prefixIcon: "dark" },
            ]}
            onToggle={(value) => setTheme(value as "light" | "dark")}
            selected={theme}
          />
        </Flex>
        <Flex horizontal="space-between" vertical="center" fillWidth paddingX="24" paddingY="16">
          <Text variant="label-default-s">Shape</Text>
          <Flex gap="4">
            {shapes.map((radius, index) => (
              <Flex
                data-border={shapes[index]}
                key={radius}
                horizontal="center"
                vertical="center"
                className={classNames(
                  styles.select,
                  selectedShape === radius ? styles.selected : "",
                )}
                onClick={() => {
                  setSelectedShape(radius);
                }}
              >
                <IconButton variant="ghost" size="m">
                  <div className={classNames(styles.neutral, styles.swatch)}></div>
                </IconButton>
              </Flex>
            ))}
          </Flex>
        </Flex>
      </Column>
      <Column fillWidth paddingTop="12" paddingLeft="16" gap="4">
        <Text variant="heading-strong-s">Color</Text>
        <Text variant="body-default-s" onBackground="neutral-weak">
          Customize color schemes
        </Text>
      </Column>
      <Column fillWidth border="neutral-alpha-medium" radius="l-4">
        <Flex
          borderBottom="neutral-alpha-medium"
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Flex textVariant="label-default-s" minWidth={3}>
            Brand
          </Flex>
          <Scroller minWidth={0} fitWidth>
            {colorOptions.brand.map((color, index) => (
              <Flex
                marginRight="2"
                key={color}
                horizontal="center"
                vertical="center"
                className={classNames(styles.select, brandColor === color ? styles.selected : "")}
                onClick={() => {
                  setBrandColor(color);
                }}
              >
                <IconButton variant="ghost" size="m">
                  <div className={`${styles[color]} ${styles.swatch}`}></div>
                </IconButton>
              </Flex>
            ))}
          </Scroller>
        </Flex>
        <Flex
          borderBottom="neutral-alpha-medium"
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Flex textVariant="label-default-s" minWidth={3}>
            Accent
          </Flex>
          <Scroller minWidth={0} fitWidth>
            {colorOptions.accent.map((color, index) => (
              <Flex
                marginRight="2"
                key={color}
                horizontal="center"
                vertical="center"
                className={classNames(styles.select, accentColor === color ? styles.selected : "")}
                onClick={() => {
                  setAccentColor(color);
                }}
              >
                <IconButton variant="ghost" size="m">
                  <div className={`${styles[color]} ${styles.swatch}`}></div>
                </IconButton>
              </Flex>
            ))}
          </Scroller>
        </Flex>
        <Flex
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Flex textVariant="label-default-s" minWidth={3}>
            Neutral
          </Flex>
          <Scroller minWidth={0} fitWidth>
            {colorOptions.neutral.map((color, index) => (
              <Flex
                marginRight="2"
                key={color}
                horizontal="center"
                vertical="center"
                className={classNames(styles.select, neutralColor === color ? styles.selected : "")}
                onClick={() => {
                  setNeutralColor(color);
                }}
              >
                <IconButton variant="ghost" size="m">
                  <div className={`${styles[color]} ${styles.swatch}`}></div>
                </IconButton>
              </Flex>
            ))}
          </Scroller>
        </Flex>
      </Column>
      <Column fillWidth paddingTop="12" paddingLeft="16" gap="4">
        <Text variant="heading-strong-s">Solid style</Text>
        <Text variant="body-default-s" onBackground="neutral-weak">
          Customize the appearance of interactive elements
        </Text>
      </Column>
      <Column fillWidth border="neutral-alpha-medium" radius="l-4">
        <Flex
          borderBottom="neutral-alpha-medium"
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Text variant="label-default-s">Style</Text>
          <SegmentedControl
            maxWidth={22}
            minWidth={0}
            buttons={[
              {
                size: "l",
                label: (
                  <Flex vertical="center" gap="12">
                    <Flex
                      data-solid="color"
                      border="brand-strong"
                      solid="brand-weak"
                      width="24"
                      height="24"
                      radius="s"
                    ></Flex>
                    Color
                  </Flex>
                ),
                value: "color",
              },
              {
                size: "l",
                label: (
                  <Flex vertical="center" gap="12">
                    <Flex
                      data-solid="inverse"
                      border="brand-strong"
                      solid="brand-strong"
                      width="24"
                      height="24"
                      radius="s"
                    ></Flex>
                    Inverse
                  </Flex>
                ),
                value: "inverse",
              },
              {
                size: "l",
                label: (
                  <Flex vertical="center" gap="12">
                    <Flex
                      data-solid="contrast"
                      border="brand-strong"
                      solid="brand-strong"
                      width="24"
                      height="24"
                      radius="s"
                    ></Flex>
                    Contrast
                  </Flex>
                ),
                value: "contrast",
              },
            ]}
            onToggle={(value) => setSolid(value as "color" | "contrast" | "inverse")}
            selected={solid}
          />
        </Flex>
        <Flex
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Text variant="label-default-s">Effect</Text>
          <SegmentedControl
            maxWidth={22}
            minWidth={0}
            buttons={[
              {
                size: "l",
                label: (
                  <Flex vertical="center" gap="12">
                    <Flex
                      border="brand-strong"
                      solid="brand-weak"
                      width="24"
                      height="24"
                      radius="s"
                    ></Flex>
                    Flat
                  </Flex>
                ),
                value: "flat",
              },
              {
                size: "l",
                label: (
                  <Flex vertical="center" gap="12">
                    <Flex
                      border="brand-strong"
                      style={{
                        boxShadow:
                          "inset 0 calc(-1 * var(--static-space-8)) var(--static-space-8) var(--brand-solid-strong)",
                      }}
                      solid="brand-weak"
                      width="24"
                      height="24"
                      radius="s"
                    ></Flex>
                    Plastic
                  </Flex>
                ),
                value: "plastic",
              },
            ]}
            onToggle={(value) => setSolidStyle(value as "flat" | "plastic")}
            selected={solidStyle}
          />
        </Flex>
      </Column>
      <Column fillWidth paddingTop="12" paddingLeft="16" gap="4">
        <Text variant="heading-strong-s">Advanced</Text>
        <Text variant="body-default-s" onBackground="neutral-weak">
          Customize advanced styling options
        </Text>
      </Column>
      <Column fillWidth border="neutral-alpha-medium" radius="l-4">
        <Flex
          borderBottom="neutral-alpha-medium"
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Text variant="label-default-s">Surface</Text>
          <SegmentedControl
            maxWidth={22}
            minWidth={0}
            onToggle={(value) => setSurface(value as "translucent" | "filled")}
            selected={surface}
            buttons={[
              {
                size: "l",
                label: "Filled",
                value: "filled",
              },
              {
                size: "l",
                label: "Translucent",
                value: "translucent",
              },
            ]}
          />
        </Flex>
        <Flex
          borderBottom="neutral-alpha-medium"
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Text variant="label-default-s">Scaling</Text>
          <SegmentedControl
            maxWidth={22}
            minWidth={0}
            onToggle={(value) => setScaling(value as "90" | "95" | "100" | "105" | "110")}
            selected={scaling}
            buttons={[
              {
                size: "l",
                label: "90",
                value: "90",
              },
              {
                size: "l",
                label: "95",
                value: "95",
              },
              {
                size: "l",
                label: "100",
                value: "100",
              },
              {
                size: "l",
                label: "105",
                value: "105",
              },
              {
                size: "l",
                label: "110",
                value: "110",
              },
            ]}
          />
        </Flex>
        <Flex
          horizontal="space-between"
          vertical="center"
          fillWidth
          paddingX="24"
          paddingY="16"
          gap="24"
        >
          <Text variant="label-default-s">Transition</Text>
          <SegmentedControl
            maxWidth={22}
            minWidth={0}
            onToggle={(value) => setTransition(value as "all" | "micro" | "macro" | "none")}
            selected={transition}
            buttons={[
              {
                size: "l",
                label: "All",
                value: "all",
              },
              {
                size: "l",
                label: "Micro",
                value: "micro",
              },
              {
                size: "l",
                label: "Macro",
                value: "macro",
              },
              {
                size: "l",
                label: "None",
                value: "none",
              },
            ]}
          />
        </Flex>
      </Column>
    </Column>
  );
});
StylePanel.displayName = "StylePanel";
export { StylePanel };
</file>

<file path="src/once-ui/components/Switch.module.scss">
.container {
    cursor: var(--cursor-interactive);
    isolation: isolate;
    &:active {
        .element {
            transform: translateY(-50%) scaleX(1.2);
        }
    }
    &:hover {
        .switch {
            background-color: var(--neutral-solid-strong);
        }
        .switch.checked {
            background-color: var(--brand-solid-strong);
        }
        .switch.checked .element::before {
            display: none;
        }
    }
}
.reverse {
    flex-direction: row-reverse;
}
.switch {
    box-shadow: inset 0 0 0 var(--solid-inset-color-brand);
    border-color: var(--solid-border-color-neutral);
    border-style: solid;
    border-width: var(--solid-border-width);
    width: var(--static-space-40);
    min-width: var(--static-space-40);
    height: var(--static-space-24);
    border-radius: var(--radius-l-nest-4);
    background-color: var(--neutral-solid-medium);
    position: relative;
    transition: var(--transition-micro-medium);
    &.checked {
        box-shadow: inset 0 var(--solid-inset-distance) var(--solid-inset-size) var(--solid-inset-color-brand);
        background-color: var(--brand-solid-medium);
        border-color: var(--solid-border-color-brand);
        .element {
            left: calc(100% - var(--static-space-20));
            transform-origin: right;
        }
    }
}
.element {
    z-index: 1;
    transform-origin: left;
    width: var(--static-space-16);
    height: var(--static-space-16);
    border-radius: var(--radius-l);
    background-color: var(--brand-on-solid-strong);
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    left: var(--static-space-4);
    transition: left 0.3s, transform 0.3s;
    outline: none;
}
.disabled {
    .switch {
        opacity: 0.4;
    }
    .element::before {
        display: none !important;
    }
}
.container:hover .element::before,
.element:focus-within::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: var(--static-space-40);
    height: var(--static-space-40);
    background-color: var(--brand-alpha-medium);
    border-radius: var(--radius-full);
    z-index: -1;
    animation: scaleInCenter 0.2s forwards;
}
@keyframes scaleInCenter {
    from {
        transform: translate(-50%, -50%) scale(0);
    }
    to {
        transform: translate(-50%, -50%) scale(1);
    }
}
</file>

<file path="src/once-ui/components/Switch.tsx">
"use client";
import React, { forwardRef } from "react";
import classNames from "classnames";
import { Flex, InteractiveDetails, InteractiveDetailsProps, Spinner } from ".";
import styles from "./Switch.module.scss";
import commonStyles from "./SharedInteractiveStyles.module.scss";
interface SwitchProps
  extends Omit<InteractiveDetailsProps, "onClick">,
    React.InputHTMLAttributes<HTMLInputElement> {
  style?: React.CSSProperties;
  className?: string;
  isChecked: boolean;
  loading?: boolean;
  name?: string;
  value?: string;
  disabled?: boolean;
  reverse?: boolean;
  ariaLabel?: string;
  onToggle: () => void;
}
const Switch: React.FC<SwitchProps> = forwardRef<HTMLInputElement, SwitchProps>(
  (
    {
      className,
      isChecked,
      reverse = false,
      loading = false,
      onToggle,
      ariaLabel = "Toggle switch",
      disabled,
      name,
      value,
      ...props
    },
    ref,
  ) => {
    const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (!disabled && (event.key === "Enter" || event.key === " ")) {
        event.preventDefault();
        onToggle();
      }
    };
    const handleClick = () => {
      if (!disabled) {
        onToggle();
      }
    };
    return (
      <Flex
        gap="16"
        vertical="center"
        horizontal={reverse ? "space-between" : undefined}
        fillWidth={reverse}
        className={classNames(styles.container, className, {
          [styles.reverse]: reverse,
          [styles.disabled]: disabled,
        })}
        onClick={handleClick}
        role="switch"
        aria-checked={isChecked}
        aria-label={ariaLabel}
        aria-disabled={disabled}
        tabIndex={-1}
      >
        <input
          ref={ref}
          type="checkbox"
          name={name}
          value={value}
          checked={isChecked}
          onChange={onToggle}
          className={commonStyles.hidden}
          tabIndex={-1}
        />
        <Flex
          cursor={disabled ? "not-allowed" : undefined}
          className={classNames(styles.switch, {
            [styles.checked]: isChecked,
            [styles.disabled]: disabled,
          })}
        >
          <div
            onKeyDown={handleKeyDown}
            tabIndex={disabled ? -1 : 0}
            className={classNames(styles.element, {
              [styles.checked]: isChecked,
              [styles.disabled]: disabled,
            })}
          >
            {loading && <Spinner size="xs" />}
          </div>
        </Flex>
        {props.label && <InteractiveDetails disabled={disabled} {...props} onClick={() => {}} />}
      </Flex>
    );
  },
);
Switch.displayName = "Switch";
export { Switch };
</file>

<file path="src/once-ui/components/Table.module.scss">
.hover {
    &:hover {
        background-color: var(--neutral-alpha-weak);
    }
}
</file>

<file path="src/once-ui/components/Table.tsx">
"use client";
import { Flex, Row, IconButton } from ".";
import { useState, ReactNode } from "react";
import styles from "./Table.module.scss";
type TableProps = React.ComponentProps<typeof Flex> & {
  data: {
    headers: {
      content: ReactNode;
      key: string;
      sortable?: boolean;
    }[];
    rows: ReactNode[][];
  };
  onRowClick?: (rowIndex: number) => void;
};
function Table({ data, onRowClick, ...flex }: TableProps) {
  const [sortConfig, setSortConfig] = useState<{
    key: string;
    direction: "ascending" | "descending";
  } | null>(null);
  const handleSort = (key: string) => {
    let direction: "ascending" | "descending" = "ascending";
    if (sortConfig && sortConfig.key === key) {
      direction = sortConfig.direction === "ascending" ? "descending" : "ascending";
    }
    setSortConfig({ key, direction });
  };
  const sortedRows = [...data.rows].sort((a, b) => {
    if (!sortConfig) return 0;
    const headerIndex = data.headers.findIndex((header) => header.key === sortConfig.key);
    if (headerIndex === -1) return 0;
    const aValue = String(a[headerIndex]);
    const bValue = String(b[headerIndex]);
    if (sortConfig.direction === "ascending") {
      return aValue.localeCompare(bValue);
    } else {
      return bValue.localeCompare(aValue);
    }
  });
  const headers = data.headers.map((header, index) => (
    <th
      style={{ textAlign: "left", borderBottom: "1px solid var(--neutral-alpha-medium)" }}
      className="px-16 py-12 font-label font-default font-s"
      key={index}
    >
      <Row gap="8" vertical="center">
        {header.content}
        {header.sortable && (
          <IconButton
            icon={
              sortConfig?.key === header.key
                ? sortConfig.direction === "ascending"
                  ? "chevronUp"
                  : "chevronDown"
                : "chevronDown"
            }
            size="s"
            variant="ghost"
            onClick={(e: React.MouseEvent) => {
              e.stopPropagation();
              handleSort(header.key);
            }}
            style={{
              opacity: sortConfig?.key === header.key ? 1 : 0.6,
            }}
          />
        )}
      </Row>
    </th>
  ));
  const rows = (sortConfig ? sortedRows : data.rows).map((row, index) => (
    <tr
      key={index}
      onClick={onRowClick ? () => onRowClick(index) : undefined}
      className={onRowClick ? "cursor-interactive " + styles.hover : ""}
      style={onRowClick ? { transition: "background-color 0.2s ease" } : undefined}
    >
      {row.map((cell, cellIndex) => (
        <td className="px-16 py-12 font-body font-default font-s" key={cellIndex}>
          {cell}
        </td>
      ))}
    </tr>
  ));
  return (
    <Row
      fillWidth
      radius="l"
      overflowY="hidden"
      border="neutral-alpha-medium"
      overflowX="auto"
      marginTop="8"
      marginBottom="16"
      {...flex}
    >
      <style jsx>{`
        .hover-row:hover {
          background-color: var(--neutral-alpha-weak);
        }
      `}</style>
      <table
        className="fill-width surface-background"
        style={{ borderSpacing: 0, borderCollapse: "collapse", minWidth: "32rem" }}
      >
        <thead className="neutral-on-background-strong">
          <tr>{headers}</tr>
        </thead>
        <tbody className="neutral-on-background-medium">
          {rows.length > 0 ? (
            rows
          ) : (
            <tr>
              <td colSpan={headers.length} className="px-24 py-12 font-body font-default font-s">
                No data available
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </Row>
  );
}
export { Table };
</file>

<file path="src/once-ui/components/Tag.module.scss">
.tag {
    white-space: nowrap;
    user-select: none;
    &.brand {
        border-color: var(--brand-border-strong);
        background-color: var(--brand-background-strong);
        color: var(--brand-on-background-medium);
    }
    &.accent {
        border-color: var(--accent-border-strong);
        background-color: var(--accent-background-strong);
        color: var(--accent-on-background-medium);
    }
    &.neutral {
        border-color: var(--neutral-border-medium);
        background-color: var(--surface-background);
        color: var(--neutral-on-background-medium);
    }
    &.warning {
        border-color: var(--warning-border-strong);
        background-color: var(--warning-background-strong);
        color: var(--warning-on-background-medium);
    }
    &.danger {
        border-color: var(--danger-border-strong);
        background-color: var(--danger-background-strong);
        color: var(--danger-on-background-medium);
    }
    &.success {
        border-color: var(--success-border-strong);
        background-color: var(--success-background-strong);
        color: var(--success-on-background-medium);
    }
    &.info {
        border-color: var(--info-border-strong);
        background-color: var(--info-background-strong);
        color: var(--info-on-background-medium);
    }
    &.gradient {
        border-color: var(--brand-alpha-medium);
        background-image: linear-gradient(45deg, var(--brand-background-strong), var(--accent-background-strong));
        color: var(--brand-on-background-medium);
        background-clip: padding-box;
    }
}
.s {
    padding: 0 var(--static-space-4);
}
.m {
    padding: var(--static-space-2) var(--static-space-8);
}
.l {
    padding: var(--static-space-4) var(--static-space-12);
}
</file>

<file path="src/once-ui/components/Tag.tsx">
"use client";
import React, { forwardRef, ReactNode } from "react";
import classNames from "classnames";
import { Flex, Text, Icon } from ".";
import styles from "./Tag.module.scss";
import { IconName } from "../icons";
interface TagProps extends React.ComponentProps<typeof Flex> {
  variant?: "brand" | "accent" | "warning" | "success" | "danger" | "neutral" | "info" | "gradient";
  size?: "s" | "m" | "l";
  label?: string;
  prefixIcon?: IconName;
  suffixIcon?: IconName;
  children?: ReactNode;
}
const Tag = forwardRef<HTMLDivElement, TagProps>(
  (
    {
      variant = "neutral",
      size = "m",
      label = "",
      prefixIcon,
      suffixIcon,
      className,
      children,
      ...rest
    },
    ref,
  ) => {
    const paddingSize = size === "s" ? "2" : "4";
    return (
      <Flex
        fitWidth
        borderWidth={1}
        borderStyle="solid"
        vertical="center"
        radius="l"
        gap="4"
        ref={ref}
        className={classNames(styles.tag, styles[variant], styles[size], className)}
        {...rest}
      >
        {prefixIcon && <Icon name={prefixIcon} size="xs" />}
        <Flex style={{ userSelect: "none" }} paddingX={paddingSize} vertical="center">
          <Text as="span" variant="label-default-s">
            {label || children}
          </Text>
        </Flex>
        {suffixIcon && <Icon name={suffixIcon} size="xs" />}
      </Flex>
    );
  },
);
Tag.displayName = "Tag";
export { Tag };
export type { TagProps };
</file>

<file path="src/once-ui/components/TagInput.tsx">
"use client";
import React, {
  useState,
  KeyboardEventHandler,
  ChangeEventHandler,
  FocusEventHandler,
  forwardRef,
} from "react";
import { Flex, Chip, Input, InputProps } from ".";
interface TagInputProps extends Omit<InputProps, "onChange" | "value"> {
  value: string[];
  onChange: (value: string[]) => void;
}
const TagInput = forwardRef<HTMLInputElement, TagInputProps>(
  ({ value, onChange, label, placeholder, ...inputProps }, ref) => {
    const [inputValue, setInputValue] = useState("");
    const [isFocused, setIsFocused] = useState(false);
    const handleInputChange: ChangeEventHandler<HTMLInputElement> = (e) => {
      setInputValue(e.target.value);
    };
    const handleKeyDown: KeyboardEventHandler<HTMLInputElement> = (e) => {
      if (e.key === "Enter" || e.key === ",") {
        e.preventDefault();
        if (inputValue.trim()) {
          onChange([...value, inputValue.trim()]);
          setInputValue("");
        }
      }
    };
    const handleRemoveTag = (index: number) => {
      const newValue = value.filter((_, i) => i !== index);
      onChange(newValue);
    };
    const handleFocus: FocusEventHandler<HTMLInputElement> = () => {
      setIsFocused(true);
    };
    const handleBlur: FocusEventHandler<HTMLInputElement> = (e) => {
      setIsFocused(false);
    };
    return (
      <Input
        ref={ref}
        label={label}
        placeholder={placeholder}
        value={inputValue}
        onChange={handleInputChange}
        onKeyDown={handleKeyDown}
        onFocus={handleFocus}
        onBlur={handleBlur}
        aria-haspopup="listbox"
        aria-expanded={isFocused}
        {...inputProps}
      >
        {value.length > 0 && (
          <Flex
            style={{
              margin: "calc(-1 * var(--static-space-8)) var(--static-space-8)",
            }}
            direction="row"
            gap="4"
            vertical="center"
            wrap
            paddingY="16"
          >
            {value.map((tag, index) => (
              <Chip
                key={index}
                label={tag}
                onRemove={() => handleRemoveTag(index)}
                aria-label={`Remove tag ${tag}`}
              />
            ))}
          </Flex>
        )}
      </Input>
    );
  },
);
TagInput.displayName = "TagInput";
export { TagInput };
export type { TagInputProps };
</file>

<file path="src/once-ui/components/Textarea.tsx">
"use client";
import React, {
  useState,
  useEffect,
  forwardRef,
  TextareaHTMLAttributes,
  useCallback,
  ReactNode,
} from "react";
import classNames from "classnames";
import { Flex, Text } from ".";
import styles from "./Input.module.scss";
import useDebounce from "../hooks/useDebounce";
interface TextareaProps extends TextareaHTMLAttributes<HTMLTextAreaElement> {
  id: string;
  label?: string;
  placeholder?: string;
  lines?: number | "auto";
  error?: boolean;
  errorMessage?: ReactNode;
  description?: ReactNode;
  radius?:
    | "none"
    | "top"
    | "right"
    | "bottom"
    | "left"
    | "top-left"
    | "top-right"
    | "bottom-right"
    | "bottom-left";
  className?: string;
  hasPrefix?: ReactNode;
  hasSuffix?: ReactNode;
  resize?: "horizontal" | "vertical" | "both" | "none";
  validate?: (value: ReactNode) => ReactNode | null;
}
const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(
  (
    {
      id,
      label,
      placeholder,
      lines = 3,
      error = false,
      errorMessage,
      description,
      radius,
      className,
      hasPrefix,
      hasSuffix,
      resize = "vertical",
      validate,
      children,
      onFocus,
      onBlur,
      onChange,
      style,
      ...props
    },
    ref,
  ) => {
    const [isFocused, setIsFocused] = useState(false);
    const [isFilled, setIsFilled] = useState(!!props.value);
    const [validationError, setValidationError] = useState<ReactNode | null>(null);
    const [height, setHeight] = useState<number | undefined>(undefined);
    const textareaRef = React.useRef<HTMLTextAreaElement>(null);
    const debouncedValue = useDebounce(props.value, 1000);
    const adjustHeight = () => {
      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
        textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`; // Set to scroll height
      }
    };
    const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
      if (lines === "auto") {
        adjustHeight();
      }
      if (onChange) onChange(event);
    };
    const handleFocus = (event: React.FocusEvent<HTMLTextAreaElement>) => {
      setIsFocused(true);
      if (onFocus) onFocus(event);
    };
    const handleBlur = (event: React.FocusEvent<HTMLTextAreaElement>) => {
      setIsFocused(false);
      setIsFilled(!!event.target.value);
      if (onBlur) onBlur(event);
    };
    const validateInput = useCallback(() => {
      if (!debouncedValue) {
        setValidationError(null);
        return;
      }
      if (validate) {
        const error = validate(debouncedValue);
        if (error) {
          setValidationError(error);
        } else {
          setValidationError(errorMessage || null);
        }
      } else {
        setValidationError(null);
      }
    }, [debouncedValue, validate, errorMessage]);
    useEffect(() => {
      validateInput();
    }, [debouncedValue, validateInput]);
    useEffect(() => {
      if (lines === "auto") {
        adjustHeight();
      }
    }, [props.value, lines]);
    const displayError = validationError || errorMessage;
    const textareaClassNames = classNames(
      styles.input,
      styles.textarea,
      "font-body",
      "font-default",
      "font-m",
      {
        [styles.filled]: isFilled,
        [styles.focused]: isFocused,
        [styles.withPrefix]: hasPrefix,
        [styles.withSuffix]: hasSuffix,
        [styles.placeholder]: placeholder,
        [styles.hasChildren]: children,
      },
    );
    return (
      <Flex
        direction="column"
        gap="8"
        fillWidth
        fitHeight
        className={classNames(className, {
          [styles.error]: displayError && debouncedValue !== "",
        })}
      >
        <Flex
          minHeight={placeholder ? "48" : "56"}
          transition="micro-medium"
          border="neutral-medium"
          background="neutral-alpha-weak"
          overflow="hidden"
          vertical="stretch"
          className={classNames(
            styles.base,
            lines !== "auto" && resize !== "none" && styles.textareaBase,
            radius === "none" ? "radius-none" : radius ? `radius-l-${radius}` : "radius-l",
          )}
        >
          {hasPrefix && (
            <Flex paddingLeft="12" className={styles.prefix}>
              {hasPrefix}
            </Flex>
          )}
          <Flex fillWidth direction="column">
            <textarea
              {...props}
              ref={(node) => {
                if (typeof ref === "function") {
                  ref(node);
                } else if (ref) {
                  ref.current = node;
                }
                // @ts-ignore
                textareaRef.current = node;
              }}
              id={id}
              rows={typeof lines === "number" ? lines : 1}
              placeholder={placeholder}
              onFocus={handleFocus}
              onBlur={handleBlur}
              className={textareaClassNames}
              aria-describedby={displayError ? `${id}-error` : undefined}
              aria-invalid={!!displayError}
              style={{
                ...style,
                resize: lines === "auto" ? "none" : resize,
                height: height ? `${height}rem` : "auto",
              }}
              onChange={handleChange}
            />
            {!placeholder && (
              <Text
                as="label"
                variant="label-default-m"
                htmlFor={id}
                className={classNames(styles.label, styles.textareaLabel, {
                  [styles.floating]: isFocused || isFilled,
                })}
              >
                {label}
              </Text>
            )}
            {children}
          </Flex>
          {hasSuffix && (
            <Flex paddingRight="12" className={styles.suffix}>
              {hasSuffix}
            </Flex>
          )}
        </Flex>
        {displayError && errorMessage !== false && (
          <Flex paddingX="16">
            <Text as="span" id={`${id}-error`} variant="body-default-s" onBackground="danger-weak">
              {displayError}
            </Text>
          </Flex>
        )}
        {description && (
          <Flex paddingX="16">
            <Text
              as="span"
              id={`${id}-description`}
              variant="body-default-s"
              onBackground="neutral-weak"
            >
              {description}
            </Text>
          </Flex>
        )}
      </Flex>
    );
  },
);
Textarea.displayName = "Textarea";
export { Textarea };
export type { TextareaProps };
</file>

<file path="src/once-ui/components/ThemeProvider.tsx">
"use client";
import { createContext, useContext, useEffect, useState } from "react";
type Theme = "dark" | "light" | "system";
type ThemeProviderState = {
  theme: Theme;
  resolvedTheme: "light" | "dark";
  setTheme: (theme: Theme) => void;
};
type ThemeProviderProps = {
  children: React.ReactNode;
  initial?: Theme;
};
const initialState: ThemeProviderState = {
  theme: "system",
  resolvedTheme: "dark",
  setTheme: () => null,
};
const ThemeProviderContext = createContext<ThemeProviderState>(initialState);
export function ThemeProvider({ children, initial = "system" }: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(initial);
  const [resolvedTheme, setResolvedTheme] = useState<"light" | "dark">("dark");
  const [mounted, setMounted] = useState(false);
  useEffect(() => {
    const savedTheme = localStorage.getItem("theme") as Theme;
    if (savedTheme) {
      setTheme(savedTheme);
    } else if (initial !== "system") {
      setTheme(initial);
    }
    setMounted(true);
  }, [initial]);
  useEffect(() => {
    if (!mounted) return;
    const updateResolvedTheme = () => {
      if (theme === "system") {
        const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light";
        setResolvedTheme(systemTheme);
        document.documentElement.setAttribute("data-theme", systemTheme);
      } else {
        setResolvedTheme(theme);
        document.documentElement.setAttribute("data-theme", theme);
      }
    };
    updateResolvedTheme();
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = () => {
      if (theme === "system") {
        updateResolvedTheme();
      }
    };
    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, [theme, mounted]);
  const value = {
    theme,
    resolvedTheme,
    setTheme: (newTheme: Theme) => {
      localStorage.setItem("theme", newTheme);
      setTheme(newTheme);
    },
  };
  return <ThemeProviderContext.Provider value={value}>{children}</ThemeProviderContext.Provider>;
}
export const useTheme = () => {
  const context = useContext(ThemeProviderContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};
</file>

<file path="src/once-ui/components/ThemeSwitcher.tsx">
"use client";
import React, { forwardRef } from "react";
import { Row, useTheme, IconButton } from ".";
const ThemeSwitcher = forwardRef<HTMLDivElement, React.ComponentProps<typeof Row>>((flex, ref) => {
  const { theme, setTheme } = useTheme();
  return (
    <Row
      data-border="rounded"
      ref={ref}
      gap="2"
      border="neutral-alpha-weak"
      radius="full"
      {...flex}
    >
      <IconButton
        icon="computer"
        variant={theme === "system" ? "primary" : "tertiary"}
        onClick={() => setTheme("system")}
      />
      <IconButton
        icon="dark"
        variant={theme === "dark" ? "primary" : "tertiary"}
        onClick={() => setTheme("dark")}
      />
      <IconButton
        icon="light"
        variant={theme === "light" ? "primary" : "tertiary"}
        onClick={() => setTheme("light")}
      />
    </Row>
  );
});
ThemeSwitcher.displayName = "ThemeSwitcher";
export { ThemeSwitcher };
</file>

<file path="src/once-ui/components/TiltFx.module.scss">
.tiltFx {
    transition: transform 0.3s ease-out;
}
@media (hover: hover) {
    .tiltFx {
        perspective: 1000px;
        transform-style: preserve-3d;
        will-change: transform;
    }
}
</file>

<file path="src/once-ui/components/TiltFx.tsx">
"use client";
import React, { useRef } from "react";
import styles from "./TiltFx.module.scss";
import { Flex } from ".";
interface TiltFxProps extends React.ComponentProps<typeof Flex> {
  children: React.ReactNode;
}
const TiltFx: React.FC<TiltFxProps> = ({ children, ...rest }) => {
  const ref = useRef<HTMLDivElement>(null);
  let lastCall = 0;
  let resetTimeout: NodeJS.Timeout;
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if ("ontouchstart" in window) return;
    clearTimeout(resetTimeout);
    const now = Date.now();
    if (now - lastCall < 16) return;
    lastCall = now;
    const element = ref.current;
    if (!element) return;
    const rect = element.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    const deltaX = (offsetX - centerX) / centerX;
    const deltaY = (offsetY - centerY) / centerY;
    const rotateX = -deltaY * 2;
    const rotateY = -deltaX * 2;
    window.requestAnimationFrame(() => {
      element.style.transform = `perspective(1000px) translate3d(0, 0, 30px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
    });
  };
  const handleMouseLeave = () => {
    if ("ontouchstart" in window) return;
    const element = ref.current;
    if (element) {
      resetTimeout = setTimeout(() => {
        element.style.transform =
          "perspective(1000px) translate3d(0, 0, 0) rotateX(0deg) rotateY(0deg)";
      }, 100);
    }
  };
  return (
    <Flex
      ref={ref}
      overflow="hidden"
      className={styles.tiltFx}
      onMouseMove={handleMouseMove}
      onMouseLeave={handleMouseLeave}
      {...rest}
    >
      {children}
    </Flex>
  );
};
export { TiltFx };
TiltFx.displayName = "TiltFx";
</file>

<file path="src/once-ui/components/Toast.module.scss">
.toast {
    transition: opacity 0.3s, transform 0.3s;
}
.visible {
    opacity: 1;
}
.hidden {
    opacity: 0;
}
</file>

<file path="src/once-ui/components/Toast.tsx">
"use client";
import React, { useEffect, useState, forwardRef } from "react";
import { IconButton, Icon, Flex, Row } from ".";
import classNames from "classnames";
import styles from "./Toast.module.scss";
import { IconName } from "../icons";
interface ToastProps {
  className?: string;
  variant: "success" | "danger";
  icon?: boolean;
  onClose?: () => void;
  action?: React.ReactNode;
  children: React.ReactNode;
}
const iconMap: { [key in ToastProps["variant"]]: IconName } = {
  success: "check",
  danger: "danger",
};
const Toast = forwardRef<HTMLDivElement, ToastProps>(
  ({ variant, className, icon = true, onClose, action, children }, ref) => {
    const [visible, setVisible] = useState(true);
    useEffect(() => {
      const timer = setTimeout(() => setVisible(false), 6000);
      return () => clearTimeout(timer);
    }, []);
    useEffect(() => {
      if (!visible && onClose) {
        onClose();
      }
    }, [visible, onClose]);
    return (
      <Flex
        ref={ref}
        fillWidth
        background="surface"
        radius="l"
        paddingY="12"
        paddingX="20"
        border="neutral-medium"
        role="alert"
        aria-live="assertive"
        className={classNames(className, styles.toast, styles[variant], {
          [styles.visible]: visible,
          [styles.hidden]: !visible,
        })}
      >
        <Flex fillWidth vertical="center" gap="8">
          {icon && <Icon size="s" onBackground={`${variant}-medium`} name={iconMap[variant]} />}
          <Row fillWidth textVariant="body-default-s">
            {children}
          </Row>
          {action && action}
          {onClose && (
            <IconButton
              variant="ghost"
              icon="close"
              size="m"
              tooltip="Hide"
              tooltipPosition="top"
              onClick={() => setVisible(false)}
            />
          )}
        </Flex>
      </Flex>
    );
  },
);
Toast.displayName = "Toast";
export { Toast };
</file>

<file path="src/once-ui/components/Toaster.module.scss">
.toastContainer {
    bottom: var(--responsive-space-l);
    left: 50%;
    transform: translateX(-50%);
}
.toastWrapper {
    bottom: 0;
    transition: transform 0.3s, opacity 0.3s;
}
.toastAnimation {
    animation: fadeIn 0.3s ease-out forwards;
}
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(4rem);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
</file>

<file path="src/once-ui/components/Toaster.tsx">
"use client";
import React, { useEffect, useState } from "react";
import { createPortal } from "react-dom";
import { Flex, Toast } from ".";
import styles from "./Toaster.module.scss";
interface ToasterProps {
  toasts: {
    id: string;
    variant: "success" | "danger";
    message: React.ReactNode;
    action?: React.ReactNode;
  }[];
  removeToast: (id: string) => void;
}
const Toaster: React.FC<ToasterProps> = ({ toasts, removeToast }) => {
  const [mounted, setMounted] = useState(false);
  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);
  if (!mounted) return null;
  return createPortal(
    <Flex
      zIndex={10}
      fillWidth
      direction="column"
      maxWidth={32}
      position="fixed"
      className={styles.toastContainer}
    >
      {toasts.map((toast, index, array) => (
        <Flex
          padding="4"
          fillWidth
          position="absolute"
          key={toast.id}
          className={styles.toastWrapper}
          style={{
            transformOrigin: "bottom center",
            transform: `scale(${1 - (array.length - 1 - index) * 0.05}) translateY(${1 - (array.length - 1 - index) * 10}%)`,
            opacity: array.length - 1 - index === 0 ? 1 : 0.9,
          }}
        >
          <Toast
            className={styles.toastAnimation}
            variant={toast.variant}
            onClose={() => removeToast(toast.id)}
            action={toast.action}
          >
            {toast.message}
          </Toast>
        </Flex>
      ))}
    </Flex>,
    document.body,
  );
};
Toaster.displayName = "Toaster";
export { Toaster };
</file>

<file path="src/once-ui/components/ToastProvider.tsx">
"use client";
import React, { createContext, useContext, useState, ReactNode } from "react";
import { Toaster } from ".";
interface Toast {
  id: string;
  variant: "success" | "danger";
  message: ReactNode;
  action?: ReactNode;
}
interface ToastContextProps {
  toasts: Toast[];
  addToast: (toast: Omit<Toast, "id">) => void;
  removeToast: (id: string) => void;
}
const ToastContext = createContext<ToastContextProps | undefined>(undefined);
export const useToast = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
};
const ToastProvider: React.FC<{
  children: ReactNode;
}> = ({ children }) => {
  // Use the same Toast interface type for the state
  const [toasts, setToasts] = useState<Toast[]>([]);
  const addToast = (toast: Omit<Toast, "id">) => {
    const newToast: Toast = {
      id: Math.random().toString(36).substring(7),
      ...toast,
    };
    setToasts((prev) => [...prev, newToast]);
  };
  const removeToast = (id: string) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  };
  return (
    <ToastContext.Provider
      value={{
        toasts,
        addToast,
        removeToast,
      }}
    >
      {children}
      <Toaster toasts={toasts} removeToast={removeToast} />
    </ToastContext.Provider>
  );
};
ToastProvider.displayName = "ToastProvider";
export { ToastProvider };
</file>

<file path="src/once-ui/components/ToggleButton.module.scss">
.button {
    display: flex;
    align-items: center;
    gap: var(--static-space-8);
    border-width: 1px;
    border-style: solid;
    background: var(--static-transparent);
    color: var(--neutral-on-background-strong);
    transition: var(--transition-micro-medium);
	user-select: none;
    white-space: nowrap;
    &:hover, &:focus {
        background: var(--neutral-alpha-weak);
        border-color: var(--neutral-alpha-weak);
    }
    &.selected {
        background-color: var(--neutral-alpha-medium);
        border-color: var(--neutral-alpha-weak);
    }
    &:disabled {
        background: var(--neutral-alpha-weak);
        color: var(--neutral-on-background-medium);
		border: none;
		pointer-events: none;
		cursor: not-allowed;
    }
}
.s {
    height: var(--static-space-24);
    min-height: var(--static-space-24);
    padding: var(--static-space-2) var(--static-space-8);
}
.m {
    height: var(--static-space-32);
    min-height: var(--static-space-32);
    padding: var(--static-space-4) var(--static-space-12);
}
.l {
    height: var(--static-space-40);
    min-height: var(--static-space-40);
    padding: var(--static-space-8) var(--static-space-16);
}
.ghost {
    border-color: var(--static-transparent);
}
.outline {
    border-color: var(--neutral-alpha-weak);
}
</file>

<file path="src/once-ui/components/ToggleButton.tsx">
"use client";
import React, { forwardRef, ReactNode } from "react";
import classNames from "classnames";
import { Flex, Icon, ElementType } from ".";
import styles from "./ToggleButton.module.scss";
import { IconName } from "../icons";
interface CommonProps {
  label?: ReactNode;
  selected?: boolean;
  variant?: "ghost" | "outline";
  size?: "s" | "m" | "l";
  radius?:
    | "none"
    | "top"
    | "right"
    | "bottom"
    | "left"
    | "top-left"
    | "top-right"
    | "bottom-right"
    | "bottom-left";
  horizontal?: "start" | "center" | "end" | "space-between";
  fillWidth?: boolean;
  weight?: "default" | "strong";
  truncate?: boolean;
  prefixIcon?: IconName;
  suffixIcon?: IconName;
  className?: string;
  style?: React.CSSProperties;
  children?: ReactNode;
  href?: string;
}
export type ToggleButtonProps = CommonProps & React.ButtonHTMLAttributes<HTMLButtonElement>;
const ToggleButton = forwardRef<HTMLElement, ToggleButtonProps>(
  (
    {
      label,
      selected = false,
      variant = "ghost",
      size = "m",
      radius,
      horizontal = "center",
      fillWidth = false,
      weight = "default",
      truncate = false,
      prefixIcon,
      suffixIcon,
      className,
      style,
      children,
      href,
      ...props
    },
    ref,
  ) => {
    return (
      <ElementType
        ref={ref}
        href={href}
        className={classNames(
          styles.button,
          styles[variant],
          styles[size],
          selected && styles.selected,
          radius === "none"
            ? "radius-none"
            : radius
              ? `radius-${size}-${radius}`
              : `radius-${size}`,
          "text-decoration-none",
          "button",
          "cursor-interactive",
          {
            ["fill-width"]: fillWidth,
            ["fit-width"]: !fillWidth,
            ["justify-" + horizontal]: horizontal,
          },
          className,
        )}
        style={style}
        {...props}
      >
        {prefixIcon && <Icon name={prefixIcon} size={size === "l" ? "s" : "xs"} />}
        {(label || children) && (
          <Flex
            fillWidth={fillWidth}
            horizontal={horizontal}
            padding={size === "s" ? "2" : "4"}
            textWeight={weight}
            textSize={size === "l" ? "m" : "s"}
            className="font-label"
            position="static"
          >
            {label || children}
          </Flex>
        )}
        {suffixIcon && <Icon name={suffixIcon} size={size === "l" ? "s" : "xs"} />}
      </ElementType>
    );
  },
);
ToggleButton.displayName = "ToggleButton";
export { ToggleButton };
</file>

<file path="src/once-ui/components/Tooltip.tsx">
"use client";
import React, { forwardRef, ReactNode } from "react";
import classNames from "classnames";
import { Flex, Icon } from ".";
import { IconName } from "../icons";
interface TooltipProps extends React.ComponentProps<typeof Flex> {
  label: ReactNode;
  prefixIcon?: IconName;
  suffixIcon?: IconName;
  className?: string;
  style?: React.CSSProperties;
}
const Tooltip = forwardRef<HTMLDivElement, TooltipProps>(
  ({ label, prefixIcon, suffixIcon, className, style, ...flex }, ref) => {
    return (
      <Flex
        hide="m"
        ref={ref}
        style={{
          whiteSpace: "nowrap",
          userSelect: "none",
          ...style,
        }}
        vertical="center"
        gap="4"
        zIndex={1}
        background="surface"
        paddingY="4"
        paddingX="8"
        radius="s"
        border="neutral-medium"
        role="tooltip"
        className={classNames(className)}
        {...flex}
      >
        {prefixIcon && <Icon name={prefixIcon} size="xs" />}
        <Flex
          paddingX="2"
          vertical="center"
          textVariant="body-default-xs"
          onBackground="neutral-strong"
        >
          {label}
        </Flex>
        {suffixIcon && <Icon name={suffixIcon} size="xs" />}
      </Flex>
    );
  },
);
Tooltip.displayName = "Tooltip";
export { Tooltip };
</file>

<file path="src/once-ui/components/User.tsx">
"use client";
import React, { forwardRef } from "react";
import classNames from "classnames";
import { Flex, Text, Skeleton, Tag, TagProps, Avatar, AvatarProps } from ".";
interface UserProps {
  name?: string;
  children?: React.ReactNode;
  subline?: React.ReactNode;
  tag?: string;
  tagProps?: TagProps;
  loading?: boolean;
  avatarProps?: AvatarProps;
  className?: string;
}
const User = forwardRef<HTMLDivElement, UserProps>(
  (
    { name, children, subline, tagProps = {}, loading = false, avatarProps = {}, className },
    ref,
  ) => {
    const { src, value, empty, ...restAvatarProps } = avatarProps;
    const isEmpty = empty || (!src && !value);
    return (
      <Flex ref={ref} vertical="center" gap="8" className={classNames(className)}>
        <Avatar
          size="m"
          src={src}
          value={value}
          empty={isEmpty}
          loading={loading}
          {...restAvatarProps}
        />
        {children}
        {name && (
          <Flex direction="column" paddingLeft="4" paddingRight="12">
            {loading ? (
              <Flex minWidth={6} paddingY="4">
                <Skeleton width="xl" height="m" shape="line" aria-label="Loading name" />
              </Flex>
            ) : (
              <Flex gap="8" vertical="center">
                <Text variant="heading-strong-xs" onBackground="neutral-strong">
                  {name}
                </Text>
                {tagProps.label && (
                  <Tag size="s" {...tagProps}>
                    {tagProps.label}
                  </Tag>
                )}
              </Flex>
            )}
            {loading ? (
              <Flex paddingY="2">
                <Skeleton width="l" height="xs" shape="line" aria-label="Loading subline" />
              </Flex>
            ) : (
              <Text wrap="nowrap" variant="body-default-xs" onBackground="neutral-weak">
                {subline}
              </Text>
            )}
          </Flex>
        )}
      </Flex>
    );
  },
);
User.displayName = "User";
export { User };
export type { UserProps };
</file>

<file path="src/once-ui/components/UserMenu.module.scss">
.wrapper {
    border: 1px solid var(--static-transparent);
    transition: var(--transition-micro-medium);
    &:hover {
        background-color: var(--neutral-alpha-weak);
        border: 1px solid var(--neutral-alpha-medium);
    }
    &.selected:hover {
        background-color: var(--neutral-background-strong);
        border: 1px solid var(--neutral-border-strong);
    }
}
</file>

<file path="src/once-ui/hooks/generateHeadingLinks.ts">
import { useEffect, useState } from "react";
export const useHeadingLinks = () => {
  const [headings, setHeadings] = useState<{ id: string; text: string; level: number }[]>([]);
  useEffect(() => {
    const elements = Array.from(document.querySelectorAll("h2, h3, h4, h5, h6"))
      .filter((elem) => !elem.hasAttribute("data-exclude-nav"))
      .map((elem, index) => ({
        id: elem.id || `heading-${index}`,
        text: elem.textContent || "",
        level: Number(elem.tagName.substring(1)),
      }));
    setHeadings(elements);
  }, []);
  return headings;
};
</file>

<file path="src/once-ui/hooks/useDebounce.ts">
import { useEffect, useState } from "react";
function useDebounce(value: any, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
}
export default useDebounce;
</file>

<file path="src/once-ui/hooks/useFetchOg.ts">
import { useState, useEffect } from "react";
interface OgData {
  title: string;
  description: string;
  image: string;
  url: string;
  faviconUrl?: string;
}
export function useOgData(url: string | null) {
  const [ogData, setOgData] = useState<Partial<OgData> | null>(null);
  const [loading, setLoading] = useState(!!url);
  useEffect(() => {
    const fetchOgData = async () => {
      try {
        const response = await fetch(`/api/og/fetch?url=${encodeURIComponent(url!)}`);
        const data = await response.json();
        if (data.error) {
          throw new Error(data.message || data.error);
        }
        setOgData(data);
      } catch (error) {
        console.error("Error fetching og data:", error);
        setOgData(null);
      } finally {
        setLoading(false);
      }
    };
    if (url) {
      fetchOgData();
    } else {
      setLoading(false);
      setOgData(null);
    }
  }, [url]);
  return { ogData, loading };
}
export function useOgImage(url: string | null) {
  const { ogData, loading } = useOgData(url);
  return { ogImage: ogData?.image || null, loading };
}
</file>

<file path="src/once-ui/modules/code/CodeBlock.module.scss">
.pre {
    display: flex;
    isolation: isolate;
    font-family: var(--font-family-code);
    color: var(--neutral-on-background-strong);
    font-size: var(--font-size-body-s);
    white-space: pre;
    width: 100%;
    tab-size: 2;
    margin: 0;
    height: fit-content;
    width: 100%;
    min-height: var(--static-space-32);
    tab-size: 2;
    line-height: 1.75;
}
.padding {
    padding: var(--static-space-8);
}
.lineNumberPadding {
    padding: var(--static-space-8) var(--static-space-8) var(--static-space-8) var(--static-space-40);
}
.code {
    flex: 1;
    width: 100%;
    margin: auto;
    padding: 0 var(--static-space-12);
    font-family: inherit;
}
.fullscreen {
    position: fixed;
    left: var(--static-space-8);
    top: var(--static-space-8);
    right: var(--static-space-8);
    bottom: var(--static-space-8);
    width: calc(100% - var(--static-space-16)) !important;
    height: calc(100% - var(--static-space-16)) !important;
    z-index: 9;
}
</file>

<file path="src/once-ui/modules/code/CodeHighlight.css">
.token.plain-text {
  color: var(--neutral-on-background-strong);
}
.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: var(--code-moss);
}
.token.punctuation {
  color: var(--code-gray);
}
.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
  color: var(--code-aqua);
}
.token.boolean,
.token.number {
  color: var(--code-green);
}
.token.attr-name {
  color: var(--code-orange);
}
.token.selector,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: var(--code-blue);
}
.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: var(--code-gray);
}
.token.atrule,
.token.attr-value,
.token.keyword {
  color: var(--code-violet);
}
.token.function,
.token.class-name {
  color: var(--code-blue);
}
.token.regex,
.token.important,
.token.variable {
  color: var(--code-orange);
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
.token.entity {
  cursor: help;
}
@media print {
  .line-highlight {
    print-color-adjust: exact;
    color-adjust: exact;
  }
}
.line-highlight {
  position: absolute;
  background-color: var(--brand-alpha-weak);
  border-left: 2px solid var(--brand-alpha-strong);
  width: 100%;
  left: 0;
  margin-top: var(--static-space-8);
  z-index: 0;
}
.line-numbers .line-highlight:before,
.line-numbers .line-highlight:after {
  content: none;
}
</file>

<file path="src/once-ui/modules/code/LineNumber.css">
.line-numbers {
  position: relative;
  counter-reset: linenumber;
}
.line-numbers > code {
  position: relative;
  white-space: inherit;
}
.line-numbers-rows {
  padding-right: var(--static-space-4);
  left: calc(-1 * var(--static-space-40));
  position: absolute;
  pointer-events: none;
  top: 0;
  font-size: 100%;
  width: var(--static-space-48);
  user-select: none;
}
.line-numbers-rows > span {
  display: block;
  counter-increment: linenumber;
}
.line-numbers-rows > span:before {
  content: counter(linenumber);
  color: var(--neutral-on-background-weak);
  display: block;
  padding-right: var(--static-space-8);
  text-align: right;
  transform: scale(0.9);
}
</file>

<file path="src/once-ui/modules/code/prismjs.d.ts">
declare module "prismjs" {
  const Prism: {
    highlightAll: () => void;
    highlight: (code: string, grammar: any, language: string) => string;
    languages: {
      [language: string]: any;
    };
  };
  export default Prism;
}
</file>

<file path="src/once-ui/modules/data/utils/colorDistribution.ts">
import { schemes } from "../../../types";
/**
 * Returns a color from the schemes array with even distribution
 * Instead of sequential colors (0,1,2), this distributes them evenly across the color spectrum
 * For small sets (2-4 items), uses a predefined optimal distribution
 * @param index The index of the item in the series
 * @param totalItems Total number of items in the series (if known)
 * @returns A color from the schemes array
 */
export const getDistributedColor = (index: number, totalItems?: number): string => {
  const totalColors = schemes.length;
  // For small sets, use predefined optimal distributions
  if (totalItems) {
    // Special case for 3 items - use blue, orange, cyan (maximally distinct)
    if (totalItems === 3) {
      const optimalIndices = [0, 6, 12]; // blue, orange, cyan
      return schemes[optimalIndices[index % 3]];
    }
    // Special case for 2 items - use blue and orange (complementary colors)
    if (totalItems === 2) {
      const optimalIndices = [0, 6]; // blue, orange
      return schemes[optimalIndices[index % 2]];
    }
    // Special case for 4 items - use blue, orange, green, magenta (balanced tetrad)
    if (totalItems === 4) {
      const optimalIndices = [0, 6, 9, 3]; // blue, orange, green, magenta
      return schemes[optimalIndices[index % 4]];
    }
    // For 5+ items, use a more sophisticated distribution
    if (totalItems > 1) {
      // Use a prime number as step to avoid repetitive patterns
      // and ensure better distribution across the spectrum
      const step = Math.max(1, Math.floor(totalColors / totalItems));
      const offset = Math.floor(totalColors / (2 * totalItems)); // Add offset for better distribution
      return schemes[(index * step + offset) % totalColors];
    }
  }
  // If we don't know the total or there's only one item,
  // use a simple distribution based on the golden ratio
  // This creates a visually pleasing distribution even as items are added one by one
  const goldenRatioConjugate = 0.618033988749895;
  const hue = (index * goldenRatioConjugate) % 1;
  const colorIndex = Math.floor(hue * totalColors);
  return schemes[colorIndex];
};
</file>

<file path="src/once-ui/modules/data/utils/formatDate.ts">
import { format, parseISO } from "date-fns";
import { DateConfig } from "../interfaces";
/**
 * Formats a value as a date if it's a valid date and a format is provided
 * Otherwise returns the original value or label if available
 *
 * @param value - The value to format (could be a date, string, or any other value)
 * @param dateConfig - Optional date configuration with format string
 * @param dataPoint - Optional data point object that might contain a label property
 * @returns Formatted date string or original value
 */
export function formatDate(
  value: any,
  dateConfig?: DateConfig,
  dataPoint?: Record<string, any>,
): string {
  if (dataPoint?.label) {
    return dataPoint.label;
  }
  if (dateConfig?.format) {
    try {
      // Check if it's already a Date object
      if (value instanceof Date) {
        return format(value, dateConfig.format);
      }
      // Check if it's an ISO date string
      if (typeof value === "string" && /^\d{4}-\d{2}-\d{2}/.test(value)) {
        return format(parseISO(value), dateConfig.format);
      }
    } catch (error) {}
  }
  return value;
}
</file>

<file path="src/once-ui/modules/data/BarChart.tsx">
"use client";
import React, { useState, useEffect, useMemo } from "react";
import { formatDate } from "./utils/formatDate";
import {
  BarChart as RechartsBarChart,
  Bar as RechartsBar,
  XAxis as RechartsXAxis,
  YAxis as RechartsYAxis,
  ResponsiveContainer as RechartsResponsiveContainer,
  CartesianGrid as RechartsCartesianGrid,
  Tooltip as RechartsTooltip,
  Legend as RechartsLegend,
} from "recharts";
import { Column, Row, DateRange } from "../../components";
import { getDistributedColor } from "./utils/colorDistribution";
import {
  ChartProps,
  LinearGradient,
  Tooltip,
  Legend,
  ChartStyles,
  ChartStatus,
  ChartHeader,
  barWidth,
} from ".";
import { chart } from "../../../app/resources/data.config";
interface BarChartProps extends ChartProps {
  barWidth?: barWidth;
  hover?: boolean;
}
const BarChart: React.FC<BarChartProps> = ({
  title,
  description,
  data,
  series,
  date,
  emptyState,
  loading = false,
  legend: legendProp = {},
  axis = "both",
  border = "neutral-medium",
  variant = chart.variant,
  barWidth = "l",
  hover = false,
  ...flex
}) => {
  const legend = {
    display: legendProp.display !== undefined ? legendProp.display : true,
    position: legendProp.position || "top-left",
    direction: legendProp.direction,
  };
  const [selectedDateRange, setSelectedDateRange] = useState<DateRange | undefined>(
    date?.start && date?.end
      ? {
          startDate: date.start,
          endDate: date.end,
        }
      : undefined,
  );
  useEffect(() => {
    if (date?.start && date?.end) {
      setSelectedDateRange({
        startDate: date.start,
        endDate: date.end,
      });
    }
  }, [date?.start, date?.end]);
  const handleDateRangeChange = (newRange: DateRange) => {
    setSelectedDateRange(newRange);
    if (date?.onChange) {
      date.onChange(newRange);
    }
  };
  const seriesArray = Array.isArray(series) ? series : series ? [series] : [];
  const seriesKeys = seriesArray.map((s) => s.key);
  const chartId = React.useMemo(() => Math.random().toString(36).substring(2, 9), []);
  const coloredSeriesArray = seriesArray.map((s, index) => ({
    ...s,
    color: s.color || getDistributedColor(index, seriesArray.length),
  }));
  const xAxisKey = Object.keys(data[0] || {}).find((key) => !seriesKeys.includes(key)) || "name";
  const autoKeys = Object.keys(data[0] || {}).filter((key) => key !== xAxisKey);
  const autoSeries =
    seriesArray.length > 0
      ? coloredSeriesArray
      : autoKeys.map((key, index) => ({
          key,
          color: getDistributedColor(index, autoKeys.length),
        }));
  const barColors = autoSeries.map((s) => `var(--data-${s.color})`);
  const filteredData = React.useMemo(() => {
    if (!selectedDateRange || !data || data.length === 0) {
      return data;
    }
    return data.filter((item) => {
      try {
        if (!item[xAxisKey] || !selectedDateRange.startDate || !selectedDateRange.endDate) {
          return true;
        }
        const itemDate =
          typeof item[xAxisKey] === "string"
            ? new Date(item[xAxisKey] as string)
            : (item[xAxisKey] as Date);
        return itemDate >= selectedDateRange.startDate && itemDate <= selectedDateRange.endDate;
      } catch (e) {
        return true;
      }
    });
  }, [data, selectedDateRange, xAxisKey]);
  return (
    <Column fillWidth height={chart.height} border={border} radius="l" {...flex}>
      <ChartHeader
        title={title}
        description={description}
        borderBottom={border}
        dateRange={selectedDateRange}
        date={date}
        onDateRangeChange={handleDateRangeChange}
        presets={date?.presets}
      />
      <Row fill>
        <ChartStatus
          loading={loading}
          isEmpty={!filteredData || filteredData.length === 0}
          emptyState={emptyState}
        />
        {!loading && filteredData && filteredData.length > 0 && (
          <RechartsResponsiveContainer width="100%" height="100%">
            <RechartsBarChart
              data={filteredData}
              margin={{ left: 0, bottom: 0, top: 0, right: 0 }}
              barGap={4}
            >
              <RechartsCartesianGrid
                horizontal
                vertical={false}
                stroke="var(--neutral-alpha-weak)"
              />
              {legend.display && (
                <RechartsLegend
                  content={(props) => {
                    const customPayload = autoSeries.map((series, index) => ({
                      value: series.key,
                      color: barColors[index],
                    }));
                    return (
                      <Legend
                        variant={variant as ChartStyles}
                        payload={customPayload}
                        labels={axis}
                        position={legend.position}
                        direction={legend.direction}
                      />
                    );
                  }}
                  wrapperStyle={{
                    position: "absolute",
                    top:
                      legend.position === "top-center" ||
                      legend.position === "top-left" ||
                      legend.position === "top-right"
                        ? 0
                        : undefined,
                    bottom:
                      legend.position === "bottom-center" ||
                      legend.position === "bottom-left" ||
                      legend.position === "bottom-right"
                        ? 0
                        : undefined,
                    paddingBottom:
                      legend.position === "bottom-center" ||
                      legend.position === "bottom-left" ||
                      legend.position === "bottom-right"
                        ? "var(--static-space-40)"
                        : undefined,
                    left:
                      (axis === "y" || axis === "both") &&
                      (legend.position === "top-center" || legend.position === "bottom-center")
                        ? "var(--static-space-64)"
                        : 0,
                    width:
                      (axis === "y" || axis === "both") &&
                      (legend.position === "top-center" || legend.position === "bottom-center")
                        ? "calc(100% - var(--static-space-64))"
                        : "100%",
                    right: 0,
                    margin: 0,
                  }}
                />
              )}
              <RechartsXAxis
                dataKey={xAxisKey}
                axisLine={false}
                tickLine={false}
                tick={
                  axis === "x" || axis === "both"
                    ? {
                        fill: chart.tick.fill,
                        fontSize: chart.tick.fontSize,
                      }
                    : false
                }
                tickFormatter={(value) => {
                  const dataPoint = data.find((item) => item[xAxisKey] === value);
                  return formatDate(value, date, dataPoint);
                }}
                hide={!(axis === "x" || axis === "both")}
              />
              {(axis === "y" || axis === "both") && (
                <RechartsYAxis
                  allowDataOverflow
                  width={64}
                  padding={{ top: 40 }}
                  tickLine={false}
                  tick={{
                    fill: chart.tick.fill,
                    fontSize: chart.tick.fontSize,
                  }}
                  axisLine={{
                    stroke: chart.axisLine.stroke,
                  }}
                />
              )}
              <RechartsTooltip
                cursor={{ fill: hover ? "var(--neutral-alpha-weak)" : "var(--static-transparent)" }}
                content={(props) => (
                  <Tooltip {...props} date={date} variant={variant as ChartStyles} />
                )}
              />
              <defs>
                {barColors.map((color, index) => (
                  <LinearGradient
                    key={`gradient-${chartId}-${index}`}
                    id={`barGradient${chartId}${index}`}
                    color={color}
                    variant={variant as ChartStyles}
                  />
                ))}
              </defs>
              {autoSeries.map((series, index) => (
                <RechartsBar
                  key={series.key}
                  dataKey={series.key}
                  name={series.key}
                  fill={`url(#barGradient${chartId}${index})`}
                  stroke={barColors[index]}
                  strokeWidth={1}
                  transform="translate(0, -1)"
                  barSize={
                    typeof barWidth === "string" && barWidth === "fill"
                      ? "100%"
                      : typeof barWidth === "string" && barWidth === "xs"
                        ? 12
                        : typeof barWidth === "string" && barWidth === "s"
                          ? 16
                          : typeof barWidth === "string" && barWidth === "m"
                            ? 24
                            : typeof barWidth === "string" && barWidth === "l"
                              ? 40
                              : typeof barWidth === "string" && barWidth === "xl"
                                ? 64
                                : barWidth
                  }
                  radius={
                    barWidth === "fill" || barWidth === "xl" ? [10, 10, 10, 10] : [6, 6, 6, 6]
                  }
                />
              ))}
            </RechartsBarChart>
          </RechartsResponsiveContainer>
        )}
      </Row>
    </Column>
  );
};
BarChart.displayName = "BarChart";
export { BarChart };
export type { BarChartProps };
</file>

<file path="src/once-ui/modules/data/ChartStatus.tsx">
"use client";
import React from "react";
import { Column, Text, Spinner } from "../../components";
export interface ChartStatusProps {
  loading?: boolean;
  isEmpty?: boolean;
  emptyState?: React.ReactNode;
}
export const ChartStatus: React.FC<ChartStatusProps> = ({
  loading = false,
  isEmpty = false,
  emptyState = "No data available for the selected period",
}) => {
  if (!loading && !isEmpty) {
    return null;
  }
  return (
    <Column fill center>
      {loading ? (
        <Spinner size="m" />
      ) : (
        isEmpty && (
          <Text variant="label-default-s" onBackground="neutral-weak">
            {emptyState}
          </Text>
        )
      )}
    </Column>
  );
};
</file>

<file path="src/once-ui/modules/data/Gradient.tsx">
"use client";
import React from "react";
import { chart } from "../../../app/resources/data.config";
import { ChartStyles } from "./interfaces";
interface GradientStop {
  offset: string;
  opacity: number;
  variant?: ChartStyles;
}
interface LinearGradientProps {
  id: string;
  color: string;
  x1?: string;
  y1?: string;
  x2?: string;
  y2?: string;
  stops?: GradientStop[];
  variant?: ChartStyles;
}
interface RadialGradientProps {
  id: string;
  color: string;
  cx?: string;
  cy?: string;
  r?: string;
  fx?: string;
  fy?: string;
  stops?: GradientStop[];
  variant?: ChartStyles;
}
const getStopsByVariant = (
  variant: ChartStyles = "gradient",
  isRadial: boolean = false,
): GradientStop[] => {
  if (isRadial) {
    // For radial gradients, we invert the opacity for better visual effect
    switch (variant) {
      case "flat":
        return [
          { offset: "0%", opacity: 1 },
          { offset: "100%", opacity: 1 },
        ];
      case "outline":
        return [
          { offset: "0%", opacity: 0 },
          { offset: "100%", opacity: 0 },
        ];
      case "gradient":
      default:
        return [
          { offset: "0%", opacity: 0 },
          { offset: "100%", opacity: 1 },
        ];
    }
  } else {
    // For linear gradients
    switch (variant) {
      case "flat":
        return [
          { offset: "0%", opacity: 1 },
          { offset: "100%", opacity: 1 },
        ];
      case "outline":
        return [
          { offset: "0%", opacity: 0 },
          { offset: "100%", opacity: 0 },
        ];
      case "gradient":
      default:
        return [
          { offset: "0%", opacity: 1 },
          { offset: "100%", opacity: 0 },
        ];
    }
  }
};
export const LinearGradient: React.FC<LinearGradientProps> = ({
  id,
  color,
  x1 = "0",
  y1 = "0",
  x2 = "0",
  y2 = "1",
  stops,
  variant = chart.variant,
}) => {
  const gradientStops = stops || getStopsByVariant(variant as ChartStyles);
  return (
    <linearGradient id={id} x1={x1} y1={y1} x2={x2} y2={y2}>
      {gradientStops.map((stop, index) => (
        <stop key={index} offset={stop.offset} stopColor={color} stopOpacity={stop.opacity} />
      ))}
    </linearGradient>
  );
};
export const RadialGradient: React.FC<RadialGradientProps> = ({
  id,
  color,
  cx = "50%",
  cy = "50%",
  r = "50%",
  fx = "50%",
  fy = "50%",
  stops,
  variant = chart.variant,
}) => {
  const gradientStops = stops || getStopsByVariant(variant as ChartStyles, true);
  return (
    <radialGradient id={id} cx={cx} cy={cy} r={r} fx={fx} fy={fy}>
      {gradientStops.map((stop, index) => (
        <stop key={index} offset={stop.offset} stopColor={color} stopOpacity={stop.opacity} />
      ))}
    </radialGradient>
  );
};
</file>

<file path="src/once-ui/modules/data/index.ts">
export * from "./interfaces";
export * from "./LineChart";
export * from "./BarChart";
export * from "./PieChart";
export * from "./LineBarChart";
export * from "./ChartHeader";
export * from "./ChartStatus";
export * from "./Gradient";
export * from "./Tooltip";
export * from "./Legend";
export * from "./Swatch";
</file>

<file path="src/once-ui/modules/data/interfaces.ts">
import { DateRange } from "@/once-ui/components";
import { Flex } from "../../components";
import { TShirtSizes } from "@/once-ui/types";
import { CurveType } from "recharts/types/shape/Curve";
type ChartStyles = "flat" | "gradient" | "outline";
type barWidth = TShirtSizes | "fill" | number;
type curveType = CurveType;
interface DataPoint {
  [key: string]: string | number | Date | undefined;
  label?: string;
}
interface SeriesConfig {
  key: string;
  color?: string;
}
interface PresetsConfig {
  display: boolean;
  granularity: "year" | "month" | "week";
}
interface DateConfig {
  start?: Date;
  end?: Date;
  max?: Date;
  min?: Date;
  dual?: boolean;
  format?: string;
  presets?: PresetsConfig;
  selector?: boolean;
  onChange?: (range: DateRange) => void;
}
interface legendConfig {
  display?: boolean;
  direction?: "row" | "column";
  position?:
    | "top-left"
    | "top-right"
    | "bottom-left"
    | "bottom-right"
    | "top-center"
    | "bottom-center";
}
interface ChartProps extends Omit<React.ComponentProps<typeof Flex>, "title" | "description"> {
  title?: React.ReactNode;
  description?: React.ReactNode;
  series: SeriesConfig | SeriesConfig[];
  data: DataPoint[];
  legend?: legendConfig;
  date?: DateConfig;
  emptyState?: React.ReactNode;
  axis?: "x" | "y" | "both" | "none";
  variant?: ChartStyles;
  loading?: boolean;
}
export type {
  DataPoint,
  SeriesConfig,
  DateConfig,
  PresetsConfig,
  ChartProps,
  ChartStyles,
  barWidth,
  curveType,
};
</file>

<file path="src/once-ui/modules/data/Legend.tsx">
"use client";
import React from "react";
import { Row, Text } from "../../components";
import { Swatch } from "./Swatch";
import { chart } from "../../../app/resources/data.config";
import { ChartStyles } from "./interfaces";
interface LegendProps {
  payload?: any[];
  labels?: "x" | "y" | "both" | "none";
  colors?: string[];
  direction?: "row" | "column";
  position?:
    | "top-left"
    | "top-right"
    | "bottom-left"
    | "bottom-right"
    | "top-center"
    | "bottom-center";
  variant?: ChartStyles;
}
const Legend: React.FC<LegendProps> = ({
  payload,
  labels = "both",
  position = "top-left",
  direction,
  colors,
  variant = chart.variant,
}) => {
  if (!payload || !payload.length) {
    return null;
  }
  const getPositionStyle = () => {
    switch (position) {
      case "top-left":
        return {
          paddingLeft:
            labels === "y" || labels === "both"
              ? "var(--static-space-80)"
              : "var(--static-space-20)",
          top: "var(--static-space-12)",
        };
      case "top-right":
        return {
          paddingRight: "var(--static-space-20)",
          top: "var(--static-space-12)",
          justifyContent: "flex-end",
        };
      case "bottom-left":
        return {
          paddingLeft: "var(--static-space-20)",
          bottom: "var(--static-space-12)",
        };
      case "bottom-right":
        return {
          paddingRight: "var(--static-space-20)",
          bottom: "var(--static-space-12)",
          justifyContent: "flex-end",
        };
      case "top-center":
        return {
          left: "50%",
          top: "var(--static-space-12)",
          transform: "translateX(-50%)",
        };
      case "bottom-center":
        return {
          left: "50%",
          bottom: "var(--static-space-12)",
          transform: "translateX(-50%)",
        };
      default:
        return {
          paddingLeft:
            labels === "y" || labels === "both"
              ? "var(--static-space-80)"
              : "var(--static-space-20)",
          top: "0.75rem",
        };
    }
  };
  const positionStyle = getPositionStyle();
  return (
    <Row
      wrap
      fillWidth
      horizontal={
        position === "top-left" ||
        position === "top-right" ||
        position === "bottom-left" ||
        position === "bottom-right"
          ? "start"
          : "center"
      }
      vertical="center"
      position="absolute"
      gap="16"
      pointerEvents="none"
      direction={direction}
      style={positionStyle}
    >
      {payload.map((entry: any, index: number) => {
        const color = colors && colors[index] ? colors[index] : entry.stroke || entry.color;
        return (
          <Row key={index} vertical="center" gap="8">
            <Swatch color={color} size="m" variant={variant as ChartStyles} />
            <Text variant="label-default-s" wrap="nowrap">
              {entry.value}
            </Text>
          </Row>
        );
      })}
    </Row>
  );
};
export { Legend };
export type { LegendProps };
</file>

<file path="src/once-ui/modules/data/LineBarChart.tsx">
"use client";
import React, { useState, useEffect, useMemo } from "react";
import { isWithinInterval, parseISO } from "date-fns";
import { formatDate } from "./utils/formatDate";
import {
  ComposedChart as RechartsComposedChart,
  Bar as RechartsBar,
  XAxis as RechartsXAxis,
  YAxis as RechartsYAxis,
  CartesianGrid as RechartsCartesianGrid,
  Tooltip as RechartsTooltip,
  ResponsiveContainer as RechartsResponsiveContainer,
  Legend as RechartsLegend,
  Area as RechartsArea,
} from "recharts";
import { Column, Row, DateRange } from "../../components";
import {
  LinearGradient,
  ChartHeader,
  Tooltip,
  Legend,
  ChartStatus,
  ChartProps,
  SeriesConfig,
  ChartStyles,
  barWidth,
  curveType,
} from ".";
import { chart } from "@/app/resources/data.config";
interface LineBarChartProps extends ChartProps {
  barWidth?: barWidth;
  curve?: curveType;
}
const LineBarChart: React.FC<LineBarChartProps> = ({
  title,
  description,
  data,
  series,
  date,
  emptyState,
  loading = false,
  legend: legendProp = {},
  axis = "both",
  border = "neutral-medium",
  variant = chart.variant,
  barWidth = "fill",
  curve = "natural",
  ...flex
}) => {
  const legend = {
    display: legendProp.display !== undefined ? legendProp.display : true,
    position: legendProp.position || "top-left",
    direction: legendProp.direction,
  };
  const [selectedDateRange, setSelectedDateRange] = useState<DateRange | undefined>(
    date?.start && date?.end
      ? {
          startDate: date.start,
          endDate: date.end,
        }
      : undefined,
  );
  useEffect(() => {
    if (date?.start && date?.end) {
      setSelectedDateRange({
        startDate: date.start,
        endDate: date.end,
      });
    }
  }, [date?.start, date?.end]);
  const allSeriesArray = Array.isArray(series) ? series : series ? [series] : [];
  const seriesKeys = allSeriesArray.map((s: SeriesConfig) => s.key);
  const xAxisKey = Object.keys(data[0] || {}).find((key) => !seriesKeys.includes(key)) || "name";
  const filteredData = React.useMemo(() => {
    if (selectedDateRange?.startDate && selectedDateRange?.endDate && xAxisKey) {
      const startDate = selectedDateRange.startDate;
      const endDate = selectedDateRange.endDate;
      if (startDate instanceof Date && endDate instanceof Date) {
        return data.filter((item) => {
          try {
            const itemDateValue = item[xAxisKey];
            if (!itemDateValue) return false;
            const itemDate =
              typeof itemDateValue === "string" ? parseISO(itemDateValue) : (itemDateValue as Date);
            return isWithinInterval(itemDate, {
              start: startDate,
              end: endDate,
            });
          } catch (error) {
            return false;
          }
        });
      }
    }
    return data;
  }, [data, selectedDateRange, xAxisKey]);
  const handleDateRangeChange = (newRange: DateRange) => {
    setSelectedDateRange(newRange);
    if (date?.onChange) {
      date.onChange(newRange);
    }
  };
  const chartSeriesArray = Array.isArray(series) ? series : series ? [series] : [];
  if (chartSeriesArray.length < 2) {
    console.warn("LineBarChart requires at least 2 series (one for line, one for bar)");
  }
  const lineSeries = chartSeriesArray[0] || { key: "value1", color: "blue" };
  const barSeries = chartSeriesArray[1] || { key: "value2", color: "green" };
  const lineColor = lineSeries.color || "blue";
  const barColor = barSeries.color || "green";
  const finalLineColor = `var(--data-${lineColor})`;
  const finalBarColor = `var(--data-${barColor})`;
  const chartId = React.useMemo(() => Math.random().toString(36).substring(2, 9), []);
  return (
    <Column fillWidth height={chart.height} border={border} radius="l" {...flex}>
      <ChartHeader
        title={title}
        description={description}
        borderBottom={border}
        dateRange={selectedDateRange}
        date={date}
        onDateRangeChange={handleDateRangeChange}
        presets={date?.presets}
      />
      <Row fill>
        <ChartStatus
          loading={loading}
          isEmpty={!filteredData || filteredData.length === 0}
          emptyState={emptyState}
        />
        {!loading && filteredData && filteredData.length > 0 && (
          <RechartsResponsiveContainer width="100%" height="100%">
            <RechartsComposedChart
              data={filteredData}
              margin={{ left: 0, bottom: 0, top: 0, right: 0 }}
              barGap={4}
            >
              <defs>
                <LinearGradient
                  id={`barGradient${chartId}`}
                  color={finalBarColor}
                  variant={variant as ChartStyles}
                />
                <LinearGradient
                  id={`lineGradient${chartId}`}
                  color={finalLineColor}
                  variant={variant as ChartStyles}
                />
              </defs>
              <RechartsCartesianGrid
                horizontal
                vertical={false}
                stroke="var(--neutral-alpha-weak)"
              />
              {legend.display && (
                <RechartsLegend
                  content={
                    <Legend
                      variant={variant as ChartStyles}
                      colors={[finalLineColor, finalBarColor]}
                      labels={axis}
                      position={legend.position}
                      direction={legend.direction}
                    />
                  }
                  wrapperStyle={{
                    position: "absolute",
                    top:
                      legend.position === "top-center" ||
                      legend.position === "top-left" ||
                      legend.position === "top-right"
                        ? 0
                        : undefined,
                    bottom:
                      legend.position === "bottom-center" ||
                      legend.position === "bottom-left" ||
                      legend.position === "bottom-right"
                        ? 0
                        : undefined,
                    paddingBottom:
                      legend.position === "bottom-center" ||
                      legend.position === "bottom-left" ||
                      legend.position === "bottom-right"
                        ? "var(--static-space-40)"
                        : undefined,
                    left:
                      (axis === "y" || axis === "both") &&
                      (legend.position === "top-center" || legend.position === "bottom-center")
                        ? "var(--static-space-64)"
                        : 0,
                    width:
                      (axis === "y" || axis === "both") &&
                      (legend.position === "top-center" || legend.position === "bottom-center")
                        ? "calc(100% - var(--static-space-64))"
                        : "100%",
                    right: 0,
                    margin: 0,
                  }}
                />
              )}
              <RechartsXAxis
                height={32}
                tickMargin={6}
                dataKey={xAxisKey}
                hide={!(axis === "x" || axis === "both")}
                axisLine={{
                  stroke: chart.axisLine.stroke,
                }}
                tickLine={chart.tickLine}
                tick={{
                  fill: chart.tick.fill,
                  fontSize: chart.tick.fontSize,
                }}
                tickFormatter={(value) => {
                  const dataPoint = data.find((item) => item[xAxisKey] === value);
                  return formatDate(value, date, dataPoint);
                }}
              />
              {(axis === "y" || axis === "both") && (
                <RechartsYAxis
                  width={64}
                  padding={{ top: 40 }}
                  allowDataOverflow
                  tickLine={chart.tickLine}
                  tick={{
                    fill: chart.tick.fill,
                    fontSize: chart.tick.fontSize,
                  }}
                  axisLine={{
                    stroke: chart.axisLine.stroke,
                  }}
                />
              )}
              <RechartsTooltip
                cursor={{
                  stroke: "var(--neutral-border-strong)",
                  strokeWidth: 1,
                }}
                content={(props) => (
                  <Tooltip
                    {...props}
                    variant={variant as ChartStyles}
                    date={date}
                    dataKey={xAxisKey}
                  />
                )}
              />
              <RechartsArea
                type={curve}
                dataKey={lineSeries.key}
                name={lineSeries.key}
                stroke={finalLineColor}
                transform="translate(0, -1)"
                fill={`url(#lineGradient${chartId})`}
                activeDot={{
                  r: 4,
                  fill: finalLineColor,
                  stroke: "var(--background)",
                  strokeWidth: 0,
                }}
              />
              <RechartsBar
                dataKey={barSeries.key}
                name={barSeries.key}
                fill={`url(#barGradient${chartId})`}
                stroke={finalBarColor}
                strokeWidth={1}
                transform="translate(0, -1)"
                radius={[4, 4, 4, 4]}
                barSize={
                  barWidth === "fill"
                    ? "100%"
                    : barWidth === "xs"
                      ? 6
                      : barWidth === "s"
                        ? 12
                        : barWidth === "m"
                          ? 20
                          : barWidth === "l"
                            ? 40
                            : barWidth === "xl"
                              ? 50
                              : barWidth
                }
              />
            </RechartsComposedChart>
          </RechartsResponsiveContainer>
        )}
      </Row>
    </Column>
  );
};
LineBarChart.displayName = "LineBarChart";
export { LineBarChart };
export type { LineBarChartProps };
</file>

<file path="src/once-ui/modules/data/LineChart.tsx">
"use client";
import React, { useState, useEffect, useMemo } from "react";
import { isWithinInterval, parseISO } from "date-fns";
import { formatDate } from "./utils/formatDate";
import { chart } from "../../../app/resources/data.config";
import {
  AreaChart as RechartsAreaChart,
  Area as RechartsArea,
  YAxis as RechartsYAxis,
  XAxis as RechartsXAxis,
  CartesianGrid as RechartsCartesianGrid,
  Tooltip as RechartsTooltip,
  ResponsiveContainer as RechartsResponsiveContainer,
  Legend as RechartsLegend,
} from "recharts";
import { Column, Row, DateRange } from "../../components";
import {
  LinearGradient,
  ChartHeader,
  Tooltip,
  Legend,
  SeriesConfig,
  ChartProps,
  ChartStatus,
  ChartStyles,
  curveType,
} from ".";
import { schemes } from "../../types";
import { getDistributedColor } from "./utils/colorDistribution";
interface LineChartProps extends ChartProps {
  curve?: curveType;
}
const LineChart: React.FC<LineChartProps> = ({
  title,
  description,
  data,
  series,
  date,
  emptyState,
  loading = false,
  legend: legendProp = {},
  axis = "both",
  border = "neutral-medium",
  variant = chart.variant,
  curve = "natural",
  ...flex
}) => {
  const legend = {
    display: legendProp.display !== undefined ? legendProp.display : true,
    position: legendProp.position || "top-left",
    direction: legendProp.direction,
  };
  const [selectedDateRange, setSelectedDateRange] = useState<DateRange | undefined>(
    date?.start && date?.end
      ? {
          startDate: date.start,
          endDate: date.end,
        }
      : undefined,
  );
  useEffect(() => {
    if (date?.start && date?.end) {
      setSelectedDateRange({
        startDate: date.start,
        endDate: date.end,
      });
    }
  }, [date?.start, date?.end]);
  const seriesArray = Array.isArray(series) ? series : series ? [series] : [];
  const seriesKeys = seriesArray.map((s: SeriesConfig) => s.key);
  // Generate a unique ID for this chart instance
  const chartId = React.useMemo(() => Math.random().toString(36).substring(2, 9), []);
  const coloredSeriesArray = seriesArray.map((s, index) => ({
    ...s,
    color: s.color || getDistributedColor(index, seriesArray.length),
  }));
  const autoKeys = Object.keys(data[0] || {}).filter((key) => !seriesKeys.includes(key));
  const autoSeries =
    seriesArray.length > 0
      ? coloredSeriesArray
      : autoKeys.map((key, index) => ({
          key,
          color: getDistributedColor(index, autoKeys.length),
        }));
  const xAxisKey = Object.keys(data[0] || {}).find((key) => !seriesKeys.includes(key)) || "name";
  const filteredData = React.useMemo(() => {
    if (selectedDateRange?.startDate && selectedDateRange?.endDate && xAxisKey) {
      const startDate = selectedDateRange.startDate;
      const endDate = selectedDateRange.endDate;
      if (startDate instanceof Date && endDate instanceof Date) {
        return data.filter((item) => {
          try {
            const itemDateValue = item[xAxisKey];
            if (!itemDateValue) return false;
            const itemDate =
              typeof itemDateValue === "string" ? parseISO(itemDateValue) : (itemDateValue as Date);
            return isWithinInterval(itemDate, {
              start: startDate,
              end: endDate,
            });
          } catch (error) {
            return false;
          }
        });
      }
    }
    return data;
  }, [data, selectedDateRange, xAxisKey]);
  const handleDateRangeChange = (newRange: DateRange) => {
    setSelectedDateRange(newRange);
    if (date?.onChange) {
      date.onChange(newRange);
    }
  };
  return (
    <Column fillWidth height={chart.height} border={border} radius="l" {...flex}>
      <ChartHeader
        title={title}
        description={description}
        borderBottom={border}
        dateRange={selectedDateRange}
        date={date}
        onDateRangeChange={handleDateRangeChange}
        presets={date?.presets}
      />
      <Row fill>
        <ChartStatus
          loading={loading}
          isEmpty={!filteredData || filteredData.length === 0}
          emptyState={emptyState}
        />
        {!loading && filteredData && filteredData.length > 0 && (
          <RechartsResponsiveContainer width="100%" height="100%">
            <RechartsAreaChart
              data={filteredData}
              margin={{ left: 0, bottom: 0, top: 0, right: 0 }}
            >
              <defs>
                {autoSeries.map(({ key, color }, index) => {
                  const colorValue = color || schemes[index % schemes.length];
                  const lineColor = `var(--data-${colorValue})`;
                  return (
                    <LinearGradient
                      key={`gradient-${chartId}-${index}`}
                      id={`barGradient${chartId}${index}`}
                      variant={variant as ChartStyles}
                      color={lineColor}
                    />
                  );
                })}
              </defs>
              <RechartsCartesianGrid vertical horizontal stroke="var(--neutral-alpha-weak)" />
              {legend.display && (
                <RechartsLegend
                  content={(props) => {
                    const customPayload = autoSeries.map(({ key, color }, index) => ({
                      value: key,
                      color: `var(--data-${color || schemes[index % schemes.length]})`,
                    }));
                    return (
                      <Legend
                        payload={customPayload}
                        labels={axis}
                        position={legend.position}
                        direction={legend.direction}
                        variant={variant as ChartStyles}
                      />
                    );
                  }}
                  wrapperStyle={{
                    position: "absolute",
                    top:
                      legend.position === "top-center" ||
                      legend.position === "top-left" ||
                      legend.position === "top-right"
                        ? 0
                        : undefined,
                    bottom:
                      legend.position === "bottom-center" ||
                      legend.position === "bottom-left" ||
                      legend.position === "bottom-right"
                        ? 0
                        : undefined,
                    paddingBottom:
                      legend.position === "bottom-center" ||
                      legend.position === "bottom-left" ||
                      legend.position === "bottom-right"
                        ? "var(--static-space-40)"
                        : undefined,
                    left:
                      (axis === "y" || axis === "both") &&
                      (legend.position === "top-center" || legend.position === "bottom-center")
                        ? "var(--static-space-64)"
                        : 0,
                    width:
                      (axis === "y" || axis === "both") &&
                      (legend.position === "top-center" || legend.position === "bottom-center")
                        ? "calc(100% - var(--static-space-64))"
                        : "100%",
                    right: 0,
                    margin: 0,
                  }}
                />
              )}
              <RechartsXAxis
                height={32}
                tickMargin={6}
                dataKey={xAxisKey}
                hide={!(axis === "x" || axis === "both")}
                axisLine={{
                  stroke: chart.axisLine.stroke,
                }}
                tickLine={chart.tickLine}
                tick={{
                  fill: chart.tick.fill,
                  fontSize: chart.tick.fontSize,
                }}
                tickFormatter={(value) => {
                  const dataPoint = data.find((item) => item[xAxisKey] === value);
                  return formatDate(value, date, dataPoint);
                }}
              />
              {(axis === "y" || axis === "both") && (
                <RechartsYAxis
                  width={64}
                  padding={{ top: 40 }}
                  allowDataOverflow
                  tickLine={chart.tickLine}
                  tick={{
                    fill: chart.tick.fill,
                    fontSize: chart.tick.fontSize,
                  }}
                  axisLine={{
                    stroke: chart.axisLine.stroke,
                  }}
                />
              )}
              <RechartsTooltip
                cursor={{
                  stroke: "var(--neutral-border-strong)",
                  strokeWidth: 1,
                }}
                content={(props) => (
                  <Tooltip {...props} variant={variant as ChartStyles} date={date} />
                )}
              />
              {autoSeries.map(({ key, color }, index) => {
                const colorValue = color || schemes[index % schemes.length];
                const lineColor = `var(--data-${colorValue})`;
                return (
                  <RechartsArea
                    key={key}
                    type={curve}
                    dataKey={key}
                    name={key}
                    stroke={lineColor}
                    transform="translate(0, -1)"
                    fill={
                      variant === "outline" ? "transparent" : `url(#barGradient${chartId}${index})`
                    }
                    activeDot={{
                      r: 4,
                      fill: lineColor,
                      stroke: "var(--background)",
                      strokeWidth: 0,
                    }}
                  />
                );
              })}
            </RechartsAreaChart>
          </RechartsResponsiveContainer>
        )}
      </Row>
    </Column>
  );
};
LineChart.displayName = "LineChart";
export { LineChart };
export type { LineChartProps };
</file>

<file path="src/once-ui/modules/data/PieChart.tsx">
"use client";
import React, { useState, useEffect } from "react";
import {
  PieChart as RechartsPieChart,
  Pie as RechartsPie,
  Cell as RechartsCell,
  Tooltip as RechartsTooltip,
  ResponsiveContainer as RechartsResponsiveContainer,
  Legend as RechartsLegend,
} from "recharts";
import { Column, Row, DateRange } from "../../components";
import {
  ChartProps,
  ChartStyles,
  ChartStatus,
  RadialGradient,
  Tooltip,
  Legend,
  ChartHeader,
} from ".";
import { getDistributedColor } from "./utils/colorDistribution";
import { chart } from "@/app/resources/data.config";
import { schemes } from "@/once-ui/types";
interface PieChartProps extends ChartProps {
  "data-viz"?: string;
  ring?: { inner: number; outer: number };
  dataKey?: string;
  nameKey?: string;
  origo?: { x: number; y: number };
}
export const PieChart: React.FC<PieChartProps> = ({
  title,
  description,
  data,
  series,
  date,
  emptyState,
  origo = { x: 50, y: 50 },
  loading = false,
  legend: legendProp = {},
  border = "neutral-medium",
  variant = chart.variant,
  ring = { inner: 0, outer: 80 },
  dataKey = "value",
  nameKey = "name",
  "data-viz": dataViz,
  ...flex
}) => {
  const legend = {
    display: legendProp.display !== undefined ? legendProp.display : true,
    position: legendProp.position || "bottom-center",
    direction: legendProp.direction,
  };
  const [selectedDateRange, setSelectedDateRange] = useState<DateRange | undefined>(
    date?.start && date?.end
      ? {
          startDate: date.start,
          endDate: date.end,
        }
      : undefined,
  );
  useEffect(() => {
    if (date?.start && date?.end) {
      setSelectedDateRange({
        startDate: date.start,
        endDate: date.end,
      });
    }
  }, [date?.start, date?.end]);
  const handleDateRangeChange = (newRange: DateRange) => {
    setSelectedDateRange(newRange);
    if (date?.onChange) {
      date.onChange(newRange);
    }
  };
  const colorPalette = React.useMemo(() => {
    if (!data || data.length === 0) return schemes.map((c) => `var(--data-${c})`);
    return Array.from({ length: data.length }, (_, index) => {
      const colorKey = getDistributedColor(index, data.length);
      return `var(--data-${colorKey})`;
    });
  }, [data]);
  const filteredData = React.useMemo(() => {
    if (!selectedDateRange || !data || data.length === 0) {
      return data;
    }
    return data.filter((item) => {
      try {
        if (!item.date || !selectedDateRange.startDate || !selectedDateRange.endDate) {
          return true;
        }
        const itemDate = typeof item.date === "string" ? new Date(item.date) : item.date;
        return itemDate >= selectedDateRange.startDate && itemDate <= selectedDateRange.endDate;
      } catch (e) {
        return true;
      }
    });
  }, [data, selectedDateRange]);
  const getGradientId = React.useCallback((colorKey: string | number | Date): string => {
    return `pieGradient-${String(colorKey)}`;
  }, []);
  return (
    <Column
      fillWidth
      height={chart.height}
      data-viz={dataViz || chart.mode}
      border={border}
      radius="l"
      {...flex}
    >
      <ChartHeader
        title={title}
        description={description}
        borderBottom={border}
        dateRange={selectedDateRange}
        date={date}
        onDateRangeChange={handleDateRangeChange}
        presets={date?.presets}
      />
      <Row fill>
        <ChartStatus
          loading={loading}
          isEmpty={!filteredData || filteredData.length === 0}
          emptyState={emptyState}
        />
        {!loading && filteredData && filteredData.length > 0 && (
          <RechartsResponsiveContainer width="100%" height="100%">
            <RechartsPieChart>
              <defs>
                <pattern
                  id="pieChartMasterPattern"
                  patternUnits="userSpaceOnUse"
                  width="100%"
                  height="100%"
                >
                  <RadialGradient
                    id="pieChartMasterGradient"
                    color="var(--page-background)"
                    cx="50%"
                    cy="50%"
                    r="50%"
                    fx="50%"
                    fy="50%"
                    variant={variant as ChartStyles}
                  />
                  <rect
                    x="0"
                    y="0"
                    width="100%"
                    height="100%"
                    fill="url(#pieChartMasterGradient)"
                  />
                </pattern>
                {Array.from(
                  new Set(
                    filteredData.map((entry, index) => {
                      return entry.color || getDistributedColor(index, filteredData.length);
                    }),
                  ),
                ).map((colorKey) => {
                  const baseColor = `var(--data-${colorKey})`;
                  const patternId = getGradientId(colorKey as string);
                  return (
                    <pattern
                      id={patternId}
                      key={`pattern-${colorKey}`}
                      patternUnits="userSpaceOnUse"
                      width="100%"
                      height="100%"
                    >
                      {variant !== "outline" && (
                        <rect x="0" y="0" width="100%" height="100%" fill={baseColor} />
                      )}
                      {variant === "gradient" && (
                        <rect
                          x="0"
                          y="0"
                          width="100%"
                          height="100%"
                          fill="url(#pieChartMasterPattern)"
                        />
                      )}
                    </pattern>
                  );
                })}
              </defs>
              {legend.display && (
                <RechartsLegend
                  content={(props) => (
                    <Legend
                      {...props}
                      variant={variant as ChartStyles}
                      position={legend.position}
                      direction={legend.direction}
                      labels="none"
                      colors={colorPalette}
                    />
                  )}
                  wrapperStyle={{
                    position: "absolute",
                    top:
                      legend.position === "top-center" ||
                      legend.position === "top-left" ||
                      legend.position === "top-right"
                        ? 0
                        : undefined,
                    bottom:
                      legend.position === "bottom-center" ||
                      legend.position === "bottom-left" ||
                      legend.position === "bottom-right"
                        ? 0
                        : undefined,
                    right: 0,
                    left: 0,
                    margin: 0,
                  }}
                />
              )}
              <RechartsPie
                data={filteredData}
                cx={origo.x + "%"}
                cy={origo.y + "%"}
                labelLine={false}
                innerRadius={ring.inner + "%"}
                outerRadius={ring.outer + "%"}
                dataKey={dataKey}
                nameKey={nameKey}
                stroke={variant === "outline" ? undefined : "none"}
              >
                {filteredData.map((entry, index) => {
                  const colorKey = entry.color || getDistributedColor(index, filteredData.length);
                  const baseColor = `var(--data-${colorKey})`;
                  const gradientId = getGradientId(String(colorKey));
                  return (
                    <RechartsCell
                      key={`cell-${index}`}
                      fill={variant === "outline" ? "transparent" : `url(#${gradientId})`}
                      strokeWidth={variant === "outline" ? 2 : 1}
                      stroke={baseColor}
                    />
                  );
                })}
              </RechartsPie>
              <RechartsTooltip
                content={(props) => {
                  if (props.payload && props.payload.length > 0) {
                    const entry = props.payload[0];
                    const index = filteredData.findIndex((item) => item[nameKey] === entry.name);
                    const colorKey =
                      filteredData[index]?.color || getDistributedColor(index, filteredData.length);
                    const color = `var(--data-${colorKey})`;
                    props.payload[0].color = color;
                  }
                  return (
                    <Tooltip
                      {...props}
                      label={undefined}
                      date={date}
                      variant={variant as ChartStyles}
                    />
                  );
                }}
              />
            </RechartsPieChart>
          </RechartsResponsiveContainer>
        )}
      </Row>
    </Column>
  );
};
</file>

<file path="src/once-ui/modules/data/Swatch.tsx">
"use client";
import React from "react";
import { Row } from "../../components";
import { RadiusSize, SpacingToken } from "../../types";
import { chart } from "../../../app/resources/data.config";
import { ChartStyles } from "./interfaces";
export interface SwatchProps {
  color: string;
  size?: "s" | "m";
  variant?: ChartStyles;
}
export const Swatch: React.FC<SwatchProps> = ({ color, size = "m", variant = chart.variant }) => {
  const sizeMap: Record<
    string,
    { minWidth: SpacingToken; minHeight: SpacingToken; radius: RadiusSize }
  > = {
    s: {
      minWidth: "12",
      minHeight: "12",
      radius: "xs",
    },
    m: {
      minWidth: "16",
      minHeight: "16",
      radius: "s",
    },
  };
  const getStyleByVariant = () => {
    const baseStyle = {
      backgroundClip: "padding-box",
      border: `1px solid ${color}`,
    };
    switch (variant) {
      case "flat":
        return {
          ...baseStyle,
          background: color,
        };
      case "outline":
        return {
          ...baseStyle,
          background: "transparent",
        };
      case "gradient":
      default:
        return {
          ...baseStyle,
          background: `linear-gradient(to bottom, ${color} 0%, transparent 100%)`,
        };
    }
  };
  return (
    <Row
      style={getStyleByVariant()}
      minWidth={sizeMap[size].minWidth}
      minHeight={sizeMap[size].minHeight}
      radius={sizeMap[size].radius}
    />
  );
};
</file>

<file path="src/once-ui/modules/data/Tooltip.tsx">
"use client";
import React, { useRef, useEffect } from "react";
import { formatDate } from "./utils/formatDate";
import { Column, Text, Row, LetterFx } from "../../components";
import { Swatch } from "./Swatch";
import { ChartStyles, DateConfig } from "./interfaces";
const ValueWithAnimation: React.FC<{ value: number }> = ({ value }) => {
  const prevValueRef = useRef<number | null>(null);
  const triggerRef = useRef<(() => void) | null>(null);
  const initialRenderRef = useRef<boolean>(true);
  useEffect(() => {
    if (initialRenderRef.current) {
      initialRenderRef.current = false;
      prevValueRef.current = value;
      return;
    }
    if (prevValueRef.current !== value && triggerRef.current) {
      triggerRef.current();
    }
    prevValueRef.current = value;
  }, [value]);
  return (
    <LetterFx
      trigger="custom"
      charset={["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]}
      onTrigger={(triggerFn) => {
        triggerRef.current = triggerFn;
      }}
    >
      {value.toLocaleString()}
    </LetterFx>
  );
};
interface TooltipProps {
  active?: boolean;
  payload?: any[];
  label?: string;
  dataKey?: string;
  tooltip?: React.ReactNode;
  date?: DateConfig;
  colors?: boolean;
  variant?: ChartStyles;
}
const Tooltip: React.FC<TooltipProps> = ({
  active,
  payload,
  label,
  dataKey = "name",
  tooltip,
  date = { format: "MMM d" },
  colors = true,
  variant = "gradient",
}) => {
  if (!active || !payload || !payload.length) {
    return null;
  }
  const dataPoint = payload[0].payload;
  const displayLabel = label || dataPoint?.[dataKey];
  const formattedLabel =
    formatDate(displayLabel, date, dataPoint) || displayLabel || dataPoint?.endDate;
  return (
    <Column
      minWidth={8}
      gap="8"
      paddingY="8"
      background="surface"
      radius="m"
      border="neutral-alpha-medium"
    >
      {label && (
        <Row fillWidth paddingX="12">
          <Text variant="label-default-s" onBackground="neutral-strong">
            {formattedLabel}
          </Text>
        </Row>
      )}
      <Column fillWidth horizontal="space-between" paddingX="12" gap="4">
        {payload.map((entry: any, index: number) => (
          <Row key={index} horizontal="space-between" fillWidth gap="16">
            <Row vertical="center" gap="8">
              {colors && <Swatch color={entry.stroke || entry.color} size="s" variant={variant} />}
              <Text onBackground="neutral-weak" variant="label-default-s">
                {tooltip && index === 0 ? tooltip : entry.name}
              </Text>
            </Row>
            <Text onBackground="neutral-strong" variant="label-default-s">
              {typeof entry.value === "number" ? (
                <ValueWithAnimation value={entry.value} />
              ) : (
                entry.value
              )}
            </Text>
          </Row>
        ))}
      </Column>
    </Column>
  );
};
export { Tooltip };
export type { TooltipProps };
</file>

<file path="src/once-ui/modules/media/MediaUpload.module.scss">
.container {
    &:hover, &:focus {
        background-color: var(--neutral-background-strong);
    }
}
.text {
    display: none;
    visibility: hidden;
    opacity: 0;
}
.upload {
    &:hover {
        background: var(--backdrop);
        backdrop-filter: blur(0.25rem);
        .text {
            display: block;
            visibility: visible;
            opacity: 1;
        }
    }
}
</file>

<file path="src/once-ui/modules/media/MediaUpload.tsx">
"use client";
import React, { useRef, useState, forwardRef, useEffect } from "react";
import Compressor from "compressorjs";
import { Flex, Icon, Media, Spinner, Text } from "@/once-ui/components";
import styles from "./MediaUpload.module.scss";
interface MediaUploadProps extends React.ComponentProps<typeof Flex> {
  onFileUpload?: (file: File) => Promise<void>;
  compress?: boolean;
  aspectRatio?: string;
  className?: string;
  style?: React.CSSProperties;
  initialPreviewImage?: string | null;
  emptyState?: React.ReactNode;
  quality?: number;
  sizes?: string;
  children?: React.ReactNode;
  convertTypes?: string[];
  resizeMaxWidth?: number;
  resizeMaxHeight?: number;
  resizeWidth?: number;
  resizeHeight?: number;
  loading?: boolean;
  accept?: string;
}
const MediaUpload = forwardRef<HTMLInputElement, MediaUploadProps>(
  (
    {
      onFileUpload,
      compress = true,
      aspectRatio = "16 / 9",
      quality = 0.8,
      convertTypes = ["image/png", "image/webp", "image/jpg"],
      emptyState = "Drag and drop or click to browse",
      resizeMaxWidth = 1920,
      resizeMaxHeight = 1920,
      resizeWidth = 1200,
      resizeHeight = 1200,
      loading = false,
      sizes,
      children,
      initialPreviewImage = null,
      accept = "image/*",
      ...rest
    },
    ref,
  ) => {
    const [dragActive, setDragActive] = useState(false);
    const [previewImage, setPreviewImage] = useState<string | null>(initialPreviewImage); // Use prop as initial state
    const [uploading, setUploading] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    useEffect(() => {
      if (initialPreviewImage) {
        setPreviewImage(initialPreviewImage);
      }
    }, [initialPreviewImage]);
    const handleDragOver = (e: React.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setDragActive(true);
    };
    const handleDragLeave = (e: React.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setDragActive(false);
    };
    const handleDrop = (e: React.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setDragActive(false);
      if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        handleFiles(e.dataTransfer.files);
      }
    };
    const handleFileSelection = () => {
      if (inputRef.current) {
        inputRef.current.click();
      }
    };
    const handleFiles = (files: FileList) => {
      const file = files[0];
      if (!file) return;
      if (file.type.startsWith("image/")) {
        setPreviewImage(URL.createObjectURL(file));
        if (compress && file.type.startsWith("image/")) {
          compressImage(file);
        } else {
          uploadFile(file);
        }
      } else {
        console.warn("Unsupported file type:", file.type);
      }
    };
    const compressImage = (file: File) => {
      new Compressor(file, {
        convertTypes: convertTypes,
        quality: quality,
        maxWidth: resizeMaxWidth,
        maxHeight: resizeMaxHeight,
        convertSize: 400 * 1024,
        width: resizeWidth,
        height: resizeHeight,
        success(compressedFile) {
          uploadFile(compressedFile as File);
        },
        error(err) {
          console.error("Compression error:", err);
          uploadFile(file);
        },
      });
    };
    const uploadFile = async (file: File) => {
      setUploading(true);
      if (onFileUpload) {
        await onFileUpload(file);
      }
      setUploading(false);
    };
    return (
      <Flex
        style={{ isolation: "isolate" }}
        transition="micro-medium"
        overflow="hidden"
        cursor="interactive"
        className={styles.container}
        aspectRatio={aspectRatio}
        fillWidth
        horizontal="center"
        vertical="center"
        border="neutral-medium"
        radius="l"
        onClick={handleFileSelection}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        {...rest}
      >
        {!loading && (
          <>
            {previewImage ? (
              <Media
                style={{
                  cursor: "pointer",
                  filter: uploading ? "grayscale(1)" : "",
                }}
                sizes={sizes}
                fill
                src={previewImage ? previewImage : ""}
                alt="Preview of uploaded image"
              />
            ) : (
              <Flex fill center>
                <Icon name="plus" size="l" />
              </Flex>
            )}
          </>
        )}
        {children}
        <Flex
          className={styles.upload}
          zIndex={1}
          transition="micro-medium"
          position="absolute"
          fill
          padding="m"
          horizontal="center"
          vertical="center"
        >
          {uploading || loading ? (
            <Spinner size="l" />
          ) : (
            <Text className={styles.text} align="center">
              {emptyState}
            </Text>
          )}
        </Flex>
        <input
          type="file"
          ref={inputRef}
          accept={accept}
          style={{ display: "none" }}
          onChange={(e) => {
            if (e.target.files) {
              handleFiles(e.target.files);
            }
          }}
        />
      </Flex>
    );
  },
);
MediaUpload.displayName = "MediaUpload";
export { MediaUpload };
</file>

<file path="src/once-ui/modules/navigation/HeadingLink.module.scss">
.control {
    cursor: pointer;
    &:hover {
        .visibility {
            opacity: 1;
        }
        .text {
            text-decoration-line: underline;
        }
    }
}
.text {
    text-decoration-thickness: 1px;
    text-underline-offset: 0.25em;
    text-decoration-color: var(--neutral-border-strong);
}
.visibility {
    opacity: 0;
    transform: scale(0.875);
}
</file>

<file path="src/once-ui/modules/navigation/HeadingLink.tsx">
"use client";
import React from "react";
import { Heading, Flex, IconButton, useToast } from "@/once-ui/components";
import styles from "./HeadingLink.module.scss";
interface HeadingLinkProps extends React.ComponentProps<typeof Heading> {
  id: string;
  as: "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
  children: React.ReactNode;
  style?: React.CSSProperties;
}
export const HeadingLink: React.FC<HeadingLinkProps> = ({
  id,
  as,
  children,
  style,
  ...heading
}) => {
  const { addToast } = useToast();
  const copyURL = (id: string): void => {
    const url = `${window.location.origin}${window.location.pathname}#${id}`;
    navigator.clipboard.writeText(url).then(
      () => {
        addToast({
          variant: "success",
          message: "Link copied to clipboard.",
        });
      },
      () => {
        addToast({
          variant: "danger",
          message: "Failed to copy link.",
        });
      },
    );
  };
  const variantMap = {
    h1: "display-strong-xs",
    h2: "heading-strong-xl",
    h3: "heading-strong-l",
    h4: "heading-strong-m",
    h5: "heading-strong-s",
    h6: "heading-strong-xs",
  } as const;
  const variant = variantMap[as];
  return (
    <Flex
      style={style}
      onClick={() => copyURL(id)}
      className={styles.control}
      vertical="center"
      gap="8"
    >
      <Heading className={styles.text} id={id} variant={variant} as={as} {...heading}>
        {children}
      </Heading>
      <IconButton
        className={styles.visibility}
        size="m"
        icon="openLink"
        variant="secondary"
        tooltip="Copy"
        tooltipPosition="right"
      />
    </Flex>
  );
};
</file>

<file path="src/once-ui/modules/navigation/index.ts">
export * from "./MegaMenu";
export * from "./MobileMegaMenu";
export * from "./HeadingNav";
export * from "./HeadingLink";
export * from "./Kbar";
</file>

<file path="src/once-ui/modules/navigation/Kbar.module.scss">
.overlay {
  animation: fadeIn 0.2s ease-out forwards;
  backdrop-filter: var(--backdrop-filter);
  &.closing {
    animation: fadeOut 0.2s ease-out forwards;
  }
}
.content {
  animation: scaleIn 0.2s ease-out forwards;
  &.closing {
    animation: scaleOut 0.2s ease-out forwards;
  }
}
@keyframes fadeIn {
  from {
    opacity: 0;
    backdrop-filter: blur(0);
  }
  to {
    opacity: 1;
    backdrop-filter: var(--backdrop-filter);
  }
}
@keyframes fadeOut {
  from {
    opacity: 1;
    backdrop-filter: var(--backdrop-filter);
  }
  to {
    opacity: 0;
    backdrop-filter: blur(0);
  }
}
@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
@keyframes scaleOut {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.9);
  }
}
</file>

<file path="src/once-ui/modules/navigation/Kbar.tsx">
"use client";
import React, { useState, useEffect, useRef, useCallback, useMemo, ReactNode } from "react";
import { Flex, Text, Icon, Column, Input, Option, Row } from "@/once-ui/components";
import { createPortal } from "react-dom";
import { useRouter, usePathname } from "next/navigation";
import styles from "./Kbar.module.scss";
export interface KbarItem {
  id: string;
  name: string;
  section: string;
  shortcut: string[];
  keywords: string;
  href?: string;
  perform?: () => void;
  icon?: string;
  description?: ReactNode;
}
const SectionHeader: React.FC<{ label: string }> = ({ label }) => (
  <Flex
    paddingX="12"
    paddingBottom="8"
    paddingTop="12"
    textVariant="label-default-s"
    onBackground="neutral-weak"
  >
    {label}
  </Flex>
);
interface KbarTriggerProps {
  onClick?: () => void;
  children: React.ReactNode;
  [key: string]: any; // Allow any additional props
}
export const KbarTrigger: React.FC<KbarTriggerProps> = ({ onClick, children, ...rest }) => {
  return (
    <Flex onClick={onClick} {...rest}>
      {children}
    </Flex>
  );
};
interface KbarContentProps {
  isOpen: boolean;
  onClose: () => void;
  items: KbarItem[];
}
export const KbarContent: React.FC<KbarContentProps> = ({ isOpen, onClose, items }) => {
  const [searchQuery, setSearchQuery] = useState("");
  const [highlightedIndex, setHighlightedIndex] = useState<number | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const optionRefs = useRef<(HTMLDivElement | null)[]>([]);
  const router = useRouter();
  const [isClosing, setIsClosing] = useState(false);
  const handleClose = useCallback(() => {
    setIsClosing(true);
    // Add a small delay to allow animations to complete
    requestAnimationFrame(() => {
      onClose();
    });
  }, [onClose]);
  // Filter items based on search query
  const filteredItems = useMemo(() => {
    return items.filter((item) => {
      if (!searchQuery) return true;
      const searchLower = searchQuery.toLowerCase();
      return (
        item.name.toLowerCase().includes(searchLower) ||
        (item.keywords ? item.keywords.toLowerCase().includes(searchLower) : false) ||
        (item.section ? item.section.toLowerCase().includes(searchLower) : false)
      );
    });
  }, [items, searchQuery]);
  // Group items by section
  const groupedItems = useMemo(() => {
    const sections = new Set(filteredItems.map((item) => item.section));
    const result = [];
    for (const section of sections) {
      // Add section header
      result.push({
        value: `section-${section}`,
        label: <SectionHeader label={section} />,
        isCustom: true,
      });
      // Add items for this section
      const sectionItems = filteredItems.filter((item) => item.section === section);
      for (const item of sectionItems) {
        result.push({
          value: item.id,
          label: item.name,
          hasPrefix: item.icon ? (
            <Icon name={item.icon} size="xs" onBackground="neutral-weak" />
          ) : undefined,
          hasSuffix:
            item.shortcut && item.shortcut.length > 0 ? (
              <Row gap="4">
                {item.shortcut.map((key, i) => (
                  <Text key={i} variant="label-default-xs" onBackground="neutral-weak">
                    {key}
                  </Text>
                ))}
              </Row>
            ) : undefined,
          description: item.description,
          href: item.href,
          onClick: item.perform
            ? () => {
                item.perform?.();
                onClose();
              }
            : undefined,
        });
      }
    }
    return result;
  }, [filteredItems, onClose]);
  // Get non-custom options for highlighting
  const nonCustomOptions = useMemo(() => {
    return groupedItems.filter((item) => !item.isCustom);
  }, [groupedItems]);
  // Reset optionRefs when nonCustomOptions change
  useEffect(() => {
    optionRefs.current = Array(nonCustomOptions.length).fill(null);
  }, [nonCustomOptions.length]);
  // Reset highlighted index when search query changes
  useEffect(() => {
    setHighlightedIndex(nonCustomOptions.length > 0 ? 0 : null);
  }, [searchQuery, nonCustomOptions.length]);
  // Handle keyboard navigation
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (!nonCustomOptions.length) return;
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          setHighlightedIndex((prevIndex) => {
            if (prevIndex === null) return 0;
            return (prevIndex + 1) % nonCustomOptions.length;
          });
          break;
        case "ArrowUp":
          e.preventDefault();
          setHighlightedIndex((prevIndex) => {
            if (prevIndex === null) return nonCustomOptions.length - 1;
            return (prevIndex - 1 + nonCustomOptions.length) % nonCustomOptions.length;
          });
          break;
        case "Enter":
          e.preventDefault();
          if (highlightedIndex !== null && highlightedIndex < nonCustomOptions.length) {
            const selectedOption = nonCustomOptions[highlightedIndex];
            if (selectedOption) {
              // Find the original item to get the perform function or href
              const originalItem = items.find((item) => item.id === selectedOption.value);
              if (originalItem) {
                if (originalItem.href) {
                  router.push(originalItem.href);
                  onClose();
                } else if (originalItem.perform) {
                  originalItem.perform();
                  onClose();
                }
              }
            }
          }
          break;
      }
    },
    [nonCustomOptions, items, router, onClose, highlightedIndex],
  );
  // Scroll highlighted element into view
  useEffect(() => {
    if (isOpen && highlightedIndex !== null && nonCustomOptions.length > 0) {
      // Use requestAnimationFrame to ensure the DOM has updated
      requestAnimationFrame(() => {
        const highlightedElement = optionRefs.current[highlightedIndex];
        const scrollContainer = scrollContainerRef.current;
        if (highlightedElement && scrollContainer) {
          const elementRect = highlightedElement.getBoundingClientRect();
          const containerRect = scrollContainer.getBoundingClientRect();
          // Check if the element is not fully visible
          if (elementRect.bottom > containerRect.bottom) {
            // Element is below the visible area - scroll just enough to show it
            const scrollAmount = elementRect.bottom - containerRect.bottom + 8; // Add a small buffer
            scrollContainer.scrollTop += scrollAmount;
          } else if (elementRect.top < containerRect.top) {
            // Element is above the visible area - scroll just enough to show it
            const scrollAmount = containerRect.top - elementRect.top + 8; // Add a small buffer
            scrollContainer.scrollTop -= scrollAmount;
          }
        }
      });
    }
  }, [highlightedIndex, isOpen, nonCustomOptions.length]);
  // Handle escape key
  useEffect(() => {
    const handleEscapeKey = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        handleClose();
      }
    };
    if (isOpen) {
      document.addEventListener("keydown", handleEscapeKey);
    }
    return () => {
      document.removeEventListener("keydown", handleEscapeKey);
    };
  }, [isOpen, handleClose]);
  // Lock body scroll when kbar is open
  useEffect(() => {
    if (isOpen) {
      // Prevent body scrolling when kbar is open
      document.body.style.overflow = "hidden";
    } else {
      // Restore body scrolling when kbar is closed
      document.body.style.overflow = "unset";
    }
    return () => {
      // Cleanup function to ensure body scroll is restored
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);
  // Clear search query when kbar is closed
  useEffect(() => {
    if (!isOpen) {
      setSearchQuery("");
      setHighlightedIndex(null);
    } else {
      // Set the first item as highlighted when opened
      if (nonCustomOptions.length > 0) {
        setHighlightedIndex(0);
      }
    }
  }, [isOpen, nonCustomOptions]);
  // Focus search input when kbar is opened
  useEffect(() => {
    if (isOpen && inputRef.current) {
      // Use a small timeout to ensure the component is fully rendered
      const timer = setTimeout(() => {
        inputRef.current?.focus();
      }, 50);
      return () => clearTimeout(timer);
    }
  }, [isOpen]);
  // Handle search input change
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };
  // Render nothing if not open
  if (!isOpen) return null;
  // Create portal for the kbar
  return (
    <Flex
      position="fixed"
      top="0"
      left="0"
      right="0"
      bottom="0"
      zIndex={10}
      center
      background="overlay"
      className={`${styles.overlay} ${isClosing ? styles.closing : ""}`}
      onClick={(e) => {
        if (e.target === e.currentTarget) {
          handleClose();
        }
      }}
    >
      <Column
        ref={containerRef}
        maxHeight={32}
        fitHeight
        maxWidth="xs"
        background="surface"
        radius="l"
        border="neutral-alpha-medium"
        overflow="hidden"
        shadow="l"
        className={`${styles.content} ${isClosing ? styles.closing : ""}`}
        onClick={(e) => e.stopPropagation()}
      >
        <Flex fillWidth>
          <Input
            id="kbar-search"
            placeholder="Search docs..."
            value={searchQuery}
            onChange={handleSearchChange}
            onKeyDown={handleKeyDown}
            ref={inputRef}
            hasPrefix={<Icon name="search" size="xs" />}
            radius="none"
            autoComplete="off"
            style={{
              marginTop: "-1px",
              marginLeft: "-1px",
              width: "calc(100% + 2px)",
            }}
          />
        </Flex>
        <Column ref={scrollContainerRef} fillWidth padding="4" gap="2" overflowY="auto">
          {groupedItems.map((option, index) => {
            if (option.isCustom) {
              return <React.Fragment key={option.value}>{option.label}</React.Fragment>;
            }
            // Find the index in the non-custom options array
            const optionIndex = nonCustomOptions.findIndex((item) => item.value === option.value);
            const isHighlighted = optionIndex === highlightedIndex;
            return (
              <Option
                ref={(el) => {
                  if (optionIndex >= 0 && optionIndex < optionRefs.current.length) {
                    optionRefs.current[optionIndex] = el;
                  }
                }}
                key={option.value}
                label={option.label}
                value={option.value}
                hasPrefix={option.hasPrefix}
                hasSuffix={option.hasSuffix}
                description={option.description}
                {...(option.href
                  ? { href: option.href, onClick: undefined, onLinkClick: onClose }
                  : { onClick: option.onClick })}
                highlighted={isHighlighted}
              />
            );
          })}
          {searchQuery && filteredItems.length === 0 && (
            <Flex fillWidth center paddingX="16" paddingY="64">
              <Text variant="body-default-m" onBackground="neutral-weak">
                No results found
              </Text>
            </Flex>
          )}
        </Column>
      </Column>
    </Flex>
  );
};
export interface KbarProps {
  items: KbarItem[];
  children: React.ReactNode;
  [key: string]: any; // Allow any additional props
}
export const Kbar: React.FC<KbarProps> = ({ items, children, ...rest }) => {
  const [isOpen, setIsOpen] = useState(false);
  const router = useRouter();
  const pathname = usePathname();
  const handleOpen = () => {
    setIsOpen(true);
  };
  const handleClose = () => {
    setIsOpen(false);
  };
  // Close Kbar when pathname changes
  useEffect(() => {
    if (isOpen) {
      handleClose();
    }
  }, [pathname]);
  // Add keyboard shortcut listener
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Check for Command+K (Mac) or Control+K (Windows/Linux)
      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault(); // Prevent default browser behavior
        setIsOpen((prev) => !prev); // Toggle Kbar open/close
      }
    };
    // Add the event listener
    document.addEventListener("keydown", handleKeyDown);
    // Clean up the event listener on component unmount
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  return (
    <>
      <KbarTrigger onClick={handleOpen} {...rest}>
        {children}
      </KbarTrigger>
      {isOpen &&
        createPortal(
          <KbarContent isOpen={isOpen} onClose={handleClose} items={items} />,
          document.body,
        )}
    </>
  );
};
</file>

<file path="src/once-ui/modules/navigation/MegaMenu.module.scss">
@keyframes fadeInDropdown {
  from {
    opacity: 0;
    transform: translateY(-1rem) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}
.dropdown {
  animation: fadeInDropdown 0.2s ease-out forwards;
}
</file>

<file path="src/once-ui/modules/navigation/MegaMenu.tsx">
"use client";
import React, { useState, useRef, useEffect, ReactNode } from "react";
import { usePathname } from "next/navigation";
import { Flex, Row, Column, Text, Icon, ToggleButton } from "@/once-ui/components";
import styles from "./MegaMenu.module.scss";
export interface MenuLink {
  label: ReactNode;
  href: string;
  icon?: string;
  description?: ReactNode;
  selected?: boolean;
}
export interface MenuSection {
  title?: ReactNode;
  links: MenuLink[];
}
export interface MenuGroup {
  id: string;
  label: ReactNode;
  suffixIcon?: string;
  href?: string;
  selected?: boolean;
  sections?: MenuSection[];
}
export interface MegaMenuProps extends React.ComponentProps<typeof Flex> {
  menuGroups: MenuGroup[];
  className?: string;
}
export const MegaMenu: React.FC<MegaMenuProps> = ({ menuGroups, className, ...rest }) => {
  const pathname = usePathname();
  const [activeDropdown, setActiveDropdown] = useState<string | null>(null);
  const [dropdownPosition, setDropdownPosition] = useState({ left: 0, width: 0 });
  const [isFirstAppearance, setIsFirstAppearance] = useState(true);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const buttonRefs = useRef<Record<string, HTMLDivElement | null>>({});
  const contentRefs = useRef<Record<string, HTMLDivElement | null>>({});
  useEffect(() => {
    if (activeDropdown && buttonRefs.current[activeDropdown]) {
      const buttonElement = buttonRefs.current[activeDropdown];
      if (buttonElement) {
        const rect = buttonElement.getBoundingClientRect();
        const parentRect = buttonElement.parentElement?.getBoundingClientRect() || { left: 0 };
        // Set initial position
        setDropdownPosition({
          left: rect.left - parentRect.left,
          width: 300, // Default width that will be updated
        });
        // Measure content after render
        requestAnimationFrame(() => {
          const contentElement = contentRefs.current[activeDropdown];
          if (contentElement) {
            const contentWidth = contentElement.scrollWidth;
            setDropdownPosition((prev) => ({
              ...prev,
              width: contentWidth + 40, // Add padding
            }));
          }
        });
      }
    } else {
      // Reset first appearance flag when dropdown is closed
      setIsFirstAppearance(true);
    }
  }, [activeDropdown]);
  // Reset animation flag after animation completes
  useEffect(() => {
    if (activeDropdown !== null) {
      const timer = setTimeout(() => {
        setIsFirstAppearance(false);
      }, 300); // Match animation duration
      return () => clearTimeout(timer);
    }
  }, [activeDropdown]);
  // Close dropdown when pathname changes (navigation occurs)
  useEffect(() => {
    setActiveDropdown(null);
  }, [pathname]);
  // Check if a menu item should be selected based on the current path
  const isSelected = (href?: string) => {
    if (!href || !pathname) return false;
    return pathname.startsWith(href);
  };
  // Filter groups to only show those with sections in the dropdown
  const dropdownGroups = menuGroups.filter((group) => group.sections);
  // Add click handler to close dropdown when clicking on links
  const handleLinkClick = (href: string) => {
    setActiveDropdown(null);
    // Let the default navigation happen
  };
  return (
    <Flex gap="4" flex={1} className={className} {...rest}>
      {menuGroups.map((group, index) => (
        <Row
          key={`menu-group-${index}`}
          ref={(el) => {
            buttonRefs.current[group.id] = el;
          }}
          onMouseEnter={() => group.sections && setActiveDropdown(group.id)}
          onMouseLeave={(e) => {
            // Check if we're not hovering over the dropdown
            const dropdownElement = dropdownRef.current;
            if (dropdownElement) {
              const rect = dropdownElement.getBoundingClientRect();
              if (
                e.clientX >= rect.left &&
                e.clientX <= rect.right &&
                e.clientY >= rect.top &&
                e.clientY <= rect.bottom
              ) {
                // We're hovering over the dropdown, don't hide it
                return;
              }
            }
            // Only hide if activeDropdown is this group
            if (activeDropdown === group.id) {
              setActiveDropdown(null);
            }
          }}
        >
          <ToggleButton
            selected={group.selected !== undefined ? group.selected : isSelected(group.href)}
            href={group.href}
          >
            {group.label}
            {group.sections && group.suffixIcon && (
              <Icon marginLeft="8" name={group.suffixIcon} size="xs" />
            )}
          </ToggleButton>
        </Row>
      ))}
      {activeDropdown && (
        <Row
          paddingTop="8"
          ref={dropdownRef}
          position="absolute"
          pointerEvents="auto"
          opacity={100}
          top="32"
          className={isFirstAppearance ? styles.dropdown : ""}
          style={{
            left: `${dropdownPosition.left}px`,
            width: `${dropdownPosition.width}px`,
            transition: "left 0.3s ease, width 0.3s ease",
            visibility: "visible",
          }}
          onMouseEnter={() => {
            // Keep the current active dropdown when hovering over it
          }}
          onMouseLeave={() => {
            // Hide dropdown when mouse leaves it
            setActiveDropdown(null);
          }}
        >
          <Row
            background="surface"
            radius="l"
            border="neutral-alpha-weak"
            shadow="xl"
            padding="12"
            gap="32"
          >
            {dropdownGroups.map(
              (group, groupIndex) =>
                activeDropdown === group.id &&
                group.sections && (
                  <Row
                    key={`dropdown-content-${groupIndex}`}
                    gap="16"
                    ref={(el) => {
                      contentRefs.current[group.id] = el;
                    }}
                  >
                    {group.sections.map((section, sectionIndex) => (
                      <Column key={`section-${sectionIndex}`} minWidth={10} gap="4">
                        {section.title && (
                          <Text
                            marginLeft="16"
                            marginBottom="12"
                            marginTop="12"
                            onBackground="neutral-weak"
                            variant="label-default-s"
                          >
                            {section.title}
                          </Text>
                        )}
                        {section.links.map((link, linkIndex) => (
                          <ToggleButton
                            key={`link-${linkIndex}`}
                            className="fit-height p-4 pr-12"
                            style={{ height: "auto" }}
                            fillWidth
                            horizontal="start"
                            href={link.href}
                            onClick={() => handleLinkClick(link.href)}
                          >
                            {link.description ? (
                              <Row gap="12">
                                {link.icon && (
                                  <Icon
                                    name={link.icon}
                                    size="s"
                                    padding="8"
                                    radius="s"
                                    border="neutral-alpha-weak"
                                  />
                                )}
                                <Column gap="4">
                                  <Text onBackground="neutral-strong" variant="label-strong-s">
                                    {link.label}
                                  </Text>
                                  <Text onBackground="neutral-weak">{link.description}</Text>
                                </Column>
                              </Row>
                            ) : (
                              link.label
                            )}
                          </ToggleButton>
                        ))}
                      </Column>
                    ))}
                  </Row>
                ),
            )}
          </Row>
        </Row>
      )}
    </Flex>
  );
};
MegaMenu.displayName = "MegaMenu";
</file>

<file path="src/once-ui/modules/navigation/MobileMegaMenu.tsx">
"use client";
import React from "react";
import { Icon, Column, Flex, Option, Accordion, ElementType, Text } from "@/once-ui/components";
interface MenuLink {
  label: React.ReactNode;
  href: string;
  icon?: string;
  description?: React.ReactNode;
  selected?: boolean;
}
interface MenuSection {
  title?: React.ReactNode;
  links: MenuLink[];
}
interface MenuGroup {
  id: string;
  label: React.ReactNode;
  suffixIcon?: string;
  href?: string;
  selected?: boolean;
  sections?: MenuSection[];
}
interface MobileMegaMenuProps extends React.ComponentProps<typeof Flex> {
  menuGroups: MenuGroup[];
  onClose?: () => void;
}
const MobileMegaMenu: React.FC<MobileMegaMenuProps> = ({ menuGroups, onClose, ...flex }) => {
  const handleLinkClick = (href: string) => {
    onClose?.();
  };
  return (
    <Column fillWidth gap="4" {...flex}>
      {menuGroups.map((group) => {
        if (group.href && !group.sections) {
          return (
            <ElementType
              key={`group-${group.id}`}
              href={group.href}
              onLinkClick={() => group.href && handleLinkClick(group.href)}
            >
              <Flex
                fillWidth
                paddingY="12"
                paddingX="16"
                horizontal="space-between"
                vertical="center"
                radius="l"
                cursor="pointer"
                transition="macro-medium"
              >
                <Text variant="heading-strong-s" onBackground="neutral-strong">
                  {group.label}
                </Text>
                {group.suffixIcon && (
                  <Icon name={group.suffixIcon} size="s" onBackground="neutral-weak" />
                )}
              </Flex>
            </ElementType>
          );
        }
        return (
          <Accordion
            key={`group-${group.id}`}
            title={group.label}
            icon={group.suffixIcon || "chevronDown"}
            size="m"
            radius="l"
          >
            {group.sections && (
              <Column gap="4" fillWidth>
                {group.sections.map((section, secIdx) => {
                  const sectionKey = section.title
                    ? `${group.id}-${section.title}`
                    : `sec-${secIdx}`;
                  return section.title ? (
                    <Accordion key={sectionKey} title={section.title} size="s" radius="m">
                      <Column fitHeight fillWidth gap="4">
                        {section.links.map((link, linkIdx) => (
                          <Option
                            key={`link-${linkIdx}`}
                            href={link.href}
                            tabIndex={0}
                            onClick={() => handleLinkClick(link.href)}
                            aria-label={typeof link.label === "string" ? link.label : undefined}
                            label={link.label}
                            description={link.description}
                            value={link.href}
                            hasPrefix={
                              link.icon ? (
                                <Icon name={link.icon} size="s" onBackground="neutral-weak" />
                              ) : undefined
                            }
                          />
                        ))}
                      </Column>
                    </Accordion>
                  ) : (
                    <Column key={sectionKey} fitHeight fillWidth gap="4" paddingX="8">
                      {section.links.map((link, linkIdx) => (
                        <Option
                          key={`link-${linkIdx}`}
                          href={link.href}
                          tabIndex={0}
                          onClick={() => handleLinkClick(link.href)}
                          aria-label={typeof link.label === "string" ? link.label : undefined}
                          label={link.label}
                          description={link.description}
                          value={link.href}
                          hasPrefix={
                            link.icon ? (
                              <Icon name={link.icon} size="s" onBackground="neutral-weak" />
                            ) : undefined
                          }
                        />
                      ))}
                    </Column>
                  );
                })}
              </Column>
            )}
          </Accordion>
        );
      })}
    </Column>
  );
};
MobileMegaMenu.displayName = "MobileMegaMenu";
export { MobileMegaMenu };
</file>

<file path="src/once-ui/modules/seo/Meta.tsx">
import type { Metadata as NextMetadata } from "next";
export interface Alternate {
  href: string;
  hrefLang: string;
}
export interface MetaProps {
  title: string;
  description: string;
  baseURL: string;
  path?: string;
  type?: "website" | "article";
  image?: string;
  publishedTime?: string;
  author?: {
    name: string;
    url?: string;
  };
  canonical?: string;
  robots?: string;
  noindex?: boolean;
  nofollow?: boolean;
  alternates?: Alternate[];
}
export function generateMetadata({
  title,
  description,
  baseURL,
  path = "",
  type = "website",
  image,
  publishedTime,
  author,
  canonical,
  robots,
  noindex,
  nofollow,
  alternates,
}: MetaProps): NextMetadata {
  const normalizedBaseURL = baseURL.endsWith("/") ? baseURL.slice(0, -1) : baseURL;
  const normalizedPath = path.startsWith("/") ? path : `/${path}`;
  const ogImage = image
    ? `${image.startsWith("/") ? image : `/${image}`}`
    : `/og?title=${encodeURIComponent(title)}`;
  const url = canonical || `${normalizedBaseURL}${normalizedPath}`;
  let robotsContent = robots;
  if (!robotsContent && (noindex || nofollow)) {
    robotsContent = `${noindex ? "noindex" : "index"},${nofollow ? "nofollow" : "follow"}`;
  }
  return {
    metadataBase: new URL(
      normalizedBaseURL.startsWith("https://") ? normalizedBaseURL : `https://${normalizedBaseURL}`,
    ),
    title,
    description,
    openGraph: {
      title,
      description,
      type,
      ...(publishedTime && type === "article" ? { publishedTime } : {}),
      url,
      images: [
        {
          url: ogImage,
          alt: title,
        },
      ],
    },
    twitter: {
      card: "summary_large_image",
      title,
      description,
      images: [ogImage],
    },
    ...(author ? { authors: [{ name: author.name, url: author.url }] } : {}),
    ...(robotsContent ? { robots: robotsContent } : {}),
    ...(alternates?.length
      ? {
          alternates: {
            canonical: url,
            languages: Object.fromEntries(alternates.map((alt) => [alt.hrefLang, alt.href])),
          },
        }
      : {}),
  };
}
export const Meta = {
  generate: generateMetadata,
};
export default Meta;
</file>

<file path="src/once-ui/modules/seo/Schema.tsx">
import React from "react";
import Script from "next/script";
import { social } from "@/app/resources/once-ui.config";
export interface SchemaProps {
  as: "website" | "article" | "blogPosting" | "techArticle" | "webPage" | "organization";
  title: string;
  description: string;
  baseURL: string;
  path: string;
  datePublished?: string;
  dateModified?: string;
  image?: string;
  author?: {
    name: string;
    url?: string;
    image?: string;
  };
}
const schemaTypeMap = {
  website: "WebSite",
  article: "Article",
  blogPosting: "BlogPosting",
  techArticle: "TechArticle",
  webPage: "WebPage",
  organization: "Organization",
};
export function Schema({
  as,
  title,
  description,
  baseURL,
  path,
  datePublished,
  dateModified,
  image,
  author,
}: SchemaProps) {
  const normalizedBaseURL = baseURL.endsWith("/") ? baseURL.slice(0, -1) : baseURL;
  const normalizedPath = path.startsWith("/") ? path : `/${path}`;
  const imageUrl = image
    ? `${normalizedBaseURL}${image.startsWith("/") ? image : `/${image}`}`
    : `${normalizedBaseURL}/og?title=${encodeURIComponent(title)}`;
  const url = `${normalizedBaseURL}${normalizedPath}`;
  const schemaType = schemaTypeMap[as];
  // biome-ignore lint/suspicious/noExplicitAny: <cause why not, we love any in typescript..>
  const schema: Record<string, any> = {
    "@context": "https://schema.org",
    "@type": schemaType,
    url,
  };
  schema.sameAs = Object.values(social).filter(Boolean);
  if (as === "website") {
    schema.name = title;
    schema.description = description;
    schema.image = imageUrl;
  } else if (as === "organization") {
    schema.name = title;
    schema.description = description;
    schema.image = imageUrl;
  } else {
    schema.headline = title;
    schema.description = description;
    schema.image = imageUrl;
    if (datePublished) {
      schema.datePublished = datePublished;
      schema.dateModified = dateModified || datePublished;
    }
  }
  if (author) {
    schema.author = {
      "@type": "Person",
      name: author.name,
      ...(author.url && { url: author.url }),
      ...(author.image && {
        image: {
          "@type": "ImageObject",
          url: author.image,
        },
      }),
    };
  }
  return (
    <Script
      id={`schema-${as}-${path}`}
      type="application/ld+json"
      // biome-ignore lint/security/noDangerouslySetInnerHtml: <It's not dynamic nor a security issue.>
      dangerouslySetInnerHTML={{
        __html: JSON.stringify(schema),
      }}
    />
  );
}
export default Schema;
</file>

<file path="src/once-ui/styles/background.scss">
/****************************/
 /*     BACKGROUND-COLOR     */
/****************************/
/* PAGE */
.page-background {
    background-color: var(--page-background);
}
.surface-background {
    background-color: var(--surface-background);
    backdrop-filter: var(--backdrop-filter);
}
.overlay-background {
    background-color: var(--backdrop);
}
/* NEUTRAL */
.neutral-background-weak,
.neutral-background-medium,
.neutral-background-strong,
.neutral-background-alpha-weak,
.neutral-background-alpha-medium,
.neutral-background-alpha-strong {
    ::selection {
        background-color: var(--neutral-on-background-weak);
        color: var(--neutral-background-weak);
    }
}
.neutral-solid-weak,
.neutral-solid-medium,
.neutral-solid-strong {
    ::selection {
        background-color: var(--neutral-background-weak);
        color: var(--neutral-on-background-medium);
    }
}
.neutral-background-weak {
    background-color: var(--neutral-background-weak);
}
.neutral-background-medium {
    background-color: var(--neutral-background-medium);
}
.neutral-background-strong {
    background-color: var(--neutral-background-strong);
}
.neutral-solid-weak {
    background-color: var(--neutral-solid-weak);
}
.neutral-solid-medium {
    background-color: var(--neutral-solid-medium);
}
.neutral-solid-strong {
    background-color: var(--neutral-solid-strong);
}
.neutral-background-alpha-weak {
    background-color: var(--neutral-alpha-weak);
}
.neutral-background-alpha-medium {
    background-color: var(--neutral-alpha-medium);
}
.neutral-background-alpha-strong {
    background-color: var(--neutral-alpha-strong);
}
/* BRAND */
.brand-background-weak,
.brand-background-medium,
.brand-background-strong,
.brand-background-alpha-weak,
.brand-background-alpha-medium,
.brand-background-alpha-strong {
    ::selection {
        background-color: var(--brand-on-background-weak);
        color: var(--brand-background-weak);
    }
}
.brand-solid-weak,
.brand-solid-medium,
.brand-solid-strong {
    ::selection {
        background-color: var(--brand-background-weak);
        color: var(--brand-on-background-medium);
    }
}
.brand-background-weak {
    background-color: var(--brand-background-weak);
}
.brand-background-medium {
    background-color: var(--brand-background-medium);
}
.brand-background-strong {
    background-color: var(--brand-background-strong);
}
.brand-solid-weak {
    background-color: var(--brand-solid-weak);
}
.brand-solid-medium {
    background-color: var(--brand-solid-medium);
}
.brand-solid-strong {
    background-color: var(--brand-solid-strong);
}
.brand-background-alpha-weak {
    background-color: var(--brand-alpha-weak);
}
.brand-background-alpha-medium {
    background-color: var(--brand-alpha-medium);
}
.brand-background-alpha-strong {
    background-color: var(--brand-alpha-strong);
}
/* ACCENT */
.accent-background-weak,
.accent-background-medium,
.accent-background-strong,
.accent-background-alpha-weak,
.accent-background-alpha-medium,
.accent-background-alpha-strong {
    ::selection {
        background-color: var(--accent-on-background-weak);
        color: var(--accent-background-weak);
    }
}
.accent-solid-weak,
.accent-solid-medium,
.accent-solid-strong {
    ::selection {
        background-color: var(--accent-background-weak);
        color: var(--accent-on-background-medium);
    }
}
.accent-background-weak {
    background-color: var(--accent-background-weak);
}
.accent-background-medium {
    background-color: var(--accent-background-medium);
}
.accent-background-strong {
    background-color: var(--accent-background-strong);
}
.accent-solid-weak {
    background-color: var(--accent-solid-weak);
}
.accent-solid-medium {
    background-color: var(--accent-solid-medium);
}
.accent-solid-strong {
    background-color: var(--accent-solid-strong);
}
.accent-background-alpha-weak {
    background-color: var(--accent-alpha-weak);
}
.accent-background-alpha-medium {
    background-color: var(--accent-alpha-medium);
}
.accent-background-alpha-strong {
    background-color: var(--accent-alpha-strong);
}
/* INFO */
.info-background-weak,
.info-background-medium,
.info-background-strong,
.info-background-alpha-weak,
.info-background-alpha-medium,
.info-background-alpha-strong {
    ::selection {
        background-color: var(--info-on-background-weak);
        color: var(--info-background-weak);
    }
}
.info-solid-weak,
.info-solid-medium,
.info-solid-strong {
    ::selection {
        background-color: var(--info-background-weak);
        color: var(--info-on-background-medium);
    }
}
.info-background-weak {
    background-color: var(--info-background-weak);
}
.info-background-medium {
    background-color: var(--info-background-medium);
}
.info-background-strong {
    background-color: var(--info-background-strong);
}
.info-solid-weak {
    background-color: var(--info-solid-weak);
}
.info-solid-medium {
    background-color: var(--info-solid-medium);
}
.info-solid-strong {
    background-color: var(--info-solid-strong);
}
.info-background-alpha-weak {
    background-color: var(--info-alpha-weak);
}
.info-background-alpha-medium {
    background-color: var(--info-alpha-medium);
}
.info-background-alpha-strong {
    background-color: var(--info-alpha-strong);
}
/* DANGER */
.danger-background-weak,
.danger-background-medium,
.danger-background-strong,
.danger-background-alpha-weak,
.danger-background-alpha-medium,
.danger-background-alpha-strong {
    ::selection {
        background-color: var(--danger-on-background-weak);
        color: var(--danger-background-weak);
    }
}
.danger-solid-weak,
.danger-solid-medium,
.danger-solid-strong {
    ::selection {
        background-color: var(--danger-background-weak);
        color: var(--danger-on-background-medium);
    }
}
.danger-background-weak {
    background-color: var(--danger-background-weak);
}
.danger-background-medium {
    background-color: var(--danger-background-medium);
}
.danger-background-strong {
    background-color: var(--danger-background-strong);
}
.danger-solid-weak {
    background-color: var(--danger-solid-weak);
}
.danger-solid-medium {
    background-color: var(--danger-solid-medium);
}
.danger-solid-strong {
    background-color: var(--danger-solid-strong);
}
.danger-background-alpha-weak {
    background-color: var(--danger-alpha-weak);
}
.danger-background-alpha-medium {
    background-color: var(--danger-alpha-medium);
}
.danger-background-alpha-strong {
    background-color: var(--danger-alpha-strong);
}
/* WARNING */
.warning-background-weak,
.warning-background-medium,
.warning-background-strong,
.warning-background-alpha-weak,
.warning-background-alpha-medium,
.warning-background-alpha-strong {
    ::selection {
        background-color: var(--warning-on-background-weak);
        color: var(--warning-background-weak);
    }
}
.warning-solid-weak,
.warning-solid-medium,
.warning-solid-strong {
    ::selection {
        background-color: var(--warning-background-weak);
        color: var(--warning-on-background-medium);
    }
}
.warning-background-weak {
    background-color: var(--warning-background-weak);
}
.warning-background-medium {
    background-color: var(--warning-background-medium);
}
.warning-background-strong {
    background-color: var(--warning-background-strong);
}
.warning-solid-weak {
    background-color: var(--warning-solid-weak);
}
.warning-solid-medium {
    background-color: var(--warning-solid-medium);
}
.warning-solid-strong {
    background-color: var(--warning-solid-strong);
}
.warning-background-alpha-weak {
    background-color: var(--warning-alpha-weak);
}
.warning-background-alpha-medium {
    background-color: var(--warning-alpha-medium);
}
.warning-background-alpha-strong {
    background-color: var(--warning-alpha-strong);
}
/* SUCCESS */
.success-background-weak,
.success-background-medium,
.success-background-strong,
.success-background-alpha-weak,
.success-background-alpha-medium,
.success-background-alpha-strong {
    ::selection {
        background-color: var(--success-on-background-weak);
        color: var(--success-background-weak);
    }
}
.success-solid-weak,
.success-solid-medium,
.success-solid-strong {
    ::selection {
        background-color: var(--success-background-weak);
        color: var(--success-on-background-medium);
    }
}
.success-background-weak {
    background-color: var(--success-background-weak);
}
.success-background-medium {
    background-color: var(--success-background-medium);
}
.success-background-strong {
    background-color: var(--success-background-strong);
}
.success-solid-weak {
    background-color: var(--success-solid-weak);
}
.success-solid-medium {
    background-color: var(--success-solid-medium);
}
.success-solid-strong {
    background-color: var(--success-solid-strong);
}
.success-background-alpha-weak {
    background-color: var(--success-alpha-weak);
}
.success-background-alpha-medium {
    background-color: var(--success-alpha-medium);
}
.success-background-alpha-strong {
    background-color: var(--success-alpha-strong);
}
</file>

<file path="src/once-ui/styles/border.scss">
/****************************/
 /*           RADIUS         */
/****************************/
.radius-none {
    border-radius: none;
}
.radius-xl {
    border-radius: var(--radius-xl);
}
.radius-xl-4 {
    border-radius: var(--radius-xl-nest-4);
}
.radius-xl-8 {
    border-radius: var(--radius-xl-nest-8);
}
.radius-l {
    border-radius: var(--radius-l);
}
.radius-l-4 {
    border-radius: var(--radius-l-nest-4);
}
.radius-l-8 {
    border-radius: var(--radius-l-nest-8);
}
.radius-m {
    border-radius: var(--radius-m);
}
.radius-m-4 {
    border-radius: var(--radius-m-nest-4);
}
.radius-m-8 {
    border-radius: var(--radius-m-nest-8);
}
.radius-s {
    border-radius: var(--radius-s);
}
.radius-s-4 {
    border-radius: var(--radius-s-nest-4);
}
.radius-s-8 {
    border-radius: var(--radius-s-nest-8);
}
.radius-xs {
    border-radius: var(--radius-xs);
}
.radius-xs-4 {
    border-radius: var(--radius-xs-nest-4);
}
.radius-xs-8 {
    border-radius: var(--radius-xs-nest-8);
}
.radius-full {
    border-radius: var(--radius-full);
}
.radius-xs-top {
    border-top-right-radius: var(--radius-xs);
    border-top-left-radius: var(--radius-xs);
}
.radius-s-top {
    border-top-right-radius: var(--radius-s);
    border-top-left-radius: var(--radius-s);
}
.radius-m-top {
    border-top-right-radius: var(--radius-m);
    border-top-left-radius: var(--radius-m);
}
.radius-l-top {
    border-top-right-radius: var(--radius-l);
    border-top-left-radius: var(--radius-l);
}
.radius-xl-top {
    border-top-right-radius: var(--radius-xl);
    border-top-left-radius: var(--radius-xl);
}
.radius-xs-right {
    border-bottom-right-radius: var(--radius-xs);
    border-top-right-radius: var(--radius-xs);
}
.radius-s-right {
    border-bottom-right-radius: var(--radius-s);
    border-top-right-radius: var(--radius-s);
}
.radius-m-right {
    border-bottom-right-radius: var(--radius-m);
    border-top-right-radius: var(--radius-m);
}
.radius-l-right {
    border-bottom-right-radius: var(--radius-l);
    border-top-right-radius: var(--radius-l);
}
.radius-xl-right {
    border-bottom-right-radius: var(--radius-xl);
    border-top-right-radius: var(--radius-xl);
}
.radius-xs-bottom {
    border-bottom-right-radius: var(--radius-xs);
    border-bottom-left-radius: var(--radius-xs);
}
.radius-s-bottom {
    border-bottom-right-radius: var(--radius-s);
    border-bottom-left-radius: var(--radius-s);
}
.radius-m-bottom {
    border-bottom-right-radius: var(--radius-m);
    border-bottom-left-radius: var(--radius-m);
}
.radius-l-bottom {
    border-bottom-right-radius: var(--radius-l);
    border-bottom-left-radius: var(--radius-l);
}
.radius-xl-bottom {
    border-bottom-right-radius: var(--radius-xl);
    border-bottom-left-radius: var(--radius-xl);
}
.radius-xs-left {
    border-bottom-left-radius: var(--radius-xs);
    border-top-left-radius: var(--radius-xs);
}
.radius-s-left {
    border-bottom-left-radius: var(--radius-s);
    border-top-left-radius: var(--radius-s);
}
.radius-m-left {
    border-bottom-left-radius: var(--radius-m);
    border-top-left-radius: var(--radius-m);
}
.radius-l-left {
    border-bottom-left-radius: var(--radius-l);
    border-top-left-radius: var(--radius-l);
}
.radius-xl-left {
    border-bottom-left-radius: var(--radius-xl);
    border-top-left-radius: var(--radius-xl);
}
.radius-xs-top-left {
    border-top-left-radius: var(--radius-xs);
}
.radius-s-top-left {
    border-top-left-radius: var(--radius-s);
}
.radius-m-top-left {
    border-top-left-radius: var(--radius-m);
}
.radius-l-top-left {
    border-top-left-radius: var(--radius-l);
}
.radius-xl-top-left {
    border-top-left-radius: var(--radius-xl);
}
.radius-xs-top-right {
    border-top-right-radius: var(--radius-xs);
}
.radius-s-top-right {
    border-top-right-radius: var(--radius-s);
}
.radius-m-top-right {
    border-top-right-radius: var(--radius-m);
}
.radius-l-top-right {
    border-top-right-radius: var(--radius-l);
}
.radius-xl-top-right {
    border-top-right-radius: var(--radius-xl);
}
.radius-xs-bottom-right {
    border-bottom-right-radius: var(--radius-xs);
}
.radius-s-bottom-right {
    border-bottom-right-radius: var(--radius-s);
}
.radius-m-bottom-right {
    border-bottom-right-radius: var(--radius-m);
}
.radius-l-bottom-right {
    border-bottom-right-radius: var(--radius-l);
}
.radius-xl-bottom-right {
    border-bottom-right-radius: var(--radius-xl);
}
.radius-xs-bottom-left {
    border-bottom-left-radius: var(--radius-xs);
}
.radius-s-bottom-left {
    border-bottom-left-radius: var(--radius-s);
}
.radius-m-bottom-left {
    border-bottom-left-radius: var(--radius-m);
}
.radius-l-bottom-left {
    border-bottom-left-radius: var(--radius-l);
}
.radius-xl-bottom-left {
    border-bottom-left-radius: var(--radius-xl);
}
  /****************************/
 /*           STYLE          */
/****************************/
.border-solid {
    border-style: solid;
}
.border-dashed {
    border-style: dashed;
}
.border-1 {
    border-width: 1px;
}
.border-2 {
    border-width: 2px;
}
.border-reset {
    border-top-width: 0;
    border-right-width: 0;
    border-bottom-width: 0;
    border-left-width: 0; 
}
.border-top-1 {
    border-top-width: 1px;
}
.border-bottom-1 {
    border-bottom-width: 1px;
}
.border-left-1 {
    border-left-width: 1px;
}
.border-right-1 {
    border-right-width: 1px;
}
  /****************************/
 /*           COLOR          */
/****************************/
/* PAGE */
.surface-border {
    border-color: var(--surface-border);
}
.transparent-border {
    border-color: var(--static-transparent);
}
/* NEUTRAL */
.neutral-border-weak {
    border-color: var(--neutral-border-weak);
}
.neutral-border-medium {
    border-color: var(--neutral-border-medium);
}
.neutral-border-strong {
    border-color: var(--neutral-border-strong);
}
.neutral-border-alpha-weak {
    border-color: var(--neutral-alpha-weak);
}
.neutral-border-alpha-medium {
    border-color: var(--neutral-alpha-medium);
}
.neutral-border-alpha-strong {
    border-color: var(--neutral-alpha-strong);
}
/* BRAND */
.brand-border-weak {
    border-color: var(--brand-border-weak);
}
.brand-border-medium {
    border-color: var(--brand-border-medium);
}
.brand-border-strong {
    border-color: var(--brand-border-strong);
}
.brand-border-alpha-weak {
    border-color: var(--brand-alpha-weak);
}
.brand-border-alpha-medium {
    border-color: var(--brand-alpha-medium);
}
.brand-border-alpha-strong {
    border-color: var(--brand-alpha-strong);
}
/* ACCENT */
.accent-border-weak {
    border-color: var(--accent-border-weak);
}
.accent-border-medium {
    border-color: var(--accent-border-medium);
}
.accent-border-strong {
    border-color: var(--accent-border-strong);
}
.accent-border-alpha-weak {
    border-color: var(--accent-alpha-weak);
}
.accent-border-alpha-medium {
    border-color: var(--accent-alpha-medium);
}
.accent-border-alpha-strong {
    border-color: var(--accent-alpha-strong);
}
/* INFO */
.info-border-weak {
    border-color: var(--info-border-weak);
}
.info-border-medium {
    border-color: var(--info-border-medium);
}
.info-border-strong {
    border-color: var(--info-border-strong);
}
.info-border-alpha-weak {
    border-color: var(--info-alpha-weak);
}
.info-border-alpha-medium {
    border-color: var(--info-alpha-medium);
}
.info-border-alpha-strong {
    border-color: var(--info-alpha-strong);
}
/* DANGER */
.danger-border-weak {
    border-color: var(--danger-border-weak);
}
.danger-border-medium {
    border-color: var(--danger-border-medium);
}
.danger-border-strong {
    border-color: var(--danger-border-strong);
}
.danger-border-alpha-weak {
    border-color: var(--danger-alpha-weak);
}
.danger-border-alpha-medium {
    border-color: var(--danger-alpha-medium);
}
.danger-border-alpha-strong {
    border-color: var(--danger-alpha-strong);
}
/* WARNING */
.warning-border-weak {
    border-color: var(--warning-border-weak);
}
.warning-border-medium {
    border-color: var(--warning-border-medium);
}
.warning-border-strong {
    border-color: var(--warning-border-strong);
}
.warning-border-alpha-weak {
    border-color: var(--warning-alpha-weak);
}
.warning-border-alpha-medium {
    border-color: var(--warning-alpha-medium);
}
.warning-border-alpha-strong {
    border-color: var(--warning-alpha-strong);
}
/* SUCCESS */
.success-border-weak {
    border-color: var(--success-border-weak);
}
.success-border-medium {
    border-color: var(--success-border-medium);
}
.success-border-strong {
    border-color: var(--success-border-strong);
}
.success-border-alpha-weak {
    border-color: var(--success-alpha-weak);
}
.success-border-alpha-medium {
    border-color: var(--success-alpha-medium);
}
.success-border-alpha-strong {
    border-color: var(--success-alpha-strong);
}
</file>

<file path="src/once-ui/styles/breakpoints.scss">
@custom-media --s (max-width: 768px);
@custom-media --m (max-width: 1024px);
@custom-media --l (max-width: 1440px);
</file>

<file path="src/once-ui/styles/color.scss">
/****************************/
 /*          COLOR           */
/****************************/
/* NEUTRAL */
.color-inherit {
    color: inherit;
}
/* NEUTRAL */
.neutral-on-background-weak {
    color: var(--neutral-on-background-weak);
}
.neutral-on-background-medium {
    color: var(--neutral-on-background-medium);
}
.neutral-on-background-strong {
    color: var(--neutral-on-background-strong);
}
.neutral-on-solid-weak {
    color: var(--neutral-on-solid-weak);
}
.neutral-on-solid-medium {
    color: var(--neutral-on-solid-medium);
}
.neutral-on-solid-strong {
    color: var(--neutral-on-solid-strong);
}
/* BRAND */
.brand-on-background-weak {
    color: var(--brand-on-background-weak);
}
.brand-on-background-medium {
    color: var(--brand-on-background-medium);
}
.brand-on-background-strong {
    color: var(--brand-on-background-strong);
}
.brand-on-solid-weak {
    color: var(--brand-on-solid-weak);
}
.brand-on-solid-medium {
    color: var(--brand-on-solid-medium);
}
.brand-on-solid-strong {
    color: var(--brand-on-solid-strong);
}
/* ACCENT */
.accent-on-background-weak {
    color: var(--accent-on-background-weak);
}
.accent-on-background-medium {
    color: var(--accent-on-background-medium);
}
.accent-on-background-strong {
    color: var(--accent-on-background-strong);
}
.accent-on-solid-weak {
    color: var(--accent-on-solid-weak);
}
.accent-on-solid-medium {
    color: var(--accent-on-solid-medium);
}
.accent-on-solid-strong {
    color: var(--accent-on-solid-strong);
}
/* INFO */
.info-on-background-weak {
    color: var(--info-on-background-weak);
}
.info-on-background-medium {
    color: var(--info-on-background-medium);
}
.info-on-background-strong {
    color: var(--info-on-background-strong);
}
.info-on-solid-weak {
    color: var(--info-on-solid-weak);
}
.info-on-solid-medium {
    color: var(--info-on-solid-medium);
}
.info-on-solid-strong {
    color: var(--info-on-solid-strong);
}
/* DANGER */
.danger-on-background-weak {
    color: var(--danger-on-background-weak);
}
.danger-on-background-medium {
    color: var(--danger-on-background-medium);
}
.danger-on-background-strong {
    color: var(--danger-on-background-strong);
}
.danger-on-solid-weak {
    color: var(--danger-on-solid-weak);
}
.danger-on-solid-medium {
    color: var(--danger-on-solid-medium);
}
.danger-on-solid-strong {
    color: var(--danger-on-solid-strong);
}
/* WARNING */
.warning-on-background-weak {
    color: var(--warning-on-background-weak);
}
.warning-on-background-medium {
    color: var(--warning-on-background-medium);
}
.warning-on-background-strong {
    color: var(--warning-on-background-strong);
}
.warning-on-solid-weak {
    color: var(--warning-on-solid-weak);
}
.warning-on-solid-medium {
    color: var(--warning-on-solid-medium);
}
.warning-on-solid-strong {
    color: var(--warning-on-solid-strong);
}
/* SUCCESS */
.success-on-background-weak {
    color: var(--success-on-background-weak);
}
.success-on-background-medium {
    color: var(--success-on-background-medium);
}
.success-on-background-strong {
    color: var(--success-on-background-strong);
}
.success-on-solid-weak {
    color: var(--success-on-solid-weak);
}
.success-on-solid-medium {
    color: var(--success-on-solid-medium);
}
.success-on-solid-strong {
    color: var(--success-on-solid-strong);
}
</file>

<file path="src/once-ui/styles/display.scss">
.overflow-auto {
  overflow: auto;
}
.overflow-x-scroll{
  overflow-x: scroll;
}
.overflow-x-auto {
  overflow-x: auto;
}
.overflow-y-auto{
  overflow-y: auto;
}
.overflow-y-scroll{
  overflow-y: scroll;
}
.overflow-hidden {
  overflow: hidden;
}
.overflow-scroll{
  overflow: scroll;
}
.overflow-x-hidden {
  overflow-x: hidden;
}
.overflow-y-hidden{
  overflow-y: hidden;
}
.opacity-0 {
  opacity: 0;
}
.opacity-10 {
  opacity: 0.1;
}
.opacity-20 {
  opacity: 0.2;
}
.opacity-30 {
  opacity: 0.3;
}
.opacity-40 {
  opacity: 0.4;
}
.opacity-50 {
  opacity: 0.5;
}
.opacity-60 {
  opacity: 0.6;
}
.opacity-70 {
  opacity: 0.7;
}
.opacity-80 {
  opacity: 0.8;
}
.opacity-90 {
  opacity: 0.9;
}
.opacity-100 {
  opacity: 1;
}
.z-index--1 {
  z-index: -1;
}
.z-index-0 {
  z-index: 0;
}
.z-index-1 {
  z-index: 1;
}
.z-index-2 {
  z-index: 2;
}
.z-index-3 {
  z-index: 3;
}
.z-index-4 {
  z-index: 4;
}
.z-index-5 {
  z-index: 5;
}
.z-index-6 {
  z-index: 6;
}
.z-index-7 {
  z-index: 7;
}
.z-index-8 {
  z-index: 8;
}
.z-index-9 {
  z-index: 9;
}
.z-index-10 {
  z-index: 10;
}
.transition-micro-short {
  transition: var(--transition-micro-short);
}
.transition-micro-medium {
  transition: var(--transition-micro-medium);
}
.transition-micro-long {
  transition: var(--transition-micro-long);
}
.transition-macro-short {
  transition: var(--transition-macro-short);
}
.transition-macro-medium {
  transition: var(--transition-macro-medium);
}
.transition-macro-long {
  transition: var(--transition-macro-long);
}
.pointer-events-none {
  pointer-events: none;
}
.pointer-events-auto {
  pointer-events: auto;
}
.pointer-events-all {
  pointer-events: all;
}
.cursor-interactive {
  cursor: var(--cursor-interactive);
}
.cursor-pointer {
  cursor: pointer;
}
.cursor-default {
  cursor: default;
}
.cursor-text {
  cursor: text;
}
.cursor-move {
  cursor: move;
}
.cursor-not-allowed {
  cursor: not-allowed;
}
.cursor-wait {
  cursor: wait;
}
.cursor-help {
  cursor: help;
}
.cursor-grab {
  cursor: grab;
}
.cursor-grabbing {
  cursor: grabbing;
}
.cursor-zoom-in {
  cursor: zoom-in;
}
.cursor-zoom-out {
  cursor: zoom-out;
}
</file>

<file path="src/once-ui/styles/flex.scss">
.justify-start {
  justify-content: flex-start;
}
.justify-center {
  justify-content: center;
}
.justify-end {
  justify-content: flex-end;
}
.justify-space-between {
  justify-content: space-between;
}
.justify-space-around {
  justify-content: space-around;
}
.justify-space-evenly {
  justify-content: space-evenly;
}
.justify-stretch {
  justify-content: stretch;
}
.align-start {
  align-items: flex-start;
}
.align-center {
  align-items: center;
}
.align-end {
  align-items: flex-end;
}
.align-space-between {
  align-items: space-between;
}
.align-space-around {
  align-items: space-around;
}
.align-space-evenly {
  align-items: space-evenly;
}
.align-stretch {
  align-items: stretch;
}
.center {
  align-items: center;
  justify-content: center;
}
.flex-wrap {
  flex-wrap: wrap;
}
.flex-nowrap {
  flex-wrap: nowrap;
}
.flex-wrap-reverse {
  flex-wrap: wrap-reverse;
}
.flex-0 {
  flex: 0;
}
.flex-1 {
  flex: 1;
}
.flex-2 {
  flex: 2;
}
.flex-3 {
  flex: 3;
}
.flex-4 {
  flex: 4;
}
.flex-5 {
  flex: 5;
}
.flex-6 {
  flex: 6;
}
.flex-7 {
  flex: 7;
}
.flex-8 {
  flex: 8;
}
.flex-9 { 
  flex: 9;
}
.flex-10 {
  flex: 10;
}
.flex-11 {
  flex: 11;
}
.flex-12 {
  flex: 12;
}
</file>

<file path="src/once-ui/styles/global.scss">
* {
    box-sizing: border-box;
    scroll-behavior: smooth;
}
h1, h2, h3, h4, h5, h6 {
    scroll-margin-top: var(--static-space-80);
}
ul, ol {
    margin: 0;
    width: 100%;
}
ul {
    padding: 0 0 0 var(--static-space-20);
    li {
        padding-left: var(--static-space-8);
    }
}
ol {
    padding: 0 0 0 var(--static-space-20);
    li {
        padding-left: var(--static-space-16);
    }
}
li {
    padding: 0;
    line-height: 175%;
    font-size: inherit;
    color: inherit;
    margin-bottom: var(--static-space-12);
    &::marker {
        color: var(--brand-on-background-weak);
    }
}
blockquote {
    display: flex;
    margin: var(--static-space-16) 0;
    border-radius: var(--radius-m);
    background: var(--brand-alpha-weak);
    overflow: hidden;
    text-wrap: balance;
    backdrop-filter: blur(var(--static-space-2));
    border: 1px dashed var(--brand-alpha-medium);
    max-width: var(--responsive-width-xs);
    padding: var(--static-space-12) var(--static-space-24) var(--static-space-8) var(--static-space-24);
    width: 100%;
    span {
        margin: 0 !important;
        padding: var(--static-space-16) var(--static-space-24);
        color: var(--brand-on-background-medium) !important;
        font-family: var(--font-family-code) !important;
    }
}
img {
    user-select: none;
}
/* SELECTION */
::selection {
    background: var(--neutral-on-background-medium);
    color: var(--neutral-background-strong);
}
/* LINK */
a:not(.button) {
    color: var(--brand-on-background-medium);
    text-decoration: none;
    transition: var(--transition-micro-medium);
    text-decoration-thickness: 1px;
    text-underline-offset: 0.25em;
    text-decoration-color: var(--neutral-border-strong) !important;
    &:hover {
        text-decoration: none;
        color: var(--brand-on-background-strong);
    }
}
/* SCROLLBAR */
::-webkit-scrollbar {
    background: var(--static-transparent);
    width: var(--static-space-8);
    height: var(--static-space-8);
}
::-webkit-scrollbar-track {
    background: var(--static-transparent);
}
::-webkit-scrollbar-thumb {
    background: var(--neutral-alpha-medium);
    transition: var(--transition-micro-medium);
    &:hover {
        background: var(--neutral-alpha-strong);
    }
}
::-webkit-scrollbar-corner {
    background-color: var(--static-transparent);
}
</file>

<file path="src/once-ui/styles/grid.scss">
.columns-1 {
  grid-template-columns: 1fr;
}
.columns-2 {
  grid-template-columns: repeat(2, 1fr);
}
.columns-3 {
  grid-template-columns: repeat(3, 1fr);
}
.columns-4 {
  grid-template-columns: repeat(4, 1fr);
}
.columns-5 {
  grid-template-columns: repeat(5, 1fr);
}
.columns-6 {
  grid-template-columns: repeat(6, 1fr);
}
.columns-7 {
  grid-template-columns: repeat(7, 1fr);
}
.columns-8 {
  grid-template-columns: repeat(8, 1fr);
}
.columns-8 {
  grid-template-columns: repeat(9, 1fr);
}
.columns-8 {
  grid-template-columns: repeat(10, 1fr);
}
.columns-8 {
  grid-template-columns: repeat(11, 1fr);
}
.columns-8 {
  grid-template-columns: repeat(12, 1fr);
}
@media (--m) {
  .tablet-columns-1 {
      grid-template-columns: 1fr;
  }
  .tablet-columns-2 {
      grid-template-columns: repeat(2, 1fr);
  }
  .tablet-columns-3 {
      grid-template-columns: repeat(3, 1fr);
  }
  .tablet-columns-4 {
      grid-template-columns: repeat(4, 1fr);
  }
  .tablet-columns-5 {
      grid-template-columns: repeat(5, 1fr);
  }
  .tablet-columns-6 {
      grid-template-columns: repeat(6, 1fr);
  }
  .tablet-columns-7 {
      grid-template-columns: repeat(7, 1fr);
  }
  .tablet-columns-8 {
      grid-template-columns: repeat(8, 1fr);
  }
  .tablet-columns-8 {
      grid-template-columns: repeat(9, 1fr);
  }
  .tablet-columns-8 {
      grid-template-columns: repeat(10, 1fr);
  }
  .tablet-columns-8 {
      grid-template-columns: repeat(11, 1fr);
  }
  .tablet-columns-8 {
      grid-template-columns: repeat(12, 1fr);
  }
}
@media (--s) {
  .mobile-columns-1 {
      grid-template-columns: 1fr;
  }
  .mobile-columns-2 {
      grid-template-columns: repeat(2, 1fr);
  }
  .mobile-columns-3 {
      grid-template-columns: repeat(3, 1fr);
  }
  .mobile-columns-4 {
      grid-template-columns: repeat(4, 1fr);
  }
  .mobile-columns-5 {
      grid-template-columns: repeat(5, 1fr);
  }
  .mobile-columns-6 {
      grid-template-columns: repeat(6, 1fr);
  }
  .mobile-columns-7 {
      grid-template-columns: repeat(7, 1fr);
  }
  .mobile-columns-8 {
      grid-template-columns: repeat(8, 1fr);
  }
  .mobile-columns-8 {
      grid-template-columns: repeat(9, 1fr);
  }
  .mobile-columns-8 {
      grid-template-columns: repeat(10, 1fr);
  }
  .mobile-columns-8 {
      grid-template-columns: repeat(11, 1fr);
  }
  .mobile-columns-8 {
      grid-template-columns: repeat(12, 1fr);
  }
}
</file>

<file path="src/once-ui/styles/index.scss">
@use "@/once-ui/styles/spacing.scss";
@use "@/once-ui/styles/border.scss";
@use "@/once-ui/styles/color.scss";
@use "@/once-ui/styles/background.scss";
@use "@/once-ui/styles/typography.scss";
@use "@/once-ui/styles/global.scss";
@use "@/once-ui/styles/layout.scss";
@use "@/once-ui/styles/shadow.scss";
@use "@/once-ui/styles/size.scss";
@use "@/once-ui/styles/display.scss";
@use "@/once-ui/styles/position.scss";
@use "@/once-ui/styles/grid.scss";
@use "@/once-ui/styles/flex.scss";
@use "@/once-ui/styles/utilities.scss";
</file>

<file path="src/once-ui/styles/layout.scss">
.display-flex {
    display: flex;
}
.display-grid {
    display: grid;
}
.display-inline-flex {
    display: inline-flex;
}
.flex-column {
    flex-direction: column;
}
.flex-row {
    flex-direction: row;
}
.flex-column-reverse {
    flex-direction: column-reverse;
}
.flex-row-reverse {
    flex-direction: row-reverse;
}
.l-flex-show {
    display: none !important;
}
.m-flex-show {
    display: none !important;
}
.s-flex-show {
    display: none !important;
}
@media (--l) {
    .l-flex-hide {
        display: none !important;
    }
    .l-flex-show {
        display: flex !important;
    }
    .l-flex-column {
        flex-direction: column !important;
    }
    .l-flex-row {
        flex-direction: row !important;
    }
    .l-flex-column-reverse {
        flex-direction: column-reverse !important;
    }
    .l-flex-row-reverse {
        flex-direction: row-reverse !important;
    }
}
@media (--m) {
    .m-flex-hide {
        display: none !important;
    }
    .m-flex-show {
        display: flex !important;
    }
    .m-flex-column {
        flex-direction: column !important;
    }
    .m-flex-row {
        flex-direction: row !important;
    }
    .m-flex-column-reverse {
        flex-direction: column-reverse !important;
    }
    .m-flex-row-reverse {
        flex-direction: row-reverse !important;
    }
}
@media (--s) {
    .s-flex-hide {
        display: none !important;
    }
    .s-flex-show {
        display: flex !important;
    }
    .s-flex-column {
        flex-direction: column !important;
    }
    .s-flex-row {
        flex-direction: row !important;
    }
    .s-flex-column-reverse {
        flex-direction: column-reverse !important;
    }
    .s-flex-row-reverse {
        flex-direction: row-reverse !important;
    }
}
</file>

<file path="src/once-ui/styles/position.scss">
.position-relative {
  position: relative;
}
.position-fixed {
  position: fixed;
}
.position-absolute {
  position: absolute;
}
.position-sticky {
  position: sticky;
}
.position-static {
  position: static;
}
.top-0 { 
  top: 0;
}
.left-0 { 
  left: 0;
}
.bottom-0 { 
  bottom: 0;
}
.right-0 { 
  right: 0;
}
.top-1 { 
  top: var(--static-space-1);
}
.left-1 { 
  left: var(--static-space-1);
}
.bottom-1 { 
  bottom: var(--static-space-1);
}
.right-1 { 
  right: var(--static-space-1);
}
.top-2 { 
  top: var(--static-space-2);
}
.left-2 { 
  left: var(--static-space-2);
}
.bottom-2 { 
  bottom: var(--static-space-2);
}
.right-2 { 
  right: var(--static-space-2);
}
.top-4 { 
  top: var(--static-space-4);
}
.left-4 { 
  left: var(--static-space-4);
}
.bottom-4 { 
  bottom: var(--static-space-4);
}
.right-4 { 
  right: var(--static-space-4);
}
.top-8 { 
  top: var(--static-space-8);
}
.left-8 { 
  left: var(--static-space-8);
}
.bottom-8 { 
  bottom: var(--static-space-8);
}
.right-8 { 
  right: var(--static-space-8);
}
.top-12 { 
  top: var(--static-space-12);
}
.left-12 { 
  left: var(--static-space-12);
}
.bottom-12 { 
  bottom: var(--static-space-12);
}
.right-12 { 
  right: var(--static-space-12);
}
.top-16 { 
  top: var(--static-space-16);
}
.left-16 { 
  left: var(--static-space-16);
}
.bottom-16 { 
  bottom: var(--static-space-16);
}
.right-16 { 
  right: var(--static-space-16);
}
.top-20 { 
  top: var(--static-space-20);
}
.left-20 { 
  left: var(--static-space-20);
}
.bottom-20 { 
  bottom: var(--static-space-20);
}
.right-20 { 
  right: var(--static-space-20);
}
.top-24 { 
  top: var(--static-space-24);
}
.left-24 { 
  left: var(--static-space-24);
}
.bottom-24 { 
  bottom: var(--static-space-24);
}
.right-24 { 
  right: var(--static-space-24);
}
.top-32 { 
  top: var(--static-space-32);
}
.left-32 { 
  left: var(--static-space-32);
}
.bottom-32 { 
  bottom: var(--static-space-32);
}
.right-32 { 
  right: var(--static-space-32);
}
.top-40 { 
  top: var(--static-space-40);
}
.left-40 { 
  left: var(--static-space-40);
}
.bottom-40 { 
  bottom: var(--static-space-40);
}
.right-40 { 
  right: var(--static-space-40);
}
.top-48 { 
  top: var(--static-space-48);
}
.left-48 { 
  left: var(--static-space-48);
}
.bottom-48 { 
  bottom: var(--static-space-48);
}
.right-48 { 
  right: var(--static-space-48);
}
.top-56 { 
  top: var(--static-space-56);
}
.left-56 { 
  left: var(--static-space-56);
}
.bottom-56 { 
  bottom: var(--static-space-56);
}
.right-56 { 
  right: var(--static-space-56);
}
.top-64 { 
  top: var(--static-space-64);
}
.left-64 { 
  left: var(--static-space-64);
}
.bottom-64 { 
  bottom: var(--static-space-64);
}
.right-64 { 
  right: var(--static-space-64);
}
.top-80 { 
  top: var(--static-space-80);
}
.left-80 { 
  left: var(--static-space-80);
}
.bottom-80 { 
  bottom: var(--static-space-80);
}
.right-80 { 
  right: var(--static-space-80);
}
.top-104 { 
  top: var(--static-space-104); 
}
.left-104 { 
  left: var(--static-space-104); 
}
.bottom-104 { 
  bottom: var(--static-space-104); 
}
.right-104 { 
  right: var(--static-space-104); 
}
.top-128 { 
  top: var(--static-space-128); 
}
.left-128 { 
  left: var(--static-space-128); 
}
.bottom-128 { 
  bottom: var(--static-space-128); 
}
.right-128 { 
  right: var(--static-space-128); 
}
.top-160 { 
  top: var(--static-space-160); 
}
.left-160 { 
  left: var(--static-space-160); 
}
.bottom-160 { 
  bottom: var(--static-space-160); 
}
.right-160 { 
  right: var(--static-space-160);
}
</file>

<file path="src/once-ui/styles/shadow.scss">
.shadow-xs {
    box-shadow: var(--shadow-xs);
}
.shadow-s {
    box-shadow: var(--shadow-s);
}
.shadow-m {
    box-shadow: var(--shadow-m);
}
.shadow-l {
    box-shadow: var(--shadow-l);
}
.shadow-xl {
    box-shadow: var(--shadow-xl);
}
</file>

<file path="src/once-ui/styles/size.scss">
.fill-width {
  width: 100%;
}
.fill-height {
  height: 100%;
}
.fill {
  width: 100%;
  height: 100%;
}
.fit-width {
  width: fit-content;
}
.fit-height {
  height: fit-content;
}
.fit {
  width: fit-content;
  height: fit-content;
}
.min-width-0 {
  min-width: 0;
}
.min-height-0 {
  min-height: 0;
}
</file>

<file path="src/once-ui/styles/spacing.scss">
/****************************/
 /*           MARGIN         */
/****************************/
/* EVEN */
.m-0 {
    margin: var(--static-space-0);
}
.m-1 {
    margin: var(--static-space-1);
}
.m-2 {
    margin: var(--static-space-2);
}
.m-4 {
    margin: var(--static-space-4);
}
.m-8 {
    margin: var(--static-space-8);
}
.m-12 {
    margin: var(--static-space-12);
}
.m-16 {
    margin: var(--static-space-16);
}
.m-20 {
    margin: var(--static-space-20);
}
.m-24 {
    margin: var(--static-space-24);
}
.m-32 {
    margin: var(--static-space-32);
}
.m-40 {
    margin: var(--static-space-40);
}
.m-48 {
    margin: var(--static-space-48);
}
.m-56 {
    margin: var(--static-space-56);
}
.m-64 {
    margin: var(--static-space-64);
}
.m-80 {
    margin: var(--static-space-80);
}
.m-104 {
    margin: var(--static-space-104);
}
.m-128 {
    margin: var(--static-space-128);
}
.m-160 {
    margin: var(--static-space-160);
}
.m-xs {
    margin-bottom: var(--responsive-space-xs);
}
.m-s {
    margin-bottom: var(--responsive-space-s);
}
.m-m {
    margin-bottom: var(--responsive-space-m);
}
.m-l {
    margin-bottom: var(--responsive-space-l);
}
.m-xl {
    margin-bottom: var(--responsive-space-xl);
}
/* X */
.mx-0 {
    margin: auto var(--static-space-0);
}
.mx-1 {
    margin: auto var(--static-space-1);
}
.mx-2 {
    margin: auto var(--static-space-2);
}
.mx-4 {
    margin: auto var(--static-space-4);
}
.mx-8 {
    margin: auto var(--static-space-8);
}
.mx-12 {
    margin: auto var(--static-space-12);
}
.mx-16 {
    margin: auto var(--static-space-16);
}
.mx-20 {
    margin: auto var(--static-space-20);
}
.mx-24 {
    margin: auto var(--static-space-24);
}
.mx-32 {
    margin: auto var(--static-space-32);
}
.mx-40 {
    margin: auto var(--static-space-40);
}
.mx-64 {
    margin: auto var(--static-space-64);
}
.mx-80 {
    margin: auto var(--static-space-80);
}
.mx-104 {
    margin: auto var(--static-space-104);
}
.mx-128 {
    margin: auto var(--static-space-128);
}
.mx-160 {
    margin: auto var(--static-space-160);
}
.mx-xs {
    margin-bottom: var(--responsive-space-xs);
}
.mx-s {
    margin-bottom: var(--responsive-space-s);
}
.mx-m {
    margin-bottom: var(--responsive-space-m);
}
.mx-l {
    margin-bottom: var(--responsive-space-l);
}
.mx-xl {
    margin-bottom: var(--responsive-space-xl);
}
/* Y */
.my-0 {
    margin: var(--static-space-0) auto;
}
.my-1 {
    margin: var(--static-space-1) auto;
}
.my-2 {
    margin: var(--static-space-2) auto;
}
.my-4 {
    margin: var(--static-space-4) auto;
}
.my-8 {
    margin: var(--static-space-8) auto;
}
.my-12 {
    margin: var(--static-space-12) auto;
}
.my-16 {
    margin: var(--static-space-16) auto;
}
.my-20 {
    margin: var(--static-space-20) auto;
}
.my-24 {
    margin: var(--static-space-24) auto;
}
.my-32 {
    margin: var(--static-space-32) auto;
}
.my-40 {
    margin: var(--static-space-40) auto;
}
.my-48 {
    margin: var(--static-space-48) auto;
}
.my-56 {
    margin: var(--static-space-56) auto;
}
.my-64 {
    margin: var(--static-space-64) auto;
}
.my-80 {
    margin: var(--static-space-80) auto;
}
.my-104 {
    margin: var(--static-space-104) auto;
}
.my-128 {
    margin: var(--static-space-128) auto;
}
.my-160 {
    margin: var(--static-space-160) auto;
}
.my-xs {
    margin-bottom: var(--responsive-space-xs);
}
.my-s {
    margin-bottom: var(--responsive-space-s);
}
.my-m {
    margin-bottom: var(--responsive-space-m);
}
.my-l {
    margin-bottom: var(--responsive-space-l);
}
.my-xl {
    margin-bottom: var(--responsive-space-xl);
}
/* TOP */
.mt-0 {
    margin-top: var(--static-space-0);
}
.mt-1 {
    margin-top: var(--static-space-1);
}
.mt-2 {
    margin-top: var(--static-space-2);
}
.mt-4 {
    margin-top: var(--static-space-4);
}
.mt-8 {
    margin-top: var(--static-space-8);
}
.mt-12 {
    margin-top: var(--static-space-12);
}
.mt-16 {
    margin-top: var(--static-space-16);
}
.mt-20 {
    margin-top: var(--static-space-20);
}
.mt-24 {
    margin-top: var(--static-space-24);
}
.mt-32 {
    margin-top: var(--static-space-32);
}
.mt-40 {
    margin-top: var(--static-space-40);
}
.mt-48 {
    margin-top: var(--static-space-48);
}
.mt-56 {
    margin-top: var(--static-space-56);
}
.mt-64 {
    margin-top: var(--static-space-64);
}
.mt-80 {
    margin-top: var(--static-space-80);
}
.mt-104 {
    margin-top: var(--static-space-104);
}
.mt-128 {
    margin-top: var(--static-space-128);
}
.mt-160 {
    margin-top: var(--static-space-160);
}
.mt-xs {
    margin-top: var(--responsive-space-xs);
}
.mt-s {
    margin-top: var(--responsive-space-s);
}
.mt-m {
    margin-top: var(--responsive-space-m);
}
.mt-l {
    margin-top: var(--responsive-space-l);
}
.mt-xl {
    margin-top: var(--responsive-space-xl);
}
/* RIGHT */
.mr-0 {
    margin-right: var(--static-space-0);
}
.mr-1 {
    margin-right: var(--static-space-1);
}
.mr-2 {
    margin-right: var(--static-space-2);
}
.mr-4 {
    margin-right: var(--static-space-4);
}
.mr-8 {
    margin-right: var(--static-space-8);
}
.mr-12 {
    margin-right: var(--static-space-12);
}
.mr-16 {
    margin-right: var(--static-space-16);
}
.mr-20 {
    margin-right: var(--static-space-20);
}
.mr-24 {
    margin-right: var(--static-space-24);
}
.mr-32 {
    margin-right: var(--static-space-32);
}
.mr-40 {
    margin-right: var(--static-space-40);
}
.mr-48 {
    margin-right: var(--static-space-48);
}
.mr-56 {
    margin-right: var(--static-space-56);
}
.mr-64 {
    margin-right: var(--static-space-64);
}
.mr-80 {
    margin-right: var(--static-space-80);
}
.mr-104 {
    margin-right: var(--static-space-104);
}
.mr-128 {
    margin-right: var(--static-space-128);
}
.mr-160 {
    margin-right: var(--static-space-160);
}
.mr-xs {
    margin-bottom: var(--responsive-space-xs);
}
.mr-s {
    margin-bottom: var(--responsive-space-s);
}
.mr-m {
    margin-bottom: var(--responsive-space-m);
}
.mr-l {
    margin-bottom: var(--responsive-space-l);
}
.mr-xl {
    margin-bottom: var(--responsive-space-xl);
}
/* BOTTOM */
.mb-0 {
    margin-bottom: var(--static-space-0);
}
.mb-1 {
    margin-bottom: var(--static-space-1);
}
.mb-2 {
    margin-bottom: var(--static-space-2);
}
.mb-4 {
    margin-bottom: var(--static-space-4);
}
.mb-8 {
    margin-bottom: var(--static-space-8);
}
.mb-12 {
    margin-bottom: var(--static-space-12);
}
.mb-16 {
    margin-bottom: var(--static-space-16);
}
.mb-20 {
    margin-bottom: var(--static-space-20);
}
.mb-24 {
    margin-bottom: var(--static-space-24);
}
.mb-32 {
    margin-bottom: var(--static-space-32);
}
.mb-40 {
    margin-bottom: var(--static-space-40);
}
.mb-48 {
    margin-bottom: var(--static-space-48);
}
.mb-56 {
    margin-bottom: var(--static-space-56);
}
.mb-64 {
    margin-bottom: var(--static-space-64);
}
.mb-80 {
    margin-bottom: var(--static-space-80);
}
.mb-104 {
    margin-bottom: var(--static-space-104);
}
.mb-128 {
    margin-bottom: var(--static-space-128);
}
.mb-160 {
    margin-bottom: var(--static-space-160);
}
.mb-xs {
    margin-bottom: var(--responsive-space-xs);
}
.mb-s {
    margin-bottom: var(--responsive-space-s);
}
.mb-m {
    margin-bottom: var(--responsive-space-m);
}
.mb-l {
    margin-bottom: var(--responsive-space-l);
}
.mb-xl {
    margin-bottom: var(--responsive-space-xl);
}
/* LEFT */
.ml-0 {
    margin-left: var(--static-space-0);
}
.ml-1 {
    margin-left: var(--static-space-1);
}
.ml-2 {
    margin-left: var(--static-space-2);
}
.ml-4 {
    margin-left: var(--static-space-4);
}
.ml-8 {
    margin-left: var(--static-space-8);
}
.ml-12 {
    margin-left: var(--static-space-12);
}
.ml-16 {
    margin-left: var(--static-space-16);
}
.ml-20 {
    margin-left: var(--static-space-20);
}
.ml-24 {
    margin-left: var(--static-space-24);
}
.ml-32 {
    margin-left: var(--static-space-32);
}
.ml-40 {
    margin-left: var(--static-space-40);
}
.ml-48 {
    margin-left: var(--static-space-48);
}
.ml-56 {
    margin-left: var(--static-space-56);
}
.ml-64 {
    margin-left: var(--static-space-64);
}
.ml-80 {
    margin-left: var(--static-space-80);
}
.ml-104 {
    margin-left: var(--static-space-104);
}
.ml-128 {
    margin-left: var(--static-space-128);
}
.ml-160 {
    margin-left: var(--static-space-160);
}
.ml-xs {
    margin-left: var(--responsive-space-xs);
}
.ml-s {
    margin-left: var(--responsive-space-s);
}
.ml-m {
    margin-left: var(--responsive-space-m);
}
.ml-l {
    margin-left: var(--responsive-space-l);
}
.ml-xl {
    margin-left: var(--responsive-space-xl);
}
  /****************************/
 /*           PADDING        */
/****************************/
/* EVEN */
.p-0 {
    padding: var(--static-space-0);
}
.p-1 {
    padding: var(--static-space-1);
}
.p-2 {
    padding: var(--static-space-2);
}
.p-4 {
    padding: var(--static-space-4);
}
.p-8 {
    padding: var(--static-space-8);
}
.p-12 {
    padding: var(--static-space-12);
}
.p-16 {
    padding: var(--static-space-16);
}
.p-20 {
    padding: var(--static-space-20);
}
.p-24 {
    padding: var(--static-space-24);
}
.p-32 {
    padding: var(--static-space-32);
}
.p-40 {
    padding: var(--static-space-40);
}
.p-48 {
    padding: var(--static-space-48);
}
.p-56 {
    padding: var(--static-space-56);
}
.p-64 {
    padding: var(--static-space-64);
}
.p-80 {
    padding: var(--static-space-80);
}
.p-104 {
    padding: var(--static-space-104);
}
.p-128 {
    padding: var(--static-space-128);
}
.p-160 {
    padding: var(--static-space-160);
}
.p-xs {
    padding: var(--responsive-space-xs);
}
.p-s {
    padding: var(--responsive-space-s);
}
.p-m {
    padding: var(--responsive-space-m);
}
.p-l {
    padding: var(--responsive-space-l);
}
.p-xl {
    padding: var(--responsive-space-xl);
}
/* X */
.px-0 {
    padding-left: var(--static-space-0);
    padding-right: var(--static-space-0);
}
.px-1 {
    padding-left: var(--static-space-1);
    padding-right: var(--static-space-1);
}
.px-2 {
    padding-left: var(--static-space-2);
    padding-right: var(--static-space-2);
}
.px-4 {
    padding-left: var(--static-space-4);
    padding-right: var(--static-space-4);
}
.px-8 {
    padding-left: var(--static-space-8);
    padding-right: var(--static-space-8);
}
.px-12 {
    padding-left: var(--static-space-12);
    padding-right: var(--static-space-12);
}
.px-16 {
    padding-left: var(--static-space-16);
    padding-right: var(--static-space-16);
}
.px-20 {
    padding-left: var(--static-space-20);
    padding-right: var(--static-space-20);
}
.px-24 {
    padding-left: var(--static-space-24);
    padding-right: var(--static-space-24);
}
.px-32 {
    padding-left: var(--static-space-32);
    padding-right: var(--static-space-32);
}
.px-40 {
    padding-left: var(--static-space-40);
    padding-right: var(--static-space-40);
}
.px-48 {
    padding-left: var(--static-space-48);
    padding-right: var(--static-space-48);
}
.px-56 {
    padding-left: var(--static-space-56);
    padding-right: var(--static-space-56);
}
.px-64 {
    padding-left: var(--static-space-64);
    padding-right: var(--static-space-64);
}
.px-80 {
    padding-left: var(--static-space-80);
    padding-right: var(--static-space-80);
}
.px-104 {
    padding-left: var(--static-space-104);
    padding-right: var(--static-space-104);
}
.px-128 {
    padding-left: var(--static-space-128);
    padding-right: var(--static-space-128);
}
.px-160 {
    padding-left: var(--static-space-160);
    padding-right: var(--static-space-160);
}
.px-xs {
    padding-left: var(--responsive-space-xs);
    padding-right: var(--responsive-space-xs);
}
.px-s {
    padding-left: var(--responsive-space-s);
    padding-right: var(--responsive-space-s);
}
.px-m {
    padding-left: var(--responsive-space-m);
    padding-right: var(--responsive-space-m);
}
.px-l {
    padding-left: var(--responsive-space-l);
    padding-right: var(--responsive-space-l);
}
.px-xl {
    padding-left: var(--responsive-space-xl);
    padding-right: var(--responsive-space-xl);
}
/* Y */
.py-0 {
    padding-top: var(--static-space-0);
    padding-bottom: var(--static-space-0);
}
.py-1 {
    padding-top: var(--static-space-1);
    padding-bottom: var(--static-space-1);
}
.py-2 {
    padding-top: var(--static-space-2);
    padding-bottom: var(--static-space-2);
}
.py-4 {
    padding-top: var(--static-space-4);
    padding-bottom: var(--static-space-4);
}
.py-8 {
    padding-top: var(--static-space-8);
    padding-bottom: var(--static-space-8);
}
.py-12 {
    padding-top: var(--static-space-12);
    padding-bottom: var(--static-space-12);
}
.py-16 {
    padding-top: var(--static-space-16);
    padding-bottom: var(--static-space-16);
}
.py-20 {
    padding-top: var(--static-space-20);
    padding-bottom: var(--static-space-20);
}
.py-24 {
    padding-top: var(--static-space-24);
    padding-bottom: var(--static-space-24);
}
.py-32 {
    padding-top: var(--static-space-32);
    padding-bottom: var(--static-space-32);
}
.py-40 {
    padding-top: var(--static-space-40);
    padding-bottom: var(--static-space-40);
}
.py-48 {
    padding-top: var(--static-space-48);
    padding-bottom: var(--static-space-48);
}
.py-56 {
    padding-top: var(--static-space-56);
    padding-bottom: var(--static-space-56);
}
.py-64 {
    padding-top: var(--static-space-64);
    padding-bottom: var(--static-space-64);
}
.py-80 {
    padding-top: var(--static-space-80);
    padding-bottom: var(--static-space-80);
}
.py-104 {
    padding-top: var(--static-space-104);
    padding-bottom: var(--static-space-104);
}
.py-128 {
    padding-top: var(--static-space-128);
    padding-bottom: var(--static-space-128);
}
.py-160 {
    padding-top: var(--static-space-160);
    padding-bottom: var(--static-space-160);
}
.py-xs {
    padding-top: var(--responsive-space-xs);
    padding-bottom: var(--responsive-space-xs);
}
.py-s {
    padding-top: var(--responsive-space-s);
    padding-bottom: var(--responsive-space-s);
}
.py-m {
    padding-top: var(--responsive-space-m);
    padding-bottom: var(--responsive-space-m);
}
.py-l {
    padding-top: var(--responsive-space-l);
    padding-bottom: var(--responsive-space-l);
}
.py-xl {
    padding-top: var(--responsive-space-xl);
    padding-bottom: var(--responsive-space-xl);
}
/* TOP */
.pt-0 {
    padding-top: var(--static-space-0);
}
.pt-1 {
    padding-top: var(--static-space-1);
}
.pt-2 {
    padding-top: var(--static-space-2);
}
.pt-4 {
    padding-top: var(--static-space-4);
}
.pt-8 {
    padding-top: var(--static-space-8);
}
.pt-12 {
    padding-top: var(--static-space-12);
}
.pt-16 {
    padding-top: var(--static-space-16);
}
.pt-20 {
    padding-top: var(--static-space-20);
}
.pt-24 {
    padding-top: var(--static-space-24);
}
.pt-32 {
    padding-top: var(--static-space-32);
}
.pt-40 {
    padding-top: var(--static-space-40);
}
.pt-48 {
    padding-top: var(--static-space-48);
}
.pt-56 {
    padding-top: var(--static-space-56);
}
.pt-64 {
    padding-top: var(--static-space-64);
}
.pt-80 {
    padding-top: var(--static-space-80);
}
.pt-104 {
    padding-top: var(--static-space-104);
}
.pt-128 {
    padding-top: var(--static-space-128);
}
.pt-160 {
    padding-top: var(--static-space-160);
}
.pt-xs {
    padding-top: var(--responsive-space-xs);
}
.pt-s {
    padding-top: var(--responsive-space-s);
}
.pt-m {
    padding-top: var(--responsive-space-m);
}
.pt-l {
    padding-top: var(--responsive-space-l);
}
.pt-xl {
    padding-top: var(--responsive-space-xl);
}
/* RIGHT */
.pr-0 {
    padding-right: var(--static-space-0);
}
.pr-1 {
    padding-right: var(--static-space-1);
}
.pr-2 {
    padding-right: var(--static-space-2);
}
.pr-4 {
    padding-right: var(--static-space-4);
}
.pr-8 {
    padding-right: var(--static-space-8);
}
.pr-12 {
    padding-right: var(--static-space-12);
}
.pr-16 {
    padding-right: var(--static-space-16);
}
.pr-20 {
    padding-right: var(--static-space-20);
}
.pr-24 {
    padding-right: var(--static-space-24);
}
.pr-32 {
    padding-right: var(--static-space-32);
}
.pr-40 {
    padding-right: var(--static-space-40);
}
.pr-48 {
    padding-right: var(--static-space-48);
}
.pr-56 {
    padding-right: var(--static-space-56);
}
.pr-64 {
    padding-right: var(--static-space-64);
}
.pr-80 {
    padding-right: var(--static-space-80);
}
.pr-104 {
    padding-right: var(--static-space-104);
}
.pr-128 {
    padding-right: var(--static-space-128);
}
.pr-160 {
    padding-right: var(--static-space-160);
}
.pr-xs {
    padding-right: var(--responsive-space-xs);
}
.pr-s {
    padding-right: var(--responsive-space-s);
}
.pr-m {
    padding-right: var(--responsive-space-m);
}
.pr-l {
    padding-right: var(--responsive-space-l);
}
.pr-xl {
    padding-right: var(--responsive-space-xl);
}
/* BOTTOM */
.pb-0 {
    padding-bottom: var(--static-space-0);
}
.pb-1 {
    padding-bottom: var(--static-space-1);
}
.pb-2 {
    padding-bottom: var(--static-space-2);
}
.pb-4 {
    padding-bottom: var(--static-space-4);
}
.pb-8 {
    padding-bottom: var(--static-space-8);
}
.pb-12 {
    padding-bottom: var(--static-space-12);
}
.pb-16 {
    padding-bottom: var(--static-space-16);
}
.pb-20 {
    padding-bottom: var(--static-space-20);
}
.pb-24 {
    padding-bottom: var(--static-space-24);
}
.pb-32 {
    padding-bottom: var(--static-space-32);
}
.pb-40 {
    padding-bottom: var(--static-space-40);
}
.pb-48 {
    padding-bottom: var(--static-space-48);
}
.pb-56 {
    padding-bottom: var(--static-space-56);
}
.pb-64 {
    padding-bottom: var(--static-space-64);
}
.pb-80 {
    padding-bottom: var(--static-space-80);
}
.pb-104 {
    padding-bottom: var(--static-space-104);
}
.pb-128 {
    padding-bottom: var(--static-space-128);
}
.pb-160 {
    padding-bottom: var(--static-space-160);
}
.pb-xs {
    padding-bottom: var(--responsive-space-xs);
}
.pb-s {
    padding-bottom: var(--responsive-space-s);
}
.pb-m {
    padding-bottom: var(--responsive-space-m);
}
.pb-l {
    padding-bottom: var(--responsive-space-l);
}
.pb-xl {
    padding-bottom: var(--responsive-space-xl);
}
/* LEFT */
.pl-0 {
    padding-left: var(--static-space-0);
}
.pl-1 {
    padding-left: var(--static-space-1);
}
.pl-2 {
    padding-left: var(--static-space-2);
}
.pl-4 {
    padding-left: var(--static-space-4);
}
.pl-8 {
    padding-left: var(--static-space-8);
}
.pl-12 {
    padding-left: var(--static-space-12);
}
.pl-16 {
    padding-left: var(--static-space-16);
}
.pl-20 {
    padding-left: var(--static-space-20);
}
.pl-24 {
    padding-left: var(--static-space-24);
}
.pl-32 {
    padding-left: var(--static-space-32);
}
.pl-40 {
    padding-left: var(--static-space-40);
}
.pl-48 {
    padding-left: var(--static-space-48);
}
.pl-56 {
    padding-left: var(--static-space-56);
}
.pl-64 {
    padding-left: var(--static-space-64);
}
.pl-80 {
    padding-left: var(--static-space-80);
}
.pl-104 {
    padding-left: var(--static-space-104);
}
.pl-128 {
    padding-left: var(--static-space-128);
}
.pl-160 {
    padding-left: var(--static-space-160);
}
.pl-xs {
    padding-left: var(--responsive-space-xs);
}
.pl-s {
    padding-left: var(--responsive-space-s);
}
.pl-m {
    padding-left: var(--responsive-space-m);
}
.pl-l {
    padding-left: var(--responsive-space-l);
}
.pl-xl {
    padding-left: var(--responsive-space-xl);
}
  /****************************/
 /*            GAP           */
/****************************/
// Negative gap: collapse stacked borders
.g-horizontal--1 > *:not(:first-child) {
    margin-left: -1px;
}
.g-vertical--1 > *:not(:first-child) {
    margin-top: -1px;
}
// Regular gap
.g-0 {
    gap: var(--static-space-0);
}
.g-1 {
    gap: var(--static-space-1);
}
.g-2 {
    gap: var(--static-space-2);
}
.g-4 {
    gap: var(--static-space-4);
}
.g-8 {
    gap: var(--static-space-8);
}
.g-12 {
    gap: var(--static-space-12);
}
.g-16 {
    gap: var(--static-space-16);
}
.g-20 {
    gap: var(--static-space-20);
}
.g-24 {
    gap: var(--static-space-24);
}
.g-32 {
    gap: var(--static-space-32);
}
.g-40 {
    gap: var(--static-space-40);
}
.g-48 {
    gap: var(--static-space-48);
}
.g-56 {
    gap: var(--static-space-56);
}
.g-64 {
    gap: var(--static-space-64);
}
.g-80 {
    gap: var(--static-space-80);
}
.g-104 {
    gap: var(--static-space-104);
}
.g-128 {
    gap: var(--static-space-128);
}
.g-160 {
    gap: var(--static-space-160);
}
.g-xs {
    gap: var(--responsive-space-xs);
}
.g-s {
    gap: var(--responsive-space-s);
}
.g-m {
    gap: var(--responsive-space-m);
}
.g-l {
    gap: var(--responsive-space-l);
}
.g-xl {
    gap: var(--responsive-space-xl);
}
</file>

<file path="src/once-ui/styles/typography.scss">
html {
    font-size:   var(--font-scaling-desktop);
    font-family: var(--font-family-body);
    font-weight: var(--font-weight-normal);
    color: var(--neutral-on-background-strong);
}
@media (--m) {
    html {
        font-size: var(--font-scaling-tablet);
    }
}
@media (--s) {
    html {
        font-size: var(--font-scaling-mobile);
    }
}
h1, h2, h3, h4, h5, h6, p {
    margin: 0;
}
.font-size-inherit {
    font-size: inherit;
}
.font-weight-inherit {
    font-weight: inherit;
}
.font-display {
    font-family: var(--font-family-heading);
    &.font-strong, & > .font-strong {
        font-weight: var(--font-weight-display-strong);
    }
    &.font-default, & > .font-default {
        font-weight: var(--font-weight-display-default);
    }
    &.font-xl, & > .font-xl {
        font-size:   calc(var(--font-size-display-xl) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-display-xl) * var(--line-height-heading-multiplier));
        letter-spacing: -0.05em;
    }
    &.font-l, & > .font-l {
        font-size:   calc(var(--font-size-display-l) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-display-l) * var(--line-height-heading-multiplier));
        letter-spacing: -0.04em;
    }
    &.font-m, & > .font-m {
        font-size:   calc(var(--font-size-display-m) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-display-m) * var(--line-height-heading-multiplier));
        letter-spacing: -0.03em;
    }
    &.font-s, & > .font-s {
        font-size:   calc(var(--font-size-display-s) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-display-s) * var(--line-height-heading-multiplier));
        letter-spacing: -0.02em;
    }
    &.font-xs, & > .font-xs {
        font-size:   calc(var(--font-size-display-xs) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-display-xs) * var(--line-height-heading-multiplier));
    }
}
.font-heading {
    font-family: var(--font-family-heading);
    &.font-strong, & > .font-strong {
        font-weight: var(--font-weight-heading-strong);
    }
    &.font-default, & > .font-default {
        font-weight: var(--font-weight-heading-default);
    }
    &.font-xl, & > .font-xl {
        font-size:   calc(var(--font-size-heading-xl) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-heading-xl) * var(--line-height-heading-multiplier));
    }
    &.font-l, & > .font-l {
        font-size:   calc(var(--font-size-heading-l) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-heading-l) * var(--line-height-heading-multiplier));
    }
    &.font-m, & > .font-m {
        font-size:   calc(var(--font-size-heading-m) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-heading-m) * var(--line-height-heading-multiplier));
    }
    &.font-s, & > .font-s {
        font-size:   calc(var(--font-size-heading-s) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-heading-s) * var(--line-height-heading-multiplier));
    }
    &.font-xs, & > .font-xs {
        font-size:   calc(var(--font-size-heading-xs) * var(--font-size-heading-multiplier));
        line-height: calc(var(--line-height-heading-xs) * var(--line-height-heading-multiplier));
    }
}
.font-body {
    font-family: var(--font-family-body);
    &.font-strong, & > .font-strong {
        font-weight: var(--font-weight-body-strong);
    }
    &.font-default, & > .font-default {
        font-weight: var(--font-weight-body-default);
    }
    &.font-xl, & > .font-xl {
        font-size:   calc(var(--font-size-body-xl) * var(--font-size-body-multiplier));
        line-height: calc(var(--line-height-body-xl) * var(--line-height-body-multiplier));
    }
    &.font-l, & > .font-l {
        font-size:   calc(var(--font-size-body-l) * var(--font-size-body-multiplier));
        line-height: calc(var(--line-height-body-l) * var(--line-height-body-multiplier));
    }
    &.font-m, & > .font-m {
        font-size:   calc(var(--font-size-body-m) * var(--font-size-body-multiplier));
        line-height: calc(var(--line-height-body-m) * var(--line-height-body-multiplier));
    }
    &.font-s, & > .font-s {
        font-size:   calc(var(--font-size-body-s) * var(--font-size-body-multiplier));
        line-height: calc(var(--line-height-body-s) * var(--line-height-body-multiplier));
    }
    &.font-xs, & > .font-xs {
        font-size:   calc(var(--font-size-body-xs) * var(--font-size-body-multiplier));
        line-height: calc(var(--line-height-body-xs) * var(--line-height-body-multiplier));
    }
}
.font-label {
    font-family: var(--font-family-label);
    &.font-strong, & > .font-strong {
        font-weight: var(--font-weight-label-strong);
    }
    &.font-default, & > .font-default {
        font-weight: var(--font-weight-label-default);
    }
    &.font-l, & > .font-l {
        font-size:   calc(var(--font-size-label-l) * var(--font-size-label-multiplier));
        line-height: calc(var(--line-height-label-l) * var(--line-height-label-multiplier));
    }
    &.font-m, & > .font-m {
        font-size:   calc(var(--font-size-label-m) * var(--font-size-label-multiplier));
        line-height: calc(var(--line-height-label-m) * var(--line-height-label-multiplier));
    }
    &.font-s, & > .font-s {
        font-size:   calc(var(--font-size-label-s) * var(--font-size-label-multiplier));
        line-height: calc(var(--line-height-label-s) * var(--line-height-label-multiplier));
    }
}
.font-code {
    font-family: var(--font-family-code);
    &.font-strong, & > .font-strong {
        font-weight: var(--font-weight-code-strong);
    }
    &.font-default, & > .font-default {
        font-weight: var(--font-weight-code-default);
    }
    &.font-l, & > .font-l {
        font-size:   calc(var(--font-size-label-l) * var(--font-size-label-multiplier));
        line-height: calc(var(--line-height-label-l) * var(--line-height-label-multiplier));
    }
    &.font-m, & > .font-m {
        font-size:   calc(var(--font-size-label-m) * var(--font-size-label-multiplier));
        line-height: calc(var(--line-height-label-m) * var(--line-height-label-multiplier));
    }
    &.font-s, & > .font-s {
        font-size:   calc(var(--font-size-label-s) * var(--font-size-label-multiplier));
        line-height: calc(var(--line-height-label-s) * var(--line-height-label-multiplier));
    }
}
</file>

<file path="src/once-ui/styles/utilities.scss">
.text-decoration-none {
  text-decoration: none;
}
.reset-button-styles {
  background: none;
  padding: 0;
  outline: 0;
  border: 0;
}
.focus-ring {
  &:focus-visible {
    outline: var(--static-space-2) solid var(--brand-solid-strong);
    outline-offset: 2px;
  }
}
</file>

<file path="src/once-ui/tokens/border.scss">
[data-border="playful"] {
    --radius-xs:        0.25rem;
    --radius-xs-nest-4: 0.375rem;
    --radius-xs-nest-8: 0.5rem;
    --radius-s:         0.5rem;
    --radius-s-nest-4:  0.75rem;
    --radius-s-nest-8:  1rem;
    --radius-m:         0.75rem;
    --radius-m-nest-4:  1rem;
    --radius-m-nest-8:  1.25rem;
    --radius-l:         1rem;
    --radius-l-nest-4:  1.25rem;
    --radius-l-nest-8:  1.75rem;
    --radius-xl:        1.25rem;
    --radius-xl-nest-4: 1.5rem;
    --radius-xl-nest-8: 1.875rem;
    --radius-full:       999rem;
}
[data-border="conservative"] {
    --radius-xs:        0.125rem;
    --radius-xs-nest-4: 0.25rem;
    --radius-xs-nest-8: 0.375rem;
    --radius-s:         0.25rem;
    --radius-s-nest-4:  0.375rem;
    --radius-s-nest-8:  0.5rem;
    --radius-m:         0.375rem;
    --radius-m-nest-4:  0.5rem;
    --radius-m-nest-8:  0.625rem;
    --radius-l:         0.625rem;
    --radius-l-nest-4:  0.875rem;
    --radius-l-nest-8:  1.125rem;
    --radius-xl:        0.75rem;
    --radius-xl-nest-4: 1rem;
    --radius-xl-nest-8: 1.25rem;
    --radius-full:       999rem;
}
[data-border="rounded"] {
    --radius-xs:        1rem;
    --radius-xs-nest-4: 1.25rem;
    --radius-xs-nest-8: 1.5rem;
    --radius-s:         1.25rem;
    --radius-s-nest-4:  1.5rem;
    --radius-s-nest-8:  2rem;
    --radius-m:         1.25rem;
    --radius-m-nest-4:  1.5rem;
    --radius-m-nest-8:  1.875rem;
    --radius-l:         1.75rem;
    --radius-l-nest-4:  2rem;
    --radius-l-nest-8:  2.5rem;
    --radius-xl:        2rem;
    --radius-xl-nest-4: 2.25rem;
    --radius-xl-nest-8: 2.75rem;
    --radius-full:       999rem;
}
</file>

<file path="src/once-ui/tokens/data.scss">
[data-theme="dark"] {
  --data-blue:     var(--scheme-blue-400);
  --data-aqua:     var(--scheme-aqua-400);
  --data-magenta:  var(--scheme-magenta-400);
  --data-pink:     var(--scheme-pink-400);
  --data-yellow:   var(--scheme-yellow-400);
  --data-orange:   var(--scheme-orange-400);
  --data-red:      var(--scheme-red-400);
  --data-moss:     var(--scheme-moss-400);
  --data-green:    var(--scheme-green-400);
  --data-emerald:  var(--scheme-emerald-400);
  --data-cyan:     var(--scheme-cyan-400);
  --data-violet:   var(--scheme-violet-400);
  --data-indigo:   var(--scheme-indigo-400);
  --data-gray:     var(--scheme-gray-400);
  --data-contrast: var(--static-white);
}
[data-theme="dark"] [data-viz="divergent"] {
  --data-blue:     var(--scheme-red-400);
  --data-aqua:     var(--scheme-red-500);
  --data-magenta:  var(--scheme-orange-500);
  --data-pink:     var(--scheme-orange-600);
  --data-yellow:   var(--scheme-yellow-700);
  --data-orange:   var(--scheme-yellow-800);
  --data-red:      var(--scheme-yellow-900);
  --data-moss:     var(--scheme-moss-1000);
  --data-green:    var(--scheme-moss-900);
  --data-emerald:  var(--scheme-green-800);
  --data-cyan:     var(--scheme-aqua-700);
  --data-violet:   var(--scheme-aqua-600);
  --data-indigo:   var(--scheme-cyan-400);
  --data-gray:     var(--scheme-gray-400);
  --data-contrast: var(--static-white);
}
[data-theme="dark"] [data-viz="sequential"] {
  --data-blue:     var(--function-brand-200);
  --data-aqua:     var(--function-brand-300);
  --data-magenta:  var(--function-brand-400);
  --data-pink:     var(--function-brand-500);
  --data-yellow:   var(--function-brand-600);
  --data-orange:   var(--function-brand-700);
  --data-red:      var(--function-brand-800);
  --data-moss:     var(--function-brand-900);
  --data-green:    var(--function-brand-1000);
  --data-emerald:  var(--function-brand-1100);
  --data-cyan:     var(--function-brand-1200);
  --data-violet:   var(--function-brand-1200);
  --data-indigo:   var(--function-brand-1200);
  --data-gray:     var(--scheme-gray-400);
  --data-contrast: var(--static-white);
}
[data-theme="light"] {
  --data-blue:     var(--scheme-blue-400);
  --data-indigo:   var(--scheme-indigo-400);
  --data-green:    var(--scheme-green-400);
  --data-aqua:     var(--scheme-aqua-400);
  --data-violet:   var(--scheme-violet-400);
  --data-orange:   var(--scheme-orange-400);
  --data-red:      var(--scheme-red-400);
  --data-cyan:     var(--scheme-cyan-400);
  --data-magenta:  var(--scheme-magenta-400);
  --data-pink:     var(--scheme-pink-400);
  --data-moss:     var(--scheme-moss-400);
  --data-emerald:  var(--scheme-emerald-400);
  --data-yellow:   var(--scheme-yellow-400);
  --data-gray:     var(--scheme-gray-400);
  --data-contrast: var(--static-black);
}
[data-theme="light"] [data-viz="divergent"] {
  --data-blue:     var(--scheme-red-300);
  --data-aqua:     var(--scheme-red-400);
  --data-magenta:  var(--scheme-orange-400);
  --data-pink:     var(--scheme-orange-500);
  --data-yellow:   var(--scheme-yellow-500);
  --data-orange:   var(--scheme-yellow-600);
  --data-red:      var(--scheme-yellow-700);
  --data-moss:     var(--scheme-moss-800);
  --data-green:    var(--scheme-moss-900);
  --data-emerald:  var(--scheme-green-800);
  --data-cyan:     var(--scheme-aqua-700);
  --data-violet:   var(--scheme-aqua-600);
  --data-indigo:   var(--scheme-cyan-400);
  --data-gray:     var(--scheme-gray-400);
  --data-contrast: var(--static-black);
}
[data-theme="light"] [data-viz="sequential"] {
  --data-blue:     var(--function-brand-200);
  --data-aqua:     var(--function-brand-200);
  --data-magenta:  var(--function-brand-200);
  --data-pink:     var(--function-brand-300);
  --data-yellow:   var(--function-brand-400);
  --data-orange:   var(--function-brand-500);
  --data-red:      var(--function-brand-600);
  --data-moss:     var(--function-brand-700);
  --data-green:    var(--function-brand-800);
  --data-emerald:  var(--function-brand-900);
  --data-cyan:     var(--function-brand-1000);
  --data-violet:   var(--function-brand-1100);
  --data-indigo:   var(--function-brand-1100);
  --data-gray:     var(--scheme-gray-400);
  --data-contrast: var(--static-black);
}
</file>

<file path="src/once-ui/tokens/function.scss">
:root {
    /* FUNCTION */
    /* info */
    --function-info-100:  var(--scheme-gray-100);
    --function-info-200:  var(--scheme-gray-200);
    --function-info-300:  var(--scheme-gray-300);
    --function-info-400:  var(--scheme-gray-400);
    --function-info-500:  var(--scheme-gray-500);
    --function-info-600:  var(--scheme-gray-600);
    --function-info-700:  var(--scheme-gray-700);
    --function-info-800:  var(--scheme-gray-800);
    --function-info-900:  var(--scheme-gray-900);
    --function-info-1000: var(--scheme-gray-1000);
    --function-info-1100: var(--scheme-gray-1100);
    --function-info-1200: var(--scheme-gray-1200);
    --function-info-600-10: var(--scheme-gray-600-10);
    --function-info-600-30: var(--scheme-gray-600-30);
    --function-info-600-50: var(--scheme-gray-600-50);
    /* warning */
    --function-warning-100:  var(--scheme-yellow-100);
    --function-warning-200:  var(--scheme-yellow-200);
    --function-warning-300:  var(--scheme-yellow-300);
    --function-warning-400:  var(--scheme-yellow-400);
    --function-warning-500:  var(--scheme-yellow-500);
    --function-warning-600:  var(--scheme-yellow-600);
    --function-warning-700:  var(--scheme-yellow-700);
    --function-warning-800:  var(--scheme-yellow-800);
    --function-warning-900:  var(--scheme-yellow-900);
    --function-warning-1000: var(--scheme-yellow-1000);
    --function-warning-1100: var(--scheme-yellow-1100);
    --function-warning-1200: var(--scheme-yellow-1200);
    --function-warning-600-10: var(--scheme-yellow-600-10);
    --function-warning-600-30: var(--scheme-yellow-600-30);
    --function-warning-600-50: var(--scheme-yellow-600-50);
    /* danger */
    --function-danger-100:  var(--scheme-red-100);
    --function-danger-200:  var(--scheme-red-200);
    --function-danger-300:  var(--scheme-red-300);
    --function-danger-400:  var(--scheme-red-400);
    --function-danger-500:  var(--scheme-red-500);
    --function-danger-600:  var(--scheme-red-600);
    --function-danger-700:  var(--scheme-red-700);
    --function-danger-800:  var(--scheme-red-800);
    --function-danger-900:  var(--scheme-red-900);
    --function-danger-1000: var(--scheme-red-1000);
    --function-danger-1100: var(--scheme-red-1100);
    --function-danger-1200: var(--scheme-red-1200);
    --function-danger-600-10: var(--scheme-red-600-10);
    --function-danger-600-30: var(--scheme-red-600-30);
    --function-danger-600-50: var(--scheme-red-600-50);
    /* success */
    --function-success-100:  var(--scheme-green-100);
    --function-success-200:  var(--scheme-green-200);
    --function-success-300:  var(--scheme-green-300);
    --function-success-400:  var(--scheme-green-400);
    --function-success-500:  var(--scheme-green-500);
    --function-success-600:  var(--scheme-green-600);
    --function-success-700:  var(--scheme-green-700);
    --function-success-800:  var(--scheme-green-800);
    --function-success-900:  var(--scheme-green-900);
    --function-success-1000: var(--scheme-green-1000);
    --function-success-1100: var(--scheme-green-1100);
    --function-success-1200: var(--scheme-green-1200);
    --function-success-600-10: var(--scheme-green-600-10);
    --function-success-600-30: var(--scheme-green-600-30);
    --function-success-600-50: var(--scheme-green-600-50);
}
/* brand */
[data-brand="custom"] {
    --function-brand-100:  var(--scheme-brand-100);
    --function-brand-200:  var(--scheme-brand-200);
    --function-brand-300:  var(--scheme-brand-300);
    --function-brand-400:  var(--scheme-brand-400);
    --function-brand-500:  var(--scheme-brand-500);
    --function-brand-600:  var(--scheme-brand-600);
    --function-brand-700:  var(--scheme-brand-700);
    --function-brand-800:  var(--scheme-brand-800);
    --function-brand-900:  var(--scheme-brand-900);
    --function-brand-1000: var(--scheme-brand-1000);
    --function-brand-1100: var(--scheme-brand-1100);
    --function-brand-1200: var(--scheme-brand-1200);
    --function-brand-600-10: var(--scheme-brand-600-10);
    --function-brand-600-30: var(--scheme-brand-600-30);
    --function-brand-600-50: var(--scheme-brand-600-50);
}
[data-brand="red"] {
    --function-brand-100:  var(--scheme-red-100);
    --function-brand-200:  var(--scheme-red-200);
    --function-brand-300:  var(--scheme-red-300);
    --function-brand-400:  var(--scheme-red-400);
    --function-brand-500:  var(--scheme-red-500);
    --function-brand-600:  var(--scheme-red-600);
    --function-brand-700:  var(--scheme-red-700);
    --function-brand-800:  var(--scheme-red-800);
    --function-brand-900:  var(--scheme-red-900);
    --function-brand-1000: var(--scheme-red-1000);
    --function-brand-1100: var(--scheme-red-1100);
    --function-brand-1200: var(--scheme-red-1200);
    --function-brand-600-10: var(--scheme-red-600-10);
    --function-brand-600-30: var(--scheme-red-600-30);
    --function-brand-600-50: var(--scheme-red-600-50);
}
[data-brand="orange"] {
    --function-brand-100:  var(--scheme-orange-100);
    --function-brand-200:  var(--scheme-orange-200);
    --function-brand-300:  var(--scheme-orange-300);
    --function-brand-400:  var(--scheme-orange-400);
    --function-brand-500:  var(--scheme-orange-500);
    --function-brand-600:  var(--scheme-orange-600);
    --function-brand-700:  var(--scheme-orange-700);
    --function-brand-800:  var(--scheme-orange-800);
    --function-brand-900:  var(--scheme-orange-900);
    --function-brand-1000: var(--scheme-orange-1000);
    --function-brand-1100: var(--scheme-orange-1100);
    --function-brand-1200: var(--scheme-orange-1200);
    --function-brand-600-10: var(--scheme-orange-600-10);
    --function-brand-600-30: var(--scheme-orange-600-30);
    --function-brand-600-50: var(--scheme-orange-600-50);
}
[data-brand="yellow"] {
    --function-brand-100:  var(--scheme-yellow-100);
    --function-brand-200:  var(--scheme-yellow-200);
    --function-brand-300:  var(--scheme-yellow-300);
    --function-brand-400:  var(--scheme-yellow-400);
    --function-brand-500:  var(--scheme-yellow-500);
    --function-brand-600:  var(--scheme-yellow-600);
    --function-brand-700:  var(--scheme-yellow-700);
    --function-brand-800:  var(--scheme-yellow-800);
    --function-brand-900:  var(--scheme-yellow-900);
    --function-brand-1000: var(--scheme-yellow-1000);
    --function-brand-1100: var(--scheme-yellow-1100);
    --function-brand-1200: var(--scheme-yellow-1200);
    --function-brand-600-10: var(--scheme-yellow-600-10);
    --function-brand-600-30: var(--scheme-yellow-600-30);
    --function-brand-600-50: var(--scheme-yellow-600-50);
}
[data-brand="moss"] {
    --function-brand-100:  var(--scheme-moss-100);
    --function-brand-200:  var(--scheme-moss-200);
    --function-brand-300:  var(--scheme-moss-300);
    --function-brand-400:  var(--scheme-moss-400);
    --function-brand-500:  var(--scheme-moss-500);
    --function-brand-600:  var(--scheme-moss-600);
    --function-brand-700:  var(--scheme-moss-700);
    --function-brand-800:  var(--scheme-moss-800);
    --function-brand-900:  var(--scheme-moss-900);
    --function-brand-1000: var(--scheme-moss-1000);
    --function-brand-1100: var(--scheme-moss-1100);
    --function-brand-1200: var(--scheme-moss-1200);
    --function-brand-600-10: var(--scheme-moss-600-10);
    --function-brand-600-30: var(--scheme-moss-600-30);
    --function-brand-600-50: var(--scheme-moss-600-50);
}
[data-brand="green"] {
    --function-brand-100:  var(--scheme-green-100);
    --function-brand-200:  var(--scheme-green-200);
    --function-brand-300:  var(--scheme-green-300);
    --function-brand-400:  var(--scheme-green-400);
    --function-brand-500:  var(--scheme-green-500);
    --function-brand-600:  var(--scheme-green-600);
    --function-brand-700:  var(--scheme-green-700);
    --function-brand-800:  var(--scheme-green-800);
    --function-brand-900:  var(--scheme-green-900);
    --function-brand-1000: var(--scheme-green-1000);
    --function-brand-1100: var(--scheme-green-1100);
    --function-brand-1200: var(--scheme-green-1200);
    --function-brand-600-10: var(--scheme-green-600-10);
    --function-brand-600-30: var(--scheme-green-600-30);
    --function-brand-600-50: var(--scheme-green-600-50);
}
[data-brand="emerald"] {
    --function-brand-100:  var(--scheme-emerald-100);
    --function-brand-200:  var(--scheme-emerald-200);
    --function-brand-300:  var(--scheme-emerald-300);
    --function-brand-400:  var(--scheme-emerald-400);
    --function-brand-500:  var(--scheme-emerald-500);
    --function-brand-600:  var(--scheme-emerald-600);
    --function-brand-700:  var(--scheme-emerald-700);
    --function-brand-800:  var(--scheme-emerald-800);
    --function-brand-900:  var(--scheme-emerald-900);
    --function-brand-1000: var(--scheme-emerald-1000);
    --function-brand-1100: var(--scheme-emerald-1100);
    --function-brand-1200: var(--scheme-emerald-1200);
    --function-brand-600-10: var(--scheme-emerald-600-10);
    --function-brand-600-30: var(--scheme-emerald-600-30);
    --function-brand-600-50: var(--scheme-emerald-600-50);
}
[data-brand="aqua"] {
    --function-brand-100:  var(--scheme-aqua-100);
    --function-brand-200:  var(--scheme-aqua-200);
    --function-brand-300:  var(--scheme-aqua-300);
    --function-brand-400:  var(--scheme-aqua-400);
    --function-brand-500:  var(--scheme-aqua-500);
    --function-brand-600:  var(--scheme-aqua-600);
    --function-brand-700:  var(--scheme-aqua-700);
    --function-brand-800:  var(--scheme-aqua-800);
    --function-brand-900:  var(--scheme-aqua-900);
    --function-brand-1000: var(--scheme-aqua-1000);
    --function-brand-1100: var(--scheme-aqua-1100);
    --function-brand-1200: var(--scheme-aqua-1200);
    --function-brand-600-10: var(--scheme-aqua-600-10);
    --function-brand-600-30: var(--scheme-aqua-600-30);
    --function-brand-600-50: var(--scheme-aqua-600-50);
}
[data-brand="cyan"] {
    --function-brand-100:  var(--scheme-cyan-100);
    --function-brand-200:  var(--scheme-cyan-200);
    --function-brand-300:  var(--scheme-cyan-300);
    --function-brand-400:  var(--scheme-cyan-400);
    --function-brand-500:  var(--scheme-cyan-500);
    --function-brand-600:  var(--scheme-cyan-600);
    --function-brand-700:  var(--scheme-cyan-700);
    --function-brand-800:  var(--scheme-cyan-800);
    --function-brand-900:  var(--scheme-cyan-900);
    --function-brand-1000: var(--scheme-cyan-1000);
    --function-brand-1100: var(--scheme-cyan-1100);
    --function-brand-1200: var(--scheme-cyan-1200);
    --function-brand-600-10: var(--scheme-cyan-600-10);
    --function-brand-600-30: var(--scheme-cyan-600-30);
    --function-brand-600-50: var(--scheme-cyan-600-50);
}
[data-brand="blue"] {
    --function-brand-100:  var(--scheme-blue-100);
    --function-brand-200:  var(--scheme-blue-200);
    --function-brand-300:  var(--scheme-blue-300);
    --function-brand-400:  var(--scheme-blue-400);
    --function-brand-500:  var(--scheme-blue-500);
    --function-brand-600:  var(--scheme-blue-600);
    --function-brand-700:  var(--scheme-blue-700);
    --function-brand-800:  var(--scheme-blue-800);
    --function-brand-900:  var(--scheme-blue-900);
    --function-brand-1000: var(--scheme-blue-1000);
    --function-brand-1100: var(--scheme-blue-1100);
    --function-brand-1200: var(--scheme-blue-1200);
    --function-brand-600-10: var(--scheme-blue-600-10);
    --function-brand-600-30: var(--scheme-blue-600-30);
    --function-brand-600-50: var(--scheme-blue-600-50);
}
[data-brand="indigo"] {
    --function-brand-100:  var(--scheme-indigo-100);
    --function-brand-200:  var(--scheme-indigo-200);
    --function-brand-300:  var(--scheme-indigo-300);
    --function-brand-400:  var(--scheme-indigo-400);
    --function-brand-500:  var(--scheme-indigo-500);
    --function-brand-600:  var(--scheme-indigo-600);
    --function-brand-700:  var(--scheme-indigo-700);
    --function-brand-800:  var(--scheme-indigo-800);
    --function-brand-900:  var(--scheme-indigo-900);
    --function-brand-1000: var(--scheme-indigo-1000);
    --function-brand-1100: var(--scheme-indigo-1100);
    --function-brand-1200: var(--scheme-indigo-1200);
    --function-brand-600-10: var(--scheme-indigo-600-10);
    --function-brand-600-30: var(--scheme-indigo-600-30);
    --function-brand-600-50: var(--scheme-indigo-600-50);
}
[data-brand="violet"] {
    --function-brand-100:  var(--scheme-violet-100);
    --function-brand-200:  var(--scheme-violet-200);
    --function-brand-300:  var(--scheme-violet-300);
    --function-brand-400:  var(--scheme-violet-400);
    --function-brand-500:  var(--scheme-violet-500);
    --function-brand-600:  var(--scheme-violet-600);
    --function-brand-700:  var(--scheme-violet-700);
    --function-brand-800:  var(--scheme-violet-800);
    --function-brand-900:  var(--scheme-violet-900);
    --function-brand-1000: var(--scheme-violet-1000);
    --function-brand-1100: var(--scheme-violet-1100);
    --function-brand-1200: var(--scheme-violet-1200);
    --function-brand-600-10: var(--scheme-violet-600-10);
    --function-brand-600-30: var(--scheme-violet-600-30);
    --function-brand-600-50: var(--scheme-violet-600-50);
}
[data-brand="magenta"] {
    --function-brand-100:  var(--scheme-magenta-100);
    --function-brand-200:  var(--scheme-magenta-200);
    --function-brand-300:  var(--scheme-magenta-300);
    --function-brand-400:  var(--scheme-magenta-400);
    --function-brand-500:  var(--scheme-magenta-500);
    --function-brand-600:  var(--scheme-magenta-600);
    --function-brand-700:  var(--scheme-magenta-700);
    --function-brand-800:  var(--scheme-magenta-800);
    --function-brand-900:  var(--scheme-magenta-900);
    --function-brand-1000: var(--scheme-magenta-1000);
    --function-brand-1100: var(--scheme-magenta-1100);
    --function-brand-1200: var(--scheme-magenta-1200);
    --function-brand-600-10: var(--scheme-magenta-600-10);
    --function-brand-600-30: var(--scheme-magenta-600-30);
    --function-brand-600-50: var(--scheme-magenta-600-50);
}
[data-brand="pink"] {
    --function-brand-100:  var(--scheme-pink-100);
    --function-brand-200:  var(--scheme-pink-200);
    --function-brand-300:  var(--scheme-pink-300);
    --function-brand-400:  var(--scheme-pink-400);
    --function-brand-500:  var(--scheme-pink-500);
    --function-brand-600:  var(--scheme-pink-600);
    --function-brand-700:  var(--scheme-pink-700);
    --function-brand-800:  var(--scheme-pink-800);
    --function-brand-900:  var(--scheme-pink-900);
    --function-brand-1000: var(--scheme-pink-1000);
    --function-brand-1100: var(--scheme-pink-1100);
    --function-brand-1200: var(--scheme-pink-1200);
    --function-brand-600-10: var(--scheme-pink-600-10);
    --function-brand-600-30: var(--scheme-pink-600-30);
    --function-brand-600-50: var(--scheme-pink-600-50);
}
/* accent */
[data-accent="custom"] {
    --function-accent-100:  var(--scheme-accent-100);
    --function-accent-200:  var(--scheme-accent-200);
    --function-accent-300:  var(--scheme-accent-300);
    --function-accent-400:  var(--scheme-accent-400);
    --function-accent-500:  var(--scheme-accent-500);
    --function-accent-600:  var(--scheme-accent-600);
    --function-accent-700:  var(--scheme-accent-700);
    --function-accent-800:  var(--scheme-accent-800);
    --function-accent-900:  var(--scheme-accent-900);
    --function-accent-1000: var(--scheme-accent-1000);
    --function-accent-1100: var(--scheme-accent-1100);
    --function-accent-1200: var(--scheme-accent-1200);
    --function-accent-600-10: var(--scheme-accent-600-10);
    --function-accent-600-30: var(--scheme-accent-600-30);
    --function-accent-600-50: var(--scheme-accent-600-50);
}
[data-accent="red"] {
    --function-accent-100:  var(--scheme-red-100);
    --function-accent-200:  var(--scheme-red-200);
    --function-accent-300:  var(--scheme-red-300);
    --function-accent-400:  var(--scheme-red-400);
    --function-accent-500:  var(--scheme-red-500);
    --function-accent-600:  var(--scheme-red-600);
    --function-accent-700:  var(--scheme-red-700);
    --function-accent-800:  var(--scheme-red-800);
    --function-accent-900:  var(--scheme-red-900);
    --function-accent-1000: var(--scheme-red-1000);
    --function-accent-1100: var(--scheme-red-1100);
    --function-accent-1200: var(--scheme-red-1200);
    --function-accent-600-10: var(--scheme-red-600-10);
    --function-accent-600-30: var(--scheme-red-600-30);
    --function-accent-600-50: var(--scheme-red-600-50);
}
[data-accent="orange"] {
    --function-accent-100:  var(--scheme-orange-100);
    --function-accent-200:  var(--scheme-orange-200);
    --function-accent-300:  var(--scheme-orange-300);
    --function-accent-400:  var(--scheme-orange-400);
    --function-accent-500:  var(--scheme-orange-500);
    --function-accent-600:  var(--scheme-orange-600);
    --function-accent-700:  var(--scheme-orange-700);
    --function-accent-800:  var(--scheme-orange-800);
    --function-accent-900:  var(--scheme-orange-900);
    --function-accent-1000: var(--scheme-orange-1000);
    --function-accent-1100: var(--scheme-orange-1100);
    --function-accent-1200: var(--scheme-orange-1200);
    --function-accent-600-10: var(--scheme-orange-600-10);
    --function-accent-600-30: var(--scheme-orange-600-30);
    --function-accent-600-50: var(--scheme-orange-600-50);
}
[data-accent="yellow"] {
    --function-accent-100:  var(--scheme-yellow-100);
    --function-accent-200:  var(--scheme-yellow-200);
    --function-accent-300:  var(--scheme-yellow-300);
    --function-accent-400:  var(--scheme-yellow-400);
    --function-accent-500:  var(--scheme-yellow-500);
    --function-accent-600:  var(--scheme-yellow-600);
    --function-accent-700:  var(--scheme-yellow-700);
    --function-accent-800:  var(--scheme-yellow-800);
    --function-accent-900:  var(--scheme-yellow-900);
    --function-accent-1000: var(--scheme-yellow-1000);
    --function-accent-1100: var(--scheme-yellow-1100);
    --function-accent-1200: var(--scheme-yellow-1200);
    --function-accent-600-10: var(--scheme-yellow-600-10);
    --function-accent-600-30: var(--scheme-yellow-600-30);
    --function-accent-600-50: var(--scheme-yellow-600-50);
}
[data-accent="moss"] {
    --function-accent-100:  var(--scheme-moss-100);
    --function-accent-200:  var(--scheme-moss-200);
    --function-accent-300:  var(--scheme-moss-300);
    --function-accent-400:  var(--scheme-moss-400);
    --function-accent-500:  var(--scheme-moss-500);
    --function-accent-600:  var(--scheme-moss-600);
    --function-accent-700:  var(--scheme-moss-700);
    --function-accent-800:  var(--scheme-moss-800);
    --function-accent-900:  var(--scheme-moss-900);
    --function-accent-1000: var(--scheme-moss-1000);
    --function-accent-1100: var(--scheme-moss-1100);
    --function-accent-1200: var(--scheme-moss-1200);
    --function-accent-600-10: var(--scheme-moss-600-10);
    --function-accent-600-30: var(--scheme-moss-600-30);
    --function-accent-600-50: var(--scheme-moss-600-50);
}
[data-accent="green"] {
    --function-accent-100:  var(--scheme-green-100);
    --function-accent-200:  var(--scheme-green-200);
    --function-accent-300:  var(--scheme-green-300);
    --function-accent-400:  var(--scheme-green-400);
    --function-accent-500:  var(--scheme-green-500);
    --function-accent-600:  var(--scheme-green-600);
    --function-accent-700:  var(--scheme-green-700);
    --function-accent-800:  var(--scheme-green-800);
    --function-accent-900:  var(--scheme-green-900);
    --function-accent-1000: var(--scheme-green-1000);
    --function-accent-1100: var(--scheme-green-1100);
    --function-accent-1200: var(--scheme-green-1200);
    --function-accent-600-10: var(--scheme-green-600-10);
    --function-accent-600-30: var(--scheme-green-600-30);
    --function-accent-600-50: var(--scheme-green-600-50);
}
[data-accent="emerald"] {
    --function-accent-100:  var(--scheme-emerald-100);
    --function-accent-200:  var(--scheme-emerald-200);
    --function-accent-300:  var(--scheme-emerald-300);
    --function-accent-400:  var(--scheme-emerald-400);
    --function-accent-500:  var(--scheme-emerald-500);
    --function-accent-600:  var(--scheme-emerald-600);
    --function-accent-700:  var(--scheme-emerald-700);
    --function-accent-800:  var(--scheme-emerald-800);
    --function-accent-900:  var(--scheme-emerald-900);
    --function-accent-1000: var(--scheme-emerald-1000);
    --function-accent-1100: var(--scheme-emerald-1100);
    --function-accent-1200: var(--scheme-emerald-1200);
    --function-accent-600-10: var(--scheme-emerald-600-10);
    --function-accent-600-30: var(--scheme-emerald-600-30);
    --function-accent-600-50: var(--scheme-emerald-600-50);
}
[data-accent="aqua"] {
    --function-accent-100:  var(--scheme-aqua-100);
    --function-accent-200:  var(--scheme-aqua-200);
    --function-accent-300:  var(--scheme-aqua-300);
    --function-accent-400:  var(--scheme-aqua-400);
    --function-accent-500:  var(--scheme-aqua-500);
    --function-accent-600:  var(--scheme-aqua-600);
    --function-accent-700:  var(--scheme-aqua-700);
    --function-accent-800:  var(--scheme-aqua-800);
    --function-accent-900:  var(--scheme-aqua-900);
    --function-accent-1000: var(--scheme-aqua-1000);
    --function-accent-1100: var(--scheme-aqua-1100);
    --function-accent-1200: var(--scheme-aqua-1200);
    --function-accent-600-10: var(--scheme-aqua-600-10);
    --function-accent-600-30: var(--scheme-aqua-600-30);
    --function-accent-600-50: var(--scheme-aqua-600-50);
}
[data-accent="cyan"] {
    --function-accent-100:  var(--scheme-cyan-100);
    --function-accent-200:  var(--scheme-cyan-200);
    --function-accent-300:  var(--scheme-cyan-300);
    --function-accent-400:  var(--scheme-cyan-400);
    --function-accent-500:  var(--scheme-cyan-500);
    --function-accent-600:  var(--scheme-cyan-600);
    --function-accent-700:  var(--scheme-cyan-700);
    --function-accent-800:  var(--scheme-cyan-800);
    --function-accent-900:  var(--scheme-cyan-900);
    --function-accent-1000: var(--scheme-cyan-1000);
    --function-accent-1100: var(--scheme-cyan-1100);
    --function-accent-1200: var(--scheme-cyan-1200);
    --function-accent-600-10: var(--scheme-cyan-600-10);
    --function-accent-600-30: var(--scheme-cyan-600-30);
    --function-accent-600-50: var(--scheme-cyan-600-50);
}
[data-accent="blue"] {
    --function-accent-100:  var(--scheme-blue-100);
    --function-accent-200:  var(--scheme-blue-200);
    --function-accent-300:  var(--scheme-blue-300);
    --function-accent-400:  var(--scheme-blue-400);
    --function-accent-500:  var(--scheme-blue-500);
    --function-accent-600:  var(--scheme-blue-600);
    --function-accent-700:  var(--scheme-blue-700);
    --function-accent-800:  var(--scheme-blue-800);
    --function-accent-900:  var(--scheme-blue-900);
    --function-accent-1000: var(--scheme-blue-1000);
    --function-accent-1100: var(--scheme-blue-1100);
    --function-accent-1200: var(--scheme-blue-1200);
    --function-accent-600-10: var(--scheme-blue-600-10);
    --function-accent-600-30: var(--scheme-blue-600-30);
    --function-accent-600-50: var(--scheme-blue-600-50);
}
[data-accent="indigo"] {
    --function-accent-100:  var(--scheme-indigo-100);
    --function-accent-200:  var(--scheme-indigo-200);
    --function-accent-300:  var(--scheme-indigo-300);
    --function-accent-400:  var(--scheme-indigo-400);
    --function-accent-500:  var(--scheme-indigo-500);
    --function-accent-600:  var(--scheme-indigo-600);
    --function-accent-700:  var(--scheme-indigo-700);
    --function-accent-800:  var(--scheme-indigo-800);
    --function-accent-900:  var(--scheme-indigo-900);
    --function-accent-1000: var(--scheme-indigo-1000);
    --function-accent-1100: var(--scheme-indigo-1100);
    --function-accent-1200: var(--scheme-indigo-1200);
    --function-accent-600-10: var(--scheme-indigo-600-10);
    --function-accent-600-30: var(--scheme-indigo-600-30);
    --function-accent-600-50: var(--scheme-indigo-600-50);
}
[data-accent="violet"] {
    --function-accent-100:  var(--scheme-violet-100);
    --function-accent-200:  var(--scheme-violet-200);
    --function-accent-300:  var(--scheme-violet-300);
    --function-accent-400:  var(--scheme-violet-400);
    --function-accent-500:  var(--scheme-violet-500);
    --function-accent-600:  var(--scheme-violet-600);
    --function-accent-700:  var(--scheme-violet-700);
    --function-accent-800:  var(--scheme-violet-800);
    --function-accent-900:  var(--scheme-violet-900);
    --function-accent-1000: var(--scheme-violet-1000);
    --function-accent-1100: var(--scheme-violet-1100);
    --function-accent-1200: var(--scheme-violet-1200);
    --function-accent-600-10: var(--scheme-violet-600-10);
    --function-accent-600-30: var(--scheme-violet-600-30);
    --function-accent-600-50: var(--scheme-violet-600-50);
}
[data-accent="magenta"] {
    --function-accent-100:  var(--scheme-magenta-100);
    --function-accent-200:  var(--scheme-magenta-200);
    --function-accent-300:  var(--scheme-magenta-300);
    --function-accent-400:  var(--scheme-magenta-400);
    --function-accent-500:  var(--scheme-magenta-500);
    --function-accent-600:  var(--scheme-magenta-600);
    --function-accent-700:  var(--scheme-magenta-700);
    --function-accent-800:  var(--scheme-magenta-800);
    --function-accent-900:  var(--scheme-magenta-900);
    --function-accent-1000: var(--scheme-magenta-1000);
    --function-accent-1100: var(--scheme-magenta-1100);
    --function-accent-1200: var(--scheme-magenta-1200);
    --function-accent-600-10: var(--scheme-magenta-600-10);
    --function-accent-600-30: var(--scheme-magenta-600-30);
    --function-accent-600-50: var(--scheme-magenta-600-50);
}
[data-accent="pink"] {
    --function-accent-100:  var(--scheme-pink-100);
    --function-accent-200:  var(--scheme-pink-200);
    --function-accent-300:  var(--scheme-pink-300);
    --function-accent-400:  var(--scheme-pink-400);
    --function-accent-500:  var(--scheme-pink-500);
    --function-accent-600:  var(--scheme-pink-600);
    --function-accent-700:  var(--scheme-pink-700);
    --function-accent-800:  var(--scheme-pink-800);
    --function-accent-900:  var(--scheme-pink-900);
    --function-accent-1000: var(--scheme-pink-1000);
    --function-accent-1100: var(--scheme-pink-1100);
    --function-accent-1200: var(--scheme-pink-1200);
    --function-accent-600-10: var(--scheme-pink-600-10);
    --function-accent-600-30: var(--scheme-pink-600-30);
    --function-accent-600-50: var(--scheme-pink-600-50);
}
/* neutral */
[data-neutral="custom"] {
    --function-neutral-100:  var(--scheme-neutral-100);
    --function-neutral-200:  var(--scheme-neutral-200);
    --function-neutral-300:  var(--scheme-neutral-300);
    --function-neutral-400:  var(--scheme-neutral-400);
    --function-neutral-500:  var(--scheme-neutral-500);
    --function-neutral-600:  var(--scheme-neutral-600);
    --function-neutral-700:  var(--scheme-neutral-700);
    --function-neutral-800:  var(--scheme-neutral-800);
    --function-neutral-900:  var(--scheme-neutral-900);
    --function-neutral-1000: var(--scheme-neutral-1000);
    --function-neutral-1100: var(--scheme-neutral-1100);
    --function-neutral-1200: var(--scheme-neutral-1200);
    --function-neutral-600-10: var(--scheme-neutral-600-10);
    --function-neutral-600-30: var(--scheme-neutral-600-30);
    --function-neutral-600-50: var(--scheme-neutral-600-50);
}
[data-neutral="slate"] {
    --function-neutral-100:  var(--scheme-slate-100);
    --function-neutral-200:  var(--scheme-slate-200);
    --function-neutral-300:  var(--scheme-slate-300);
    --function-neutral-400:  var(--scheme-slate-400);
    --function-neutral-500:  var(--scheme-slate-500);
    --function-neutral-600:  var(--scheme-slate-600);
    --function-neutral-700:  var(--scheme-slate-700);
    --function-neutral-800:  var(--scheme-slate-800);
    --function-neutral-900:  var(--scheme-slate-900);
    --function-neutral-1000: var(--scheme-slate-1000);
    --function-neutral-1100: var(--scheme-slate-1100);
    --function-neutral-1200: var(--scheme-slate-1200);
    --function-neutral-600-10: var(--scheme-slate-600-10);
    --function-neutral-600-30: var(--scheme-slate-600-30);
    --function-neutral-600-50: var(--scheme-slate-600-50);
}
[data-neutral="gray"] {
    --function-neutral-100:  var(--scheme-gray-100);
    --function-neutral-200:  var(--scheme-gray-200);
    --function-neutral-300:  var(--scheme-gray-300);
    --function-neutral-400:  var(--scheme-gray-400);
    --function-neutral-500:  var(--scheme-gray-500);
    --function-neutral-600:  var(--scheme-gray-600);
    --function-neutral-700:  var(--scheme-gray-700);
    --function-neutral-800:  var(--scheme-gray-800);
    --function-neutral-900:  var(--scheme-gray-900);
    --function-neutral-1000: var(--scheme-gray-1000);
    --function-neutral-1100: var(--scheme-gray-1100);
    --function-neutral-1200: var(--scheme-gray-1200);
    --function-neutral-600-10: var(--scheme-gray-600-10);
    --function-neutral-600-30: var(--scheme-gray-600-30);
    --function-neutral-600-50: var(--scheme-gray-600-50);
}
[data-neutral="sand"] {
    --function-neutral-100:  var(--scheme-sand-100);
    --function-neutral-200:  var(--scheme-sand-200);
    --function-neutral-300:  var(--scheme-sand-300);
    --function-neutral-400:  var(--scheme-sand-400);
    --function-neutral-500:  var(--scheme-sand-500);
    --function-neutral-600:  var(--scheme-sand-600);
    --function-neutral-700:  var(--scheme-sand-700);
    --function-neutral-800:  var(--scheme-sand-800);
    --function-neutral-900:  var(--scheme-sand-900);
    --function-neutral-1000: var(--scheme-sand-1000);
    --function-neutral-1100: var(--scheme-sand-1100);
    --function-neutral-1200: var(--scheme-sand-1200);
    --function-neutral-600-10: var(--scheme-sand-600-10);
    --function-neutral-600-30: var(--scheme-sand-600-30);
    --function-neutral-600-50: var(--scheme-sand-600-50);
}
</file>

<file path="src/once-ui/tokens/index.scss">
@use "@/once-ui/tokens/scheme.scss";
@use "@/once-ui/tokens/function.scss";
@use "@/once-ui/tokens/layout.scss";
@use "@/once-ui/tokens/border.scss";
@use "@/once-ui/tokens/shadow.scss";
@use "@/once-ui/tokens/typography.scss";
@use "@/once-ui/tokens/theme.scss";
@use "@/once-ui/tokens/data.scss";
</file>

<file path="src/once-ui/tokens/layout.scss">
:root {
    --static-space-0:   0;
    --static-space-1:   1px;
    --static-space-2:   0.125rem;
    --static-space-4:   0.25rem;
    --static-space-8:   0.5rem;
    --static-space-12:  0.75rem;
    --static-space-16:  1rem;
    --static-space-20:  1.25rem;
    --static-space-24:  1.5rem;
    --static-space-32:  2rem;
    --static-space-40:  2.5rem;
    --static-space-48:  3rem;
    --static-space-56:  3.5rem;
    --static-space-64:  4rem;
    --static-space-80:  5rem;
    --static-space-104: 6.5rem;
    --static-space-128: 8rem;
    --static-space-160: 10rem;
    --static-width-2400: 150rem;
    --static-width-1600: 100rem;
    --static-width-1440: 90rem;
    --static-width-1200: 75rem;
    --static-width-1024: 64rem;
    --static-width-880:  55rem;
    --static-width-768:  48rem;
    --static-width-640:  40rem;
    --static-width-560:  35rem;
    --static-width-400:  25rem;
    --static-width-320:  20rem;
    --static-height-560: 35rem;
    --static-height-480: 30rem;
    --static-height-400: 25rem;
    --static-height-360: 22.5rem;
    --static-height-320: 20rem;
    --static-height-280: 17.5rem;
    --static-height-240: 15rem;
    --static-height-220: 13.75rem;
    --static-height-160: 10rem;
    --responsive-width-xl: var(--static-width-1440);
    --responsive-width-l:  var(--static-width-1200);
    --responsive-width-m:  var(--static-width-1024);
    --responsive-width-s:  var(--static-width-768);
    --responsive-width-xs: var(--static-width-640);
    --responsive-height-xl: var(--static-height-560);
    --responsive-height-l:  var(--static-height-480);
    --responsive-height-m:  var(--static-height-400);
    --responsive-height-s:  var(--static-height-360);
    --responsive-height-xs: var(--static-height-280);
    --responsive-space-xl: var(--static-space-80);
    --responsive-space-l:  var(--static-space-40);
    --responsive-space-m:  var(--static-space-24);
    --responsive-space-s:  var(--static-space-16);
    --responsive-space-xs: var(--static-space-12);
}
@media (--m) {
    :root {
        --responsive-width-xl: var(--static-width-1024);
        --responsive-width-l:  var(--static-width-1024);
        --responsive-width-m:  var(--static-width-880);
        --responsive-width-s:  var(--static-width-768);
        --responsive-width-xs: var(--static-width-640);
        --responsive-height-xl: var(--static-height-480);
        --responsive-height-l:  var(--static-height-400);
        --responsive-height-m:  var(--static-height-360);
        --responsive-height-s:  var(--static-height-280);
        --responsive-height-xs: var(--static-height-240);
        --responsive-space-xl: var(--static-space-64);
        --responsive-space-l:  var(--static-space-24);
        --responsive-space-m:  var(--static-space-16);
        --responsive-space-s:  var(--static-space-12);
        --responsive-space-xs: var(--static-space-8);
    }
}
@media (--s) {
    :root {
        --responsive-width-xl: var(--static-width-1024);
        --responsive-width-l:  var(--static-width-1024);
        --responsive-width-m:  var(--static-width-880);
        --responsive-width-s:  var(--static-width-768);
        --responsive-width-xs: var(--static-width-640);
        --responsive-height-xl: var(--static-height-320);
        --responsive-height-l:  var(--static-height-280);
        --responsive-height-m:  var(--static-height-240);
        --responsive-height-s:  var(--static-height-220);
        --responsive-height-xs: var(--static-height-160);
        --responsive-space-xl: var(--static-space-40);
        --responsive-space-l:  var(--static-space-16);
        --responsive-space-m:  var(--static-space-12);
        --responsive-space-s:  var(--static-space-8);
        --responsive-space-xs: var(--static-space-4);
    }
}
[data-scaling="110"] {
    --static-space-1:   calc(0.0625rem * 1.1);
    --static-space-2:   calc(0.125rem * 1.1);
    --static-space-4:   calc(0.25rem * 1.1);
    --static-space-8:   calc(0.5rem * 1.1);
    --static-space-12:  calc(0.75rem * 1.1);
    --static-space-16:  calc(1rem * 1.1);
    --static-space-20:  calc(1.25rem * 1.1);
    --static-space-24:  calc(1.5rem * 1.1);
    --static-space-32:  calc(2rem * 1.1);
    --static-space-40:  calc(2.5rem * 1.1);
    --static-space-48:  calc(3rem * 1.1);
    --static-space-56:  calc(3.5rem * 1.1);
    --static-space-64:  calc(4rem * 1.1);
    --static-space-80:  calc(5rem * 1.1);
    --static-space-104: calc(6.5rem * 1.1);
    --static-space-128: calc(8rem * 1.1);
    --static-space-160: calc(10rem * 1.1);
    --static-width-2400: calc(150rem * 1.1);
    --static-width-1600: calc(100rem * 1.1);
    --static-width-1440: calc(90rem * 1.1);
    --static-width-1200: calc(75rem * 1.1);
    --static-width-1024: calc(64rem * 1.1);
    --static-width-880:  calc(55rem * 1.1);
    --static-width-768:  calc(48rem * 1.1);
    --static-width-560:  calc(35rem * 1.1);
    --static-width-400:  calc(25rem * 1.1);
    --static-width-320:  calc(20rem * 1.1);
    --static-height-560: calc(35rem * 1.1);
    --static-height-480: calc(30rem * 1.1);
    --static-height-400: calc(25rem * 1.1);
    --static-height-360: calc(22.5rem * 1.1);
    --static-height-320: calc(20rem * 1.1);
    --static-height-280: calc(17.5rem * 1.1);
    --static-height-240: calc(15rem * 1.1);
    --static-height-220: calc(13.75rem * 1.1);
    --static-height-160: calc(10rem * 1.1);
}
[data-scaling="105"] {
    --static-space-1:   calc(0.0625rem * 1.05);
    --static-space-2:   calc(0.125rem * 1.05);
    --static-space-4:   calc(0.25rem * 1.05);
    --static-space-8:   calc(0.5rem * 1.05);
    --static-space-12:  calc(0.75rem * 1.05);
    --static-space-16:  calc(1rem * 1.05);
    --static-space-20:  calc(1.25rem * 1.05);
    --static-space-24:  calc(1.5rem * 1.05);
    --static-space-32:  calc(2rem * 1.05);
    --static-space-40:  calc(2.5rem * 1.05);
    --static-space-48:  calc(3rem * 1.05);
    --static-space-56:  calc(3.5rem * 1.05);
    --static-space-64:  calc(4rem * 1.05);
    --static-space-80:  calc(5rem * 1.05);
    --static-space-104: calc(6.5rem * 1.05);
    --static-space-128: calc(8rem * 1.05);
    --static-space-160: calc(10rem * 1.05);
    --static-width-2400: calc(150rem * 1.05);
    --static-width-1600: calc(100rem * 1.05);
    --static-width-1440: calc(90rem * 1.05);
    --static-width-1200: calc(75rem * 1.05);
    --static-width-1024: calc(64rem * 1.05);
    --static-width-880:  calc(55rem * 1.05);
    --static-width-768:  calc(48rem * 1.05);
    --static-width-560:  calc(35rem * 1.05);
    --static-width-400:  calc(25rem * 1.05);
    --static-width-320:  calc(20rem * 1.05);
    --static-height-560: calc(35rem * 1.05);
    --static-height-480: calc(30rem * 1.05);
    --static-height-400: calc(25rem * 1.05);
    --static-height-360: calc(22.5rem * 1.05);
    --static-height-320: calc(20rem * 1.05);
    --static-height-280: calc(17.5rem * 1.05);
    --static-height-240: calc(15rem * 1.05);
    --static-height-220: calc(13.75rem * 1.05);
    --static-height-160: calc(10rem * 1.05);
}
[data-scaling="95"] {
    --static-space-1:   calc(0.0625rem * 0.95);
    --static-space-2:   calc(0.125rem * 0.95);
    --static-space-4:   calc(0.25rem * 0.95);
    --static-space-8:   calc(0.5rem * 0.95);
    --static-space-12:  calc(0.75rem * 0.95);
    --static-space-16:  calc(1rem * 0.95);
    --static-space-20:  calc(1.25rem * 0.95);
    --static-space-24:  calc(1.5rem * 0.95);
    --static-space-32:  calc(2rem * 0.95);
    --static-space-40:  calc(2.5rem * 0.95);
    --static-space-48:  calc(3rem * 0.95);
    --static-space-56:  calc(3.5rem * 0.95);
    --static-space-64:  calc(4rem * 0.95);
    --static-space-80:  calc(5rem * 0.95);
    --static-space-104: calc(6.5rem * 0.95);
    --static-space-128: calc(8rem * 0.95);
    --static-space-160: calc(10rem * 0.95);
    --static-width-2400: calc(150rem * 0.95);
    --static-width-1600: calc(100rem * 0.95);
    --static-width-1440: calc(90rem * 0.95);
    --static-width-1200: calc(75rem * 0.95);
    --static-width-1024: calc(64rem * 0.95);
    --static-width-880:  calc(55rem * 0.95);
    --static-width-768:  calc(48rem * 0.95);
    --static-width-560:  calc(35rem * 0.95);
    --static-width-400:  calc(25rem * 0.95);
    --static-width-320:  calc(20rem * 0.95);
    --static-height-560: calc(35rem * 0.95);
    --static-height-480: calc(30rem * 0.95);
    --static-height-400: calc(25rem * 0.95);
    --static-height-360: calc(22.5rem * 0.95);
    --static-height-320: calc(20rem * 0.95);
    --static-height-280: calc(17.5rem * 0.95);
    --static-height-240: calc(15rem * 0.95);
    --static-height-220: calc(13.75rem * 0.95);
    --static-height-160: calc(10rem * 0.95);
}
[data-scaling="90"] {
    --static-space-1:   calc(0.0625rem * 0.9);
    --static-space-2:   calc(0.125rem * 0.9);
    --static-space-4:   calc(0.25rem * 0.9);
    --static-space-8:   calc(0.5rem * 0.9);
    --static-space-12:  calc(0.75rem * 0.9);
    --static-space-16:  calc(1rem * 0.9);
    --static-space-20:  calc(1.25rem * 0.9);
    --static-space-24:  calc(1.5rem * 0.9);
    --static-space-32:  calc(2rem * 0.9);
    --static-space-40:  calc(2.5rem * 0.9);
    --static-space-48:  calc(3rem * 0.9);
    --static-space-56:  calc(3.5rem * 0.9);
    --static-space-64:  calc(4rem * 0.9);
    --static-space-80:  calc(5rem * 0.9);
    --static-space-104: calc(6.5rem * 0.9);
    --static-space-128: calc(8rem * 0.9);
    --static-space-160: calc(10rem * 0.9);
    --static-width-2400: calc(150rem * 0.9);
    --static-width-1600: calc(100rem * 0.9);
    --static-width-1440: calc(90rem * 0.9);
    --static-width-1200: calc(75rem * 0.9);
    --static-width-1024: calc(64rem * 0.9);
    --static-width-880:  calc(55rem * 0.9);
    --static-width-768:  calc(48rem * 0.9);
    --static-width-560:  calc(35rem * 0.9);
    --static-width-400:  calc(25rem * 0.9);
    --static-width-320:  calc(20rem * 0.9);
    --static-height-560: calc(35rem * 0.9);
    --static-height-480: calc(30rem * 0.9);
    --static-height-400: calc(25rem * 0.9);
    --static-height-360: calc(22.5rem * 0.9);
    --static-height-320: calc(20rem * 0.9);
    --static-height-280: calc(17.5rem * 0.9);
    --static-height-240: calc(15rem * 0.9);
    --static-height-220: calc(13.75rem * 0.9);
    --static-height-160: calc(10rem * 0.9);
}
</file>

<file path="src/once-ui/tokens/scheme.scss">
:root {
    /* STATIC */
    --static-transparent: #00000000;
    --static-white:        #ffffff;
    --static-white-medium: #ffffff4D;
    --static-black:        #000000;
    --static-black-medium: #0000004D;
    /* CUSTOM */
    /* 
        Insert code for your custom color palette
        generated at https://once-ui.com/customize
    */
    /* BASE */
    /* sand */
    --scheme-sand-100:  #0D0A00;
    --scheme-sand-200:  #1B1608;
    --scheme-sand-300:  #443F30;
    --scheme-sand-400:  #5E594C;
    --scheme-sand-500:  #797465;
    --scheme-sand-600:  #999486;
    --scheme-sand-700:  #B7B2A4;
    --scheme-sand-800:  #D7D2C4;
    --scheme-sand-900:  #E5E0D2;
    --scheme-sand-1000: #F2EDDF;
    --scheme-sand-1100: #F8F3E5;
    --scheme-sand-1200: #FDF9EE;
    --scheme-sand-600-10: #9994861A;
    --scheme-sand-600-30: #9994864D;
    --scheme-sand-600-50: #99948680;
    /* gray */
    --scheme-gray-100:  #0A0A0A;
    --scheme-gray-200:  #151515;
    --scheme-gray-300:  #3F3F3F;
    --scheme-gray-400:  #595959;
    --scheme-gray-500:  #757575;
    --scheme-gray-600:  #959595;
    --scheme-gray-700:  #B2B2B2;
    --scheme-gray-800:  #D2D2D2;
    --scheme-gray-900:  #E0E0E0;
    --scheme-gray-1000: #EDEDED;
    --scheme-gray-1100: #F3F3F3;
    --scheme-gray-1200: #F9F9F9;
    --scheme-gray-600-10: #9595951A;
    --scheme-gray-600-30: #9595954D;
    --scheme-gray-600-50: #95959580;
    /* slate */
    --scheme-slate-100:  #040816;
    --scheme-slate-200:  #0F152B;
    --scheme-slate-300:  #393F55;
    --scheme-slate-400:  #52586F;
    --scheme-slate-500:  #6D748A;
    --scheme-slate-600:  #8E94AA;
    --scheme-slate-700:  #ACB2C8;
    --scheme-slate-800:  #CCD2E8;
    --scheme-slate-900:  #DAE0F6;
    --scheme-slate-1000: #E9EDFE;
    --scheme-slate-1100: #F1F3FD;
    --scheme-slate-1200: #F8F9FD;
    --scheme-slate-600-10: #8E94AA1A;
    --scheme-slate-600-30: #8E94AA4D;
    --scheme-slate-600-50: #8E94AA80;
    /* red */
    --scheme-red-100:  #130507;
    --scheme-red-200:  #2A0A10;
    --scheme-red-300:  #830711;
    --scheme-red-400:  #B6020C;
    --scheme-red-500:  #E90507;
    --scheme-red-600:  #FF5F53;
    --scheme-red-700:  #FF9689;
    --scheme-red-800:  #FDC6BD;
    --scheme-red-900:  #FDD8D2;
    --scheme-red-1000: #FDEAE6;
    --scheme-red-1100: #FCF1EF;
    --scheme-red-1200: #FDF9F8;
    --scheme-red-600-10: #FF5F531A;
    --scheme-red-600-30: #FF5F534D;
    --scheme-red-600-50: #FF5F5380;
    /* orange */
    --scheme-orange-100:  #120605;
    --scheme-orange-200:  #270D0A;
    --scheme-orange-300:  #7C1A06;
    --scheme-orange-400:  #AC2401;
    --scheme-orange-500:  #DB3400;
    --scheme-orange-600:  #FD6325;
    --scheme-orange-700:  #FF9964;
    --scheme-orange-800:  #FEC8A4;
    --scheme-orange-900:  #FDDAC2;
    --scheme-orange-1000: #FDEADD;
    --scheme-orange-1100: #FCF2E9;
    --scheme-orange-1200: #FCF9F5;
    --scheme-orange-600-10: #FD63251A;
    --scheme-orange-600-30: #FD63254D;
    --scheme-orange-600-50: #FD632580;
    /* yellow */
    --scheme-yellow-100:  #100704;
    --scheme-yellow-200:  #231009;
    --scheme-yellow-300:  #6B2D09;
    --scheme-yellow-400:  #924205;
    --scheme-yellow-500:  #B85B02;
    --scheme-yellow-600:  #E07B00;
    --scheme-yellow-700:  #FE9C0B;
    --scheme-yellow-800:  #FECC55;
    --scheme-yellow-900:  #FEDE79;
    --scheme-yellow-1000: #FCEEA7;
    --scheme-yellow-1100: #FBF5CB;
    --scheme-yellow-1200: #FBFAEB;
    --scheme-yellow-600-10: #E07B001A;
    --scheme-yellow-600-30: #E07B004D;
    --scheme-yellow-600-50: #E07B0080;
    /* moss */
    --scheme-moss-100:  #080B04;
    --scheme-moss-200:  #111707;
    --scheme-moss-300:  #2F460C;
    --scheme-moss-400:  #3C630A;
    --scheme-moss-500:  #478309;
    --scheme-moss-600:  #4FA900;
    --scheme-moss-700:  #54CC01;
    --scheme-moss-800:  #76ED53;
    --scheme-moss-900:  #98F789;
    --scheme-moss-1000: #C0FDBB;
    --scheme-moss-1100: #DAFDD7;
    --scheme-moss-1200: #F0FDEF;
    --scheme-moss-600-10: #4FA9001A;
    --scheme-moss-600-30: #4FA9004D;
    --scheme-moss-600-50: #4FA90080;
    /* green */
    --scheme-green-100:  #040B07;
    --scheme-green-200:  #081810;
    --scheme-green-300:  #0D4929;
    --scheme-green-400:  #0C6731;
    --scheme-green-500:  #0A8637;
    --scheme-green-600:  #08AC3A;
    --scheme-green-700:  #01CF38;
    --scheme-green-800:  #5FEF61;
    --scheme-green-900:  #91F88C;
    --scheme-green-1000: #C0FDBB;
    --scheme-green-1100: #DAFDD7;
    --scheme-green-1200: #F0FDEF;
    --scheme-green-600-10: #08AC3A1A;
    --scheme-green-600-30: #08AC3A4D;
    --scheme-green-600-50: #08AC3A80;
    /* emerald */
    --scheme-emerald-100:  #040B0A;
    --scheme-emerald-200:  #081816;
    --scheme-emerald-300:  #0D483C;
    --scheme-emerald-400:  #0C6551;
    --scheme-emerald-500:  #0A8466;
    --scheme-emerald-600:  #08A97C;
    --scheme-emerald-700:  #01CB90;
    --scheme-emerald-800:  #56ECAD;
    --scheme-emerald-900:  #84F6C3;
    --scheme-emerald-1000: #B4FDDA;
    --scheme-emerald-1100: #D7FCEA;
    --scheme-emerald-1200: #EEFDF5;
    --scheme-emerald-600-10: #08A97C1A;
    --scheme-emerald-600-30: #08A97C4D;
    --scheme-emerald-600-50: #08A97C80;
    /* aqua */
    --scheme-aqua-100:  #050B0D;
    --scheme-aqua-200:  #081719;
    --scheme-aqua-300:  #0C464B;
    --scheme-aqua-400:  #0C6367;
    --scheme-aqua-500:  #0B8184;
    --scheme-aqua-600:  #08A6A5;
    --scheme-aqua-700:  #01C7C3;
    --scheme-aqua-800:  #4DE9DC;
    --scheme-aqua-900:  #78F6E4;
    --scheme-aqua-1000: #B0FCEE;
    --scheme-aqua-1100: #D3FCF3;
    --scheme-aqua-1200: #ECFDF9;
    --scheme-aqua-600-10: #08A6A51A;
    --scheme-aqua-600-30: #08A6A54D;
    --scheme-aqua-600-50: #08A6A580;
    /* cyan */
    --scheme-cyan-100:  #050911;
    --scheme-cyan-200:  #0A1525;
    --scheme-cyan-300:  #094074;
    --scheme-cyan-400:  #045B9C;
    --scheme-cyan-500:  #0279BE;
    --scheme-cyan-600:  #049EE2;
    --scheme-cyan-700:  #17C0FD;
    --scheme-cyan-800:  #60E4FC;
    --scheme-cyan-900:  #82F1FC;
    --scheme-cyan-1000: #B3FAFC;
    --scheme-cyan-1100: #D4FBFC;
    --scheme-cyan-1200: #EFFCFD;
    --scheme-cyan-600-10: #049EE21A;
    --scheme-cyan-600-30: #049EE24D;
    --scheme-cyan-600-50: #049EE280;
    /* blue */
    --scheme-blue-100:  #0A071B;
    --scheme-blue-200:  #0D0B44;
    --scheme-blue-300:  #0019CB;
    --scheme-blue-400:  #033CF8;
    --scheme-blue-500:  #2D69FA;
    --scheme-blue-600:  #5A93FC;
    --scheme-blue-700:  #84B5FD;
    --scheme-blue-800:  #B4D6FB;
    --scheme-blue-900:  #CBE3FB;
    --scheme-blue-1000: #E0EFFC;
    --scheme-blue-1100: #EBF5FC;
    --scheme-blue-1200: #F6FAFD;
    --scheme-blue-600-10: #5A93FC1A;
    --scheme-blue-600-30: #5A93FC4D;
    --scheme-blue-600-50: #5A93FC80;
    /* indigo */
    --scheme-indigo-100:  #0E0718;
    --scheme-indigo-200:  #1C0B35;
    --scheme-indigo-300:  #3D01C5;
    --scheme-indigo-400:  #5625F7;
    --scheme-indigo-500:  #7358FA;
    --scheme-indigo-600:  #9585FA;
    --scheme-indigo-700:  #B3A9FD;
    --scheme-indigo-800:  #D2CEFB;
    --scheme-indigo-900:  #E0DEFA;
    --scheme-indigo-1000: #EDEDFB;
    --scheme-indigo-1100: #F3F2FC;
    --scheme-indigo-1200: #F9F9FD;
    --scheme-indigo-600-10:  #9585FA1A;
    --scheme-indigo-600-30:  #9585FA4D;
    --scheme-indigo-600-50:  #9585FA80;
    /* violet */
    --scheme-violet-100:  #0E0512;
    --scheme-violet-200:  #210B2B;
    --scheme-violet-300:  #60099B;
    --scheme-violet-400:  #7D04E4;
    --scheme-violet-500:  #9745F7;
    --scheme-violet-600:  #B07AFA;
    --scheme-violet-700:  #C7A2FD;
    --scheme-violet-800:  #DDCBFB;
    --scheme-violet-900:  #E6DCFB;
    --scheme-violet-1000: #F0EBFC;
    --scheme-violet-1100: #F5F3FC;
    --scheme-violet-1200: #FAF8FD;
    --scheme-violet-600-10:  #B07AFA1A;
    --scheme-violet-600-30:  #B07AFA4D;
    --scheme-violet-600-50:  #B07AFA80;
    /* magenta */
    --scheme-magenta-100:  #100511;
    --scheme-magenta-200:  #250A26;
    --scheme-magenta-300:  #70077B;
    --scheme-magenta-400:  #9902B3;
    --scheme-magenta-500:  #BD1DE8;
    --scheme-magenta-600:  #D166FA;
    --scheme-magenta-700:  #DC98FD;
    --scheme-magenta-800:  #E8C7FB;
    --scheme-magenta-900:  #EFD9FB;
    --scheme-magenta-1000: #F5E9FC;
    --scheme-magenta-1100: #F8F1FC;
    --scheme-magenta-1200: #FBF8FD;
    --scheme-magenta-600-10:  #D166FA1A;
    --scheme-magenta-600-30:  #D166FA4D;
    --scheme-magenta-600-50:  #D166FA80;
    /* pink */
    --scheme-pink-100:  #12050B;
    --scheme-pink-200:  #280A1A;
    --scheme-pink-300:  #7D074A;
    --scheme-pink-400:  #AE0169;
    --scheme-pink-500:  #DE028E;
    --scheme-pink-600:  #F854BE;
    --scheme-pink-700:  #FD8BE4;
    --scheme-pink-800:  #FCC0F1;
    --scheme-pink-900:  #FCD5F5;
    --scheme-pink-1000: #FCE7F9;
    --scheme-pink-1100: #FCF0FA;
    --scheme-pink-1200: #FDF8FC;
    --scheme-pink-600-10:  #F854BE1A;
    --scheme-pink-600-30:  #F854BE4D;
    --scheme-pink-600-50:  #F854BE80;
}
</file>

<file path="src/once-ui/tokens/shadow.scss">
:root {
    --shadow-xs: 0px 0px 1px rgba(0, 0, 0, 0.12), 0px 1px 2px  rgba(0, 0, 0, 0.08),  0px 2px 4px   rgba(0, 0, 0, 0.08);
    --shadow-s:  0px 0px 2px rgba(0, 0, 0, 0.12), 0px 1px 4px  rgba(0, 0, 0, 0.08),  0px 4px 8px   rgba(0, 0, 0, 0.08);
    --shadow-m:  0px 0px 2px rgba(0, 0, 0, 0.12), 0px 2px 4px  rgba(0, 0, 0, 0.08),  0px 8px 8px   rgba(0, 0, 0, 0.08);
    --shadow-l:  0px 2px 4px rgba(0, 0, 0, 0.12), 0px 8px 12px rgba(0, 0, 0, 0.08),  0px 8px 16px  rgba(0, 0, 0, 0.08);
    --shadow-xl: 0px 4px 4px rgba(0, 0, 0, 0.12), 0px 8px 12px rgba(0, 0, 0, 0.08),  0px 24px 24px rgba(0, 0, 0, 0.08);
}
</file>

<file path="src/once-ui/tokens/theme.scss">
:root {
    /* FONT FAMILY */
    --font-family-body:     var(--font-primary);
    --font-family-heading:  var(--font-secondary);
    --font-family-label:    var(--font-tertiary);
    --font-family-code:     var(--font-code);
    --font-size-heading-multiplier:   1;
    --font-size-body-multiplier:      1;
    --font-size-label-multiplier:     1;
    --line-height-heading-multiplier: 1;
    --line-height-body-multiplier:    1;
    --line-height-label-multiplier:   1;
    /* FONT SCALING */
    --font-scaling-desktop: 16px;
    --font-scaling-tablet:  15px;
    --font-scaling-mobile:  14px;
    --cursor-interactive:    pointer;
    --solid-inset-distance:  0;
    --solid-inset-size:      0;
    --solid-border-width:    0;
    --backdrop-filter:       none;
    --surface-border:        var(--static-transparent);
    --surface-background:    var(--neutral-background-medium);
}
[data-theme="dark"] {
    --icon: url('/trademark/icon-dark.svg');
    --type: url('/trademark/type-dark.svg');
    --page-background:              var(--neutral-background-weak);
    --backdrop:                     var(--static-black-medium);
    --solid-border-color-brand:     var(--brand-alpha-strong);
    --solid-border-color-neutral:   var(--neutral-alpha-strong);
    --solid-border-color-danger:    var(--danger-alpha-strong);
    /* code */
    --code-moss:                    var(--scheme-moss-800);
    --code-gray:                    var(--scheme-gray-800);
    --code-aqua:                    var(--scheme-aqua-800);
    --code-green:                   var(--scheme-green-800);
    --code-blue:                    var(--scheme-blue-800);
    --code-violet:                  var(--scheme-violet-800);
    --code-orange:                  var(--scheme-orange-800);
    /* brand */
    --brand-background-strong:      var(--function-brand-300);
    --brand-background-medium:      var(--function-brand-200);
    --brand-background-weak:        var(--function-brand-100);
    --brand-on-background-strong:   var(--static-white);
    --brand-on-background-medium:   var(--function-brand-900);
    --brand-on-background-weak:     var(--function-brand-700);
    --brand-border-strong:          var(--function-brand-400);
    --brand-border-medium:          var(--function-brand-300);
    --brand-border-weak:            var(--function-brand-200);
    --brand-alpha-strong:           var(--function-brand-600-50);
    --brand-alpha-medium:           var(--function-brand-600-30);
    --brand-alpha-weak:             var(--function-brand-600-10);
    /* accent */
    --accent-background-strong:     var(--function-accent-300);
    --accent-background-medium:     var(--function-accent-200);
    --accent-background-weak:       var(--function-accent-100);
    --accent-on-background-strong:  var(--static-white);
    --accent-on-background-medium:  var(--function-accent-900);
    --accent-on-background-weak:    var(--function-accent-700);
    --accent-solid-strong:          var(--function-accent-500);
    --accent-solid-medium:          var(--function-accent-400);
    --accent-solid-weak:            var(--function-accent-300);
    --accent-on-solid-strong:       var(--static-white);      
    --accent-on-solid-weak:         var(--function-accent-900);
    --accent-border-strong:         var(--function-accent-400);
    --accent-border-medium:         var(--function-accent-300);
    --accent-border-weak:           var(--function-accent-200);
    --accent-alpha-strong:          var(--function-accent-600-50);
    --accent-alpha-medium:          var(--function-accent-600-30);
    --accent-alpha-weak:            var(--function-accent-600-10);
    /* neutral */
    --neutral-background-strong:    var(--function-neutral-300);
    --neutral-background-medium:    var(--function-neutral-200);
    --neutral-background-weak:      var(--function-neutral-100);
    --neutral-on-background-strong: var(--static-white);
    --neutral-on-background-medium: var(--function-neutral-900);
    --neutral-on-background-weak:   var(--function-neutral-700);
    --neutral-solid-strong:         var(--function-neutral-500);
    --neutral-solid-medium:         var(--function-neutral-400);
    --neutral-solid-weak:           var(--function-neutral-300);
    --neutral-on-solid-strong:      var(--static-white);      
    --neutral-on-solid-weak:        var(--function-neutral-900);
    --neutral-border-strong:        var(--function-neutral-400);
    --neutral-border-medium:        var(--function-neutral-300);
    --neutral-border-weak:          var(--function-neutral-200);
    --neutral-alpha-strong:         var(--function-neutral-600-50);
    --neutral-alpha-medium:         var(--function-neutral-600-30);
    --neutral-alpha-weak:           var(--function-neutral-600-10);
    /* info */
    --info-background-strong:       var(--function-info-300);
    --info-background-medium:       var(--function-info-200);
    --info-background-weak:         var(--function-info-100);
    --info-on-background-strong:    var(--static-white);
    --info-on-background-medium:    var(--function-info-900);
    --info-on-background-weak:      var(--function-info-700);
    --info-solid-strong:            var(--function-info-500);
    --info-solid-medium:            var(--function-info-400);
    --info-solid-weak:              var(--function-info-300);
    --info-on-solid-strong:         var(--static-white);      
    --info-on-solid-weak:           var(--function-info-900);
    --info-border-strong:           var(--function-info-400);
    --info-border-medium:           var(--function-info-300);
    --info-border-weak:             var(--function-info-200);
    --info-alpha-strong:            var(--function-info-600-50);
    --info-alpha-medium:            var(--function-info-600-30);
    --info-alpha-weak:              var(--function-info-600-10);
    /* warning */
    --warning-background-strong:    var(--function-warning-300);
    --warning-background-medium:    var(--function-warning-200);
    --warning-background-weak:      var(--function-warning-100);
    --warning-on-background-strong: var(--static-white);
    --warning-on-background-medium: var(--function-warning-900);
    --warning-on-background-weak:   var(--function-warning-700);
    --warning-solid-strong:         var(--function-warning-500);
    --warning-solid-medium:         var(--function-warning-400);
    --warning-solid-weak:           var(--function-warning-300);
    --warning-on-solid-strong:      var(--static-white);      
    --warning-on-solid-weak:        var(--function-warning-900);
    --warning-border-strong:        var(--function-warning-400);
    --warning-border-medium:        var(--function-warning-300);
    --warning-border-weak:          var(--function-warning-200);
    --warning-alpha-strong:         var(--function-warning-600-50);
    --warning-alpha-medium:         var(--function-warning-600-30);
    --warning-alpha-weak:           var(--function-warning-600-10);
    /* danger */
    --danger-background-strong:     var(--function-danger-300);
    --danger-background-medium:     var(--function-danger-200);
    --danger-background-weak:       var(--function-danger-100);
    --danger-on-background-strong:  var(--static-white);
    --danger-on-background-medium:  var(--function-danger-900);
    --danger-on-background-weak:    var(--function-danger-700);
    --danger-solid-strong:          var(--function-danger-500);
    --danger-solid-medium:          var(--function-danger-400);
    --danger-solid-weak:            var(--function-danger-300);
    --danger-on-solid-strong:       var(--static-white);      
    --danger-on-solid-weak:         var(--function-danger-900);
    --danger-border-strong:         var(--function-danger-400);
    --danger-border-medium:         var(--function-danger-300);
    --danger-border-weak:           var(--function-danger-200);
    --danger-alpha-strong:          var(--function-danger-600-50);
    --danger-alpha-medium:          var(--function-danger-600-30);
    --danger-alpha-weak:            var(--function-danger-600-10);
    /* success */ 
    --success-background-strong:    var(--function-success-300);
    --success-background-medium:    var(--function-success-200);
    --success-background-weak:      var(--function-success-100);
    --success-on-background-strong: var(--static-white);
    --success-on-background-medium: var(--function-success-900);
    --success-on-background-weak:   var(--function-success-700);
    --success-solid-strong:         var(--function-success-500);
    --success-solid-medium:         var(--function-success-400);
    --success-solid-weak:           var(--function-success-300);
    --success-on-solid-strong:      var(--static-white);      
    --success-on-solid-weak:        var(--function-success-900);
    --success-border-strong:        var(--function-success-400);
    --success-border-medium:        var(--function-success-300);
    --success-border-weak:          var(--function-success-200);
    --success-alpha-strong:         var(--function-success-600-50);
    --success-alpha-medium:         var(--function-success-600-30);
    --success-alpha-weak:           var(--function-success-600-10);
    .dark-flex {
        display: flex;
    }
    .dark-grid {
        display: grid;
    }
    .light-flex {
        display: none;
    }
    .light-grid {
        display: none;
    }
}
[data-theme="light"] {
    /* Move all CSS variable declarations above nested rules */
    --icon: url('/trademark/icon-light.svg');
    --type: url('/trademark/type-light.svg');
    --page-background:              var(--neutral-background-weak);
    --backdrop:                     var(--static-white-medium);
    --solid-border-color-brand:     var(--brand-alpha-strong);
    --solid-border-color-neutral:   var(--neutral-alpha-strong);
    --solid-border-color-danger:    var(--danger-alpha-strong);
    /* code */
    --code-moss:                    var(--scheme-moss-600);
    --code-gray:                    var(--scheme-gray-600);
    --code-aqua:                    var(--scheme-aqua-600);
    --code-green:                   var(--scheme-green-600);
    --code-blue:                    var(--scheme-blue-600);
    --code-violet:                  var(--scheme-violet-600);
    --code-orange:                  var(--scheme-orange-600);
    /* brand */  
    --brand-background-strong:      var(--function-brand-800);
    --brand-background-medium:      var(--function-brand-1000);
    --brand-background-weak:        var(--static-white);
    --brand-on-background-strong:   var(--function-brand-100);
    --brand-on-background-medium:   var(--function-brand-400);
    --brand-on-background-weak:     var(--function-brand-500);
    --brand-border-strong:          var(--function-brand-800);
    --brand-border-medium:          var(--function-brand-900);
    --brand-border-weak:            var(--function-brand-1000);
    --brand-alpha-strong:           var(--function-brand-600-50);
    --brand-alpha-medium:           var(--function-brand-600-30);
    --brand-alpha-weak:             var(--function-brand-600-10);
    /* accent */
    --accent-background-strong:     var(--function-accent-800);
    --accent-background-medium:     var(--function-accent-1000);
    --accent-background-weak:       var(--static-white);
    --accent-on-background-strong:  var(--function-accent-100);
    --accent-on-background-medium:  var(--function-accent-400);
    --accent-on-background-weak:    var(--function-accent-500);
    --accent-solid-strong:          var(--function-accent-600);
    --accent-solid-medium:          var(--function-accent-500);
    --accent-solid-weak:            var(--function-accent-400);
    --accent-on-solid-strong:       var(--static-white);      
    --accent-on-solid-weak:         var(--function-accent-1000);
    --accent-border-strong:         var(--function-accent-800);
    --accent-border-medium:         var(--function-accent-900);
    --accent-border-weak:           var(--function-accent-1000);
    --accent-alpha-strong:          var(--function-accent-600-50);
    --accent-alpha-medium:          var(--function-accent-600-30);
    --accent-alpha-weak:            var(--function-accent-600-10);
    /* neutral */
    --neutral-background-strong:    var(--function-neutral-800);
    --neutral-background-medium:    var(--function-neutral-1000);
    --neutral-background-weak:      var(--static-white);
    --neutral-on-background-strong: var(--function-neutral-100);
    --neutral-on-background-medium: var(--function-neutral-400);
    --neutral-on-background-weak:   var(--function-neutral-500);
    --neutral-solid-strong:         var(--function-neutral-600);
    --neutral-solid-medium:         var(--function-neutral-500);
    --neutral-solid-weak:           var(--function-neutral-400);
    --neutral-on-solid-strong:      var(--static-white);      
    --neutral-on-solid-weak:        var(--function-neutral-1000);
    --neutral-border-strong:        var(--function-neutral-800);
    --neutral-border-medium:        var(--function-neutral-900);
    --neutral-border-weak:          var(--function-neutral-1000);
    --neutral-alpha-strong:         var(--function-neutral-600-50);
    --neutral-alpha-medium:         var(--function-neutral-600-30);
    --neutral-alpha-weak:           var(--function-neutral-600-10);
    /* info */
    --info-background-strong:       var(--function-info-800);
    --info-background-medium:       var(--function-info-1000);
    --info-background-weak:         var(--static-white);
    --info-on-background-strong:    var(--function-info-100);
    --info-on-background-medium:    var(--function-info-400);
    --info-on-background-weak:      var(--function-info-500);
    --info-solid-strong:            var(--function-info-600);
    --info-solid-medium:            var(--function-info-500);
    --info-solid-weak:              var(--function-info-400);
    --info-on-solid-strong:         var(--static-white);      
    --info-on-solid-weak:           var(--function-info-1000);
    --info-border-strong:           var(--function-info-800);
    --info-border-medium:           var(--function-info-900);
    --info-border-weak:             var(--function-info-1000);
    --info-alpha-strong:            var(--function-info-600-50);
    --info-alpha-medium:            var(--function-info-600-30);
    --info-alpha-weak:              var(--function-info-600-10);
    /* warning */
    --warning-background-strong:    var(--function-warning-800);
    --warning-background-medium:    var(--function-warning-1000);
    --warning-background-weak:      var(--static-white);
    --warning-on-background-strong: var(--function-warning-100);
    --warning-on-background-medium: var(--function-warning-400);
    --warning-on-background-weak:   var(--function-warning-500);
    --warning-solid-strong:         var(--function-warning-600);
    --warning-solid-medium:         var(--function-warning-500);
    --warning-solid-weak:           var(--function-warning-400);
    --warning-on-solid-strong:      var(--static-white);      
    --warning-on-solid-weak:        var(--function-warning-1000);
    --warning-border-strong:        var(--function-warning-800);
    --warning-border-medium:        var(--function-warning-900);
    --warning-border-weak:          var(--function-warning-1000);
    --warning-alpha-strong:         var(--function-warning-600-50);
    --warning-alpha-medium:         var(--function-warning-600-30);
    --warning-alpha-weak:           var(--function-warning-600-10);
    /* danger */   
    --danger-background-strong:     var(--function-danger-800);
    --danger-background-medium:     var(--function-danger-1000);
    --danger-background-weak:       var(--static-white);
    --danger-on-background-strong:  var(--function-danger-100);
    --danger-on-background-medium:  var(--function-danger-400);
    --danger-on-background-weak:    var(--function-danger-500);
    --danger-solid-strong:          var(--function-danger-600);
    --danger-solid-medium:          var(--function-danger-500);
    --danger-solid-weak:            var(--function-danger-400);
    --danger-on-solid-strong:       var(--static-white);      
    --danger-on-solid-weak:         var(--function-danger-1000);
    --danger-border-strong:         var(--function-danger-800);
    --danger-border-medium:         var(--function-danger-900);
    --danger-border-weak:           var(--function-danger-1000);
    --danger-alpha-strong:          var(--function-danger-600-50);
    --danger-alpha-medium:          var(--function-danger-600-30);
    --danger-alpha-weak:            var(--function-danger-600-10);
    /* success */   
    --success-background-strong:    var(--function-success-800);
    --success-background-medium:    var(--function-success-1000);
    --success-background-weak:      var(--static-white);
    --success-on-background-strong: var(--function-success-100);
    --success-on-background-medium: var(--function-success-400);
    --success-on-background-weak:   var(--function-success-500);
    --success-solid-strong:         var(--function-success-600);
    --success-solid-medium:         var(--function-success-500);
    --success-solid-weak:           var(--function-success-400);
    --success-on-solid-strong:      var(--static-white);      
    --success-on-solid-weak:        var(--function-success-1000);
    --success-border-strong:        var(--function-success-800);
    --success-border-medium:        var(--function-success-900);
    --success-border-weak:          var(--function-success-1000);
    --success-alpha-strong:         var(--function-success-600-50);
    --success-alpha-medium:         var(--function-success-600-30);
    --success-alpha-weak:           var(--function-success-600-10);
    .dark-flex {
        display: none;
    }
    .dark-grid {
        display: none;
    }
    .light-flex {
        display: flex;
    }
    .light-grid {
        display: grid;
    }
}
[data-solid-style="plastic"] {
    --solid-inset-distance: -1rem;
    --solid-inset-size:      1rem;
    --solid-border-width:    1px;
}
[data-transition="all"],[data-transition="micro"] {
    --transition-eased:                  ease-in-out;
    --transition-property-all:           all;
    --transition-duration-micro-short:   0.1s;
    --transition-duration-micro-medium:  0.2s;
    --transition-duration-micro-long:    0.4s;
    --transition-micro-short:            var(--transition-property-all) var(--transition-duration-micro-short) var(--transition-eased);
    --transition-micro-medium:           var(--transition-property-all) var(--transition-duration-micro-medium) var(--transition-eased);
    --transition-micro-long:             var(--transition-property-all) var(--transition-duration-micro-long) var(--transition-eased);
}
[data-transition="all"],[data-transition="macro"] {
    --transition-eased:                  ease-in-out;
    --transition-property-all:           all;
    --transition-duration-macro-short:   0.15s;
    --transition-duration-macro-medium:  0.3s;
    --transition-duration-macro-long:    0.6s;
    --transition-macro-short:            var(--transition-property-all) var(--transition-duration-macro-short) var(--transition-eased);
    --transition-macro-medium:           var(--transition-property-all) var(--transition-duration-macro-medium) var(--transition-eased);
    --transition-macro-long:             var(--transition-property-all) var(--transition-duration-macro-long) var(--transition-eased);
}
[data-surface="translucent"] {
    --backdrop-filter: blur(1rem);
}
[data-surface="translucent"][data-theme="light"],
[data-surface="translucent"] [data-theme="light"] {
    --surface-background:    var(--static-white-medium);
    --surface-border:        var(--neutral-alpha-medium);
}
[data-surface="translucent"][data-theme="dark"],
[data-surface="translucent"] [data-theme="dark"] {
    --surface-background:    var(--static-black-medium);
    --surface-border:        var(--neutral-alpha-medium);
}
[data-surface="filled"][data-theme="light"],
[data-surface="filled"] [data-theme="light"] {
    --surface-background:    var(--neutral-background-weak);
    --surface-border:        var(--neutral-border-medium);
}
[data-surface="filled"][data-theme="dark"],
[data-surface="filled"] [data-theme="dark"] {
    --surface-background:    var(--neutral-background-medium);
    --surface-border:        var(--static-transparent);
}
[data-theme="dark"][data-solid="color"],
[data-theme="dark"] [data-solid="color"] {
    --brand-solid-strong:         var(--function-brand-500);
    --brand-solid-medium:         var(--function-brand-400);
    --brand-solid-weak:           var(--function-brand-300);
    --brand-on-solid-strong:      var(--static-white);      
    --brand-on-solid-weak:        var(--function-brand-900);
}
[data-theme="dark"][data-solid="contrast"],
[data-theme="dark"] [data-solid="contrast"] {
    --brand-solid-strong:         var(--function-neutral-1000);
    --brand-solid-medium:         var(--static-white);
    --brand-solid-weak:           var(--function-neutral-900);
    --brand-on-solid-strong:      var(--static-black);
    --brand-on-solid-weak:        var(--function-neutral-200);
}
[data-theme="dark"][data-solid="inverse"],
[data-theme="dark"] [data-solid="inverse"] {
    --brand-solid-strong:         var(--function-brand-800);
    --brand-solid-medium:         var(--function-brand-700);
    --brand-solid-weak:           var(--function-brand-600);
    --brand-on-solid-strong:      var(--static-black);      
    --brand-on-solid-weak:        var(--function-brand-200);
}
[data-theme="light"][data-solid="color"],
[data-theme="light"] [data-solid="color"] {
    --brand-solid-strong:         var(--function-brand-600);
    --brand-solid-medium:         var(--function-brand-500);
    --brand-solid-weak:           var(--function-brand-400);
    --brand-on-solid-strong:      var(--static-white);      
    --brand-on-solid-weak:        var(--function-brand-1000);
}
[data-theme="light"][data-solid="contrast"],
[data-theme="light"] [data-solid="contrast"] {
    --brand-solid-strong:         var(--function-neutral-300);
    --brand-solid-medium:         var(--static-black);
    --brand-solid-weak:           var(--function-neutral-400);
    --brand-on-solid-strong:      var(--static-white);      
    --brand-on-solid-weak:        var(--function-neutral-1000);
}
[data-solid="color"] {
    --solid-inset-color-brand:    var(--brand-alpha-strong);
    --solid-inset-color-neutral:  var(--static-transparent);
    --solid-inset-color-danger:   var(--danger-alpha-strong);
}
[data-solid="contrast"] {
    --solid-border-color-brand:   var(--neutral-alpha-strong);
    --solid-inset-color-brand:    var(--static-transparent);
    --solid-inset-color-neutral:  var(--static-transparent);
    --solid-inset-color-danger:   var(--danger-alpha-strong);
}
[data-solid="inverse"] {
    --solid-border-color-brand:   var(--brand-alpha-strong);
    --solid-inset-color-brand:    var(--brand-alpha-strong);
    --solid-inset-color-neutral:  var(--static-transparent);
    --solid-inset-color-danger:   var(--danger-alpha-strong);
}
[data-theme="light"][data-solid="inverse"],
[data-theme="light"] [data-solid="inverse"] {
    --brand-solid-strong:         var(--function-brand-900);
    --brand-solid-medium:         var(--function-brand-800);
    --brand-solid-weak:           var(--function-brand-700);
    --brand-on-solid-strong:      var(--static-black);      
    --brand-on-solid-weak:        var(--function-brand-200);
}
</file>

<file path="src/once-ui/tokens/typography.scss">
:root {
    /* FONT WEIGHT */
    --font-weight-thin:            100;
    --font-weight-extraLight:      200;
    --font-weight-light:           300;
    --font-weight-normal:          400;
    --font-weight-medium:          500;
    --font-weight-semiBold:        600;
    --font-weight-bold:            700;
    --font-weight-extraBold:       800;
    --font-weight-body-default:    var(--font-weight-normal);
    --font-weight-body-strong:     var(--font-weight-bold);
    --font-weight-label-default:   var(--font-weight-normal);
    --font-weight-label-strong:    var(--font-weight-semiBold);
    --font-weight-code-default:    var(--font-weight-normal);
    --font-weight-code-strong:     var(--font-weight-bold);
    --font-weight-heading-default: var(--font-weight-normal);
    --font-weight-heading-strong:  var(--font-weight-semiBold);
    --font-weight-display-default: var(--font-weight-light);
    --font-weight-display-strong:  var(--font-weight-semiBold);
    /* FONT SIZE */
    --font-size-display-xl:        5rem;
    --font-size-display-l:         4rem;
    --font-size-display-m:         3rem;
    --font-size-display-s:         2.5rem;
    --font-size-display-xs:        2rem;
    --font-size-heading-xl:        1.5rem;
    --font-size-heading-l:         1.33rem;
    --font-size-heading-m:         1.25rem;
    --font-size-heading-s:         1.125rem;
    --font-size-heading-xs:        1rem;
    --font-size-body-xl:           1.25rem;
    --font-size-body-l:            1.125rem;
    --font-size-body-m:            1rem;
    --font-size-body-s:            0.875rem;
    --font-size-body-xs:           0.75rem;
    --font-size-label-l:           1rem;
    --font-size-label-m:           0.925rem;
    --font-size-label-s:           0.825rem;
    /* LINE HEIGHT */
    --line-height-display-xl:      5rem;
    --line-height-display-l:       4.25rem;
    --line-height-display-m:       3.25rem;
    --line-height-display-s:       3rem;
    --line-height-display-xs:      2.5rem;
    --line-height-heading-xl:      2rem;
    --line-height-heading-l:       1.75rem;
    --line-height-heading-m:       1.5rem;
    --line-height-heading-s:       1.5rem;
    --line-height-heading-xs:      1.25rem;
    --line-height-body-xl:         1.75rem;
    --line-height-body-l:          1.5rem;
    --line-height-body-m:          1.5rem;
    --line-height-body-s:          1.125rem;
    --line-height-body-xs:         1rem;
    --line-height-label-l:         1.25rem;
    --line-height-label-m:         1.25rem;
    --line-height-label-s:         1rem;
}
@media (--m) {
    :root {
        /* FONT SIZE */
        --font-size-display-xl:    3.5rem;
        --font-size-display-l:     3.25rem;
        --font-size-display-m:     2.75rem;
        --font-size-display-s:     2.25rem;
        --font-size-display-xs:    1.75rem;
        --font-size-heading-xl:    1.33rem;
        --font-size-heading-l:     1.25rem;
        --font-size-heading-m:     1.125rem;
        /* LINE HEIGHT */
        --line-height-display-xl:  3.75rem;
        --line-height-display-l:   3.5rem;
        --line-height-display-m:   3rem;
        --line-height-display-s:   2.5rem;
        --line-height-display-xs:  2rem;
        --line-height-heading-xl:  1.75rem;
        --line-height-heading-l:   1.5rem;
        --line-height-heading-m:   1.25rem;
    }
}
@media (--s) {
    :root {
        /* FONT SIZE */
        --font-size-display-xl:    2.75rem;
        --font-size-display-l:     2.5rem;
        --font-size-display-m:     2.25rem;
        --font-size-display-s:     2rem;
        /* LINE HEIGHT */
        --line-height-display-xl:  3rem;
        --line-height-display-l:   3rem;
        --line-height-display-m:   2.5rem;
        --line-height-display-s:   2.5rem;
    }
}
</file>

<file path="src/once-ui/utils/devLogger.ts">
"use client";
/**
 * Logger utility that only logs in development mode
 * Use this instead of console.log for debugging messages that
 * should not appear in production
 */
export const dev = {
  log: (...args: any[]) => {
    if (process.env.NODE_ENV === "development") {
      console.log(...args);
    }
  },
  warn: (...args: any[]) => {
    if (process.env.NODE_ENV === "development") {
      console.warn(...args);
    }
  },
  error: (...args: any[]) => {
    if (process.env.NODE_ENV === "development") {
      console.error(...args);
    }
  },
  info: (...args: any[]) => {
    if (process.env.NODE_ENV === "development") {
      console.info(...args);
    }
  },
  debug: (...args: any[]) => {
    if (process.env.NODE_ENV === "development") {
      console.debug(...args);
    }
  },
};
</file>

<file path="src/once-ui/icons.ts">
import { IconType } from "react-icons";
import {
  HiChevronUp,
  HiChevronDown,
  HiChevronRight,
  HiChevronLeft,
  HiOutlineArrowPath,
  HiOutlineSun,
  HiOutlineMoon,
  HiOutlineEye,
  HiOutlineEyeSlash,
  HiOutlineClipboard,
  HiOutlineMagnifyingGlass,
  HiOutlineLink,
  HiArrowUpRight,
  HiOutlineShieldCheck,
  HiOutlineSparkles,
  HiOutlineComputerDesktop,
  HiOutlineQuestionMarkCircle,
  HiOutlineInformationCircle,
  HiOutlineExclamationTriangle,
  HiOutlineExclamationCircle,
  HiOutlineCheckBadge,
  HiOutlineCheckCircle,
  HiOutlineXMark,
  HiOutlineUser,
  HiOutlineEyeDropper,
  HiOutlineMinus,
  HiOutlinePlus,
  HiOutlineCalendar,
  HiOutlineDocumentDuplicate,
} from "react-icons/hi2";
export const iconLibrary: Record<string, IconType> = {
  chevronUp: HiChevronUp,
  chevronDown: HiChevronDown,
  chevronRight: HiChevronRight,
  chevronLeft: HiChevronLeft,
  refresh: HiOutlineArrowPath,
  light: HiOutlineSun,
  dark: HiOutlineMoon,
  help: HiOutlineQuestionMarkCircle,
  info: HiOutlineInformationCircle,
  warning: HiOutlineExclamationTriangle,
  danger: HiOutlineExclamationCircle,
  checkbox: HiOutlineCheckBadge,
  check: HiOutlineCheckCircle,
  copy: HiOutlineDocumentDuplicate,
  eyeDropper: HiOutlineEyeDropper,
  clipboard: HiOutlineClipboard,
  person: HiOutlineUser,
  close: HiOutlineXMark,
  openLink: HiOutlineLink,
  arrowUpRight: HiArrowUpRight,
  minus: HiOutlineMinus,
  plus: HiOutlinePlus,
  calendar: HiOutlineCalendar,
  eye: HiOutlineEye,
  eyeOff: HiOutlineEyeSlash,
  search: HiOutlineMagnifyingGlass,
  security: HiOutlineShieldCheck,
  sparkle: HiOutlineSparkles,
  computer: HiOutlineComputerDesktop,
};
export type IconLibrary = typeof iconLibrary;
export type IconName = keyof IconLibrary;
</file>

<file path="src/once-ui/types.ts">
export type StaticSpacingToken =
  | "0"
  | "1"
  | "2"
  | "4"
  | "8"
  | "12"
  | "16"
  | "20"
  | "24"
  | "32"
  | "40"
  | "48"
  | "56"
  | "64"
  | "80"
  | "104"
  | "128"
  | "160";
export const schemes = [
  "blue",
  "aqua",
  "magenta",
  "pink",
  "yellow",
  "orange",
  "red",
  "moss",
  "green",
  "emerald",
  "cyan",
  "violet",
  "indigo",
];
export type Schemes =
  | "blue"
  | "indigo"
  | "violet"
  | "magenta"
  | "pink"
  | "red"
  | "orange"
  | "yellow"
  | "moss"
  | "green"
  | "emerald"
  | "aqua"
  | "cyan";
export type TShirtSizes = "xs" | "s" | "m" | "l" | "xl";
export type ResponsiveSpacingToken = TShirtSizes;
export type ShadowSize = TShirtSizes;
export type SpacingToken = StaticSpacingToken | ResponsiveSpacingToken;
export type opacity = 0 | 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;
export type ColorScheme =
  | "neutral"
  | "brand"
  | "accent"
  | "info"
  | "danger"
  | "warning"
  | "success";
export type ColorCategory = "on-solid" | "on-background";
export type ColorWeight = "weak" | "medium" | "strong";
export type RadiusSize = TShirtSizes | "full";
export type RadiusNest = "4" | "8";
export type TextType = "body" | "heading" | "display" | "label" | "code";
export type TextWeight = "default" | "strong";
export type TextSize = TShirtSizes;
export type TextVariant = `${TextType}-${TextWeight}-${TextSize}`;
export type gridColumns =
  | "1"
  | "2"
  | "3"
  | "4"
  | "5"
  | "6"
  | "7"
  | "8"
  | "9"
  | "10"
  | "11"
  | "12"
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9
  | 10
  | 11
  | 12;
export type flex =
  | "0"
  | "1"
  | "2"
  | "3"
  | "4"
  | "5"
  | "6"
  | "7"
  | "8"
  | "9"
  | "10"
  | "11"
  | "12"
  | 0
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9
  | 10
  | 11
  | 12;
</file>

<file path="src/services/workers/ragWorker.d.ts">
export {};
</file>

<file path="src/services/workers/ragWorker.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const worker_threads_1 = require("worker_threads");
const logger_1 = require("../../utils/logger");
if (!worker_threads_1.parentPort) {
    throw new Error('This module must be run as a worker thread');
}
const { workerId, config } = worker_threads_1.workerData;
// Handle messages from the main thread
worker_threads_1.parentPort.on('message', async (message) => {
    try {
        if (message.type === 'health_check') {
            worker_threads_1.parentPort?.postMessage({ type: 'health_check_response' });
            return;
        }
        if (message.type === 'task') {
            const { task } = message;
            const result = await processTask(task);
            worker_threads_1.parentPort?.postMessage({
                type: 'task_complete',
                taskId: task.id,
                result
            });
        }
    }
    catch (error) {
        logger_1.logger.error(`Worker ${workerId} error:`, error);
        worker_threads_1.parentPort?.postMessage({
            type: 'task_error',
            taskId: message.task?.id,
            error: error instanceof Error ? error.message : 'Unknown error'
        });
    }
});
async function processTask(task) {
    // This is a placeholder - the actual task processing will be injected
    // by the service that uses this worker
    return task.data;
}
// Handle worker termination
process.on('SIGTERM', () => {
    logger_1.logger.info(`Worker ${workerId} shutting down`);
    process.exit(0);
});
//# sourceMappingURL=ragWorker.js.map
</file>

<file path="src/services/workers/ragWorker.js.map">
{"version":3,"file":"ragWorker.js","sourceRoot":"","sources":["ragWorker.ts"],"names":[],"mappings":";;AAAA,mDAAwD;AACxD,+CAA4C;AAmB5C,IAAI,CAAC,2BAAU,EAAE,CAAC;IAChB,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;AAChE,CAAC;AAED,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,2BAAwB,CAAC;AAEtD,uCAAuC;AACvC,2BAAU,CAAC,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,OAAY,EAAE,EAAE;IAC9C,IAAI,CAAC;QACH,IAAI,OAAO,CAAC,IAAI,KAAK,cAAc,EAAE,CAAC;YACpC,2BAAU,EAAE,WAAW,CAAC,EAAE,IAAI,EAAE,uBAAuB,EAAE,CAAC,CAAC;YAC3D,OAAO;QACT,CAAC;QAED,IAAI,OAAO,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;YAC5B,MAAM,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;YACzB,MAAM,MAAM,GAAG,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC;YAEvC,2BAAU,EAAE,WAAW,CAAC;gBACtB,IAAI,EAAE,eAAe;gBACrB,MAAM,EAAE,IAAI,CAAC,EAAE;gBACf,MAAM;aACP,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,eAAM,CAAC,KAAK,CAAC,UAAU,QAAQ,SAAS,EAAE,KAAK,CAAC,CAAC;QACjD,2BAAU,EAAE,WAAW,CAAC;YACtB,IAAI,EAAE,YAAY;YAClB,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,EAAE;YACxB,KAAK,EAAE,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,eAAe;SAChE,CAAC,CAAC;IACL,CAAC;AACH,CAAC,CAAC,CAAC;AAEH,KAAK,UAAU,WAAW,CAAC,IAAU;IACnC,sEAAsE;IACtE,uCAAuC;IACvC,OAAO,IAAI,CAAC,IAAI,CAAC;AACnB,CAAC;AAED,4BAA4B;AAC5B,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,GAAG,EAAE;IACzB,eAAM,CAAC,IAAI,CAAC,UAAU,QAAQ,gBAAgB,CAAC,CAAC;IAChD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC"}
</file>

<file path="src/services/workers/ragWorker.ts">
import { parentPort, workerData } from 'worker_threads';
import { logger } from '../../utils/logger';
interface WorkerData {
  workerId: number;
  config: {
    maxWorkers: number;
    taskQueueSize: number;
    workerTimeout: number;
    retryAttempts: number;
  };
}
interface Task {
  id: string;
  type: string;
  data: any;
  priority: number;
}
if (!parentPort) {
  throw new Error('This module must be run as a worker thread');
}
const { workerId, config } = workerData as WorkerData;
// Handle messages from the main thread
parentPort.on('message', async (message: any) => {
  try {
    if (message.type === 'health_check') {
      parentPort?.postMessage({ type: 'health_check_response' });
      return;
    }
    if (message.type === 'task') {
      const { task } = message;
      const result = await processTask(task);
      parentPort?.postMessage({
        type: 'task_complete',
        taskId: task.id,
        result
      });
    }
  } catch (error) {
    logger.error(`Worker ${workerId} error:`, error);
    parentPort?.postMessage({
      type: 'task_error',
      taskId: message.task?.id,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});
async function processTask(task: Task): Promise<any> {
  // This is a placeholder - the actual task processing will be injected
  // by the service that uses this worker
  return task.data;
}
// Handle worker termination
process.on('SIGTERM', () => {
  logger.info(`Worker ${workerId} shutting down`);
  process.exit(0);
});
</file>

<file path="src/services/ChatService.d.ts">
import type { ChatMessage, Conversation } from '../types/ipc';
export declare class ChatService {
    private static instance;
    private ollamaService;
    private vectorStoreService;
    private conversations;
    private constructor();
    static getInstance(): ChatService;
    initialize(): Promise<void>;
    sendMessage(message: ChatMessage): Promise<ChatMessage>;
    sendMessageStream(message: ChatMessage): Promise<void>;
    createConversation(title: string): Promise<string>;
    getConversation(id: string): Promise<ChatMessage[]>;
    listConversations(): Promise<Conversation[]>;
    deleteConversation(id: string): Promise<void>;
    updateConversationTitle(id: string, title: string): Promise<void>;
}
</file>

<file path="src/services/ChatService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatService = void 0;
const OllamaService_1 = require("./OllamaService");
const VectorStoreService_1 = require("./VectorStoreService");
const logger_1 = require("../utils/logger");
const ipc_1 = require("../types/ipc");
const uuid_1 = require("uuid");
class ChatService {
    constructor(ollamaService, vectorStoreService) {
        this.conversations = new Map();
        this.ollamaService = ollamaService;
        this.vectorStoreService = vectorStoreService;
    }
    static getInstance() {
        if (!ChatService.instance) {
            const ollamaService = OllamaService_1.OllamaService.getInstance();
            const vectorStoreService = VectorStoreService_1.VectorStoreService.getInstance();
            ChatService.instance = new ChatService(ollamaService, vectorStoreService);
        }
        return ChatService.instance;
    }
    async initialize() {
        logger_1.logger.info('Initializing ChatService');
    }
    async sendMessage(message) {
        try {
            // Search for relevant documents
            const relevantDocs = await this.vectorStoreService.searchSimilar(message.content);
            // Create context from relevant documents
            const context = relevantDocs
                .map(doc => `[Source: ${doc.metadata.source}]\n${doc.content}`)
                .join('\n\n');
            // Create prompt with context
            const prompt = context
                ? `Context:\n${context}\n\nQuestion: ${message.content}\n\nAnswer:`
                : message.content;
            // Generate response using Ollama
            const { content: responseContent } = await this.ollamaService.generateResponse(prompt);
            // Create response message
            const responseMessage = {
                id: (0, uuid_1.v4)(),
                role: ipc_1.Role.Assistant,
                content: responseContent,
                timestamp: Date.now(),
            };
            // Store the conversation in vector store
            await this.vectorStoreService.addDocument({
                content: message.content,
                metadata: {
                    source: 'user_message',
                    timestamp: Date.now(),
                    type: 'chat',
                },
            });
            await this.vectorStoreService.addDocument({
                content: responseContent,
                metadata: {
                    source: 'assistant_response',
                    timestamp: Date.now(),
                    type: 'chat',
                },
            });
            return responseMessage;
        }
        catch (error) {
            logger_1.logger.error('Error sending message:', error);
            throw error;
        }
    }
    async sendMessageStream(message) {
        try {
            // Search for relevant documents
            const relevantDocs = await this.vectorStoreService.searchSimilar(message.content);
            // Create context from relevant documents
            const context = relevantDocs
                .map(doc => `[Source: ${doc.metadata.source}]\n${doc.content}`)
                .join('\n\n');
            // Create prompt with context
            const prompt = context
                ? `Context:\n${context}\n\nQuestion: ${message.content}\n\nAnswer:`
                : message.content;
            // Generate response using Ollama
            await this.ollamaService.generateResponse(prompt);
        }
        catch (error) {
            logger_1.logger.error('Error sending message stream:', error);
            throw error;
        }
    }
    async createConversation(title) {
        const id = (0, uuid_1.v4)();
        const conversation = {
            id,
            title,
            messages: [],
            createdAt: Date.now(),
            updatedAt: Date.now(),
        };
        this.conversations.set(id, conversation);
        return id;
    }
    async getConversation(id) {
        const conversation = this.conversations.get(id);
        if (!conversation) {
            throw new Error(`Conversation ${id} not found`);
        }
        return conversation.messages;
    }
    async listConversations() {
        return Array.from(this.conversations.values());
    }
    async deleteConversation(id) {
        if (!this.conversations.has(id)) {
            throw new Error(`Conversation ${id} not found`);
        }
        this.conversations.delete(id);
    }
    async updateConversationTitle(id, title) {
        const conversation = this.conversations.get(id);
        if (!conversation) {
            throw new Error(`Conversation ${id} not found`);
        }
        conversation.title = title;
        conversation.updatedAt = Date.now();
        this.conversations.set(id, conversation);
    }
}
exports.ChatService = ChatService;
//# sourceMappingURL=ChatService.js.map
</file>

<file path="src/services/ChatService.js.map">
{"version":3,"file":"ChatService.js","sourceRoot":"","sources":["ChatService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/ChatService.ts">
import { OllamaService } from './OllamaService';
import { VectorStoreService } from './VectorStoreService';
import { logger } from '../utils/logger';
import type { ChatMessage, Conversation } from '@shared/types/ipc';
import { Role } from '@shared/types/ipc';
import { v4 as uuidv4 } from 'uuid';
export class ChatService {
  private static instance: ChatService;
  private ollamaService: OllamaService;
  private vectorStoreService: VectorStoreService;
  private conversations: Map<string, Conversation> = new Map();
  private constructor(ollamaService: OllamaService, vectorStoreService: VectorStoreService) {
    this.ollamaService = ollamaService;
    this.vectorStoreService = vectorStoreService;
  }
  public static getInstance(): ChatService {
    if (!ChatService.instance) {
      const ollamaService = OllamaService.getInstance();
      const vectorStoreService = VectorStoreService.getInstance();
      ChatService.instance = new ChatService(ollamaService, vectorStoreService);
    }
    return ChatService.instance;
  }
  async initialize(): Promise<void> {
    logger.info('Initializing ChatService');
  }
  async sendMessage(message: ChatMessage): Promise<ChatMessage> {
    try {
      // Search for relevant documents
      const relevantDocs = await this.vectorStoreService.searchSimilar(message.content);
      // Create context from relevant documents
      const context = relevantDocs
        .map(doc => `[Source: ${doc.metadata.source}]\n${doc.content}`)
        .join('\n\n');
      // Create prompt with context
      const prompt = context
        ? `Context:\n${context}\n\nQuestion: ${message.content}\n\nAnswer:`
        : message.content;
      // Generate response using Ollama
      const { content: responseContent } = await this.ollamaService.generateResponse(prompt);
      // Create response message
      const responseMessage: ChatMessage = {
        id: uuidv4(),
        role: Role.Assistant,
        content: responseContent,
        timestamp: Date.now(),
      };
      // Store the conversation in vector store
      await this.vectorStoreService.addDocument({
        content: message.content,
        metadata: {
          source: 'user_message',
          timestamp: Date.now(),
          type: 'chat',
        },
      });
      await this.vectorStoreService.addDocument({
        content: responseContent,
        metadata: {
          source: 'assistant_response',
          timestamp: Date.now(),
          type: 'chat',
        },
      });
      return responseMessage;
    } catch (error) {
      logger.error('Error sending message:', error);
      throw error;
    }
  }
  async sendMessageStream(message: ChatMessage): Promise<void> {
    try {
      // Search for relevant documents
      const relevantDocs = await this.vectorStoreService.searchSimilar(message.content);
      // Create context from relevant documents
      const context = relevantDocs
        .map(doc => `[Source: ${doc.metadata.source}]\n${doc.content}`)
        .join('\n\n');
      // Create prompt with context
      const prompt = context
        ? `Context:\n${context}\n\nQuestion: ${message.content}\n\nAnswer:`
        : message.content;
      // Generate response using Ollama
      await this.ollamaService.generateResponse(prompt);
    } catch (error) {
      logger.error('Error sending message stream:', error);
      throw error;
    }
  }
  async createConversation(title: string): Promise<string> {
    const id = uuidv4();
    const conversation: Conversation = {
      id,
      title,
      messages: [],
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    this.conversations.set(id, conversation);
    return id;
  }
  async getConversation(id: string): Promise<ChatMessage[]> {
    const conversation = this.conversations.get(id);
    if (!conversation) {
      throw new Error(`Conversation ${id} not found`);
    }
    return conversation.messages;
  }
  async listConversations(): Promise<Conversation[]> {
    return Array.from(this.conversations.values());
  }
  async deleteConversation(id: string): Promise<void> {
    if (!this.conversations.has(id)) {
      throw new Error(`Conversation ${id} not found`);
    }
    this.conversations.delete(id);
  }
  async updateConversationTitle(id: string, title: string): Promise<void> {
    const conversation = this.conversations.get(id);
    if (!conversation) {
      throw new Error(`Conversation ${id} not found`);
    }
    conversation.title = title;
    conversation.updatedAt = Date.now();
    this.conversations.set(id, conversation);
  }
}
</file>

<file path="src/services/DatabaseService.d.ts">
import { EventEmitter } from 'events';
import { z } from 'zod';
declare const MessageSchema: any;
declare const ConversationSchema: any;
declare const MemorySchema: any;
export type Message = z.infer<typeof MessageSchema>;
export type Conversation = z.infer<typeof ConversationSchema>;
export type Memory = z.infer<typeof MemorySchema>;
export declare class DatabaseService extends EventEmitter {
    private static instance;
    private chatDb;
    private memoryDb;
    private migrationManager;
    private isInitialized;
    private readonly BACKUP_DIR;
    private readonly MAX_BACKUPS;
    private constructor();
    static getInstance(): DatabaseService;
    initialize(): Promise<void>;
    private createTables;
    saveMessage(message: Message): Promise<void>;
    getMessages(conversationId: string): Promise<Message[]>;
    createConversation(conversation: Conversation): Promise<void>;
    getConversations(): Promise<Conversation[]>;
    saveMemory(memory: Memory): Promise<void>;
    getMemories(limit?: number): Promise<Memory[]>;
    createBackup(): Promise<string>;
    restoreFromBackup(backupPath: string): Promise<void>;
    private cleanupOldBackups;
    cleanup(): Promise<void>;
}
export {};
</file>

<file path="src/services/DatabaseService.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DatabaseService = void 0;
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const electron_1 = require("electron");
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const events_1 = require("events");
const logger_1 = require("../utils/logger");
const zod_1 = require("zod");
const migrations_1 = require("../database/migrations");
// Database schemas
const MessageSchema = zod_1.z.object({
    id: zod_1.z.string(),
    content: zod_1.z.string(),
    role: zod_1.z.enum(['user', 'assistant', 'system']),
    timestamp: zod_1.z.number(),
    status: zod_1.z.enum(['sending', 'sent', 'error']),
    error: zod_1.z.string().optional(),
    metadata: zod_1.z.record(zod_1.z.unknown()).optional()
});
const ConversationSchema = zod_1.z.object({
    id: zod_1.z.string(),
    title: zod_1.z.string(),
    created_at: zod_1.z.number(),
    updated_at: zod_1.z.number(),
    metadata: zod_1.z.record(zod_1.z.unknown()).optional()
});
const MemorySchema = zod_1.z.object({
    id: zod_1.z.string(),
    content: zod_1.z.string(),
    metadata: zod_1.z.record(zod_1.z.unknown()),
    embedding: zod_1.z.instanceof(Buffer).optional(),
    created_at: zod_1.z.number(),
    updated_at: zod_1.z.number(),
    importance: zod_1.z.number(),
    expires_at: zod_1.z.number().nullable(),
    compressed: zod_1.z.boolean()
});
class DatabaseService extends events_1.EventEmitter {
    constructor() {
        super();
        this.isInitialized = false;
        this.BACKUP_DIR = 'backups';
        this.MAX_BACKUPS = 5;
        const userDataPath = electron_1.app.getPath('userData');
        const chatDbPath = path.join(userDataPath, 'chat.db');
        const memoryDbPath = path.join(userDataPath, 'memory.db');
        this.chatDb = new better_sqlite3_1.default(chatDbPath);
        this.memoryDb = new better_sqlite3_1.default(memoryDbPath);
        this.migrationManager = migrations_1.MigrationManager.getInstance();
    }
    static getInstance() {
        if (!DatabaseService.instance) {
            DatabaseService.instance = new DatabaseService();
        }
        return DatabaseService.instance;
    }
    async initialize() {
        if (this.isInitialized)
            return;
        try {
            // Initialize migration manager first
            await this.migrationManager.initialize();
            // Enable foreign keys
            this.chatDb.pragma('foreign_keys = ON');
            this.memoryDb.pragma('foreign_keys = ON');
            // Create backup directory
            const backupPath = path.join(electron_1.app.getPath('userData'), this.BACKUP_DIR);
            await fs.ensureDir(backupPath);
            this.isInitialized = true;
            this.emit('initialized');
            logger_1.logger.info('Database service initialized successfully');
        }
        catch (error) {
            logger_1.logger.error('Failed to initialize database service:', error);
            throw error;
        }
    }
    async createTables() {
        // Chat tables
        this.chatDb.exec(`
      CREATE TABLE IF NOT EXISTS conversations (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        metadata TEXT
      );
      CREATE TABLE IF NOT EXISTS messages (
        id TEXT PRIMARY KEY,
        conversation_id TEXT NOT NULL,
        content TEXT NOT NULL,
        role TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        status TEXT NOT NULL,
        error TEXT,
        metadata TEXT,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
      );
      CREATE INDEX IF NOT EXISTS idx_messages_conversation 
        ON messages(conversation_id, timestamp);
    `);
        // Memory tables
        this.memoryDb.exec(`
      CREATE TABLE IF NOT EXISTS memories (
        id TEXT PRIMARY KEY,
        content TEXT NOT NULL,
        metadata TEXT NOT NULL,
        embedding BLOB,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        importance REAL DEFAULT 1.0,
        expires_at INTEGER,
        compressed BOOLEAN DEFAULT FALSE
      );
      CREATE INDEX IF NOT EXISTS idx_memories_metadata 
        ON memories(metadata);
      CREATE INDEX IF NOT EXISTS idx_memories_timestamp 
        ON memories(created_at);
      CREATE INDEX IF NOT EXISTS idx_memories_importance 
        ON memories(importance);
      CREATE INDEX IF NOT EXISTS idx_memories_expires 
        ON memories(expires_at);
    `);
    }
    // Chat operations
    async saveMessage(message) {
        const validated = MessageSchema.parse(message);
        const stmt = this.chatDb.prepare(`
      INSERT OR REPLACE INTO messages (
        id, conversation_id, content, role, timestamp, status, error, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
        stmt.run(validated.id, validated.metadata?.conversationId, validated.content, validated.role, validated.timestamp, validated.status, validated.error || null, validated.metadata ? JSON.stringify(validated.metadata) : null);
    }
    async getMessages(conversationId) {
        const stmt = this.chatDb.prepare(`
      SELECT * FROM messages 
      WHERE conversation_id = ? 
      ORDER BY timestamp ASC
    `);
        const rows = stmt.all(conversationId);
        return rows.map(row => ({
            ...row,
            metadata: row.metadata ? JSON.parse(row.metadata) : undefined
        }));
    }
    async createConversation(conversation) {
        const validated = ConversationSchema.parse(conversation);
        const stmt = this.chatDb.prepare(`
      INSERT INTO conversations (id, title, created_at, updated_at, metadata)
      VALUES (?, ?, ?, ?, ?)
    `);
        stmt.run(validated.id, validated.title, validated.created_at, validated.updated_at, validated.metadata ? JSON.stringify(validated.metadata) : null);
    }
    async getConversations() {
        const stmt = this.chatDb.prepare(`
      SELECT * FROM conversations 
      ORDER BY updated_at DESC
    `);
        const rows = stmt.all();
        return rows.map(row => ({
            ...row,
            metadata: row.metadata ? JSON.parse(row.metadata) : undefined
        }));
    }
    // Memory operations
    async saveMemory(memory) {
        const validated = MemorySchema.parse(memory);
        const stmt = this.memoryDb.prepare(`
      INSERT OR REPLACE INTO memories (
        id, content, metadata, embedding, created_at, updated_at, 
        importance, expires_at, compressed
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
        stmt.run(validated.id, validated.content, JSON.stringify(validated.metadata), validated.embedding || null, validated.created_at, validated.updated_at, validated.importance, validated.expires_at, validated.compressed);
    }
    async getMemories(limit = 100) {
        const stmt = this.memoryDb.prepare(`
      SELECT * FROM memories 
      WHERE expires_at IS NULL OR expires_at > ? 
      ORDER BY importance DESC, created_at DESC 
      LIMIT ?
    `);
        const rows = stmt.all(Date.now(), limit);
        return rows.map(row => ({
            ...row,
            metadata: JSON.parse(row.metadata),
            embedding: row.embedding ? Buffer.from(row.embedding) : undefined
        }));
    }
    // Backup and restore
    async createBackup() {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupPath = path.join(electron_1.app.getPath('userData'), this.BACKUP_DIR, `backup-${timestamp}.db`);
        // Backup chat database
        await fs.copy(path.join(electron_1.app.getPath('userData'), 'chat.db'), `${backupPath}.chat`);
        // Backup memory database
        await fs.copy(path.join(electron_1.app.getPath('userData'), 'memory.db'), `${backupPath}.memory`);
        // Cleanup old backups
        await this.cleanupOldBackups();
        return backupPath;
    }
    async restoreFromBackup(backupPath) {
        // Close current connections
        this.chatDb.close();
        this.memoryDb.close();
        // Restore chat database
        await fs.copy(`${backupPath}.chat`, path.join(electron_1.app.getPath('userData'), 'chat.db'));
        // Restore memory database
        await fs.copy(`${backupPath}.memory`, path.join(electron_1.app.getPath('userData'), 'memory.db'));
        // Reinitialize connections
        await this.initialize();
    }
    async cleanupOldBackups() {
        const backupPath = path.join(electron_1.app.getPath('userData'), this.BACKUP_DIR);
        const backups = await fs.readdir(backupPath);
        if (backups.length > this.MAX_BACKUPS) {
            const sortedBackups = backups
                .filter(b => b.startsWith('backup-'))
                .sort()
                .reverse();
            for (const backup of sortedBackups.slice(this.MAX_BACKUPS)) {
                await fs.remove(path.join(backupPath, backup));
            }
        }
    }
    // Cleanup
    async cleanup() {
        await this.migrationManager.cleanup();
        this.chatDb.close();
        this.memoryDb.close();
        this.isInitialized = false;
    }
}
exports.DatabaseService = DatabaseService;
//# sourceMappingURL=DatabaseService.js.map
</file>

<file path="src/services/DatabaseService.js.map">
{"version":3,"file":"DatabaseService.js","sourceRoot":"","sources":["DatabaseService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/DatabaseService.ts">
import Database from 'better-sqlite3';
import { app } from 'electron';
import * as path from 'path';
import * as fs from 'fs-extra';
import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import { z } from 'zod';
import { MigrationManager } from '../database/migrations';
// Database schemas
const MessageSchema = z.object({
  id: z.string(),
  content: z.string(),
  role: z.enum(['user', 'assistant', 'system']),
  timestamp: z.number(),
  status: z.enum(['sending', 'sent', 'error']),
  error: z.string().optional(),
  metadata: z.record(z.unknown()).optional()
});
const ConversationSchema = z.object({
  id: z.string(),
  title: z.string(),
  created_at: z.number(),
  updated_at: z.number(),
  metadata: z.record(z.unknown()).optional()
});
const MemorySchema = z.object({
  id: z.string(),
  content: z.string(),
  metadata: z.record(z.unknown()),
  embedding: z.instanceof(Buffer).optional(),
  created_at: z.number(),
  updated_at: z.number(),
  importance: z.number(),
  expires_at: z.number().nullable(),
  compressed: z.boolean()
});
export type Message = z.infer<typeof MessageSchema>;
export type Conversation = z.infer<typeof ConversationSchema>;
export type Memory = z.infer<typeof MemorySchema>;
export class DatabaseService extends EventEmitter {
  private static instance: DatabaseService;
  private chatDb: Database;
  private memoryDb: Database;
  private migrationManager: MigrationManager;
  private isInitialized = false;
  private readonly BACKUP_DIR = 'backups';
  private readonly MAX_BACKUPS = 5;
  private constructor() {
    super();
    const userDataPath = app.getPath('userData');
    const chatDbPath = path.join(userDataPath, 'chat.db');
    const memoryDbPath = path.join(userDataPath, 'memory.db');
    this.chatDb = new Database(chatDbPath);
    this.memoryDb = new Database(memoryDbPath);
    this.migrationManager = MigrationManager.getInstance();
  }
  public static getInstance(): DatabaseService {
    if (!DatabaseService.instance) {
      DatabaseService.instance = new DatabaseService();
    }
    return DatabaseService.instance;
  }
  public async initialize(): Promise<void> {
    if (this.isInitialized) return;
    try {
      // Initialize migration manager first
      await this.migrationManager.initialize();
      // Enable foreign keys
      this.chatDb.pragma('foreign_keys = ON');
      this.memoryDb.pragma('foreign_keys = ON');
      // Create backup directory
      const backupPath = path.join(app.getPath('userData'), this.BACKUP_DIR);
      await fs.ensureDir(backupPath);
      this.isInitialized = true;
      this.emit('initialized');
      logger.info('Database service initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize database service:', error);
      throw error;
    }
  }
  private async createTables(): Promise<void> {
    // Chat tables
    this.chatDb.exec(`
      CREATE TABLE IF NOT EXISTS conversations (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        metadata TEXT
      );
      CREATE TABLE IF NOT EXISTS messages (
        id TEXT PRIMARY KEY,
        conversation_id TEXT NOT NULL,
        content TEXT NOT NULL,
        role TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        status TEXT NOT NULL,
        error TEXT,
        metadata TEXT,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
      );
      CREATE INDEX IF NOT EXISTS idx_messages_conversation 
        ON messages(conversation_id, timestamp);
    `);
    // Memory tables
    this.memoryDb.exec(`
      CREATE TABLE IF NOT EXISTS memories (
        id TEXT PRIMARY KEY,
        content TEXT NOT NULL,
        metadata TEXT NOT NULL,
        embedding BLOB,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        importance REAL DEFAULT 1.0,
        expires_at INTEGER,
        compressed BOOLEAN DEFAULT FALSE
      );
      CREATE INDEX IF NOT EXISTS idx_memories_metadata 
        ON memories(metadata);
      CREATE INDEX IF NOT EXISTS idx_memories_timestamp 
        ON memories(created_at);
      CREATE INDEX IF NOT EXISTS idx_memories_importance 
        ON memories(importance);
      CREATE INDEX IF NOT EXISTS idx_memories_expires 
        ON memories(expires_at);
    `);
  }
  // Chat operations
  public async saveMessage(message: Message): Promise<void> {
    const validated = MessageSchema.parse(message);
    const stmt = this.chatDb.prepare(`
      INSERT OR REPLACE INTO messages (
        id, conversation_id, content, role, timestamp, status, error, metadata
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      validated.id,
      validated.metadata?.conversationId,
      validated.content,
      validated.role,
      validated.timestamp,
      validated.status,
      validated.error || null,
      validated.metadata ? JSON.stringify(validated.metadata) : null
    );
  }
  public async getMessages(conversationId: string): Promise<Message[]> {
    const stmt = this.chatDb.prepare(`
      SELECT * FROM messages 
      WHERE conversation_id = ? 
      ORDER BY timestamp ASC
    `);
    const rows = stmt.all(conversationId);
    return rows.map(row => ({
      ...row,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    }));
  }
  public async createConversation(conversation: Conversation): Promise<void> {
    const validated = ConversationSchema.parse(conversation);
    const stmt = this.chatDb.prepare(`
      INSERT INTO conversations (id, title, created_at, updated_at, metadata)
      VALUES (?, ?, ?, ?, ?)
    `);
    stmt.run(
      validated.id,
      validated.title,
      validated.created_at,
      validated.updated_at,
      validated.metadata ? JSON.stringify(validated.metadata) : null
    );
  }
  public async getConversations(): Promise<Conversation[]> {
    const stmt = this.chatDb.prepare(`
      SELECT * FROM conversations 
      ORDER BY updated_at DESC
    `);
    const rows = stmt.all();
    return rows.map(row => ({
      ...row,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    }));
  }
  // Memory operations
  public async saveMemory(memory: Memory): Promise<void> {
    const validated = MemorySchema.parse(memory);
    const stmt = this.memoryDb.prepare(`
      INSERT OR REPLACE INTO memories (
        id, content, metadata, embedding, created_at, updated_at, 
        importance, expires_at, compressed
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      validated.id,
      validated.content,
      JSON.stringify(validated.metadata),
      validated.embedding || null,
      validated.created_at,
      validated.updated_at,
      validated.importance,
      validated.expires_at,
      validated.compressed
    );
  }
  public async getMemories(limit: number = 100): Promise<Memory[]> {
    const stmt = this.memoryDb.prepare(`
      SELECT * FROM memories 
      WHERE expires_at IS NULL OR expires_at > ? 
      ORDER BY importance DESC, created_at DESC 
      LIMIT ?
    `);
    const rows = stmt.all(Date.now(), limit);
    return rows.map(row => ({
      ...row,
      metadata: JSON.parse(row.metadata),
      embedding: row.embedding ? Buffer.from(row.embedding) : undefined
    }));
  }
  // Backup and restore
  public async createBackup(): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(
      app.getPath('userData'),
      this.BACKUP_DIR,
      `backup-${timestamp}.db`
    );
    // Backup chat database
    await fs.copy(
      path.join(app.getPath('userData'), 'chat.db'),
      `${backupPath}.chat`
    );
    // Backup memory database
    await fs.copy(
      path.join(app.getPath('userData'), 'memory.db'),
      `${backupPath}.memory`
    );
    // Cleanup old backups
    await this.cleanupOldBackups();
    return backupPath;
  }
  public async restoreFromBackup(backupPath: string): Promise<void> {
    // Close current connections
    this.chatDb.close();
    this.memoryDb.close();
    // Restore chat database
    await fs.copy(
      `${backupPath}.chat`,
      path.join(app.getPath('userData'), 'chat.db')
    );
    // Restore memory database
    await fs.copy(
      `${backupPath}.memory`,
      path.join(app.getPath('userData'), 'memory.db')
    );
    // Reinitialize connections
    await this.initialize();
  }
  private async cleanupOldBackups(): Promise<void> {
    const backupPath = path.join(app.getPath('userData'), this.BACKUP_DIR);
    const backups = await fs.readdir(backupPath);
    if (backups.length > this.MAX_BACKUPS) {
      const sortedBackups = backups
        .filter(b => b.startsWith('backup-'))
        .sort()
        .reverse();
      for (const backup of sortedBackups.slice(this.MAX_BACKUPS)) {
        await fs.remove(path.join(backupPath, backup));
      }
    }
  }
  // Cleanup
  public async cleanup(): Promise<void> {
    await this.migrationManager.cleanup();
    this.chatDb.close();
    this.memoryDb.close();
    this.isInitialized = false;
  }
}
</file>

<file path="src/services/EmbeddingService.d.ts">
import { EventEmitter } from 'events';
export type ServiceStatus = 'operational' | 'degraded' | 'unavailable';
export interface EmbeddingConfig {
    model: string;
    modelParameters: {
        temperature: number;
        topK: number;
        topP: number;
        contextWindow: number;
        repeatPenalty: number;
        presencePenalty: number;
        frequencyPenalty: number;
        mirostatMode: number;
        mirostatTau: number;
        mirostatEta: number;
    };
    batchSize: number;
    normalize: boolean;
    truncateStrategy: 'NONE' | 'FIRST' | 'LAST' | 'MIDDLE';
    maxTokens: number;
    chunkSize: number;
    chunkOverlap: number;
    chunkStrategy: 'SENTENCE' | 'PARAGRAPH' | 'FIXED';
    enableCache: boolean;
    cacheSize: number;
    cacheTTL: number;
    parallelProcessing: boolean;
    maxConcurrentRequests: number;
    timeout: number;
    minSimilarityThreshold: number;
    maxResults: number;
    rerankResults: boolean;
}
export declare class EmbeddingService extends EventEmitter {
    private static instance;
    private ollamaService;
    private isInitialized;
    private readonly MODEL_NAME;
    private readonly BATCH_SIZE;
    private readonly MAX_RETRIES;
    private readonly RETRY_DELAY;
    private config;
    private status;
    private fallbackStore;
    private readonly defaultConfig;
    private constructor();
    static getInstance(): EmbeddingService;
    initialize(): Promise<void>;
    getStatus(): ServiceStatus;
    updateConfig(newConfig: Partial<EmbeddingConfig>): Promise<void>;
    getConfig(): EmbeddingConfig;
    private truncateText;
    private chunkText;
    private generateFallbackEmbedding;
    generateEmbedding(text: string): Promise<number[]>;
    generateEmbeddings(texts: string[]): Promise<number[][]>;
    private chunkArray;
    storeEmbedding(text: string, metadata?: any): Promise<string>;
    searchSimilar(query: string, k?: number): Promise<Array<{
        id: string;
        similarity: number;
        metadata: any;
    }>>;
    rerankResults(query: string, results: {
        text: string;
        score: number;
    }[]): Promise<{
        text: string;
        score: number;
    }[]>;
    private cosineSimilarity;
    cleanup(): Promise<void>;
}
</file>

<file path="src/services/EmbeddingService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddingService = void 0;
const logger_1 = require("../utils/logger");
const OllamaService_1 = require("./OllamaService");
const InMemoryVectorStore_1 = require("./InMemoryVectorStore");
const uuid_1 = require("uuid");
const events_1 = require("events");
class EmbeddingService extends events_1.EventEmitter {
    constructor(ollamaService) {
        super();
        this.isInitialized = false;
        this.MODEL_NAME = 'nomic-embed-text';
        this.BATCH_SIZE = 10;
        this.MAX_RETRIES = 3;
        this.RETRY_DELAY = 1000; // 1 second
        this.status = 'operational';
        this.defaultConfig = {
            model: 'nomic-embed-text',
            modelParameters: {
                temperature: 0.7,
                topK: 40,
                topP: 0.9,
                contextWindow: 2048,
                repeatPenalty: 1.1,
                presencePenalty: 0.0,
                frequencyPenalty: 0.0,
                mirostatMode: 0,
                mirostatTau: 5.0,
                mirostatEta: 0.1,
            },
            batchSize: 32,
            normalize: true,
            truncateStrategy: 'NONE',
            maxTokens: 2048,
            chunkSize: 1000,
            chunkOverlap: 200,
            chunkStrategy: 'SENTENCE',
            enableCache: true,
            cacheSize: 1000,
            cacheTTL: 3600,
            parallelProcessing: true,
            maxConcurrentRequests: 4,
            timeout: 30000,
            minSimilarityThreshold: 0.7,
            maxResults: 10,
            rerankResults: false,
        };
        this.ollamaService = ollamaService;
        this.config = { ...this.defaultConfig };
        this.fallbackStore = new InMemoryVectorStore_1.InMemoryVectorStore(1536);
    }
    static getInstance() {
        if (!EmbeddingService.instance) {
            const ollamaService = OllamaService_1.OllamaService.getInstance();
            EmbeddingService.instance = new EmbeddingService(ollamaService);
        }
        return EmbeddingService.instance;
    }
    async initialize() {
        if (this.isInitialized)
            return;
        try {
            logger_1.logger.info('Initializing EmbeddingService');
            // Check if Ollama is available
            const isAvailable = await this.ollamaService.isAvailable();
            if (!isAvailable) {
                throw new Error('Ollama service is not available');
            }
            // Check if model is available
            const models = await this.ollamaService.listModels();
            if (!models.includes(this.MODEL_NAME)) {
                logger_1.logger.info(`Model ${this.MODEL_NAME} not found, pulling...`);
                await this.ollamaService.pullModel(this.MODEL_NAME);
            }
            this.isInitialized = true;
            this.emit('initialized');
            logger_1.logger.info('EmbeddingService initialized successfully');
        }
        catch (error) {
            logger_1.logger.error('Error initializing EmbeddingService:', error);
            throw error;
        }
    }
    getStatus() {
        return this.status;
    }
    async updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        logger_1.logger.info(`Updated embedding configuration: ${JSON.stringify(this.config, null, 2)}`);
    }
    getConfig() {
        return { ...this.config };
    }
    truncateText(text) {
        if (this.config.truncateStrategy === 'NONE')
            return text;
        const tokens = text.split(/\s+/);
        if (tokens.length <= this.config.maxTokens)
            return text;
        switch (this.config.truncateStrategy) {
            case 'FIRST':
                return tokens.slice(0, this.config.maxTokens).join(' ');
            case 'LAST':
                return tokens.slice(-this.config.maxTokens).join(' ');
            case 'MIDDLE':
                const half = Math.floor(this.config.maxTokens / 2);
                return [
                    ...tokens.slice(0, half),
                    '...',
                    ...tokens.slice(-half)
                ].join(' ');
            default:
                return text;
        }
    }
    chunkText(text) {
        const chunks = [];
        let startIndex = 0;
        while (startIndex < text.length) {
            const endIndex = Math.min(startIndex + this.config.chunkSize, text.length);
            let chunk = text.slice(startIndex, endIndex);
            if (this.config.chunkStrategy === 'SENTENCE') {
                if (endIndex < text.length) {
                    const lastPeriod = chunk.lastIndexOf('.');
                    if (lastPeriod !== -1) {
                        chunk = chunk.slice(0, lastPeriod + 1);
                        startIndex += lastPeriod + 1;
                    }
                    else {
                        startIndex = endIndex;
                    }
                }
                else {
                    startIndex = endIndex;
                }
            }
            else if (this.config.chunkStrategy === 'PARAGRAPH') {
                if (endIndex < text.length) {
                    const lastNewline = chunk.lastIndexOf('\n\n');
                    if (lastNewline !== -1) {
                        chunk = chunk.slice(0, lastNewline + 2);
                        startIndex += lastNewline + 2;
                    }
                    else {
                        startIndex = endIndex;
                    }
                }
                else {
                    startIndex = endIndex;
                }
            }
            else {
                startIndex = endIndex;
            }
            chunks.push(chunk);
            startIndex -= this.config.chunkOverlap;
        }
        return chunks;
    }
    generateFallbackEmbedding(text) {
        // Simple fallback embedding using character frequencies
        const embedding = new Array(1536).fill(0);
        const chars = text.toLowerCase().split('');
        chars.forEach((char, i) => {
            const index = (char.charCodeAt(0) * i) % 1536;
            embedding[index] += 1;
        });
        // Normalize the embedding
        const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
        return embedding.map(val => val / magnitude);
    }
    async generateEmbedding(text) {
        if (!this.isInitialized) {
            throw new Error('EmbeddingService not initialized');
        }
        let retries = 0;
        while (retries < this.MAX_RETRIES) {
            try {
                const response = await this.ollamaService.generateEmbedding(text, this.MODEL_NAME);
                return response.embedding;
            }
            catch (error) {
                retries++;
                if (retries === this.MAX_RETRIES) {
                    logger_1.logger.error('Failed to generate embedding after max retries:', error);
                    throw error;
                }
                logger_1.logger.warn(`Retrying embedding generation (${retries}/${this.MAX_RETRIES})...`);
                await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));
            }
        }
        throw new Error('Failed to generate embedding');
    }
    async generateEmbeddings(texts) {
        if (!this.isInitialized) {
            throw new Error('EmbeddingService not initialized');
        }
        const embeddings = [];
        const batches = this.chunkArray(texts, this.BATCH_SIZE);
        for (const batch of batches) {
            const batchEmbeddings = await Promise.all(batch.map(text => this.generateEmbedding(text)));
            embeddings.push(...batchEmbeddings);
        }
        return embeddings;
    }
    chunkArray(array, size) {
        const chunks = [];
        for (let i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }
    async storeEmbedding(text, metadata = {}) {
        const id = (0, uuid_1.v4)();
        const embedding = await this.generateEmbedding(text);
        this.fallbackStore.add(id, embedding, metadata);
        return id;
    }
    async searchSimilar(query, k = 5) {
        const queryEmbedding = await this.generateEmbedding(query);
        return this.fallbackStore.search(queryEmbedding, k);
    }
    async rerankResults(query, results) {
        if (!this.config.rerankResults)
            return results;
        try {
            const queryEmbedding = await this.generateEmbedding(query);
            const resultEmbeddings = await this.generateEmbeddings(results.map(r => r.text));
            const rerankedResults = results.map((result, index) => {
                const similarity = this.cosineSimilarity(queryEmbedding, resultEmbeddings[index]);
                return { ...result, score: similarity };
            });
            return rerankedResults
                .filter(r => r.score >= this.config.minSimilarityThreshold)
                .sort((a, b) => b.score - a.score)
                .slice(0, this.config.maxResults);
        }
        catch (error) {
            logger_1.logger.error('Error reranking results:', error);
            return results;
        }
    }
    cosineSimilarity(a, b) {
        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
        return dotProduct / (magnitudeA * magnitudeB);
    }
    async cleanup() {
        if (!this.isInitialized)
            return;
        this.isInitialized = false;
    }
}
exports.EmbeddingService = EmbeddingService;
//# sourceMappingURL=EmbeddingService.js.map
</file>

<file path="src/services/EmbeddingService.js.map">
{"version":3,"file":"EmbeddingService.js","sourceRoot":"","sources":["EmbeddingService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/EmbeddingService.ts">
import { logger } from '../utils/logger';
import { OllamaService } from './OllamaService';
import { InMemoryVectorStore } from './InMemoryVectorStore';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';
export type ServiceStatus = 'operational' | 'degraded' | 'unavailable';
export interface EmbeddingConfig {
  // Model settings
  model: string;
  modelParameters: {
    temperature: number;
    topK: number;
    topP: number;
    contextWindow: number;
    repeatPenalty: number;
    presencePenalty: number;
    frequencyPenalty: number;
    mirostatMode: number;
    mirostatTau: number;
    mirostatEta: number;
  };
  // Processing settings
  batchSize: number;
  normalize: boolean;
  truncateStrategy: 'NONE' | 'FIRST' | 'LAST' | 'MIDDLE';
  maxTokens: number;
  // Chunking settings
  chunkSize: number;
  chunkOverlap: number;
  chunkStrategy: 'SENTENCE' | 'PARAGRAPH' | 'FIXED';
  // Cache settings
  enableCache: boolean;
  cacheSize: number;
  cacheTTL: number;
  // Performance settings
  parallelProcessing: boolean;
  maxConcurrentRequests: number;
  timeout: number;
  // Quality settings
  minSimilarityThreshold: number;
  maxResults: number;
  rerankResults: boolean;
}
export class EmbeddingService extends EventEmitter {
  private static instance: EmbeddingService;
  private ollamaService: OllamaService;
  private isInitialized = false;
  private readonly MODEL_NAME = 'nomic-embed-text';
  private readonly BATCH_SIZE = 10;
  private readonly MAX_RETRIES = 3;
  private readonly RETRY_DELAY = 1000; // 1 second
  private config: EmbeddingConfig;
  private status: ServiceStatus = 'operational';
  private fallbackStore: InMemoryVectorStore;
  private readonly defaultConfig: EmbeddingConfig = {
    model: 'nomic-embed-text',
    modelParameters: {
      temperature: 0.7,
      topK: 40,
      topP: 0.9,
      contextWindow: 2048,
      repeatPenalty: 1.1,
      presencePenalty: 0.0,
      frequencyPenalty: 0.0,
      mirostatMode: 0,
      mirostatTau: 5.0,
      mirostatEta: 0.1,
    },
    batchSize: 32,
    normalize: true,
    truncateStrategy: 'NONE',
    maxTokens: 2048,
    chunkSize: 1000,
    chunkOverlap: 200,
    chunkStrategy: 'SENTENCE',
    enableCache: true,
    cacheSize: 1000,
    cacheTTL: 3600,
    parallelProcessing: true,
    maxConcurrentRequests: 4,
    timeout: 30000,
    minSimilarityThreshold: 0.7,
    maxResults: 10,
    rerankResults: false,
  };
  private constructor(ollamaService: OllamaService) {
    super();
    this.ollamaService = ollamaService;
    this.config = { ...this.defaultConfig };
    this.fallbackStore = new InMemoryVectorStore(1536);
  }
  public static getInstance(): EmbeddingService {
    if (!EmbeddingService.instance) {
      const ollamaService = OllamaService.getInstance();
      EmbeddingService.instance = new EmbeddingService(ollamaService);
    }
    return EmbeddingService.instance;
  }
  async initialize(): Promise<void> {
    if (this.isInitialized) return;
    try {
      logger.info('Initializing EmbeddingService');
      // Check if Ollama is available
      const isAvailable = await this.ollamaService.isAvailable();
      if (!isAvailable) {
        throw new Error('Ollama service is not available');
      }
      // Check if model is available
      const models = await this.ollamaService.listModels();
      if (!models.includes(this.MODEL_NAME)) {
        logger.info(`Model ${this.MODEL_NAME} not found, pulling...`);
        await this.ollamaService.pullModel(this.MODEL_NAME);
      }
      this.isInitialized = true;
      this.emit('initialized');
      logger.info('EmbeddingService initialized successfully');
    } catch (error) {
      logger.error('Error initializing EmbeddingService:', error);
      throw error;
    }
  }
  getStatus(): ServiceStatus {
    return this.status;
  }
  async updateConfig(newConfig: Partial<EmbeddingConfig>): Promise<void> {
    this.config = { ...this.config, ...newConfig };
    logger.info(`Updated embedding configuration: ${JSON.stringify(this.config, null, 2)}`);
  }
  getConfig(): EmbeddingConfig {
    return { ...this.config };
  }
  private truncateText(text: string): string {
    if (this.config.truncateStrategy === 'NONE') return text;
    const tokens = text.split(/\s+/);
    if (tokens.length <= this.config.maxTokens) return text;
    switch (this.config.truncateStrategy) {
      case 'FIRST':
        return tokens.slice(0, this.config.maxTokens).join(' ');
      case 'LAST':
        return tokens.slice(-this.config.maxTokens).join(' ');
      case 'MIDDLE':
        const half = Math.floor(this.config.maxTokens / 2);
        return [
          ...tokens.slice(0, half),
          '...',
          ...tokens.slice(-half)
        ].join(' ');
      default:
        return text;
    }
  }
  private chunkText(text: string): string[] {
    const chunks: string[] = [];
    let startIndex = 0;
    while (startIndex < text.length) {
      const endIndex = Math.min(startIndex + this.config.chunkSize, text.length);
      let chunk = text.slice(startIndex, endIndex);
      if (this.config.chunkStrategy === 'SENTENCE') {
        if (endIndex < text.length) {
          const lastPeriod = chunk.lastIndexOf('.');
          if (lastPeriod !== -1) {
            chunk = chunk.slice(0, lastPeriod + 1);
            startIndex += lastPeriod + 1;
          } else {
            startIndex = endIndex;
          }
        } else {
          startIndex = endIndex;
        }
      } else if (this.config.chunkStrategy === 'PARAGRAPH') {
        if (endIndex < text.length) {
          const lastNewline = chunk.lastIndexOf('\n\n');
          if (lastNewline !== -1) {
            chunk = chunk.slice(0, lastNewline + 2);
            startIndex += lastNewline + 2;
          } else {
            startIndex = endIndex;
          }
        } else {
          startIndex = endIndex;
        }
      } else {
        startIndex = endIndex;
      }
      chunks.push(chunk);
      startIndex -= this.config.chunkOverlap;
    }
    return chunks;
  }
  private generateFallbackEmbedding(text: string): number[] {
    // Simple fallback embedding using character frequencies
    const embedding = new Array(1536).fill(0);
    const chars = text.toLowerCase().split('');
    chars.forEach((char, i) => {
      const index = (char.charCodeAt(0) * i) % 1536;
      embedding[index] += 1;
    });
    // Normalize the embedding
    const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
    return embedding.map(val => val / magnitude);
  }
  async generateEmbedding(text: string): Promise<number[]> {
    if (!this.isInitialized) {
      throw new Error('EmbeddingService not initialized');
    }
    let retries = 0;
    while (retries < this.MAX_RETRIES) {
      try {
        const response = await this.ollamaService.generateEmbedding(text, this.MODEL_NAME);
        return response.embedding;
      } catch (error) {
        retries++;
        if (retries === this.MAX_RETRIES) {
          logger.error('Failed to generate embedding after max retries:', error);
          throw error;
        }
        logger.warn(`Retrying embedding generation (${retries}/${this.MAX_RETRIES})...`);
        await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));
      }
    }
    throw new Error('Failed to generate embedding');
  }
  async generateEmbeddings(texts: string[]): Promise<number[][]> {
    if (!this.isInitialized) {
      throw new Error('EmbeddingService not initialized');
    }
    const embeddings: number[][] = [];
    const batches = this.chunkArray(texts, this.BATCH_SIZE);
    for (const batch of batches) {
      const batchEmbeddings = await Promise.all(
        batch.map(text => this.generateEmbedding(text))
      );
      embeddings.push(...batchEmbeddings);
    }
    return embeddings;
  }
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  async storeEmbedding(text: string, metadata: any = {}): Promise<string> {
    const id = uuidv4();
    const embedding = await this.generateEmbedding(text);
    this.fallbackStore.add(id, embedding, metadata);
    return id;
  }
  async searchSimilar(query: string, k: number = 5): Promise<Array<{ id: string; similarity: number; metadata: any }>> {
    const queryEmbedding = await this.generateEmbedding(query);
    return this.fallbackStore.search(queryEmbedding, k);
  }
  async rerankResults(query: string, results: { text: string; score: number }[]): Promise<{ text: string; score: number }[]> {
    if (!this.config.rerankResults) return results;
    try {
      const queryEmbedding = await this.generateEmbedding(query);
      const resultEmbeddings = await this.generateEmbeddings(results.map(r => r.text));
      const rerankedResults = results.map((result, index) => {
        const similarity = this.cosineSimilarity(queryEmbedding, resultEmbeddings[index]);
        return { ...result, score: similarity };
      });
      return rerankedResults
        .filter(r => r.score >= this.config.minSimilarityThreshold)
        .sort((a, b) => b.score - a.score)
        .slice(0, this.config.maxResults);
    } catch (error) {
      logger.error('Error reranking results:', error);
      return results;
    }
  }
  private cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (magnitudeA * magnitudeB);
  }
  async cleanup(): Promise<void> {
    if (!this.isInitialized) return;
    this.isInitialized = false;
  }
}
</file>

<file path="src/services/ExpressService.d.ts">
import { BaseService, ServiceConfig } from './Service';
export declare class ExpressService extends BaseService {
    private app;
    private server;
    constructor(config: ServiceConfig);
    protected initialize(): Promise<void>;
    protected cleanup(): Promise<void>;
    protected checkHealth(): Promise<boolean>;
    private setupRoutes;
}
</file>

<file path="src/services/ExpressService.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressService = void 0;
const express_1 = __importDefault(require("express"));
const Service_1 = require("./Service");
const logger_1 = require("../utils/logger");
class ExpressService extends Service_1.BaseService {
    constructor(config) {
        super(config);
        this.app = (0, express_1.default)();
    }
    async initialize() {
        try {
            // Initialize Express application
            logger_1.logger.info('Initializing Express service...');
            // Setup middleware
            this.app.use(express_1.default.json());
            this.app.use(express_1.default.urlencoded({ extended: true }));
            // Setup routes
            this.setupRoutes();
            // Start server
            const port = process.env.PORT || 3000;
            this.server = this.app.listen(port, () => {
                logger_1.logger.info(`Express server listening on port ${port}`);
            });
            // Handle server errors
            if (this.server) {
                this.server.on('error', (error) => {
                    logger_1.logger.error('Express server error:', error);
                    this.handleError(error);
                });
            }
        }
        catch (error) {
            logger_1.logger.error('Failed to initialize Express service:', error);
            throw error;
        }
    }
    async cleanup() {
        try {
            // Cleanup Express server
            logger_1.logger.info('Cleaning up Express service...');
            if (this.server) {
                await new Promise((resolve) => {
                    this.server.close(() => {
                        logger_1.logger.info('Express server stopped');
                        resolve();
                    });
                });
                this.server = null;
            }
        }
        catch (error) {
            logger_1.logger.error('Failed to cleanup Express service:', error);
            throw error;
        }
    }
    async checkHealth() {
        try {
            // Check if server is running
            if (!this.server) {
                return false;
            }
            // TODO: Implement more comprehensive health check
            return true;
        }
        catch (error) {
            logger_1.logger.error('Express health check failed:', error);
            return false;
        }
    }
    setupRoutes() {
        // Health check endpoint
        this.app.get('/health', (req, res) => {
            res.json({ status: 'ok' });
        });
        // TODO: Add more routes as needed
    }
}
exports.ExpressService = ExpressService;
//# sourceMappingURL=ExpressService.js.map
</file>

<file path="src/services/ExpressService.js.map">
{"version":3,"file":"ExpressService.js","sourceRoot":"","sources":["ExpressService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/ExpressService.ts">
import express, { Request, Response } from 'express';
import { BaseService, ServiceConfig } from './Service';
import { logger } from '../utils/logger';
import http from 'http';
export class ExpressService extends BaseService {
  private app: express.Application;
  private server: any;
  constructor(config: ServiceConfig) {
    super(config);
    this.app = express();
  }
  protected async initialize(): Promise<void> {
    try {
      // Initialize Express application
      logger.info('Initializing Express service...');
      // Setup middleware
      this.app.use(express.json());
      this.app.use(express.urlencoded({ extended: true }));
      // Setup routes
      this.setupRoutes();
      // Start server
      const port = process.env.PORT || 3000;
      this.server = this.app.listen(port, () => {
        logger.info(`Express server listening on port ${port}`);
      });
      // Handle server errors
      if (this.server) {
        this.server.on('error', (error) => {
          logger.error('Express server error:', error);
          this.handleError(error);
        });
      }
    } catch (error) {
      logger.error('Failed to initialize Express service:', error);
      throw error;
    }
  }
  protected async cleanup(): Promise<void> {
    try {
      // Cleanup Express server
      logger.info('Cleaning up Express service...');
      if (this.server) {
        await new Promise<void>((resolve) => {
          this.server.close(() => {
            logger.info('Express server stopped');
            resolve();
          });
        });
        this.server = null;
      }
    } catch (error) {
      logger.error('Failed to cleanup Express service:', error);
      throw error;
    }
  }
  protected async checkHealth(): Promise<boolean> {
    try {
      // Check if server is running
      if (!this.server) {
        return false;
      }
      // TODO: Implement more comprehensive health check
      return true;
    } catch (error) {
      logger.error('Express health check failed:', error);
      return false;
    }
  }
  private setupRoutes(): void {
    // Health check endpoint
    this.app.get('/health', (req: Request, res: Response) => {
      res.json({ status: 'ok' });
    });
    // TODO: Add more routes as needed
  }
}
</file>

<file path="src/services/InMemoryVectorStore.d.ts">
interface VectorEntry {
    id: string;
    vector: number[];
    metadata: any;
}
interface SearchResult extends VectorEntry {
    similarity: number;
}
export declare class InMemoryVectorStore {
    private vectors;
    private dimension;
    constructor(dimension?: number);
    add(id: string, vector: number[], metadata?: any): void;
    search(queryVector: number[], k?: number): SearchResult[];
    delete(id: string): void;
    clear(): void;
    size(): number;
    private cosineSimilarity;
}
export {};
</file>

<file path="src/services/InMemoryVectorStore.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryVectorStore = void 0;
class InMemoryVectorStore {
    constructor(dimension = 1536) {
        this.vectors = new Map();
        this.dimension = dimension;
    }
    add(id, vector, metadata = {}) {
        if (vector.length !== this.dimension) {
            throw new Error(`Vector dimension mismatch. Expected ${this.dimension}, got ${vector.length}`);
        }
        this.vectors.set(id, { id, vector, metadata });
    }
    search(queryVector, k = 5) {
        if (queryVector.length !== this.dimension) {
            throw new Error(`Query vector dimension mismatch. Expected ${this.dimension}, got ${queryVector.length}`);
        }
        const entries = Array.from(this.vectors.values());
        const results = entries.map(entry => ({
            ...entry,
            similarity: this.cosineSimilarity(queryVector, entry.vector)
        }));
        return results
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, k);
    }
    delete(id) {
        this.vectors.delete(id);
    }
    clear() {
        this.vectors.clear();
    }
    size() {
        return this.vectors.size;
    }
    cosineSimilarity(a, b) {
        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
        return dotProduct / (magnitudeA * magnitudeB);
    }
}
exports.InMemoryVectorStore = InMemoryVectorStore;
//# sourceMappingURL=InMemoryVectorStore.js.map
</file>

<file path="src/services/InMemoryVectorStore.js.map">
{"version":3,"file":"InMemoryVectorStore.js","sourceRoot":"","sources":["InMemoryVectorStore.ts"],"names":[],"mappings":";;;AAYA,MAAa,mBAAmB;IAI9B,YAAY,YAAoB,IAAI;QAH5B,YAAO,GAA6B,IAAI,GAAG,EAAE,CAAC;QAIpD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAED,GAAG,CAAC,EAAU,EAAE,MAAgB,EAAE,WAAgB,EAAE;QAClD,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,CAAC,SAAS,EAAE,CAAC;YACrC,MAAM,IAAI,KAAK,CAAC,uCAAuC,IAAI,CAAC,SAAS,SAAS,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;QACjG,CAAC;QACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC;IACjD,CAAC;IAED,MAAM,CAAC,WAAqB,EAAE,IAAY,CAAC;QACzC,IAAI,WAAW,CAAC,MAAM,KAAK,IAAI,CAAC,SAAS,EAAE,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,6CAA6C,IAAI,CAAC,SAAS,SAAS,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC;QAC5G,CAAC;QAED,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;QAClD,MAAM,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YACpC,GAAG,KAAK;YACR,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE,KAAK,CAAC,MAAM,CAAC;SAC7D,CAAC,CAAC,CAAC;QAEJ,OAAO,OAAO;aACX,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC;aAC3C,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACjB,CAAC;IAED,MAAM,CAAC,EAAU;QACf,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IAC1B,CAAC;IAED,KAAK;QACH,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;IACvB,CAAC;IAED,IAAI;QACF,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;IAC3B,CAAC;IAEO,gBAAgB,CAAC,CAAW,EAAE,CAAW;QAC/C,MAAM,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAClE,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;QACzE,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;QACzE,OAAO,UAAU,GAAG,CAAC,UAAU,GAAG,UAAU,CAAC,CAAC;IAChD,CAAC;CACF;AAjDD,kDAiDC"}
</file>

<file path="src/services/InMemoryVectorStore.ts">
import { logger } from '../utils/logger';
interface VectorEntry {
  id: string;
  vector: number[];
  metadata: any;
}
interface SearchResult extends VectorEntry {
  similarity: number;
}
export class InMemoryVectorStore {
  private vectors: Map<string, VectorEntry> = new Map();
  private dimension: number;
  constructor(dimension: number = 1536) {
    this.dimension = dimension;
  }
  add(id: string, vector: number[], metadata: any = {}): void {
    if (vector.length !== this.dimension) {
      throw new Error(`Vector dimension mismatch. Expected ${this.dimension}, got ${vector.length}`);
    }
    this.vectors.set(id, { id, vector, metadata });
  }
  search(queryVector: number[], k: number = 5): SearchResult[] {
    if (queryVector.length !== this.dimension) {
      throw new Error(`Query vector dimension mismatch. Expected ${this.dimension}, got ${queryVector.length}`);
    }
    const entries = Array.from(this.vectors.values());
    const results = entries.map(entry => ({
      ...entry,
      similarity: this.cosineSimilarity(queryVector, entry.vector)
    }));
    return results
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, k);
  }
  delete(id: string): void {
    this.vectors.delete(id);
  }
  clear(): void {
    this.vectors.clear();
  }
  size(): number {
    return this.vectors.size;
  }
  private cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (magnitudeA * magnitudeB);
  }
}
</file>

<file path="src/services/MemoryService.d.ts">
import { EventEmitter } from 'events';
export interface MemoryChunk {
    id: string;
    content: string;
    metadata: {
        timestamp: number;
        source?: string;
        type?: string;
        tags?: string[];
        importance?: number;
        context?: {
            conversationId?: string;
            messageId?: string;
            [key: string]: any;
        };
        embedding?: number[];
        [key: string]: any;
    };
    vector?: number[];
    similarity?: number;
    importance?: number;
    expiresAt?: number;
}
export declare class MemoryService extends EventEmitter {
    private static instance;
    private isInitialized;
    private db;
    private embeddingService;
    private vectorStore;
    private cache;
    private readonly CACHE_SIZE;
    private readonly COMPRESSION_THRESHOLD;
    private readonly DEFAULT_EXPIRY;
    private readonly IMPORTANCE_DECAY;
    private constructor();
    static getInstance(): MemoryService;
    initialize(): Promise<{
        success: boolean;
        error?: string;
    }>;
    private startMaintenanceTasks;
    private cleanExpiredMemories;
    private updateImportanceScores;
    private pruneLowImportanceMemories;
    store(chunk: MemoryChunk): Promise<void>;
    private calculateImportance;
    private updateCache;
    search(query: string, options?: {
        limit?: number;
        minImportance?: number;
        type?: string;
        tags?: string[];
        useVectorSearch?: boolean;
    }): Promise<MemoryChunk[]>;
    private processMemoryRow;
    getRecent(limit?: number): Promise<MemoryChunk[]>;
    delete(id: string): Promise<void>;
    clear(): Promise<void>;
    export(path: string): Promise<void>;
    import(path: string): Promise<void>;
    getStats(): Promise<{
        total: number;
        active: number;
        expired: number;
        averageImportance: number;
        cacheSize: number;
    }>;
}
</file>

<file path="src/services/MemoryService.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryService = void 0;
const electron_1 = require("electron");
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const events_1 = require("events");
const zlib_1 = require("zlib");
const util_1 = require("util");
const EmbeddingService_1 = require("./EmbeddingService");
const VectorStoreService_1 = require("./VectorStoreService");
const logger_1 = require("../utils/logger");
const gzipAsync = (0, util_1.promisify)(zlib_1.gzip);
const unzipAsync = (0, util_1.promisify)(zlib_1.unzip);
class MemoryService extends events_1.EventEmitter {
    constructor() {
        super();
        this.isInitialized = false;
        this.db = null;
        this.cache = new Map();
        this.CACHE_SIZE = 1000;
        this.COMPRESSION_THRESHOLD = 1024; // 1KB
        this.DEFAULT_EXPIRY = 30 * 24 * 60 * 60 * 1000; // 30 days
        this.IMPORTANCE_DECAY = 0.95; // 5% decay per day
        this.embeddingService = EmbeddingService_1.EmbeddingService.getInstance();
        this.vectorStore = VectorStoreService_1.VectorStoreService.getInstance();
    }
    static getInstance() {
        if (!MemoryService.instance) {
            MemoryService.instance = new MemoryService();
        }
        return MemoryService.instance;
    }
    async initialize() {
        try {
            if (this.isInitialized) {
                return { success: true };
            }
            const dbPath = path.join(electron_1.app.getPath('userData'), 'memory.db');
            this.db = new better_sqlite3_1.default(dbPath);
            // Create tables with enhanced schema
            this.db.exec(`
        CREATE TABLE IF NOT EXISTS memories (
          id TEXT PRIMARY KEY,
          content TEXT,
          metadata TEXT,
          embedding BLOB,
          created_at INTEGER,
          updated_at INTEGER,
          importance REAL DEFAULT 1.0,
          expires_at INTEGER,
          compressed BOOLEAN DEFAULT FALSE
        );
        CREATE INDEX IF NOT EXISTS idx_memories_metadata 
          ON memories(metadata);
        CREATE INDEX IF NOT EXISTS idx_memories_timestamp 
          ON memories(created_at);
        CREATE INDEX IF NOT EXISTS idx_memories_importance 
          ON memories(importance);
        CREATE INDEX IF NOT EXISTS idx_memories_expires 
          ON memories(expires_at);
      `);
            // Start maintenance tasks
            this.startMaintenanceTasks();
            this.isInitialized = true;
            this.emit('initialized');
            return { success: true };
        }
        catch (error) {
            logger_1.logger.error('Failed to initialize memory service:', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to initialize memory service'
            };
        }
    }
    startMaintenanceTasks() {
        // Clean expired memories every hour
        setInterval(() => this.cleanExpiredMemories(), 60 * 60 * 1000);
        // Update importance scores daily
        setInterval(() => this.updateImportanceScores(), 24 * 60 * 60 * 1000);
        // Prune low-importance memories weekly
        setInterval(() => this.pruneLowImportanceMemories(), 7 * 24 * 60 * 60 * 1000);
    }
    async cleanExpiredMemories() {
        if (!this.db)
            return;
        const stmt = this.db.prepare(`
      DELETE FROM memories 
      WHERE expires_at IS NOT NULL AND expires_at < ?
    `);
        try {
            const result = stmt.run(Date.now());
            if (result.changes > 0) {
                this.emit('pruned', result.changes);
            }
        }
        catch (error) {
            logger_1.logger.error('Error cleaning expired memories:', error);
        }
    }
    async updateImportanceScores() {
        if (!this.db)
            return;
        const stmt = this.db.prepare(`
      UPDATE memories 
      SET importance = importance * ?
      WHERE expires_at IS NULL OR expires_at > ?
    `);
        try {
            stmt.run(this.IMPORTANCE_DECAY, Date.now());
        }
        catch (error) {
            logger_1.logger.error('Error updating importance scores:', error);
        }
    }
    async pruneLowImportanceMemories() {
        if (!this.db)
            return;
        const stmt = this.db.prepare(`
      DELETE FROM memories 
      WHERE importance < 0.1 
      AND (expires_at IS NULL OR expires_at > ?)
    `);
        try {
            const result = stmt.run(Date.now());
            if (result.changes > 0) {
                this.emit('pruned', result.changes);
            }
        }
        catch (error) {
            logger_1.logger.error('Error pruning low importance memories:', error);
        }
    }
    async store(chunk) {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        // Generate embedding if not provided
        if (!chunk.vector) {
            chunk.vector = await this.embeddingService.generateEmbedding(chunk.content);
        }
        // Calculate importance score
        const importance = this.calculateImportance(chunk);
        // Determine if content should be compressed
        const shouldCompress = chunk.content.length > this.COMPRESSION_THRESHOLD;
        const content = shouldCompress ?
            (await gzipAsync(Buffer.from(chunk.content))).toString('base64') :
            chunk.content;
        const stmt = this.db.prepare(`
      INSERT INTO memories (
        id, content, metadata, embedding, created_at, updated_at, 
        importance, expires_at, compressed
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
        try {
            stmt.run(chunk.id, content, JSON.stringify(chunk.metadata), new Float64Array(chunk.vector).buffer, Date.now(), Date.now(), importance, chunk.expiresAt || null, shouldCompress);
            // Update cache
            this.updateCache(chunk);
            this.emit('stored', chunk);
        }
        catch (error) {
            logger_1.logger.error('Error storing memory:', error);
            throw error;
        }
    }
    calculateImportance(chunk) {
        let importance = 1.0;
        // Adjust based on metadata
        if (chunk.metadata.importance) {
            importance *= chunk.metadata.importance;
        }
        // Adjust based on content length
        const contentLength = chunk.content.length;
        if (contentLength > 1000) {
            importance *= 1.2; // Longer content might be more important
        }
        // Adjust based on tags
        if (chunk.metadata.tags?.length) {
            importance *= (1 + (chunk.metadata.tags.length * 0.1));
        }
        return Math.min(importance, 10.0); // Cap at 10
    }
    updateCache(chunk) {
        if (this.cache.size >= this.CACHE_SIZE) {
            // Remove least recently used item
            const oldestKey = this.cache.keys().next().value;
            this.cache.delete(oldestKey);
        }
        this.cache.set(chunk.id, chunk);
    }
    async search(query, options = {}) {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        const { limit = 10, minImportance = 0, type, tags, useVectorSearch = true } = options;
        let results = [];
        if (useVectorSearch) {
            // Use vector similarity search
            const queryVector = await this.embeddingService.generateEmbedding(query);
            results = await this.vectorStore.searchSimilar(query, limit);
        }
        else {
            // Use text search
            const stmt = this.db.prepare(`
        SELECT * FROM memories 
        WHERE content LIKE ? 
        AND importance >= ?
        ${type ? 'AND json_extract(metadata, "$.type") = ?' : ''}
        ${tags?.length ? 'AND json_extract(metadata, "$.tags") LIKE ?' : ''}
        ORDER BY importance DESC, created_at DESC
        LIMIT ?
      `);
            const rows = stmt.all(`%${query}%`, minImportance, ...(type ? [type] : []), ...(tags?.length ? [`%${tags.join('%')}%`] : []), limit);
            results = await Promise.all(rows.map(row => this.processMemoryRow(row)));
        }
        this.emit('searched', results);
        return results;
    }
    async processMemoryRow(row) {
        let content = row.content;
        if (row.compressed) {
            content = (await unzipAsync(Buffer.from(content, 'base64'))).toString();
        }
        return {
            id: row.id,
            content,
            metadata: JSON.parse(row.metadata),
            vector: row.embedding ? Array.from(new Float64Array(row.embedding)) : undefined,
            importance: row.importance,
            expiresAt: row.expires_at || undefined
        };
    }
    async getRecent(limit = 10) {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        const stmt = this.db.prepare(`
      SELECT * FROM memories 
      WHERE expires_at IS NULL OR expires_at > ?
      ORDER BY created_at DESC 
      LIMIT ?
    `);
        const rows = stmt.all(Date.now(), limit);
        const results = await Promise.all(rows.map(row => this.processMemoryRow(row)));
        this.emit('recent', results);
        return results;
    }
    async delete(id) {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        const stmt = this.db.prepare('DELETE FROM memories WHERE id = ?');
        stmt.run(id);
        this.cache.delete(id);
        this.emit('deleted', id);
    }
    async clear() {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        this.db.exec('DELETE FROM memories');
        this.cache.clear();
        this.emit('cleared');
    }
    async export(path) {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        if (!path || typeof path !== 'string') {
            throw new Error('Export path must be a valid string');
        }
        const memories = await this.getRecent(Number.MAX_SAFE_INTEGER);
        await fs.writeJson(path, memories, { spaces: 2 });
    }
    async import(path) {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        if (!path || typeof path !== 'string') {
            throw new Error('Import path must be a valid string');
        }
        const memories = await fs.readJson(path);
        for (const memory of memories) {
            await this.store(memory);
        }
    }
    async getStats() {
        if (!this.isInitialized || !this.db) {
            throw new Error('Memory service not initialized');
        }
        const stats = this.db.prepare(`
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN expires_at IS NULL OR expires_at > ? THEN 1 ELSE 0 END) as active,
        SUM(CASE WHEN expires_at <= ? THEN 1 ELSE 0 END) as expired,
        AVG(importance) as averageImportance
      FROM memories
    `).get(Date.now(), Date.now());
        return {
            ...stats,
            cacheSize: this.cache.size
        };
    }
}
exports.MemoryService = MemoryService;
//# sourceMappingURL=MemoryService.js.map
</file>

<file path="src/services/MemoryService.js.map">
{"version":3,"file":"MemoryService.js","sourceRoot":"","sources":["MemoryService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/MemoryService.ts">
import { app } from 'electron';
import Database from 'better-sqlite3';
import * as path from 'path';
import * as fs from 'fs-extra';
import * as crypto from 'crypto';
import { EventEmitter } from 'events';
import { gzip, unzip } from 'zlib';
import { promisify } from 'util';
import { EmbeddingService } from './EmbeddingService';
import { VectorStoreService } from './VectorStoreService';
import { logger } from '../utils/logger';
const gzipAsync = promisify(gzip);
const unzipAsync = promisify(unzip);
interface DatabaseRow {
  id: string;
  content: string;
  metadata: string;
  embedding: Buffer;
  created_at: number;
  updated_at: number;
  importance: number;
  expires_at: number | null;
  compressed: boolean;
}
interface DatabaseResult {
  changes: number;
  lastInsertRowid: number;
}
export interface MemoryChunk {
  id: string;
  content: string;
  metadata: {
    timestamp: number;
    source?: string;
    type?: string;
    tags?: string[];
    importance?: number;
    context?: {
      conversationId?: string;
      messageId?: string;
      [key: string]: any;
    };
    embedding?: number[];
    [key: string]: any;
  };
  vector?: number[];
  similarity?: number;
  importance?: number;
  expiresAt?: number;
}
export class MemoryService extends EventEmitter {
  private static instance: MemoryService;
  private isInitialized: boolean = false;
  private db: Database | null = null;
  private embeddingService: EmbeddingService;
  private vectorStore: VectorStoreService;
  private cache: Map<string, MemoryChunk> = new Map();
  private readonly CACHE_SIZE = 1000;
  private readonly COMPRESSION_THRESHOLD = 1024; // 1KB
  private readonly DEFAULT_EXPIRY = 30 * 24 * 60 * 60 * 1000; // 30 days
  private readonly IMPORTANCE_DECAY = 0.95; // 5% decay per day
  private constructor() {
    super();
    this.embeddingService = EmbeddingService.getInstance();
    this.vectorStore = VectorStoreService.getInstance();
  }
  public static getInstance(): MemoryService {
    if (!MemoryService.instance) {
      MemoryService.instance = new MemoryService();
    }
    return MemoryService.instance;
  }
  public async initialize(): Promise<{ success: boolean; error?: string }> {
    try {
      if (this.isInitialized) {
        return { success: true };
      }
      const dbPath = path.join(app.getPath('userData'), 'memory.db');
      this.db = new Database(dbPath);
      // Create tables with enhanced schema
      this.db.exec(`
        CREATE TABLE IF NOT EXISTS memories (
          id TEXT PRIMARY KEY,
          content TEXT,
          metadata TEXT,
          embedding BLOB,
          created_at INTEGER,
          updated_at INTEGER,
          importance REAL DEFAULT 1.0,
          expires_at INTEGER,
          compressed BOOLEAN DEFAULT FALSE
        );
        CREATE INDEX IF NOT EXISTS idx_memories_metadata 
          ON memories(metadata);
        CREATE INDEX IF NOT EXISTS idx_memories_timestamp 
          ON memories(created_at);
        CREATE INDEX IF NOT EXISTS idx_memories_importance 
          ON memories(importance);
        CREATE INDEX IF NOT EXISTS idx_memories_expires 
          ON memories(expires_at);
      `);
      // Start maintenance tasks
      this.startMaintenanceTasks();
      this.isInitialized = true;
      this.emit('initialized');
      return { success: true };
    } catch (error) {
      logger.error('Failed to initialize memory service:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to initialize memory service' 
      };
    }
  }
  private startMaintenanceTasks(): void {
    // Clean expired memories every hour
    setInterval(() => this.cleanExpiredMemories(), 60 * 60 * 1000);
    // Update importance scores daily
    setInterval(() => this.updateImportanceScores(), 24 * 60 * 60 * 1000);
    // Prune low-importance memories weekly
    setInterval(() => this.pruneLowImportanceMemories(), 7 * 24 * 60 * 60 * 1000);
  }
  private async cleanExpiredMemories(): Promise<void> {
    if (!this.db) return;
    const stmt = this.db.prepare(`
      DELETE FROM memories 
      WHERE expires_at IS NOT NULL AND expires_at < ?
    `);
    try {
      const result = stmt.run(Date.now()) as unknown as DatabaseResult;
      if (result.changes > 0) {
        this.emit('pruned', result.changes);
      }
    } catch (error) {
      logger.error('Error cleaning expired memories:', error);
    }
  }
  private async updateImportanceScores(): Promise<void> {
    if (!this.db) return;
    const stmt = this.db.prepare(`
      UPDATE memories 
      SET importance = importance * ?
      WHERE expires_at IS NULL OR expires_at > ?
    `);
    try {
      stmt.run(this.IMPORTANCE_DECAY, Date.now());
    } catch (error) {
      logger.error('Error updating importance scores:', error);
    }
  }
  private async pruneLowImportanceMemories(): Promise<void> {
    if (!this.db) return;
    const stmt = this.db.prepare(`
      DELETE FROM memories 
      WHERE importance < 0.1 
      AND (expires_at IS NULL OR expires_at > ?)
    `);
    try {
      const result = stmt.run(Date.now()) as unknown as DatabaseResult;
      if (result.changes > 0) {
        this.emit('pruned', result.changes);
      }
    } catch (error) {
      logger.error('Error pruning low importance memories:', error);
    }
  }
  public async store(chunk: MemoryChunk): Promise<void> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    // Generate embedding if not provided
    if (!chunk.vector) {
      chunk.vector = await this.embeddingService.generateEmbedding(chunk.content);
    }
    // Calculate importance score
    const importance = this.calculateImportance(chunk);
    // Determine if content should be compressed
    const shouldCompress = chunk.content.length > this.COMPRESSION_THRESHOLD;
    const content = shouldCompress ? 
      (await gzipAsync(Buffer.from(chunk.content))).toString('base64') : 
      chunk.content;
    const stmt = this.db.prepare(`
      INSERT INTO memories (
        id, content, metadata, embedding, created_at, updated_at, 
        importance, expires_at, compressed
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    try {
      stmt.run(
        chunk.id,
        content,
        JSON.stringify(chunk.metadata),
        new Float64Array(chunk.vector).buffer,
        Date.now(),
        Date.now(),
        importance,
        chunk.expiresAt || null,
        shouldCompress
      );
      // Update cache
      this.updateCache(chunk);
      this.emit('stored', chunk);
    } catch (error) {
      logger.error('Error storing memory:', error);
      throw error;
    }
  }
  private calculateImportance(chunk: MemoryChunk): number {
    let importance = 1.0;
    // Adjust based on metadata
    if (chunk.metadata.importance) {
      importance *= chunk.metadata.importance;
    }
    // Adjust based on content length
    const contentLength = chunk.content.length;
    if (contentLength > 1000) {
      importance *= 1.2; // Longer content might be more important
    }
    // Adjust based on tags
    if (chunk.metadata.tags?.length) {
      importance *= (1 + (chunk.metadata.tags.length * 0.1));
    }
    return Math.min(importance, 10.0); // Cap at 10
  }
  private updateCache(chunk: MemoryChunk): void {
    if (this.cache.size >= this.CACHE_SIZE) {
      // Remove least recently used item
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(chunk.id, chunk);
  }
  public async search(query: string, options: {
    limit?: number;
    minImportance?: number;
    type?: string;
    tags?: string[];
    useVectorSearch?: boolean;
  } = {}): Promise<MemoryChunk[]> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    const {
      limit = 10,
      minImportance = 0,
      type,
      tags,
      useVectorSearch = true
    } = options;
    let results: MemoryChunk[] = [];
    if (useVectorSearch) {
      // Use vector similarity search
      const queryVector = await this.embeddingService.generateEmbedding(query);
      results = await this.vectorStore.searchSimilar(query, limit);
    } else {
      // Use text search
      const stmt = this.db.prepare(`
        SELECT * FROM memories 
        WHERE content LIKE ? 
        AND importance >= ?
        ${type ? 'AND json_extract(metadata, "$.type") = ?' : ''}
        ${tags?.length ? 'AND json_extract(metadata, "$.tags") LIKE ?' : ''}
        ORDER BY importance DESC, created_at DESC
        LIMIT ?
      `);
      const rows = stmt.all(
        `%${query}%`,
        minImportance,
        ...(type ? [type] : []),
        ...(tags?.length ? [`%${tags.join('%')}%`] : []),
        limit
      );
      results = await Promise.all(rows.map(row => this.processMemoryRow(row)));
    }
    this.emit('searched', results);
    return results;
  }
  private async processMemoryRow(row: DatabaseRow): Promise<MemoryChunk> {
    let content = row.content;
    if (row.compressed) {
      content = (await unzipAsync(Buffer.from(content, 'base64'))).toString();
    }
    return {
      id: row.id,
      content,
      metadata: JSON.parse(row.metadata),
      vector: row.embedding ? Array.from(new Float64Array(row.embedding)) : undefined,
      importance: row.importance,
      expiresAt: row.expires_at || undefined
    };
  }
  public async getRecent(limit: number = 10): Promise<MemoryChunk[]> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    const stmt = this.db.prepare(`
      SELECT * FROM memories 
      WHERE expires_at IS NULL OR expires_at > ?
      ORDER BY created_at DESC 
      LIMIT ?
    `);
    const rows = stmt.all(Date.now(), limit);
    const results = await Promise.all(rows.map(row => this.processMemoryRow(row)));
    this.emit('recent', results);
    return results;
  }
  public async delete(id: string): Promise<void> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    const stmt = this.db.prepare('DELETE FROM memories WHERE id = ?');
    stmt.run(id);
    this.cache.delete(id);
    this.emit('deleted', id);
  }
  public async clear(): Promise<void> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    this.db.exec('DELETE FROM memories');
    this.cache.clear();
    this.emit('cleared');
  }
  public async export(path: string): Promise<void> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    if (!path || typeof path !== 'string') {
      throw new Error('Export path must be a valid string');
    }
    const memories = await this.getRecent(Number.MAX_SAFE_INTEGER);
    await fs.writeJson(path, memories, { spaces: 2 });
  }
  public async import(path: string): Promise<void> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    if (!path || typeof path !== 'string') {
      throw new Error('Import path must be a valid string');
    }
    const memories = await fs.readJson(path);
    for (const memory of memories) {
      await this.store(memory);
    }
  }
  public async getStats(): Promise<{
    total: number;
    active: number;
    expired: number;
    averageImportance: number;
    cacheSize: number;
  }> {
    if (!this.isInitialized || !this.db) {
      throw new Error('Memory service not initialized');
    }
    const stats = this.db.prepare(`
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN expires_at IS NULL OR expires_at > ? THEN 1 ELSE 0 END) as active,
        SUM(CASE WHEN expires_at <= ? THEN 1 ELSE 0 END) as expired,
        AVG(importance) as averageImportance
      FROM memories
    `).get(Date.now(), Date.now());
    return {
      ...stats,
      cacheSize: this.cache.size
    };
  }
}
</file>

<file path="src/services/MessageStore.d.ts">
import { ChatMessage, Conversation } from '../types/chat';
export declare class MessageStore {
    private db;
    private encryptionKey;
    constructor();
    initialize(): Promise<void>;
    private getOrCreateKey;
    private generateId;
    createConversation(title: string, metadata?: Record<string, any>): Promise<string>;
    saveMessage(conversationId: string, message: ChatMessage): Promise<void>;
    getConversation(id: string): Promise<ChatMessage[]>;
    listConversations(): Promise<Conversation[]>;
    deleteConversation(id: string): Promise<void>;
    updateConversationTitle(id: string, title: string): Promise<void>;
    private encrypt;
    private decrypt;
}
</file>

<file path="src/services/MessageStore.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageStore = void 0;
const electron_1 = require("electron");
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const crypto = __importStar(require("crypto"));
class MessageStore {
    constructor() {
        // Initialize with dummy values that will be replaced in initialize()
        this.db = {};
        this.encryptionKey = Buffer.alloc(0);
    }
    async initialize() {
        const dbPath = path.join(electron_1.app.getPath('userData'), 'messages.db');
        this.db = new (require('better-sqlite3'))(dbPath);
        // Create tables with encryption
        this.db.exec(`
      CREATE TABLE IF NOT EXISTS conversations (
        id TEXT PRIMARY KEY,
        title TEXT,
        created_at INTEGER,
        updated_at INTEGER,
        metadata TEXT
      );
      CREATE TABLE IF NOT EXISTS messages (
        id TEXT PRIMARY KEY,
        conversation_id TEXT,
        role TEXT,
        content_encrypted BLOB,
        timestamp INTEGER,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id)
      );
      CREATE INDEX IF NOT EXISTS idx_messages_conversation 
        ON messages(conversation_id, timestamp);
    `);
        // Generate or retrieve encryption key
        this.encryptionKey = await this.getOrCreateKey();
    }
    async getOrCreateKey() {
        const keyPath = path.join(electron_1.app.getPath('userData'), '.key');
        if (await fs.pathExists(keyPath)) {
            const encrypted = await fs.readFile(keyPath);
            return Buffer.from(electron_1.safeStorage.decryptString(encrypted), 'base64');
        }
        const key = crypto.randomBytes(32);
        const encrypted = electron_1.safeStorage.encryptString(key.toString('base64'));
        await fs.writeFile(keyPath, encrypted);
        return key;
    }
    generateId() {
        return `${Date.now()}-${crypto.randomBytes(8).toString('hex')}`;
    }
    async createConversation(title, metadata) {
        const id = this.generateId();
        const now = Date.now();
        this.db.prepare(`
      INSERT INTO conversations (id, title, created_at, updated_at, metadata)
      VALUES (?, ?, ?, ?, ?)
    `).run(id, title, now, now, metadata ? JSON.stringify(metadata) : null);
        return id;
    }
    async saveMessage(conversationId, message) {
        const encrypted = this.encrypt(message.content);
        this.db.prepare(`
      INSERT INTO messages (id, conversation_id, role, content_encrypted, timestamp)
      VALUES (?, ?, ?, ?, ?)
    `).run(message.id, conversationId, message.role, encrypted, message.timestamp);
        // Update conversation timestamp
        this.db.prepare(`
      UPDATE conversations 
      SET updated_at = ? 
      WHERE id = ?
    `).run(message.timestamp, conversationId);
    }
    async getConversation(id) {
        const rows = this.db.prepare(`
      SELECT id, role, content_encrypted, timestamp
      FROM messages
      WHERE conversation_id = ?
      ORDER BY timestamp ASC
    `).all(id);
        return rows.map(row => ({
            id: row.id,
            role: row.role,
            content: this.decrypt(row.content_encrypted),
            timestamp: row.timestamp
        }));
    }
    async listConversations() {
        const rows = this.db.prepare(`
      SELECT id, title, created_at, updated_at, metadata
      FROM conversations
      ORDER BY updated_at DESC
    `).all();
        return rows.map(row => ({
            id: row.id,
            title: row.title,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            metadata: row.metadata ? JSON.parse(row.metadata) : undefined
        }));
    }
    async deleteConversation(id) {
        this.db.prepare('DELETE FROM messages WHERE conversation_id = ?').run(id);
        this.db.prepare('DELETE FROM conversations WHERE id = ?').run(id);
    }
    async updateConversationTitle(id, title) {
        this.db.prepare(`
      UPDATE conversations 
      SET title = ?, updated_at = ? 
      WHERE id = ?
    `).run(title, Date.now(), id);
    }
    encrypt(text) {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv);
        const encrypted = Buffer.concat([
            cipher.update(text, 'utf8'),
            cipher.final()
        ]);
        const authTag = cipher.getAuthTag();
        return Buffer.concat([iv, authTag, encrypted]);
    }
    decrypt(data) {
        const iv = data.slice(0, 16);
        const authTag = data.slice(16, 32);
        const encrypted = data.slice(32);
        const decipher = crypto.createDecipheriv('aes-256-gcm', this.encryptionKey, iv);
        decipher.setAuthTag(authTag);
        return decipher.update(encrypted) + decipher.final('utf8');
    }
}
exports.MessageStore = MessageStore;
//# sourceMappingURL=MessageStore.js.map
</file>

<file path="src/services/MessageStore.js.map">
{"version":3,"file":"MessageStore.js","sourceRoot":"","sources":["MessageStore.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/MessageStore.ts">
import { app, safeStorage } from 'electron';
import * as path from 'path';
import * as fs from 'fs-extra';
import * as crypto from 'crypto';
import { ChatMessage, Conversation } from '../types/chat';
import type Database from 'better-sqlite3';
interface DatabaseRow {
  id: string;
  role: string;
  content_encrypted: Buffer;
  timestamp: number;
  title?: string;
  created_at?: number;
  updated_at?: number;
  metadata?: string;
}
export class MessageStore {
  private db: Database;
  private encryptionKey: Buffer;
  constructor() {
    // Initialize with dummy values that will be replaced in initialize()
    this.db = {} as Database;
    this.encryptionKey = Buffer.alloc(0);
  }
  async initialize() {
    const dbPath = path.join(app.getPath('userData'), 'messages.db');
    this.db = new (require('better-sqlite3'))(dbPath);
    // Create tables with encryption
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS conversations (
        id TEXT PRIMARY KEY,
        title TEXT,
        created_at INTEGER,
        updated_at INTEGER,
        metadata TEXT
      );
      CREATE TABLE IF NOT EXISTS messages (
        id TEXT PRIMARY KEY,
        conversation_id TEXT,
        role TEXT,
        content_encrypted BLOB,
        timestamp INTEGER,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id)
      );
      CREATE INDEX IF NOT EXISTS idx_messages_conversation 
        ON messages(conversation_id, timestamp);
    `);
    // Generate or retrieve encryption key
    this.encryptionKey = await this.getOrCreateKey();
  }
  private async getOrCreateKey(): Promise<Buffer> {
    const keyPath = path.join(app.getPath('userData'), '.key');
    if (await fs.pathExists(keyPath)) {
      const encrypted = await fs.readFile(keyPath);
      return Buffer.from(safeStorage.decryptString(encrypted), 'base64');
    }
    const key = crypto.randomBytes(32);
    const encrypted = safeStorage.encryptString(key.toString('base64'));
    await fs.writeFile(keyPath, encrypted);
    return key;
  }
  private generateId(): string {
    return `${Date.now()}-${crypto.randomBytes(8).toString('hex')}`;
  }
  async createConversation(title: string, metadata?: Record<string, any>): Promise<string> {
    const id = this.generateId();
    const now = Date.now();
    this.db.prepare(`
      INSERT INTO conversations (id, title, created_at, updated_at, metadata)
      VALUES (?, ?, ?, ?, ?)
    `).run(
      id,
      title,
      now,
      now,
      metadata ? JSON.stringify(metadata) : null
    );
    return id;
  }
  async saveMessage(conversationId: string, message: ChatMessage): Promise<void> {
    const encrypted = this.encrypt(message.content);
    this.db.prepare(`
      INSERT INTO messages (id, conversation_id, role, content_encrypted, timestamp)
      VALUES (?, ?, ?, ?, ?)
    `).run(
      message.id,
      conversationId,
      message.role,
      encrypted,
      message.timestamp
    );
    // Update conversation timestamp
    this.db.prepare(`
      UPDATE conversations 
      SET updated_at = ? 
      WHERE id = ?
    `).run(message.timestamp, conversationId);
  }
  async getConversation(id: string): Promise<ChatMessage[]> {
    const rows = this.db.prepare(`
      SELECT id, role, content_encrypted, timestamp
      FROM messages
      WHERE conversation_id = ?
      ORDER BY timestamp ASC
    `).all(id);
    return rows.map(row => ({
      id: row.id,
      role: row.role,
      content: this.decrypt(row.content_encrypted),
      timestamp: row.timestamp
    }));
  }
  async listConversations(): Promise<Conversation[]> {
    const rows = this.db.prepare(`
      SELECT id, title, created_at, updated_at, metadata
      FROM conversations
      ORDER BY updated_at DESC
    `).all();
    return rows.map(row => ({
      id: row.id,
      title: row.title,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      metadata: row.metadata ? JSON.parse(row.metadata) : undefined
    }));
  }
  async deleteConversation(id: string): Promise<void> {
    this.db.prepare('DELETE FROM messages WHERE conversation_id = ?').run(id);
    this.db.prepare('DELETE FROM conversations WHERE id = ?').run(id);
  }
  async updateConversationTitle(id: string, title: string): Promise<void> {
    this.db.prepare(`
      UPDATE conversations 
      SET title = ?, updated_at = ? 
      WHERE id = ?
    `).run(title, Date.now(), id);
  }
  private encrypt(text: string): Buffer {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv);
    const encrypted = Buffer.concat([
      cipher.update(text, 'utf8'),
      cipher.final()
    ]);
    const authTag = cipher.getAuthTag();
    return Buffer.concat([iv, authTag, encrypted]);
  }
  private decrypt(data: Buffer): string {
    const iv = data.slice(0, 16);
    const authTag = data.slice(16, 32);
    const encrypted = data.slice(32);
    const decipher = crypto.createDecipheriv('aes-256-gcm', this.encryptionKey, iv);
    decipher.setAuthTag(authTag);
    return decipher.update(encrypted) + decipher.final('utf8');
  }
}
</file>

<file path="src/services/OllamaClient.d.ts">
interface OllamaResponse {
    content: string;
    model: string;
    created_at: string;
}
interface OllamaModel {
    name: string;
    size: number;
    digest: string;
    details: {
        format: string;
        family: string;
        parameter_size: string;
        quantization_level: string;
    };
}
export declare class OllamaClient {
    private baseUrl;
    private currentModel;
    private isConnected;
    constructor(baseUrl?: string);
    checkConnection(): Promise<boolean>;
    setModel(modelName: string): void;
    getCurrentModel(): string;
    generateResponse(prompt: string, onChunk?: (chunk: string) => void): Promise<OllamaResponse>;
    listModels(): Promise<OllamaModel[]>;
    pullModel(modelName: string, onProgress?: (progress: number) => void): Promise<void>;
}
export {};
</file>

<file path="src/services/OllamaClient.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OllamaClient = void 0;
const electron_1 = require("electron");
const node_fetch_1 = __importDefault(require("node-fetch"));
const BACKOFF_DELAYS = [1000, 2000, 3000]; // 1s  2s  3s
async function retryRequest(requestFn, maxAttempts = 3) {
    let lastError = null;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        try {
            return await requestFn();
        }
        catch (error) {
            lastError = error;
            if (attempt < maxAttempts - 1) {
                await new Promise(resolve => setTimeout(resolve, BACKOFF_DELAYS[attempt]));
            }
        }
    }
    throw lastError;
}
class OllamaClient {
    constructor(baseUrl = 'http://localhost:11434') {
        this.isConnected = false;
        this.baseUrl = baseUrl;
        this.currentModel = 'llama2';
    }
    async checkConnection() {
        try {
            console.log('[OllamaClient] Checking connection to Ollama at:', this.baseUrl);
            const response = await retryRequest(() => (0, node_fetch_1.default)(`${this.baseUrl}/api/tags`));
            this.isConnected = response.ok;
            console.log('[OllamaClient] Connection check result:', this.isConnected ? 'Connected' : 'Failed');
            return this.isConnected;
        }
        catch (error) {
            console.error('[OllamaClient] Connection check failed:', error);
            this.isConnected = false;
            // Emit event to notify the app that Ollama is unavailable
            electron_1.ipcMain.emit('ollama-unavailable', {
                error: error instanceof Error ? error.message : 'Unknown error',
                url: this.baseUrl
            });
            return false;
        }
    }
    setModel(modelName) {
        this.currentModel = modelName;
    }
    getCurrentModel() {
        return this.currentModel;
    }
    async generateResponse(prompt, onChunk) {
        try {
            const response = await retryRequest(() => (0, node_fetch_1.default)(`${this.baseUrl}/api/generate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: this.currentModel,
                    prompt,
                    stream: !!onChunk
                })
            }));
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            if (onChunk) {
                const reader = response.body.getReader();
                if (!reader)
                    throw new Error('Failed to get response reader');
                let fullResponse = '';
                while (true) {
                    const { done, value } = await reader.read();
                    if (done)
                        break;
                    const chunk = Buffer.from(value).toString();
                    const lines = chunk.split('\n').filter(Boolean);
                    for (const line of lines) {
                        try {
                            const data = JSON.parse(line);
                            if (data.response) {
                                fullResponse += data.response;
                                onChunk(data.response);
                            }
                        }
                        catch (e) {
                            console.error('Failed to parse chunk:', e);
                        }
                    }
                }
                return {
                    content: fullResponse,
                    model: this.currentModel,
                    created_at: new Date().toISOString()
                };
            }
            else {
                const data = await response.json();
                return {
                    content: data.response,
                    model: data.model,
                    created_at: new Date().toISOString()
                };
            }
        }
        catch (error) {
            console.error('[OllamaClient] Generate response failed:', error);
            electron_1.ipcMain.emit('ollama-unavailable');
            throw new Error('Failed to generate response from Ollama');
        }
    }
    async listModels() {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/tags`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data.models;
        }
        catch (error) {
            console.error('Failed to list Ollama models:', error);
            throw new Error('Failed to list Ollama models');
        }
    }
    async pullModel(modelName, onProgress) {
        try {
            const response = await (0, node_fetch_1.default)(`${this.baseUrl}/pull`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: modelName
                })
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            if (onProgress) {
                const reader = response.body.getReader();
                if (!reader)
                    throw new Error('Failed to get response reader');
                while (true) {
                    const { done, value } = await reader.read();
                    if (done)
                        break;
                    const chunk = new TextDecoder().decode(value);
                    const lines = chunk.split('\n').filter(Boolean);
                    for (const line of lines) {
                        try {
                            const data = JSON.parse(line);
                            if (data.status === 'pulling' && data.completed !== undefined) {
                                onProgress(data.completed);
                            }
                        }
                        catch (e) {
                            console.error('Failed to parse progress chunk:', e);
                        }
                    }
                }
            }
        }
        catch (error) {
            console.error('Failed to pull Ollama model:', error);
            throw new Error(`Failed to pull model: ${modelName}`);
        }
    }
}
exports.OllamaClient = OllamaClient;
//# sourceMappingURL=OllamaClient.js.map
</file>

<file path="src/services/OllamaClient.js.map">
{"version":3,"file":"OllamaClient.js","sourceRoot":"","sources":["OllamaClient.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/OllamaClient.ts">
import { ipcMain } from 'electron';
import fetch, { Response } from 'node-fetch';
import { Readable } from 'stream';
const BACKOFF_DELAYS = [1000, 2000, 3000]; // 1s  2s  3s
async function retryRequest<T>(
  requestFn: () => Promise<T>,
  maxAttempts: number = 3
): Promise<T> {
  let lastError: Error | null = null;
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      return await requestFn();
    } catch (error) {
      lastError = error as Error;
      if (attempt < maxAttempts - 1) {
        await new Promise(resolve => setTimeout(resolve, BACKOFF_DELAYS[attempt]));
      }
    }
  }
  throw lastError;
}
interface OllamaResponse {
  content: string;
  model: string;
  created_at: string;
}
interface OllamaModel {
  name: string;
  size: number;
  digest: string;
  details: {
    format: string;
    family: string;
    parameter_size: string;
    quantization_level: string;
  };
}
export class OllamaClient {
  private baseUrl: string;
  private currentModel: string;
  private isConnected: boolean = false;
  constructor(baseUrl: string = 'http://localhost:11434') {
    this.baseUrl = baseUrl;
    this.currentModel = 'llama2';
  }
  async checkConnection(): Promise<boolean> {
    try {
      console.log('[OllamaClient] Checking connection to Ollama at:', this.baseUrl);
      const response = await retryRequest(() => 
        fetch(`${this.baseUrl}/api/tags`)
      );
      this.isConnected = response.ok;
      console.log('[OllamaClient] Connection check result:', this.isConnected ? 'Connected' : 'Failed');
      return this.isConnected;
    } catch (error) {
      console.error('[OllamaClient] Connection check failed:', error);
      this.isConnected = false;
      // Emit event to notify the app that Ollama is unavailable
      ipcMain.emit('ollama-unavailable', { 
        error: error instanceof Error ? error.message : 'Unknown error',
        url: this.baseUrl
      });
      return false;
    }
  }
  setModel(modelName: string) {
    this.currentModel = modelName;
  }
  getCurrentModel(): string {
    return this.currentModel;
  }
  async generateResponse(prompt: string, onChunk?: (chunk: string) => void): Promise<OllamaResponse> {
    try {
      const response = await retryRequest(() =>
        fetch(`${this.baseUrl}/api/generate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: this.currentModel,
            prompt,
            stream: !!onChunk
          })
        })
      ) as Response;
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      if (onChunk) {
        const reader = (response.body as unknown as ReadableStream<Uint8Array>).getReader();
        if (!reader) throw new Error('Failed to get response reader');
        let fullResponse = '';
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = Buffer.from(value).toString();
          const lines = chunk.split('\n').filter(Boolean);
          for (const line of lines) {
            try {
              const data = JSON.parse(line);
              if (data.response) {
                fullResponse += data.response;
                onChunk(data.response);
              }
            } catch (e) {
              console.error('Failed to parse chunk:', e);
            }
          }
        }
        return {
          content: fullResponse,
          model: this.currentModel,
          created_at: new Date().toISOString()
        };
      } else {
        const data = await response.json();
        return {
          content: data.response,
          model: data.model,
          created_at: new Date().toISOString()
        };
      }
    } catch (error) {
      console.error('[OllamaClient] Generate response failed:', error);
      ipcMain.emit('ollama-unavailable');
      throw new Error('Failed to generate response from Ollama');
    }
  }
  async listModels(): Promise<OllamaModel[]> {
    try {
      const response = await fetch(`${this.baseUrl}/tags`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      return data.models;
    } catch (error) {
      console.error('Failed to list Ollama models:', error);
      throw new Error('Failed to list Ollama models');
    }
  }
  async pullModel(modelName: string, onProgress?: (progress: number) => void): Promise<void> {
    try {
      const response = await fetch(`${this.baseUrl}/pull`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: modelName
        })
      }) as Response;
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      if (onProgress) {
        const reader = (response.body as unknown as ReadableStream<Uint8Array>).getReader();
        if (!reader) throw new Error('Failed to get response reader');
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n').filter(Boolean);
          for (const line of lines) {
            try {
              const data = JSON.parse(line);
              if (data.status === 'pulling' && data.completed !== undefined) {
                onProgress(data.completed);
              }
            } catch (e) {
              console.error('Failed to parse progress chunk:', e);
            }
          }
        }
      }
    } catch (error) {
      console.error('Failed to pull Ollama model:', error);
      throw new Error(`Failed to pull model: ${modelName}`);
    }
  }
}
</file>

<file path="src/services/OllamaService.d.ts">
import { BaseService, ServiceConfig } from './Service';
export interface ModelLoadingState {
    status: 'loading' | 'loaded' | 'error';
    isLoading: boolean;
    modelName: string;
    progress: number;
    estimatedTimeRemaining?: number;
    error?: string;
}
export interface OllamaResponse {
    model: string;
    created_at: string;
    response: string;
    done: boolean;
}
export interface OllamaEmbeddingResponse {
    embedding: number[];
}
export declare class OllamaService extends BaseService {
    private client;
    private currentModel;
    private fallbackResponses;
    private responseMonitor;
    private eventEmitter;
    private static instance;
    private readonly BASE_URL;
    private isInitialized;
    constructor(config: ServiceConfig);
    static getInstance(): OllamaService;
    protected initialize(): Promise<void>;
    isAvailable(): Promise<boolean>;
    protected cleanup(): Promise<void>;
    protected checkHealth(): Promise<boolean>;
    private getFallbackResponse;
    listModels(): Promise<string[]>;
    setModel(modelName: string): Promise<void>;
    getCurrentModel(): string;
    cancelLoad(): Promise<void>;
    private callOllama;
    generateResponse(prompt: string, context: string): Promise<string>;
    private handleTruncation;
    private handleHallucinations;
    private shortenPrompt;
    private reinforceContext;
    private estimateTokenCount;
    isServiceAvailable(): boolean;
    getConnectionStatus(): {
        isConnected: boolean;
        isFallbackMode: boolean;
        lastSuccessfulConnection: number;
        connectionAttempts: number;
    };
    pullModel(modelName: string): Promise<void>;
    generateEmbedding(text: string, modelName: string): Promise<OllamaEmbeddingResponse>;
}
</file>

<file path="src/services/OllamaService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OllamaService = void 0;
const uuid_1 = require("uuid");
const events_1 = require("events");
const OllamaClient_1 = require("./OllamaClient");
const logger_1 = require("../utils/logger");
const chat_1 = require("@shared/types/chat");
const responseMonitor_1 = require("../utils/responseMonitor");
const Service_1 = require("./Service");
class OllamaService extends Service_1.BaseService {
    constructor(config) {
        super(config);
        this.fallbackResponses = new Map([
            ['error', 'I apologize, but I am currently unable to process your request. The Ollama service is temporarily unavailable.'],
            ['greeting', 'Hello! I am currently operating in limited mode. Some features may be unavailable.'],
            ['help', 'I can help you with basic tasks, but advanced features are currently unavailable due to service limitations.']
        ]);
        this.BASE_URL = 'http://localhost:11434';
        this.isInitialized = false;
        this.client = new OllamaClient_1.OllamaClient();
        this.currentModel = '';
        this.responseMonitor = responseMonitor_1.ResponseMonitor.getInstance();
        this.eventEmitter = new events_1.EventEmitter();
        // Forward model loading state changes from the client
        this.eventEmitter.on('modelLoading', (model) => {
            this.emit('modelLoading', model);
        });
        this.eventEmitter.on('modelLoaded', (model) => {
            this.emit('modelLoaded', model);
        });
    }
    static getInstance() {
        if (!OllamaService.instance) {
            OllamaService.instance = new OllamaService({
                name: 'ollama',
                autoStart: true,
                restartOnCrash: true,
                maxRestarts: 3,
                restartDelay: 1000,
            });
        }
        return OllamaService.instance;
    }
    async initialize() {
        if (this.isInitialized)
            return;
        try {
            logger_1.logger.info('Initializing OllamaService');
            const isAvailable = await this.isAvailable();
            if (!isAvailable) {
                throw new Error('Ollama service is not available');
            }
            this.isInitialized = true;
            this.emit('initialized');
            logger_1.logger.info('OllamaService initialized successfully');
        }
        catch (error) {
            logger_1.logger.error('Error initializing OllamaService:', error);
            throw error;
        }
    }
    async isAvailable() {
        try {
            const response = await fetch(`${this.BASE_URL}/api/tags`);
            return response.ok;
        }
        catch (error) {
            logger_1.logger.warn('Ollama service is not available:', error);
            return false;
        }
    }
    async cleanup() {
        if (!this.isInitialized)
            return;
        this.isInitialized = false;
    }
    async checkHealth() {
        return await this.isAvailable();
    }
    getFallbackResponse(message) {
        // Simple keyword matching for fallback responses
        const lowerMessage = message.toLowerCase();
        let responseType = 'error';
        if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
            responseType = 'greeting';
        }
        else if (lowerMessage.includes('help') || lowerMessage.includes('what can you do')) {
            responseType = 'help';
        }
        return {
            id: (0, uuid_1.v4)(),
            content: this.fallbackResponses.get(responseType) || this.fallbackResponses.get('error'),
            role: chat_1.Role.Assistant,
            timestamp: Date.now()
        };
    }
    async listModels() {
        try {
            const response = await fetch(`${this.BASE_URL}/api/tags`);
            if (!response.ok) {
                throw new Error(`Failed to list models: ${response.statusText}`);
            }
            const data = await response.json();
            return data.models.map((model) => model.name);
        }
        catch (error) {
            logger_1.logger.error('Error listing models:', error);
            throw error;
        }
    }
    async setModel(modelName) {
        try {
            this.client.setModel(modelName);
            this.currentModel = modelName;
        }
        catch (error) {
            this.logger.error('Error setting model:', error);
            throw error;
        }
    }
    getCurrentModel() {
        return this.currentModel;
    }
    async cancelLoad() {
        try {
            // No cancel load method in OllamaClient
        }
        catch (error) {
            this.logger.error('Error canceling load:', error);
            throw error;
        }
    }
    async callOllama(prompt) {
        const isConnected = await this.client.checkConnection();
        if (!isConnected) {
            throw new Error('Ollama service is not available');
        }
        const response = await this.client.generateResponse(prompt);
        return response.content;
    }
    async generateResponse(prompt, context) {
        const startTime = Date.now();
        try {
            // Get response from Ollama
            const response = await this.callOllama(prompt);
            // Analyze response quality
            const metrics = await this.responseMonitor.analyzeResponse(response, context, startTime, this.estimateTokenCount(response));
            // Handle quality issues
            if (metrics.isTruncated || metrics.potentialHallucinations.length > 0) {
                this.logger.warn('Response quality issues detected:', metrics);
                // If truncated, try to get a complete response
                if (metrics.isTruncated) {
                    return await this.handleTruncation(prompt, context);
                }
                // If hallucinations detected, try to get a more accurate response
                if (metrics.potentialHallucinations.length > 0) {
                    return await this.handleHallucinations(prompt, context, metrics);
                }
            }
            return response;
        }
        catch (error) {
            this.logger.error('Error generating response:', error);
            throw error;
        }
    }
    async handleTruncation(prompt, context) {
        // Implement truncation handling strategy
        this.logger.info('Handling truncated response...');
        // Try with a shorter prompt
        const shorterPrompt = this.shortenPrompt(prompt);
        return await this.callOllama(shorterPrompt);
    }
    async handleHallucinations(prompt, context, metrics) {
        // Implement hallucination handling strategy
        this.logger.info('Handling potential hallucinations...');
        // Try with reinforced context
        const reinforcedPrompt = this.reinforceContext(prompt, context);
        return await this.callOllama(reinforcedPrompt);
    }
    shortenPrompt(prompt) {
        // Implement prompt shortening logic
        return prompt.split('\n').slice(0, 3).join('\n');
    }
    reinforceContext(prompt, context) {
        // Implement context reinforcement logic
        return `${context}\n\n${prompt}`;
    }
    estimateTokenCount(text) {
        // Implement token estimation logic
        return Math.ceil(text.length / 4);
    }
    isServiceAvailable() {
        return this.status === Service_1.ServiceStatus.RUNNING;
    }
    getConnectionStatus() {
        return {
            isConnected: this.status === Service_1.ServiceStatus.RUNNING,
            isFallbackMode: this.status === Service_1.ServiceStatus.ERROR,
            lastSuccessfulConnection: this.startTime,
            connectionAttempts: this.restartAttempts
        };
    }
    async pullModel(modelName) {
        try {
            const response = await fetch(`${this.BASE_URL}/api/pull`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: modelName,
                }),
            });
            if (!response.ok) {
                throw new Error(`Failed to pull model: ${response.statusText}`);
            }
            const reader = response.body?.getReader();
            if (!reader) {
                throw new Error('Failed to get response reader');
            }
            while (true) {
                const { done, value } = await reader.read();
                if (done)
                    break;
                // Process streaming response if needed
            }
        }
        catch (error) {
            logger_1.logger.error('Error pulling model:', error);
            throw error;
        }
    }
    async generateEmbedding(text, modelName) {
        try {
            const response = await fetch(`${this.BASE_URL}/api/embeddings`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: modelName,
                    prompt: text,
                }),
            });
            if (!response.ok) {
                throw new Error(`Failed to generate embedding: ${response.statusText}`);
            }
            return await response.json();
        }
        catch (error) {
            logger_1.logger.error('Error generating embedding:', error);
            throw error;
        }
    }
}
exports.OllamaService = OllamaService;
//# sourceMappingURL=OllamaService.js.map
</file>

<file path="src/services/OllamaService.js.map">
{"version":3,"file":"OllamaService.js","sourceRoot":"","sources":["OllamaService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/OllamaService.ts">
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';
import { OllamaClient } from './OllamaClient';
import { logger } from '../utils/logger';
import { Role, ChatResponse } from '@shared/types/chat';
import { ResponseMonitor } from '../utils/responseMonitor';
import type { OllamaModel } from '@shared/types/ollama';
import { BaseService, ServiceConfig, ServiceStatus } from './Service';
export interface ModelLoadingState {
  status: 'loading' | 'loaded' | 'error';
  isLoading: boolean;
  modelName: string;
  progress: number;
  estimatedTimeRemaining?: number;
  error?: string;
}
export interface OllamaResponse {
  model: string;
  created_at: string;
  response: string;
  done: boolean;
}
export interface OllamaEmbeddingResponse {
  embedding: number[];
}
export class OllamaService extends BaseService {
  private client: OllamaClient;
  private currentModel: string;
  private fallbackResponses: Map<string, string> = new Map([
    ['error', 'I apologize, but I am currently unable to process your request. The Ollama service is temporarily unavailable.'],
    ['greeting', 'Hello! I am currently operating in limited mode. Some features may be unavailable.'],
    ['help', 'I can help you with basic tasks, but advanced features are currently unavailable due to service limitations.']
  ]);
  private responseMonitor: ResponseMonitor;
  private eventEmitter: EventEmitter;
  private static instance: OllamaService;
  private readonly BASE_URL = 'http://localhost:11434';
  private isInitialized = false;
  constructor(config: ServiceConfig) {
    super(config);
    this.client = new OllamaClient();
    this.currentModel = '';
    this.responseMonitor = ResponseMonitor.getInstance();
    this.eventEmitter = new EventEmitter();
    // Forward model loading state changes from the client
    this.eventEmitter.on('modelLoading', (model: string) => {
      this.emit('modelLoading', model);
    });
    this.eventEmitter.on('modelLoaded', (model: string) => {
      this.emit('modelLoaded', model);
    });
  }
  public static getInstance(): OllamaService {
    if (!OllamaService.instance) {
      OllamaService.instance = new OllamaService({
        name: 'ollama',
        autoStart: true,
        restartOnCrash: true,
        maxRestarts: 3,
        restartDelay: 1000,
      });
    }
    return OllamaService.instance;
  }
  protected async initialize(): Promise<void> {
    if (this.isInitialized) return;
    try {
      logger.info('Initializing OllamaService');
      const isAvailable = await this.isAvailable();
      if (!isAvailable) {
        throw new Error('Ollama service is not available');
      }
      this.isInitialized = true;
      this.emit('initialized');
      logger.info('OllamaService initialized successfully');
    } catch (error) {
      logger.error('Error initializing OllamaService:', error);
      throw error;
    }
  }
  async isAvailable(): Promise<boolean> {
    try {
      const response = await fetch(`${this.BASE_URL}/api/tags`);
      return response.ok;
    } catch (error) {
      logger.warn('Ollama service is not available:', error);
      return false;
    }
  }
  protected async cleanup(): Promise<void> {
    if (!this.isInitialized) return;
    this.isInitialized = false;
  }
  protected async checkHealth(): Promise<boolean> {
    return await this.isAvailable();
  }
  private getFallbackResponse(message: string): ChatResponse {
    // Simple keyword matching for fallback responses
    const lowerMessage = message.toLowerCase();
    let responseType = 'error';
    if (lowerMessage.includes('hello') || lowerMessage.includes('hi')) {
      responseType = 'greeting';
    } else if (lowerMessage.includes('help') || lowerMessage.includes('what can you do')) {
      responseType = 'help';
    }
    return {
      id: uuidv4(),
      content: this.fallbackResponses.get(responseType) || this.fallbackResponses.get('error')!,
      role: Role.Assistant,
      timestamp: Date.now()
    };
  }
  async listModels(): Promise<string[]> {
    try {
      const response = await fetch(`${this.BASE_URL}/api/tags`);
      if (!response.ok) {
        throw new Error(`Failed to list models: ${response.statusText}`);
      }
      const data = await response.json();
      return data.models.map((model: OllamaModel) => model.name);
    } catch (error) {
      logger.error('Error listing models:', error);
      throw error;
    }
  }
  async setModel(modelName: string): Promise<void> {
    try {
      this.client.setModel(modelName);
      this.currentModel = modelName;
    } catch (error) {
      this.logger.error('Error setting model:', error);
      throw error;
    }
  }
  getCurrentModel(): string {
    return this.currentModel;
  }
  async cancelLoad(): Promise<void> {
    try {
      // No cancel load method in OllamaClient
    } catch (error) {
      this.logger.error('Error canceling load:', error);
      throw error;
    }
  }
  private async callOllama(prompt: string): Promise<string> {
    const isConnected = await this.client.checkConnection();
    if (!isConnected) {
      throw new Error('Ollama service is not available');
    }
    const response = await this.client.generateResponse(prompt);
    return response.content;
  }
  async generateResponse(prompt: string, context: string): Promise<string> {
    const startTime = Date.now();
    try {
      // Get response from Ollama
      const response = await this.callOllama(prompt);
      // Analyze response quality
      const metrics = await this.responseMonitor.analyzeResponse(
        response,
        context,
        startTime,
        this.estimateTokenCount(response)
      );
      // Handle quality issues
      if (metrics.isTruncated || metrics.potentialHallucinations.length > 0) {
        this.logger.warn('Response quality issues detected:', metrics);
        // If truncated, try to get a complete response
        if (metrics.isTruncated) {
          return await this.handleTruncation(prompt, context);
        }
        // If hallucinations detected, try to get a more accurate response
        if (metrics.potentialHallucinations.length > 0) {
          return await this.handleHallucinations(prompt, context, metrics);
        }
      }
      return response;
    } catch (error) {
      this.logger.error('Error generating response:', error);
      throw error;
    }
  }
  private async handleTruncation(prompt: string, context: string): Promise<string> {
    // Implement truncation handling strategy
    this.logger.info('Handling truncated response...');
    // Try with a shorter prompt
    const shorterPrompt = this.shortenPrompt(prompt);
    return await this.callOllama(shorterPrompt);
  }
  private async handleHallucinations(
    prompt: string,
    context: string,
    metrics: any
  ): Promise<string> {
    // Implement hallucination handling strategy
    this.logger.info('Handling potential hallucinations...');
    // Try with reinforced context
    const reinforcedPrompt = this.reinforceContext(prompt, context);
    return await this.callOllama(reinforcedPrompt);
  }
  private shortenPrompt(prompt: string): string {
    // Implement prompt shortening logic
    return prompt.split('\n').slice(0, 3).join('\n');
  }
  private reinforceContext(prompt: string, context: string): string {
    // Implement context reinforcement logic
    return `${context}\n\n${prompt}`;
  }
  private estimateTokenCount(text: string): number {
    // Implement token estimation logic
    return Math.ceil(text.length / 4);
  }
  isServiceAvailable(): boolean {
    return this.status === ServiceStatus.RUNNING;
  }
  getConnectionStatus(): { 
    isConnected: boolean; 
    isFallbackMode: boolean; 
    lastSuccessfulConnection: number;
    connectionAttempts: number;
  } {
    return {
      isConnected: this.status === ServiceStatus.RUNNING,
      isFallbackMode: this.status === ServiceStatus.ERROR,
      lastSuccessfulConnection: this.startTime,
      connectionAttempts: this.restartAttempts
    };
  }
  async pullModel(modelName: string): Promise<void> {
    try {
      const response = await fetch(`${this.BASE_URL}/api/pull`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: modelName,
        }),
      });
      if (!response.ok) {
        throw new Error(`Failed to pull model: ${response.statusText}`);
      }
      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('Failed to get response reader');
      }
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        // Process streaming response if needed
      }
    } catch (error) {
      logger.error('Error pulling model:', error);
      throw error;
    }
  }
  async generateEmbedding(text: string, modelName: string): Promise<OllamaEmbeddingResponse> {
    try {
      const response = await fetch(`${this.BASE_URL}/api/embeddings`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: modelName,
          prompt: text,
        }),
      });
      if (!response.ok) {
        throw new Error(`Failed to generate embedding: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      logger.error('Error generating embedding:', error);
      throw error;
    }
  }
}
</file>

<file path="src/services/RAGService.d.ts">
import { BaseService, ServiceConfig } from './Service';
import { Document } from '../types/ipc';
export interface ChunkConfig {
    chunkSize: number;
    chunkOverlap: number;
}
export interface RAGConfig extends ServiceConfig {
    chunkConfig: ChunkConfig;
    embeddingModel: string;
}
interface SearchResult {
    text: string;
    score: number;
    metadata: Record<string, any>;
}
export declare class RAGService extends BaseService {
    private static instance;
    private embeddingService;
    private vectorStore;
    private chunkConfig;
    private embeddingModel;
    private constructor();
    static getInstance(): RAGService;
    protected initialize(): Promise<void>;
    private chunkText;
    addDocument(document: Document): Promise<void>;
    search(query: string, k?: number): Promise<SearchResult[]>;
    deleteDocument(documentId: string): Promise<void>;
    protected cleanup(): Promise<void>;
    protected checkHealth(): Promise<boolean>;
}
export {};
</file>

<file path="src/services/RAGService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RAGService = void 0;
const Service_1 = require("./Service");
const logger_1 = require("../utils/logger");
const EmbeddingService_1 = require("./EmbeddingService");
const VectorStoreService_1 = require("./VectorStoreService");
class RAGService extends Service_1.BaseService {
    constructor(config) {
        super(config);
        this.chunkConfig = config.chunkConfig;
        this.embeddingModel = config.embeddingModel;
        this.embeddingService = EmbeddingService_1.EmbeddingService.getInstance();
        this.vectorStore = VectorStoreService_1.VectorStoreService.getInstance();
    }
    static getInstance() {
        if (!RAGService.instance) {
            RAGService.instance = new RAGService({
                name: 'rag',
                autoStart: true,
                restartOnCrash: true,
                maxRestarts: 3,
                restartDelay: 1000,
                chunkConfig: {
                    chunkSize: 1000,
                    chunkOverlap: 200,
                },
                embeddingModel: 'nomic-embed-text',
            });
        }
        return RAGService.instance;
    }
    async initialize() {
        try {
            logger_1.logger.info('Initializing RAGService');
            await this.embeddingService.initialize();
            await this.vectorStore.initialize();
            logger_1.logger.info('RAGService initialized successfully');
        }
        catch (error) {
            logger_1.logger.error('Error initializing RAGService:', error);
            throw error;
        }
    }
    chunkText(text) {
        const chunks = [];
        let startIndex = 0;
        while (startIndex < text.length) {
            const endIndex = Math.min(startIndex + this.chunkConfig.chunkSize, text.length);
            chunks.push(text.slice(startIndex, endIndex));
            startIndex = endIndex - this.chunkConfig.chunkOverlap;
        }
        return chunks;
    }
    async addDocument(document) {
        try {
            logger_1.logger.info(`Adding document: ${document.id}`);
            const chunks = this.chunkText(document.content);
            for (const chunk of chunks) {
                const embedding = await this.embeddingService.generateEmbedding(chunk);
                await this.vectorStore.addDocument({
                    content: chunk,
                    metadata: {
                        ...document.metadata,
                        chunkIndex: chunks.indexOf(chunk),
                        totalChunks: chunks.length,
                        text: chunk,
                    },
                });
            }
            logger_1.logger.info(`Document ${document.id} added successfully`);
        }
        catch (error) {
            logger_1.logger.error(`Error adding document ${document.id}:`, error);
            throw error;
        }
    }
    async search(query, k = 5) {
        try {
            logger_1.logger.info(`Searching for: ${query}`);
            const results = await this.vectorStore.searchSimilar(query, k);
            return results.map((result) => ({
                text: result.content,
                score: 1.0, // TODO: Implement proper scoring
                metadata: result.metadata,
            }));
        }
        catch (error) {
            logger_1.logger.error('Error searching:', error);
            throw error;
        }
    }
    async deleteDocument(documentId) {
        try {
            logger_1.logger.info(`Deleting document: ${documentId}`);
            await this.vectorStore.deleteDocument(documentId);
            logger_1.logger.info(`Document ${documentId} deleted successfully`);
        }
        catch (error) {
            logger_1.logger.error(`Error deleting document ${documentId}:`, error);
            throw error;
        }
    }
    async cleanup() {
        try {
            await this.vectorStore.cleanup();
            logger_1.logger.info('RAGService cleaned up successfully');
        }
        catch (error) {
            logger_1.logger.error('Error cleaning up RAGService:', error);
            throw error;
        }
    }
    async checkHealth() {
        try {
            const stats = await this.vectorStore.getStats();
            return stats.totalDocuments > 0;
        }
        catch (error) {
            logger_1.logger.error('Health check failed:', error);
            return false;
        }
    }
}
exports.RAGService = RAGService;
//# sourceMappingURL=RAGService.js.map
</file>

<file path="src/services/RAGService.js.map">
{"version":3,"file":"RAGService.js","sourceRoot":"","sources":["RAGService.ts"],"names":[],"mappings":";;;AAAA,uCAAuD;AACvD,4CAAyC;AACzC,yDAAsD;AACtD,6DAA0D;AAmB1D,MAAa,UAAW,SAAQ,qBAAW;IAOzC,YAAoB,MAAiB;QACnC,KAAK,CAAC,MAAM,CAAC,CAAC;QACd,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,WAAW,CAAC;QACtC,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;QAC5C,IAAI,CAAC,gBAAgB,GAAG,mCAAgB,CAAC,WAAW,EAAE,CAAC;QACvD,IAAI,CAAC,WAAW,GAAG,uCAAkB,CAAC,WAAW,EAAE,CAAC;IACtD,CAAC;IAEM,MAAM,CAAC,WAAW;QACvB,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;YACzB,UAAU,CAAC,QAAQ,GAAG,IAAI,UAAU,CAAC;gBACnC,IAAI,EAAE,KAAK;gBACX,SAAS,EAAE,IAAI;gBACf,cAAc,EAAE,IAAI;gBACpB,WAAW,EAAE,CAAC;gBACd,YAAY,EAAE,IAAI;gBAClB,WAAW,EAAE;oBACX,SAAS,EAAE,IAAI;oBACf,YAAY,EAAE,GAAG;iBAClB;gBACD,cAAc,EAAE,kBAAkB;aACnC,CAAC,CAAC;QACL,CAAC;QACD,OAAO,UAAU,CAAC,QAAQ,CAAC;IAC7B,CAAC;IAES,KAAK,CAAC,UAAU;QACxB,IAAI,CAAC;YACH,eAAM,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAC;YACvC,MAAM,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,CAAC;YACzC,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC;YACpC,eAAM,CAAC,IAAI,CAAC,qCAAqC,CAAC,CAAC;QACrD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,gCAAgC,EAAE,KAAK,CAAC,CAAC;YACtD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAEO,SAAS,CAAC,IAAY;QAC5B,MAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,IAAI,UAAU,GAAG,CAAC,CAAC;QAEnB,OAAO,UAAU,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;YAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CACvB,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EACvC,IAAI,CAAC,MAAM,CACZ,CAAC;YACF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC;YAC9C,UAAU,GAAG,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC;QACxD,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,QAAkB;QAClC,IAAI,CAAC;YACH,eAAM,CAAC,IAAI,CAAC,oBAAoB,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC;YAC/C,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YAEhD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;gBAC3B,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;gBAEvE,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC;oBACjC,OAAO,EAAE,KAAK;oBACd,QAAQ,EAAE;wBACR,GAAG,QAAQ,CAAC,QAAQ;wBACpB,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;wBACjC,WAAW,EAAE,MAAM,CAAC,MAAM;wBAC1B,IAAI,EAAE,KAAK;qBACZ;iBACF,CAAC,CAAC;YACL,CAAC;YAED,eAAM,CAAC,IAAI,CAAC,YAAY,QAAQ,CAAC,EAAE,qBAAqB,CAAC,CAAC;QAC5D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,yBAAyB,QAAQ,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YAC7D,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,KAAa,EAAE,IAAY,CAAC;QACvC,IAAI,CAAC;YACH,eAAM,CAAC,IAAI,CAAC,kBAAkB,KAAK,EAAE,CAAC,CAAC;YACvC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YAE/D,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;gBAC9B,IAAI,EAAE,MAAM,CAAC,OAAO;gBACpB,KAAK,EAAE,GAAG,EAAE,iCAAiC;gBAC7C,QAAQ,EAAE,MAAM,CAAC,QAAQ;aAC1B,CAAC,CAAC,CAAC;QACN,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,kBAAkB,EAAE,KAAK,CAAC,CAAC;YACxC,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,UAAkB;QACrC,IAAI,CAAC;YACH,eAAM,CAAC,IAAI,CAAC,sBAAsB,UAAU,EAAE,CAAC,CAAC;YAChD,MAAM,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAClD,eAAM,CAAC,IAAI,CAAC,YAAY,UAAU,uBAAuB,CAAC,CAAC;QAC7D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,2BAA2B,UAAU,GAAG,EAAE,KAAK,CAAC,CAAC;YAC9D,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAES,KAAK,CAAC,OAAO;QACrB,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;YACjC,eAAM,CAAC,IAAI,CAAC,oCAAoC,CAAC,CAAC;QACpD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,+BAA+B,EAAE,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAES,KAAK,CAAC,WAAW;QACzB,IAAI,CAAC;YACH,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC;YAChD,OAAO,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC;QAClC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,eAAM,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;YAC5C,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;CACF;AArID,gCAqIC"}
</file>

<file path="src/services/RAGService.ts">
import { BaseService, ServiceConfig } from './Service';
import { logger } from '../utils/logger';
import { EmbeddingService } from './EmbeddingService';
import { VectorStoreService } from './VectorStoreService';
import { Document } from '@shared/types/ipc';
export interface ChunkConfig {
  chunkSize: number;
  chunkOverlap: number;
}
export interface RAGConfig extends ServiceConfig {
  chunkConfig: ChunkConfig;
  embeddingModel: string;
}
interface SearchResult {
  text: string;
  score: number;
  metadata: Record<string, any>;
}
export class RAGService extends BaseService {
  private static instance: RAGService;
  private embeddingService: EmbeddingService;
  private vectorStore: VectorStoreService;
  private chunkConfig: ChunkConfig;
  private embeddingModel: string;
  private constructor(config: RAGConfig) {
    super(config);
    this.chunkConfig = config.chunkConfig;
    this.embeddingModel = config.embeddingModel;
    this.embeddingService = EmbeddingService.getInstance();
    this.vectorStore = VectorStoreService.getInstance();
  }
  public static getInstance(): RAGService {
    if (!RAGService.instance) {
      RAGService.instance = new RAGService({
        name: 'rag',
        autoStart: true,
        restartOnCrash: true,
        maxRestarts: 3,
        restartDelay: 1000,
        chunkConfig: {
          chunkSize: 1000,
          chunkOverlap: 200,
        },
        embeddingModel: 'nomic-embed-text',
      });
    }
    return RAGService.instance;
  }
  protected async initialize(): Promise<void> {
    try {
      logger.info('Initializing RAGService');
      await this.embeddingService.initialize();
      await this.vectorStore.initialize();
      logger.info('RAGService initialized successfully');
    } catch (error) {
      logger.error('Error initializing RAGService:', error);
      throw error;
    }
  }
  private chunkText(text: string): string[] {
    const chunks: string[] = [];
    let startIndex = 0;
    while (startIndex < text.length) {
      const endIndex = Math.min(
        startIndex + this.chunkConfig.chunkSize,
        text.length
      );
      chunks.push(text.slice(startIndex, endIndex));
      startIndex = endIndex - this.chunkConfig.chunkOverlap;
    }
    return chunks;
  }
  async addDocument(document: Document): Promise<void> {
    try {
      logger.info(`Adding document: ${document.id}`);
      const chunks = this.chunkText(document.content);
      for (const chunk of chunks) {
        const embedding = await this.embeddingService.generateEmbedding(chunk);
        await this.vectorStore.addDocument({
          content: chunk,
          metadata: {
            ...document.metadata,
            chunkIndex: chunks.indexOf(chunk),
            totalChunks: chunks.length,
            text: chunk,
          },
        });
      }
      logger.info(`Document ${document.id} added successfully`);
    } catch (error) {
      logger.error(`Error adding document ${document.id}:`, error);
      throw error;
    }
  }
  async search(query: string, k: number = 5): Promise<SearchResult[]> {
    try {
      logger.info(`Searching for: ${query}`);
      const results = await this.vectorStore.searchSimilar(query, k);
      return results.map((result) => ({
        text: result.content,
        score: 1.0, // TODO: Implement proper scoring
        metadata: result.metadata,
      }));
    } catch (error) {
      logger.error('Error searching:', error);
      throw error;
    }
  }
  async deleteDocument(documentId: string): Promise<void> {
    try {
      logger.info(`Deleting document: ${documentId}`);
      await this.vectorStore.deleteDocument(documentId);
      logger.info(`Document ${documentId} deleted successfully`);
    } catch (error) {
      logger.error(`Error deleting document ${documentId}:`, error);
      throw error;
    }
  }
  protected async cleanup(): Promise<void> {
    try {
      await this.vectorStore.cleanup();
      logger.info('RAGService cleaned up successfully');
    } catch (error) {
      logger.error('Error cleaning up RAGService:', error);
      throw error;
    }
  }
  protected async checkHealth(): Promise<boolean> {
    try {
      const stats = await this.vectorStore.getStats();
      return stats.totalDocuments > 0;
    } catch (error) {
      logger.error('Health check failed:', error);
      return false;
    }
  }
}
</file>

<file path="src/services/RAGWorker.d.ts">
import { BaseService, ServiceConfig } from './Service';
export interface RAGTask {
    id: string;
    type: 'embed' | 'search' | 'chunk' | 'process';
    data: any;
    priority: number;
}
export interface RAGWorkerConfig extends ServiceConfig {
    maxWorkers: number;
    taskQueueSize: number;
    workerTimeout: number;
    retryAttempts: number;
}
export declare class RAGWorker extends BaseService {
    private workers;
    private taskQueue;
    private activeTasks;
    private config;
    constructor(config: RAGWorkerConfig);
    protected initialize(): Promise<void>;
    protected cleanup(): Promise<void>;
    protected checkHealth(): Promise<boolean>;
    submitTask(task: RAGTask): Promise<string>;
    private processNextTask;
    private handleWorkerMessage;
    private handleWorkerError;
    private handleWorkerExit;
    private handleTaskTimeout;
    getMetrics(): Promise<any>;
}
</file>

<file path="src/services/RAGWorker.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RAGWorker = void 0;
const worker_threads_1 = require("worker_threads");
const Service_1 = require("./Service");
const path_1 = __importDefault(require("path"));
class RAGWorker extends Service_1.BaseService {
    constructor(config) {
        super(config);
        this.workers = [];
        this.taskQueue = [];
        this.activeTasks = new Map();
        this.config = {
            maxWorkers: 4,
            taskQueueSize: 100,
            workerTimeout: 30000,
            retryAttempts: 3,
            ...config
        };
    }
    async initialize() {
        try {
            // Initialize worker pool
            for (let i = 0; i < this.config.maxWorkers; i++) {
                const worker = new worker_threads_1.Worker(path_1.default.join(__dirname, 'workers', 'ragWorker.js'), {
                    workerData: {
                        workerId: i,
                        config: this.config
                    }
                });
                worker.on('message', this.handleWorkerMessage.bind(this));
                worker.on('error', this.handleWorkerError.bind(this));
                worker.on('exit', this.handleWorkerExit.bind(this));
                this.workers.push(worker);
            }
            this.logger.info(`RAGWorker initialized with ${this.config.maxWorkers} workers`);
        }
        catch (error) {
            this.logger.error('Failed to initialize RAGWorker:', error);
            throw error;
        }
    }
    async cleanup() {
        try {
            // Terminate all workers
            await Promise.all(this.workers.map(worker => worker.terminate()));
            this.workers = [];
            this.taskQueue = [];
            this.activeTasks.clear();
        }
        catch (error) {
            this.logger.error('Error cleaning up RAGWorker:', error);
            throw error;
        }
    }
    async checkHealth() {
        try {
            // Check if workers are responsive
            const healthChecks = this.workers.map(worker => new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(false), 5000);
                worker.postMessage({ type: 'health_check' });
                worker.once('message', (msg) => {
                    if (msg.type === 'health_check_response') {
                        clearTimeout(timeout);
                        resolve(true);
                    }
                });
            }));
            const results = await Promise.all(healthChecks);
            return results.every(healthy => healthy);
        }
        catch (error) {
            this.logger.error('Health check failed:', error);
            return false;
        }
    }
    async submitTask(task) {
        if (this.taskQueue.length >= this.config.taskQueueSize) {
            throw new Error('Task queue is full');
        }
        this.taskQueue.push(task);
        this.processNextTask();
        return task.id;
    }
    async processNextTask() {
        if (this.taskQueue.length === 0)
            return;
        const availableWorker = this.workers.find(worker => !Array.from(this.activeTasks.values()).some(task => task.workerId === worker.threadId));
        if (!availableWorker)
            return;
        const task = this.taskQueue.shift();
        this.activeTasks.set(task.id, { ...task, workerId: availableWorker.threadId });
        availableWorker.postMessage({
            type: 'task',
            task
        });
        // Set timeout for task
        setTimeout(() => {
            if (this.activeTasks.has(task.id)) {
                this.handleTaskTimeout(task.id);
            }
        }, this.config.workerTimeout);
    }
    handleWorkerMessage(message) {
        if (message.type === 'task_complete') {
            const task = this.activeTasks.get(message.taskId);
            if (task) {
                this.activeTasks.delete(message.taskId);
                this.emit('taskComplete', {
                    taskId: message.taskId,
                    result: message.result
                });
                this.processNextTask();
            }
        }
    }
    handleWorkerError(error) {
        this.logger.error('Worker error:', error);
        this.emit('workerError', error);
    }
    handleWorkerExit(code) {
        this.logger.warn(`Worker exited with code ${code}`);
        this.emit('workerExit', code);
    }
    handleTaskTimeout(taskId) {
        const task = this.activeTasks.get(taskId);
        if (task) {
            this.activeTasks.delete(taskId);
            this.emit('taskTimeout', taskId);
            if (task.retryCount < this.config.retryAttempts) {
                this.taskQueue.push({
                    ...task,
                    retryCount: (task.retryCount || 0) + 1
                });
                this.processNextTask();
            }
        }
    }
    getMetrics() {
        return Promise.resolve({
            activeTasks: this.activeTasks.size,
            queuedTasks: this.taskQueue.length,
            workerCount: this.workers.length
        });
    }
}
exports.RAGWorker = RAGWorker;
//# sourceMappingURL=RAGWorker.js.map
</file>

<file path="src/services/RAGWorker.js.map">
{"version":3,"file":"RAGWorker.js","sourceRoot":"","sources":["RAGWorker.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/RAGWorker.ts">
import { Worker } from 'worker_threads';
import { BaseService, ServiceConfig } from './Service';
import { logger } from '../utils/logger';
import path from 'path';
import { app } from 'electron';
export interface RAGTask {
  id: string;
  type: 'embed' | 'search' | 'chunk' | 'process';
  data: any;
  priority: number;
}
export interface RAGWorkerConfig extends ServiceConfig {
  maxWorkers: number;
  taskQueueSize: number;
  workerTimeout: number;
  retryAttempts: number;
}
export class RAGWorker extends BaseService {
  private workers: Worker[] = [];
  private taskQueue: RAGTask[] = [];
  private activeTasks: Map<string, RAGTask> = new Map();
  private config: RAGWorkerConfig;
  constructor(config: RAGWorkerConfig) {
    super(config);
    this.config = {
      maxWorkers: 4,
      taskQueueSize: 100,
      workerTimeout: 30000,
      retryAttempts: 3,
      ...config
    };
  }
  protected async initialize(): Promise<void> {
    try {
      // Initialize worker pool
      for (let i = 0; i < this.config.maxWorkers; i++) {
        const worker = new Worker(
          path.join(__dirname, 'workers', 'ragWorker.js'),
          {
            workerData: {
              workerId: i,
              config: this.config
            }
          }
        );
        worker.on('message', this.handleWorkerMessage.bind(this));
        worker.on('error', this.handleWorkerError.bind(this));
        worker.on('exit', this.handleWorkerExit.bind(this));
        this.workers.push(worker);
      }
      this.logger.info(`RAGWorker initialized with ${this.config.maxWorkers} workers`);
    } catch (error) {
      this.logger.error('Failed to initialize RAGWorker:', error);
      throw error;
    }
  }
  protected async cleanup(): Promise<void> {
    try {
      // Terminate all workers
      await Promise.all(
        this.workers.map(worker => worker.terminate())
      );
      this.workers = [];
      this.taskQueue = [];
      this.activeTasks.clear();
    } catch (error) {
      this.logger.error('Error cleaning up RAGWorker:', error);
      throw error;
    }
  }
  protected async checkHealth(): Promise<boolean> {
    try {
      // Check if workers are responsive
      const healthChecks = this.workers.map(worker => 
        new Promise<boolean>((resolve) => {
          const timeout = setTimeout(() => resolve(false), 5000);
          worker.postMessage({ type: 'health_check' });
          worker.once('message', (msg) => {
            if (msg.type === 'health_check_response') {
              clearTimeout(timeout);
              resolve(true);
            }
          });
        })
      );
      const results = await Promise.all(healthChecks);
      return results.every(healthy => healthy);
    } catch (error) {
      this.logger.error('Health check failed:', error);
      return false;
    }
  }
  public async submitTask(task: RAGTask): Promise<string> {
    if (this.taskQueue.length >= this.config.taskQueueSize) {
      throw new Error('Task queue is full');
    }
    this.taskQueue.push(task);
    this.processNextTask();
    return task.id;
  }
  private async processNextTask(): Promise<void> {
    if (this.taskQueue.length === 0) return;
    const availableWorker = this.workers.find(worker => 
      !Array.from(this.activeTasks.values()).some(task => 
        task.workerId === worker.threadId
      )
    );
    if (!availableWorker) return;
    const task = this.taskQueue.shift()!;
    this.activeTasks.set(task.id, { ...task, workerId: availableWorker.threadId });
    availableWorker.postMessage({
      type: 'task',
      task
    });
    // Set timeout for task
    setTimeout(() => {
      if (this.activeTasks.has(task.id)) {
        this.handleTaskTimeout(task.id);
      }
    }, this.config.workerTimeout);
  }
  private handleWorkerMessage(message: any): void {
    if (message.type === 'task_complete') {
      const task = this.activeTasks.get(message.taskId);
      if (task) {
        this.activeTasks.delete(message.taskId);
        this.emit('taskComplete', {
          taskId: message.taskId,
          result: message.result
        });
        this.processNextTask();
      }
    }
  }
  private handleWorkerError(error: Error): void {
    this.logger.error('Worker error:', error);
    this.emit('workerError', error);
  }
  private handleWorkerExit(code: number): void {
    this.logger.warn(`Worker exited with code ${code}`);
    this.emit('workerExit', code);
  }
  private handleTaskTimeout(taskId: string): void {
    const task = this.activeTasks.get(taskId);
    if (task) {
      this.activeTasks.delete(taskId);
      this.emit('taskTimeout', taskId);
      if (task.retryCount < this.config.retryAttempts) {
        this.taskQueue.push({
          ...task,
          retryCount: (task.retryCount || 0) + 1
        });
        this.processNextTask();
      }
    }
  }
  public getMetrics(): Promise<any> {
    return Promise.resolve({
      activeTasks: this.activeTasks.size,
      queuedTasks: this.taskQueue.length,
      workerCount: this.workers.length
    });
  }
}
</file>

<file path="src/services/Service.d.ts">
import { EventEmitter } from 'events';
import { ErrorHandler } from '../utils/errors';
import { logger as defaultLogger } from '../utils/logger';
export declare enum ServiceStatus {
    STOPPED = "stopped",
    STARTING = "starting",
    RUNNING = "running",
    ERROR = "error",
    STOPPING = "stopping"
}
export interface ServiceConfig {
    name: string;
    autoStart?: boolean;
    restartOnCrash?: boolean;
    maxRestarts?: number;
    restartDelay?: number;
    environment?: string[];
    dependencies?: string[];
    config?: Record<string, any>;
}
export interface ServiceMetrics {
    uptime: number;
    memoryUsage: number;
    cpuUsage: number;
    lastError?: Error;
    restartCount: number;
}
export interface ServiceEvents {
    status: (status: ServiceStatus) => void;
    error: (error: Error) => void;
    metrics: (metrics: ServiceMetrics) => void;
    log: (message: string, level: string) => void;
}
export interface Service extends EventEmitter {
    readonly name: string;
    readonly status: ServiceStatus;
    readonly metrics: ServiceMetrics;
    readonly config: ServiceConfig;
    start(): Promise<void>;
    stop(): Promise<void>;
    restart(): Promise<void>;
    getStatus(): Promise<ServiceStatus>;
    getMetrics(): Promise<ServiceMetrics>;
    isHealthy(): Promise<boolean>;
}
export declare abstract class BaseService extends EventEmitter implements Service {
    status: ServiceStatus;
    metrics: ServiceMetrics;
    readonly config: ServiceConfig;
    readonly logger: typeof defaultLogger;
    protected startTime: number;
    protected errorHandler: ErrorHandler;
    protected restartAttempts: number;
    protected healthCheckInterval?: NodeJS.Timeout;
    constructor(config: ServiceConfig, logger?: import("../utils/logger").Logger);
    get name(): string;
    get currentStatus(): ServiceStatus;
    get currentMetrics(): ServiceMetrics;
    start(): Promise<void>;
    stop(): Promise<void>;
    restart(): Promise<void>;
    getStatus(): Promise<ServiceStatus>;
    getMetrics(): Promise<ServiceMetrics>;
    isHealthy(): Promise<boolean>;
    protected abstract initialize(): Promise<void>;
    protected abstract cleanup(): Promise<void>;
    protected abstract checkHealth(): Promise<boolean>;
    protected validateDependencies(): Promise<void>;
    protected handleError(error: unknown): void;
    private startHealthCheck;
    private stopHealthCheck;
}
</file>

<file path="src/services/Service.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseService = exports.ServiceStatus = void 0;
const events_1 = require("events");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
var ServiceStatus;
(function (ServiceStatus) {
    ServiceStatus["STOPPED"] = "stopped";
    ServiceStatus["STARTING"] = "starting";
    ServiceStatus["RUNNING"] = "running";
    ServiceStatus["ERROR"] = "error";
    ServiceStatus["STOPPING"] = "stopping";
})(ServiceStatus || (exports.ServiceStatus = ServiceStatus = {}));
class BaseService extends events_1.EventEmitter {
    constructor(config, logger = logger_1.logger) {
        super();
        this.status = ServiceStatus.STOPPED;
        this.metrics = {
            uptime: 0,
            memoryUsage: 0,
            cpuUsage: 0,
            restartCount: 0
        };
        this.startTime = 0;
        this.restartAttempts = 0;
        this.config = config;
        this.logger = logger;
        this.errorHandler = errors_1.ErrorHandler.getInstance();
    }
    get name() {
        return this.config.name;
    }
    get currentStatus() {
        return this.status;
    }
    get currentMetrics() {
        return this.metrics;
    }
    async start() {
        if (this.status === ServiceStatus.RUNNING) {
            return;
        }
        try {
            this.status = ServiceStatus.STARTING;
            this.emit('status', this.status);
            await this.validateDependencies();
            await this.initialize();
            this.status = ServiceStatus.RUNNING;
            this.startTime = Date.now();
            this.restartAttempts = 0;
            this.emit('status', this.status);
            this.startHealthCheck();
            this.logger.info(`Service ${this.name} started successfully`);
        }
        catch (error) {
            this.handleError(error);
            throw error;
        }
    }
    async stop() {
        if (this.status === ServiceStatus.STOPPED) {
            return;
        }
        try {
            this.status = ServiceStatus.STOPPING;
            this.emit('status', this.status);
            this.stopHealthCheck();
            await this.cleanup();
            this.status = ServiceStatus.STOPPED;
            this.emit('status', this.status);
            this.logger.info(`Service ${this.name} stopped successfully`);
        }
        catch (error) {
            this.handleError(error);
            throw error;
        }
    }
    async restart() {
        await this.stop();
        await this.start();
    }
    async getStatus() {
        return this.status;
    }
    async getMetrics() {
        const currentTime = Date.now();
        this.metrics.uptime = this.startTime ? currentTime - this.startTime : 0;
        const processMetrics = process.memoryUsage();
        this.metrics.memoryUsage = processMetrics.heapUsed;
        return this.metrics;
    }
    async isHealthy() {
        try {
            return await this.checkHealth();
        }
        catch (error) {
            this.handleError(error);
            return false;
        }
    }
    async validateDependencies() {
        if (!this.config.dependencies?.length) {
            return;
        }
        for (const dep of this.config.dependencies) {
            // This will be implemented by ServiceManager
            // to check if dependent services are running
        }
    }
    handleError(error) {
        const serviceError = new errors_1.ServiceError(error instanceof Error ? error.message : 'Unknown error', errors_1.ErrorSeverity.HIGH, { serviceName: this.name });
        this.errorHandler.handleError(serviceError);
        this.metrics.lastError = serviceError;
        this.emit('error', serviceError);
        if (this.config.restartOnCrash &&
            this.restartAttempts < (this.config.maxRestarts || 3)) {
            this.restartAttempts++;
            setTimeout(() => this.restart(), this.config.restartDelay || 5000);
        }
    }
    startHealthCheck() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(async () => {
            const isHealthy = await this.isHealthy();
            if (!isHealthy) {
                this.handleError(new Error('Health check failed'));
            }
        }, 30000); // Check every 30 seconds
    }
    stopHealthCheck() {
        if (this.healthCheckInterval) {
            clearInterval(this.healthCheckInterval);
            this.healthCheckInterval = undefined;
        }
    }
}
exports.BaseService = BaseService;
//# sourceMappingURL=Service.js.map
</file>

<file path="src/services/Service.js.map">
{"version":3,"file":"Service.js","sourceRoot":"","sources":["Service.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/Service.ts">
import { EventEmitter } from 'events';
import { ErrorHandler, ServiceError, ErrorSeverity } from '../utils/errors';
import { logger as defaultLogger } from '../utils/logger';
export enum ServiceStatus {
  STOPPED = 'stopped',
  STARTING = 'starting',
  RUNNING = 'running',
  ERROR = 'error',
  STOPPING = 'stopping'
}
export interface ServiceConfig {
  name: string;
  autoStart?: boolean;
  restartOnCrash?: boolean;
  maxRestarts?: number;
  restartDelay?: number;
  environment?: string[];
  dependencies?: string[];
  config?: Record<string, any>;
}
export interface ServiceMetrics {
  uptime: number;
  memoryUsage: number;
  cpuUsage: number;
  lastError?: Error;
  restartCount: number;
}
export interface ServiceEvents {
  status: (status: ServiceStatus) => void;
  error: (error: Error) => void;
  metrics: (metrics: ServiceMetrics) => void;
  log: (message: string, level: string) => void;
}
export interface Service extends EventEmitter {
  readonly name: string;
  readonly status: ServiceStatus;
  readonly metrics: ServiceMetrics;
  readonly config: ServiceConfig;
  start(): Promise<void>;
  stop(): Promise<void>;
  restart(): Promise<void>;
  getStatus(): Promise<ServiceStatus>;
  getMetrics(): Promise<ServiceMetrics>;
  isHealthy(): Promise<boolean>;
}
export abstract class BaseService extends EventEmitter implements Service {
  public status: ServiceStatus = ServiceStatus.STOPPED;
  public metrics: ServiceMetrics = {
    uptime: 0,
    memoryUsage: 0,
    cpuUsage: 0,
    restartCount: 0
  };
  public readonly config: ServiceConfig;
  public readonly logger: typeof defaultLogger;
  protected startTime: number = 0;
  protected errorHandler: ErrorHandler;
  protected restartAttempts: number = 0;
  protected healthCheckInterval?: NodeJS.Timeout;
  constructor(
    config: ServiceConfig,
    logger = defaultLogger
  ) {
    super();
    this.config = config;
    this.logger = logger;
    this.errorHandler = ErrorHandler.getInstance();
  }
  public get name(): string {
    return this.config.name;
  }
  public get currentStatus(): ServiceStatus {
    return this.status;
  }
  public get currentMetrics(): ServiceMetrics {
    return this.metrics;
  }
  public async start(): Promise<void> {
    if (this.status === ServiceStatus.RUNNING) {
      return;
    }
    try {
      this.status = ServiceStatus.STARTING;
      this.emit('status', this.status);
      await this.validateDependencies();
      await this.initialize();
      this.status = ServiceStatus.RUNNING;
      this.startTime = Date.now();
      this.restartAttempts = 0;
      this.emit('status', this.status);
      this.startHealthCheck();
      this.logger.info(`Service ${this.name} started successfully`);
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }
  public async stop(): Promise<void> {
    if (this.status === ServiceStatus.STOPPED) {
      return;
    }
    try {
      this.status = ServiceStatus.STOPPING;
      this.emit('status', this.status);
      this.stopHealthCheck();
      await this.cleanup();
      this.status = ServiceStatus.STOPPED;
      this.emit('status', this.status);
      this.logger.info(`Service ${this.name} stopped successfully`);
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }
  public async restart(): Promise<void> {
    await this.stop();
    await this.start();
  }
  public async getStatus(): Promise<ServiceStatus> {
    return this.status;
  }
  public async getMetrics(): Promise<ServiceMetrics> {
    const currentTime = Date.now();
    this.metrics.uptime = this.startTime ? currentTime - this.startTime : 0;
    const processMetrics = process.memoryUsage();
    this.metrics.memoryUsage = processMetrics.heapUsed;
    return this.metrics;
  }
  public async isHealthy(): Promise<boolean> {
    try {
      return await this.checkHealth();
    } catch (error) {
      this.handleError(error);
      return false;
    }
  }
  protected abstract initialize(): Promise<void>;
  protected abstract cleanup(): Promise<void>;
  protected abstract checkHealth(): Promise<boolean>;
  protected async validateDependencies(): Promise<void> {
    if (!this.config.dependencies?.length) {
      return;
    }
    for (const dep of this.config.dependencies) {
      // This will be implemented by ServiceManager
      // to check if dependent services are running
    }
  }
  protected handleError(error: unknown): void {
    const serviceError = new ServiceError(
      error instanceof Error ? error.message : 'Unknown error',
      ErrorSeverity.HIGH,
      { serviceName: this.name }
    );
    this.errorHandler.handleError(serviceError);
    this.metrics.lastError = serviceError;
    this.emit('error', serviceError);
    if (this.config.restartOnCrash && 
        this.restartAttempts < (this.config.maxRestarts || 3)) {
      this.restartAttempts++;
      setTimeout(() => this.restart(), this.config.restartDelay || 5000);
    }
  }
  private startHealthCheck(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
    this.healthCheckInterval = setInterval(async () => {
      const isHealthy = await this.isHealthy();
      if (!isHealthy) {
        this.handleError(new Error('Health check failed'));
      }
    }, 30000); // Check every 30 seconds
  }
  private stopHealthCheck(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = undefined;
    }
  }
}
</file>

<file path="src/services/ServiceManager.d.ts">
import { EventEmitter } from 'events';
import { Service, ServiceStatus, ServiceMetrics } from './Service';
export interface ServiceManagerEvents {
    'service:status': (serviceName: string, status: ServiceStatus) => void;
    'service:error': (serviceName: string, error: Error) => void;
    'service:metrics': (serviceName: string, metrics: ServiceMetrics) => void;
    'service:log': (serviceName: string, message: string, level: string) => void;
}
export declare class ServiceManager extends EventEmitter {
    private static instance;
    private services;
    private serviceConfigs;
    private errorHandler;
    private metricsInterval?;
    private environment;
    private constructor();
    static getInstance(): ServiceManager;
    private setupServiceRegistry;
    private registerServiceConfig;
    initialize(): Promise<void>;
    private getServicesToStart;
    private startService;
    private createService;
    private setupServiceEventListeners;
    stopService(serviceName: string): Promise<void>;
    restartService(serviceName: string): Promise<void>;
    getService<T extends Service>(serviceName: string): T | undefined;
    getServiceStatus(serviceName: string): ServiceStatus | undefined;
    getAllServiceStatus(): Map<string, ServiceStatus>;
    cleanup(): Promise<void>;
    private buildServiceGraph;
    private getServiceStopOrder;
    private startMetricsCollection;
    private stopMetricsCollection;
}
</file>

<file path="src/services/ServiceManager.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceManager = void 0;
const events_1 = require("events");
const Service_1 = require("./Service");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const OllamaService_1 = require("./OllamaService");
class ServiceManager extends events_1.EventEmitter {
    constructor() {
        super();
        this.services = new Map();
        this.serviceConfigs = new Map();
        this.errorHandler = errors_1.ErrorHandler.getInstance();
        this.environment = process.env.NODE_ENV || 'development';
        this.setupServiceRegistry();
    }
    static getInstance() {
        if (!ServiceManager.instance) {
            ServiceManager.instance = new ServiceManager();
        }
        return ServiceManager.instance;
    }
    setupServiceRegistry() {
        // Register service configurations with enhanced settings
        this.registerServiceConfig({
            name: 'ollama',
            autoStart: true,
            restartOnCrash: true,
            maxRestarts: 3,
            restartDelay: 5000,
            environment: ['development', 'production'],
            dependencies: [],
            config: {
                baseUrl: process.env.OLLAMA_BASE_URL || 'http://localhost:11434',
                defaultModel: process.env.OLLAMA_DEFAULT_MODEL || 'llama2',
                timeout: parseInt(process.env.OLLAMA_TIMEOUT || '30000', 10),
                maxRetries: parseInt(process.env.OLLAMA_MAX_RETRIES || '3', 10),
                retryDelay: parseInt(process.env.OLLAMA_RETRY_DELAY || '1000', 10)
            }
        });
        this.registerServiceConfig({
            name: 'vectordb',
            autoStart: true,
            restartOnCrash: true,
            maxRestarts: 3,
            restartDelay: 5000,
            environment: ['development', 'production'],
            dependencies: [],
            config: {
                dataDir: process.env.VECTOR_DB_DIR || './data/vectordb',
                maxConnections: parseInt(process.env.VECTOR_DB_MAX_CONNECTIONS || '10', 10),
                cacheSize: parseInt(process.env.VECTOR_DB_CACHE_SIZE || '1000', 10)
            }
        });
        this.registerServiceConfig({
            name: 'express',
            autoStart: true,
            restartOnCrash: true,
            maxRestarts: 3,
            restartDelay: 5000,
            environment: ['development', 'production'],
            dependencies: ['ollama', 'vectordb'],
            config: {
                port: parseInt(process.env.EXPRESS_PORT || '3000', 10),
                host: process.env.EXPRESS_HOST || 'localhost',
                cors: process.env.EXPRESS_CORS === 'true',
                rateLimit: {
                    windowMs: parseInt(process.env.EXPRESS_RATE_LIMIT_WINDOW || '900000', 10),
                    max: parseInt(process.env.EXPRESS_RATE_LIMIT_MAX || '100', 10)
                }
            }
        });
    }
    registerServiceConfig(config) {
        this.serviceConfigs.set(config.name, config);
    }
    async initialize() {
        try {
            // Start metrics collection
            this.startMetricsCollection();
            // Initialize services based on environment and dependencies
            const servicesToStart = this.getServicesToStart();
            // Start services in parallel if they have no dependencies
            const independentServices = servicesToStart.filter(service => !this.serviceConfigs.get(service)?.dependencies?.length);
            await Promise.all(independentServices.map(service => this.startService(service)));
            // Start dependent services sequentially
            const dependentServices = servicesToStart.filter(service => this.serviceConfigs.get(service)?.dependencies?.length);
            for (const service of dependentServices) {
                await this.startService(service);
            }
            logger_1.logger.info('ServiceManager initialized successfully');
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.ServiceError('Failed to initialize services', errors_1.ErrorSeverity.CRITICAL, { error: error instanceof Error ? error.message : 'Unknown error' }));
            throw error;
        }
    }
    getServicesToStart() {
        return Array.from(this.serviceConfigs.entries())
            .filter(([_, config]) => config.autoStart &&
            (!config.environment || config.environment.includes(this.environment)))
            .map(([name]) => name);
    }
    async startService(serviceName) {
        try {
            const config = this.serviceConfigs.get(serviceName);
            if (!config) {
                throw new Error(`Service configuration not found for ${serviceName}`);
            }
            // Check dependencies
            if (config.dependencies?.length) {
                for (const dep of config.dependencies) {
                    const depService = this.services.get(dep);
                    if (!depService || depService.status !== Service_1.ServiceStatus.RUNNING) {
                        throw new Error(`Dependency ${dep} not running for service ${serviceName}`);
                    }
                }
            }
            // Create and start service
            const service = await this.createService(serviceName, config);
            this.services.set(serviceName, service);
            // Setup service event listeners
            this.setupServiceEventListeners(service);
            await service.start();
            logger_1.logger.info(`Service ${serviceName} started successfully`);
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.ServiceError(error instanceof Error ? error.message : 'Service start failed', errors_1.ErrorSeverity.HIGH, { serviceName }));
            throw error;
        }
    }
    async createService(name, config) {
        switch (name) {
            case 'ollama':
                return new OllamaService_1.OllamaService(config);
            case 'vectordb':
                // Import dynamically to avoid circular dependencies
                const { VectorDBService } = await Promise.resolve().then(() => __importStar(require('./VectorDBService')));
                return new VectorDBService(config);
            case 'express':
                // Import dynamically to avoid circular dependencies
                const { ExpressService } = await Promise.resolve().then(() => __importStar(require('./ExpressService')));
                return new ExpressService(config);
            default:
                throw new Error(`Unknown service type: ${name}`);
        }
    }
    setupServiceEventListeners(service) {
        service.on('status', (status) => {
            this.emit('service:status', service.name, status);
        });
        service.on('error', (error) => {
            this.emit('service:error', service.name, error);
        });
        service.on('metrics', (metrics) => {
            this.emit('service:metrics', service.name, metrics);
        });
        service.on('log', (message, level) => {
            this.emit('service:log', service.name, message, level);
        });
    }
    async stopService(serviceName) {
        const service = this.services.get(serviceName);
        if (!service) {
            throw new Error(`Service ${serviceName} not found`);
        }
        try {
            await service.stop();
            this.services.delete(serviceName);
            logger_1.logger.info(`Service ${serviceName} stopped successfully`);
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.ServiceError(error instanceof Error ? error.message : 'Service stop failed', errors_1.ErrorSeverity.HIGH, { serviceName }));
            throw error;
        }
    }
    async restartService(serviceName) {
        try {
            await this.stopService(serviceName);
            await this.startService(serviceName);
            logger_1.logger.info(`Service ${serviceName} restarted successfully`);
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.ServiceError(error instanceof Error ? error.message : 'Service restart failed', errors_1.ErrorSeverity.HIGH, { serviceName }));
            throw error;
        }
    }
    getService(serviceName) {
        return this.services.get(serviceName);
    }
    getServiceStatus(serviceName) {
        return this.services.get(serviceName)?.status;
    }
    getAllServiceStatus() {
        const statusMap = new Map();
        for (const [name, service] of this.services.entries()) {
            statusMap.set(name, service.status);
        }
        return statusMap;
    }
    async cleanup() {
        try {
            // Stop metrics collection
            this.stopMetricsCollection();
            // Get services in correct stop order
            const graph = this.buildServiceGraph();
            const stopOrder = this.getServiceStopOrder(graph);
            // Stop services in reverse dependency order
            for (const serviceName of stopOrder) {
                await this.stopService(serviceName);
            }
            logger_1.logger.info('ServiceManager cleaned up successfully');
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.ServiceError(error instanceof Error ? error.message : 'ServiceManager cleanup failed', errors_1.ErrorSeverity.CRITICAL, { error: error instanceof Error ? error.message : 'Unknown error' }));
            throw error;
        }
    }
    buildServiceGraph() {
        const graph = new Map();
        for (const [name, config] of this.serviceConfigs.entries()) {
            graph.set(name, new Set(config.dependencies || []));
        }
        return graph;
    }
    getServiceStopOrder(graph) {
        const visited = new Set();
        const order = [];
        const visit = (service) => {
            if (visited.has(service))
                return;
            visited.add(service);
            const dependencies = graph.get(service) || new Set();
            for (const dep of dependencies) {
                visit(dep);
            }
            order.push(service);
        };
        for (const service of graph.keys()) {
            visit(service);
        }
        return order;
    }
    startMetricsCollection() {
        this.metricsInterval = setInterval(() => {
            for (const [name, service] of this.services.entries()) {
                try {
                    const metrics = service.getMetrics();
                    this.emit('service:metrics', name, metrics);
                }
                catch (error) {
                    this.errorHandler.handleError(new errors_1.ServiceError(error instanceof Error ? error.message : 'Failed to collect metrics', errors_1.ErrorSeverity.LOW, { serviceName: name }));
                }
            }
        }, 60000); // Collect metrics every minute
    }
    stopMetricsCollection() {
        if (this.metricsInterval) {
            clearInterval(this.metricsInterval);
            this.metricsInterval = undefined;
        }
    }
}
exports.ServiceManager = ServiceManager;
//# sourceMappingURL=ServiceManager.js.map
</file>

<file path="src/services/ServiceManager.js.map">
{"version":3,"file":"ServiceManager.js","sourceRoot":"","sources":["ServiceManager.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mCAAsC;AACtC,uCAAkF;AAClF,4CAA4E;AAC5E,4CAAyC;AACzC,mDAAgD;AAWhD,MAAa,cAAe,SAAQ,qBAAY;IAQ9C;QACE,KAAK,EAAE,CAAC;QAPF,aAAQ,GAAyB,IAAI,GAAG,EAAE,CAAC;QAC3C,mBAAc,GAA+B,IAAI,GAAG,EAAE,CAAC;QAO7D,IAAI,CAAC,YAAY,GAAG,qBAAY,CAAC,WAAW,EAAE,CAAC;QAC/C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,QAAQ,IAAI,aAAa,CAAC;QACzD,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAC9B,CAAC;IAEM,MAAM,CAAC,WAAW;QACvB,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC;YAC7B,cAAc,CAAC,QAAQ,GAAG,IAAI,cAAc,EAAE,CAAC;QACjD,CAAC;QACD,OAAO,cAAc,CAAC,QAAQ,CAAC;IACjC,CAAC;IAEO,oBAAoB;QAC1B,yDAAyD;QACzD,IAAI,CAAC,qBAAqB,CAAC;YACzB,IAAI,EAAE,QAAQ;YACd,SAAS,EAAE,IAAI;YACf,cAAc,EAAE,IAAI;YACpB,WAAW,EAAE,CAAC;YACd,YAAY,EAAE,IAAI;YAClB,WAAW,EAAE,CAAC,aAAa,EAAE,YAAY,CAAC;YAC1C,YAAY,EAAE,EAAE;YAChB,MAAM,EAAE;gBACN,OAAO,EAAE,OAAO,CAAC,GAAG,CAAC,eAAe,IAAI,wBAAwB;gBAChE,YAAY,EAAE,OAAO,CAAC,GAAG,CAAC,oBAAoB,IAAI,QAAQ;gBAC1D,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,IAAI,OAAO,EAAE,EAAE,CAAC;gBAC5D,UAAU,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,GAAG,EAAE,EAAE,CAAC;gBAC/D,UAAU,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,MAAM,EAAE,EAAE,CAAC;aACnE;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,qBAAqB,CAAC;YACzB,IAAI,EAAE,UAAU;YAChB,SAAS,EAAE,IAAI;YACf,cAAc,EAAE,IAAI;YACpB,WAAW,EAAE,CAAC;YACd,YAAY,EAAE,IAAI;YAClB,WAAW,EAAE,CAAC,aAAa,EAAE,YAAY,CAAC;YAC1C,YAAY,EAAE,EAAE;YAChB,MAAM,EAAE;gBACN,OAAO,EAAE,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,iBAAiB;gBACvD,cAAc,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,yBAAyB,IAAI,IAAI,EAAE,EAAE,CAAC;gBAC3E,SAAS,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,IAAI,MAAM,EAAE,EAAE,CAAC;aACpE;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,qBAAqB,CAAC;YACzB,IAAI,EAAE,SAAS;YACf,SAAS,EAAE,IAAI;YACf,cAAc,EAAE,IAAI;YACpB,WAAW,EAAE,CAAC;YACd,YAAY,EAAE,IAAI;YAClB,WAAW,EAAE,CAAC,aAAa,EAAE,YAAY,CAAC;YAC1C,YAAY,EAAE,CAAC,QAAQ,EAAE,UAAU,CAAC;YACpC,MAAM,EAAE;gBACN,IAAI,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,IAAI,MAAM,EAAE,EAAE,CAAC;gBACtD,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,YAAY,IAAI,WAAW;gBAC7C,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,YAAY,KAAK,MAAM;gBACzC,SAAS,EAAE;oBACT,QAAQ,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,yBAAyB,IAAI,QAAQ,EAAE,EAAE,CAAC;oBACzE,GAAG,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,sBAAsB,IAAI,KAAK,EAAE,EAAE,CAAC;iBAC/D;aACF;SACF,CAAC,CAAC;IACL,CAAC;IAEO,qBAAqB,CAAC,MAAqB;QACjD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC/C,CAAC;IAEM,KAAK,CAAC,UAAU;QACrB,IAAI,CAAC;YACH,2BAA2B;YAC3B,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAE9B,4DAA4D;YAC5D,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAElD,0DAA0D;YAC1D,MAAM,mBAAmB,GAAG,eAAe,CAAC,MAAM,CAChD,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,YAAY,EAAE,MAAM,CACnE,CAAC;YAEF,MAAM,OAAO,CAAC,GAAG,CACf,mBAAmB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAC/D,CAAC;YAEF,wCAAwC;YACxC,MAAM,iBAAiB,GAAG,eAAe,CAAC,MAAM,CAC9C,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,YAAY,EAAE,MAAM,CAClE,CAAC;YAEF,KAAK,MAAM,OAAO,IAAI,iBAAiB,EAAE,CAAC;gBACxC,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;YACnC,CAAC;YAED,eAAM,CAAC,IAAI,CAAC,yCAAyC,CAAC,CAAC;QACzD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,YAAY,CAAC,WAAW,CAC3B,IAAI,qBAAY,CACd,+BAA+B,EAC/B,sBAAa,CAAC,QAAQ,EACtB,EAAE,KAAK,EAAE,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,eAAe,EAAE,CACpE,CACF,CAAC;YACF,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAEO,kBAAkB;QACxB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;aAC7C,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,EAAE,EAAE,CACtB,MAAM,CAAC,SAAS;YAChB,CAAC,CAAC,MAAM,CAAC,WAAW,IAAI,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CACvE;aACA,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,WAAmB;QAC5C,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YACpD,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,MAAM,IAAI,KAAK,CAAC,uCAAuC,WAAW,EAAE,CAAC,CAAC;YACxE,CAAC;YAED,qBAAqB;YACrB,IAAI,MAAM,CAAC,YAAY,EAAE,MAAM,EAAE,CAAC;gBAChC,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;oBACtC,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAC1C,IAAI,CAAC,UAAU,IAAI,UAAU,CAAC,MAAM,KAAK,uBAAa,CAAC,OAAO,EAAE,CAAC;wBAC/D,MAAM,IAAI,KAAK,CAAC,cAAc,GAAG,4BAA4B,WAAW,EAAE,CAAC,CAAC;oBAC9E,CAAC;gBACH,CAAC;YACH,CAAC;YAED,2BAA2B;YAC3B,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;YAC9D,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YAExC,gCAAgC;YAChC,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC;YAEzC,MAAM,OAAO,CAAC,KAAK,EAAE,CAAC;YAEtB,eAAM,CAAC,IAAI,CAAC,WAAW,WAAW,uBAAuB,CAAC,CAAC;QAC7D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,YAAY,CAAC,WAAW,CAC3B,IAAI,qBAAY,CACd,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,sBAAsB,EAC/D,sBAAa,CAAC,IAAI,EAClB,EAAE,WAAW,EAAE,CAChB,CACF,CAAC;YACF,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAEO,KAAK,CAAC,aAAa,CAAC,IAAY,EAAE,MAAqB;QAC7D,QAAQ,IAAI,EAAE,CAAC;YACb,KAAK,QAAQ;gBACX,OAAO,IAAI,6BAAa,CAAC,MAAM,CAAC,CAAC;YACnC,KAAK,UAAU;gBACb,oDAAoD;gBACpD,MAAM,EAAE,eAAe,EAAE,GAAG,wDAAa,mBAAmB,GAAC,CAAC;gBAC9D,OAAO,IAAI,eAAe,CAAC,MAAM,CAAC,CAAC;YACrC,KAAK,SAAS;gBACZ,oDAAoD;gBACpD,MAAM,EAAE,cAAc,EAAE,GAAG,wDAAa,kBAAkB,GAAC,CAAC;gBAC5D,OAAO,IAAI,cAAc,CAAC,MAAM,CAAC,CAAC;YACpC;gBACE,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,EAAE,CAAC,CAAC;QACrD,CAAC;IACH,CAAC;IAEO,0BAA0B,CAAC,OAAgB;QACjD,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,MAAqB,EAAE,EAAE;YAC7C,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAY,EAAE,EAAE;YACnC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,OAAuB,EAAE,EAAE;YAChD,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACtD,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,OAAe,EAAE,KAAa,EAAE,EAAE;YACnD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,WAAmB;QAC1C,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC/C,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,MAAM,IAAI,KAAK,CAAC,WAAW,WAAW,YAAY,CAAC,CAAC;QACtD,CAAC;QAED,IAAI,CAAC;YACH,MAAM,OAAO,CAAC,IAAI,EAAE,CAAC;YACrB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;YAClC,eAAM,CAAC,IAAI,CAAC,WAAW,WAAW,uBAAuB,CAAC,CAAC;QAC7D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,YAAY,CAAC,WAAW,CAC3B,IAAI,qBAAY,CACd,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,qBAAqB,EAC9D,sBAAa,CAAC,IAAI,EAClB,EAAE,WAAW,EAAE,CAChB,CACF,CAAC;YACF,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAEM,KAAK,CAAC,cAAc,CAAC,WAAmB;QAC7C,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YACpC,MAAM,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;YACrC,eAAM,CAAC,IAAI,CAAC,WAAW,WAAW,yBAAyB,CAAC,CAAC;QAC/D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,YAAY,CAAC,WAAW,CAC3B,IAAI,qBAAY,CACd,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,wBAAwB,EACjE,sBAAa,CAAC,IAAI,EAClB,EAAE,WAAW,EAAE,CAChB,CACF,CAAC;YACF,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAEM,UAAU,CAAoB,WAAmB;QACtD,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAkB,CAAC;IACzD,CAAC;IAEM,gBAAgB,CAAC,WAAmB;QACzC,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,MAAM,CAAC;IAChD,CAAC;IAEM,mBAAmB;QACxB,MAAM,SAAS,GAAG,IAAI,GAAG,EAAyB,CAAC;QACnD,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC;YACtD,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;QACtC,CAAC;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAEM,KAAK,CAAC,OAAO;QAClB,IAAI,CAAC;YACH,0BAA0B;YAC1B,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAE7B,qCAAqC;YACrC,MAAM,KAAK,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACvC,MAAM,SAAS,GAAG,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;YAElD,4CAA4C;YAC5C,KAAK,MAAM,WAAW,IAAI,SAAS,EAAE,CAAC;gBACpC,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YACtC,CAAC;YAED,eAAM,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;QACxD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,YAAY,CAAC,WAAW,CAC3B,IAAI,qBAAY,CACd,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,+BAA+B,EACxE,sBAAa,CAAC,QAAQ,EACtB,EAAE,KAAK,EAAE,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,eAAe,EAAE,CACpE,CACF,CAAC;YACF,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAEO,iBAAiB;QACvB,MAAM,KAAK,GAAG,IAAI,GAAG,EAAuB,CAAC;QAC7C,KAAK,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,EAAE,CAAC;YAC3D,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC,MAAM,CAAC,YAAY,IAAI,EAAE,CAAC,CAAC,CAAC;QACtD,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAEO,mBAAmB,CAAC,KAA+B;QACzD,MAAM,OAAO,GAAG,IAAI,GAAG,EAAU,CAAC;QAClC,MAAM,KAAK,GAAa,EAAE,CAAC;QAE3B,MAAM,KAAK,GAAG,CAAC,OAAe,EAAE,EAAE;YAChC,IAAI,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC;gBAAE,OAAO;YACjC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAErB,MAAM,YAAY,GAAG,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,IAAI,GAAG,EAAE,CAAC;YACrD,KAAK,MAAM,GAAG,IAAI,YAAY,EAAE,CAAC;gBAC/B,KAAK,CAAC,GAAG,CAAC,CAAC;YACb,CAAC;YAED,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACtB,CAAC,CAAC;QAEF,KAAK,MAAM,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC;YACnC,KAAK,CAAC,OAAO,CAAC,CAAC;QACjB,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAEO,sBAAsB;QAC5B,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC,GAAG,EAAE;YACtC,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC;gBACtD,IAAI,CAAC;oBACH,MAAM,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;oBACrC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;gBAC9C,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,IAAI,CAAC,YAAY,CAAC,WAAW,CAC3B,IAAI,qBAAY,CACd,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,2BAA2B,EACpE,sBAAa,CAAC,GAAG,EACjB,EAAE,WAAW,EAAE,IAAI,EAAE,CACtB,CACF,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,+BAA+B;IAC5C,CAAC;IAEO,qBAAqB;QAC3B,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACzB,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YACpC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;QACnC,CAAC;IACH,CAAC;CACF;AApVD,wCAoVC"}
</file>

<file path="src/services/ServiceManager.ts">
import { EventEmitter } from 'events';
import { Service, ServiceConfig, ServiceStatus, ServiceMetrics } from './Service';
import { ErrorHandler, ServiceError, ErrorSeverity } from '../utils/errors';
import { logger } from '../utils/logger';
import { OllamaService } from './OllamaService';
import type { VectorDBService } from './VectorDBService';
import type { ExpressService } from './ExpressService';
export interface ServiceManagerEvents {
  'service:status': (serviceName: string, status: ServiceStatus) => void;
  'service:error': (serviceName: string, error: Error) => void;
  'service:metrics': (serviceName: string, metrics: ServiceMetrics) => void;
  'service:log': (serviceName: string, message: string, level: string) => void;
}
export class ServiceManager extends EventEmitter {
  private static instance: ServiceManager;
  private services: Map<string, Service> = new Map();
  private serviceConfigs: Map<string, ServiceConfig> = new Map();
  private errorHandler: ErrorHandler;
  private metricsInterval?: NodeJS.Timeout;
  private environment: string;
  private constructor() {
    super();
    this.errorHandler = ErrorHandler.getInstance();
    this.environment = process.env.NODE_ENV || 'development';
    this.setupServiceRegistry();
  }
  public static getInstance(): ServiceManager {
    if (!ServiceManager.instance) {
      ServiceManager.instance = new ServiceManager();
    }
    return ServiceManager.instance;
  }
  private setupServiceRegistry(): void {
    // Register service configurations with enhanced settings
    this.registerServiceConfig({
      name: 'ollama',
      autoStart: true,
      restartOnCrash: true,
      maxRestarts: 3,
      restartDelay: 5000,
      environment: ['development', 'production'],
      dependencies: [],
      config: {
        baseUrl: process.env.OLLAMA_BASE_URL || 'http://localhost:11434',
        defaultModel: process.env.OLLAMA_DEFAULT_MODEL || 'llama2',
        timeout: parseInt(process.env.OLLAMA_TIMEOUT || '30000', 10),
        maxRetries: parseInt(process.env.OLLAMA_MAX_RETRIES || '3', 10),
        retryDelay: parseInt(process.env.OLLAMA_RETRY_DELAY || '1000', 10)
      }
    });
    this.registerServiceConfig({
      name: 'vectordb',
      autoStart: true,
      restartOnCrash: true,
      maxRestarts: 3,
      restartDelay: 5000,
      environment: ['development', 'production'],
      dependencies: [],
      config: {
        dataDir: process.env.VECTOR_DB_DIR || './data/vectordb',
        maxConnections: parseInt(process.env.VECTOR_DB_MAX_CONNECTIONS || '10', 10),
        cacheSize: parseInt(process.env.VECTOR_DB_CACHE_SIZE || '1000', 10)
      }
    });
    this.registerServiceConfig({
      name: 'express',
      autoStart: true,
      restartOnCrash: true,
      maxRestarts: 3,
      restartDelay: 5000,
      environment: ['development', 'production'],
      dependencies: ['ollama', 'vectordb'],
      config: {
        port: parseInt(process.env.EXPRESS_PORT || '3000', 10),
        host: process.env.EXPRESS_HOST || 'localhost',
        cors: process.env.EXPRESS_CORS === 'true',
        rateLimit: {
          windowMs: parseInt(process.env.EXPRESS_RATE_LIMIT_WINDOW || '900000', 10),
          max: parseInt(process.env.EXPRESS_RATE_LIMIT_MAX || '100', 10)
        }
      }
    });
  }
  private registerServiceConfig(config: ServiceConfig): void {
    this.serviceConfigs.set(config.name, config);
  }
  public async initialize(): Promise<void> {
    try {
      // Start metrics collection
      this.startMetricsCollection();
      // Initialize services based on environment and dependencies
      const servicesToStart = this.getServicesToStart();
      // Start services in parallel if they have no dependencies
      const independentServices = servicesToStart.filter(
        service => !this.serviceConfigs.get(service)?.dependencies?.length
      );
      await Promise.all(
        independentServices.map(service => this.startService(service))
      );
      // Start dependent services sequentially
      const dependentServices = servicesToStart.filter(
        service => this.serviceConfigs.get(service)?.dependencies?.length
      );
      for (const service of dependentServices) {
        await this.startService(service);
      }
      logger.info('ServiceManager initialized successfully');
    } catch (error) {
      this.errorHandler.handleError(
        new ServiceError(
          'Failed to initialize services',
          ErrorSeverity.CRITICAL,
          { error: error instanceof Error ? error.message : 'Unknown error' }
        )
      );
      throw error;
    }
  }
  private getServicesToStart(): string[] {
    return Array.from(this.serviceConfigs.entries())
      .filter(([_, config]) => 
        config.autoStart && 
        (!config.environment || config.environment.includes(this.environment))
      )
      .map(([name]) => name);
  }
  private async startService(serviceName: string): Promise<void> {
    try {
      const config = this.serviceConfigs.get(serviceName);
      if (!config) {
        throw new Error(`Service configuration not found for ${serviceName}`);
      }
      // Check dependencies
      if (config.dependencies?.length) {
        for (const dep of config.dependencies) {
          const depService = this.services.get(dep);
          if (!depService || depService.status !== ServiceStatus.RUNNING) {
            throw new Error(`Dependency ${dep} not running for service ${serviceName}`);
          }
        }
      }
      // Create and start service
      const service = await this.createService(serviceName, config);
      this.services.set(serviceName, service);
      // Setup service event listeners
      this.setupServiceEventListeners(service);
      await service.start();
      logger.info(`Service ${serviceName} started successfully`);
    } catch (error) {
      this.errorHandler.handleError(
        new ServiceError(
          error instanceof Error ? error.message : 'Service start failed',
          ErrorSeverity.HIGH,
          { serviceName }
        )
      );
      throw error;
    }
  }
  private async createService(name: string, config: ServiceConfig): Promise<Service> {
    switch (name) {
      case 'ollama':
        return new OllamaService(config);
      case 'vectordb':
        // Import dynamically to avoid circular dependencies
        const { VectorDBService } = await import('./VectorDBService');
        return new VectorDBService(config);
      case 'express':
        // Import dynamically to avoid circular dependencies
        const { ExpressService } = await import('./ExpressService');
        return new ExpressService(config);
      default:
        throw new Error(`Unknown service type: ${name}`);
    }
  }
  private setupServiceEventListeners(service: Service): void {
    service.on('status', (status: ServiceStatus) => {
      this.emit('service:status', service.name, status);
    });
    service.on('error', (error: Error) => {
      this.emit('service:error', service.name, error);
    });
    service.on('metrics', (metrics: ServiceMetrics) => {
      this.emit('service:metrics', service.name, metrics);
    });
    service.on('log', (message: string, level: string) => {
      this.emit('service:log', service.name, message, level);
    });
  }
  public async stopService(serviceName: string): Promise<void> {
    const service = this.services.get(serviceName);
    if (!service) {
      throw new Error(`Service ${serviceName} not found`);
    }
    try {
      await service.stop();
      this.services.delete(serviceName);
      logger.info(`Service ${serviceName} stopped successfully`);
    } catch (error) {
      this.errorHandler.handleError(
        new ServiceError(
          error instanceof Error ? error.message : 'Service stop failed',
          ErrorSeverity.HIGH,
          { serviceName }
        )
      );
      throw error;
    }
  }
  public async restartService(serviceName: string): Promise<void> {
    try {
      await this.stopService(serviceName);
      await this.startService(serviceName);
      logger.info(`Service ${serviceName} restarted successfully`);
    } catch (error) {
      this.errorHandler.handleError(
        new ServiceError(
          error instanceof Error ? error.message : 'Service restart failed',
          ErrorSeverity.HIGH,
          { serviceName }
        )
      );
      throw error;
    }
  }
  public getService<T extends Service>(serviceName: string): T | undefined {
    return this.services.get(serviceName) as T | undefined;
  }
  public getServiceStatus(serviceName: string): ServiceStatus | undefined {
    return this.services.get(serviceName)?.status;
  }
  public getAllServiceStatus(): Map<string, ServiceStatus> {
    const statusMap = new Map<string, ServiceStatus>();
    for (const [name, service] of this.services.entries()) {
      statusMap.set(name, service.status);
    }
    return statusMap;
  }
  public async cleanup(): Promise<void> {
    try {
      // Stop metrics collection
      this.stopMetricsCollection();
      // Get services in correct stop order
      const graph = this.buildServiceGraph();
      const stopOrder = this.getServiceStopOrder(graph);
      // Stop services in reverse dependency order
      for (const serviceName of stopOrder) {
        await this.stopService(serviceName);
      }
      logger.info('ServiceManager cleaned up successfully');
    } catch (error) {
      this.errorHandler.handleError(
        new ServiceError(
          error instanceof Error ? error.message : 'ServiceManager cleanup failed',
          ErrorSeverity.CRITICAL,
          { error: error instanceof Error ? error.message : 'Unknown error' }
        )
      );
      throw error;
    }
  }
  private buildServiceGraph(): Map<string, Set<string>> {
    const graph = new Map<string, Set<string>>();
    for (const [name, config] of this.serviceConfigs.entries()) {
      graph.set(name, new Set(config.dependencies || []));
    }
    return graph;
  }
  private getServiceStopOrder(graph: Map<string, Set<string>>): string[] {
    const visited = new Set<string>();
    const order: string[] = [];
    const visit = (service: string) => {
      if (visited.has(service)) return;
      visited.add(service);
      const dependencies = graph.get(service) || new Set();
      for (const dep of dependencies) {
        visit(dep);
      }
      order.push(service);
    };
    for (const service of graph.keys()) {
      visit(service);
    }
    return order;
  }
  private startMetricsCollection(): void {
    this.metricsInterval = setInterval(() => {
      for (const [name, service] of this.services.entries()) {
        try {
          const metrics = service.getMetrics();
          this.emit('service:metrics', name, metrics);
        } catch (error) {
          this.errorHandler.handleError(
            new ServiceError(
              error instanceof Error ? error.message : 'Failed to collect metrics',
              ErrorSeverity.LOW,
              { serviceName: name }
            )
          );
        }
      }
    }, 60000); // Collect metrics every minute
  }
  private stopMetricsCollection(): void {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
      this.metricsInterval = undefined;
    }
  }
}
</file>

<file path="src/services/VectorDBService.d.ts">
import { BaseService, ServiceConfig } from './Service';
export declare class VectorDBService extends BaseService {
    constructor(config: ServiceConfig);
    protected initialize(): Promise<void>;
    protected cleanup(): Promise<void>;
    protected checkHealth(): Promise<boolean>;
}
</file>

<file path="src/services/VectorDBService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorDBService = void 0;
const Service_1 = require("./Service");
class VectorDBService extends Service_1.BaseService {
    constructor(config) {
        super(config);
    }
    async initialize() {
        // TODO: Initialize vector database connection
        this.logger.info('VectorDB service initialized');
    }
    async cleanup() {
        // TODO: Cleanup vector database connection
        this.logger.info('VectorDB service cleaned up');
    }
    async checkHealth() {
        // TODO: Implement health check
        return true;
    }
}
exports.VectorDBService = VectorDBService;
//# sourceMappingURL=VectorDBService.js.map
</file>

<file path="src/services/VectorDBService.js.map">
{"version":3,"file":"VectorDBService.js","sourceRoot":"","sources":["VectorDBService.ts"],"names":[],"mappings":";;;AAAA,uCAAuD;AAGvD,MAAa,eAAgB,SAAQ,qBAAW;IAC9C,YAAY,MAAqB;QAC/B,KAAK,CAAC,MAAM,CAAC,CAAC;IAChB,CAAC;IAES,KAAK,CAAC,UAAU;QACxB,8CAA8C;QAC9C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,8BAA8B,CAAC,CAAC;IACnD,CAAC;IAES,KAAK,CAAC,OAAO;QACrB,2CAA2C;QAC3C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,6BAA6B,CAAC,CAAC;IAClD,CAAC;IAES,KAAK,CAAC,WAAW;QACzB,+BAA+B;QAC/B,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAnBD,0CAmBC"}
</file>

<file path="src/services/VectorDBService.ts">
import { BaseService, ServiceConfig } from './Service';
import { logger } from '../utils/logger';
export class VectorDBService extends BaseService {
  constructor(config: ServiceConfig) {
    super(config);
  }
  protected async initialize(): Promise<void> {
    // TODO: Initialize vector database connection
    this.logger.info('VectorDB service initialized');
  }
  protected async cleanup(): Promise<void> {
    // TODO: Cleanup vector database connection
    this.logger.info('VectorDB service cleaned up');
  }
  protected async checkHealth(): Promise<boolean> {
    // TODO: Implement health check
    return true;
  }
}
</file>

<file path="src/services/VectorStore.d.ts">
import { Vector } from '../types/ipc';
export declare class VectorStore {
    private vectors;
    update(id: string, content: string): Promise<void>;
    get(id: string): Promise<Vector | undefined>;
    list(): Promise<Vector[]>;
    add(vector: Vector): Promise<void>;
    delete(id: string): Promise<void>;
    clear(): Promise<void>;
    search(query: string): Promise<Vector[]>;
    stats(): Promise<{
        count: number;
        dimensions: number;
    }>;
}
export declare const vectorStore: VectorStore;
</file>

<file path="src/services/VectorStore.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.vectorStore = exports.VectorStore = void 0;
class VectorStore {
    constructor() {
        this.vectors = new Map();
    }
    async update(id, content) {
        const vector = this.vectors.get(id);
        if (vector) {
            vector.content = content;
            this.vectors.set(id, vector);
        }
    }
    async get(id) {
        return this.vectors.get(id);
    }
    async list() {
        return Array.from(this.vectors.values());
    }
    async add(vector) {
        this.vectors.set(vector.id, vector);
    }
    async delete(id) {
        this.vectors.delete(id);
    }
    async clear() {
        this.vectors.clear();
    }
    async search(query) {
        // Simple search implementation - can be enhanced with vector similarity search
        return Array.from(this.vectors.values()).filter(vector => vector.content.toLowerCase().includes(query.toLowerCase()));
    }
    async stats() {
        return {
            count: this.vectors.size,
            dimensions: 0 // TODO: Implement actual dimension tracking
        };
    }
}
exports.VectorStore = VectorStore;
exports.vectorStore = new VectorStore();
//# sourceMappingURL=VectorStore.js.map
</file>

<file path="src/services/VectorStore.js.map">
{"version":3,"file":"VectorStore.js","sourceRoot":"","sources":["VectorStore.ts"],"names":[],"mappings":";;;AAGA,MAAa,WAAW;IAAxB;QACU,YAAO,GAAwB,IAAI,GAAG,EAAE,CAAC;IA2CnD,CAAC;IAzCC,KAAK,CAAC,MAAM,CAAC,EAAU,EAAE,OAAe;QACtC,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACpC,IAAI,MAAM,EAAE,CAAC;YACX,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;YACzB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;QAC/B,CAAC;IACH,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,EAAU;QAClB,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAC9B,CAAC;IAED,KAAK,CAAC,IAAI;QACR,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;IAC3C,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,MAAc;QACtB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;IACtC,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,EAAU;QACrB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,KAAK;QACT,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;IACvB,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,KAAa;QACxB,+EAA+E;QAC/E,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CACvD,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAC3D,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,KAAK;QACT,OAAO;YACL,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI;YACxB,UAAU,EAAE,CAAC,CAAC,4CAA4C;SAC3D,CAAC;IACJ,CAAC;CACF;AA5CD,kCA4CC;AAEY,QAAA,WAAW,GAAG,IAAI,WAAW,EAAE,CAAC"}
</file>

<file path="src/services/VectorStore.ts">
import { Vector } from '@shared/types/ipc';
import { logger } from '../utils/logger';
export class VectorStore {
  private vectors: Map<string, Vector> = new Map();
  async update(id: string, content: string): Promise<void> {
    const vector = this.vectors.get(id);
    if (vector) {
      vector.content = content;
      this.vectors.set(id, vector);
    }
  }
  async get(id: string): Promise<Vector | undefined> {
    return this.vectors.get(id);
  }
  async list(): Promise<Vector[]> {
    return Array.from(this.vectors.values());
  }
  async add(vector: Vector): Promise<void> {
    this.vectors.set(vector.id, vector);
  }
  async delete(id: string): Promise<void> {
    this.vectors.delete(id);
  }
  async clear(): Promise<void> {
    this.vectors.clear();
  }
  async search(query: string): Promise<Vector[]> {
    // Simple search implementation - can be enhanced with vector similarity search
    return Array.from(this.vectors.values()).filter(vector => 
      vector.content.toLowerCase().includes(query.toLowerCase())
    );
  }
  async stats(): Promise<{ count: number; dimensions: number }> {
    return {
      count: this.vectors.size,
      dimensions: 0 // TODO: Implement actual dimension tracking
    };
  }
}
export const vectorStore = new VectorStore();
</file>

<file path="src/services/VectorStoreService.d.ts">
import type { Document } from '../types/ipc';
import { EventEmitter } from 'events';
export declare class VectorStoreService extends EventEmitter {
    private static instance;
    private readonly CHUNK_SIZE;
    private readonly CHUNK_OVERLAP;
    private readonly VECTOR_SIZE;
    private readonly MAX_ELEMENTS;
    private readonly INDEX_PATH;
    private readonly SIMILARITY_THRESHOLD;
    private documents;
    private vectorMap;
    private index;
    private embeddingService;
    private nextId;
    private isInitialized;
    private constructor();
    static getInstance(): VectorStoreService;
    initialize(): Promise<void>;
    private loadDocuments;
    private saveIndex;
    private chunkText;
    addDocument(document: Omit<Document, 'id'>): Promise<void>;
    searchSimilar(query: string, k?: number): Promise<Document[]>;
    deleteDocument(id: string): Promise<void>;
    clear(): Promise<void>;
    getStats(): Promise<{
        totalDocuments: number;
        totalVectors: number;
        indexSize: number;
        maxElements: number;
    }>;
    cleanup(): Promise<void>;
}
</file>

<file path="src/services/VectorStoreService.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorStoreService = void 0;
const logger_1 = require("../utils/logger");
const uuid_1 = require("uuid");
const hnswlib_node_1 = __importDefault(require("hnswlib-node"));
const path_1 = __importDefault(require("path"));
const electron_1 = require("electron");
const EmbeddingService_1 = require("./EmbeddingService");
const events_1 = require("events");
class VectorStoreService extends events_1.EventEmitter {
    constructor(embeddingService) {
        super();
        this.CHUNK_SIZE = 1000;
        this.CHUNK_OVERLAP = 200;
        this.VECTOR_SIZE = 1536; // OpenAI embedding dimension
        this.MAX_ELEMENTS = 100000; // Maximum number of vectors to store
        this.INDEX_PATH = 'vector-store';
        this.SIMILARITY_THRESHOLD = 0.7;
        this.documents = new Map();
        this.vectorMap = new Map(); // Maps vector IDs to document IDs
        this.nextId = 0;
        this.isInitialized = false;
        this.embeddingService = embeddingService;
    }
    static getInstance() {
        if (!VectorStoreService.instance) {
            const embeddingService = EmbeddingService_1.EmbeddingService.getInstance();
            VectorStoreService.instance = new VectorStoreService(embeddingService);
        }
        return VectorStoreService.instance;
    }
    async initialize() {
        if (this.isInitialized)
            return;
        try {
            logger_1.logger.info('Initializing VectorStoreService');
            // Initialize HNSW index
            this.index = new hnswlib_node_1.default.HierarchicalNSW('cosine', this.VECTOR_SIZE);
            await this.index.initIndex(this.MAX_ELEMENTS);
            // Load existing index if available
            const indexPath = path_1.default.join(electron_1.app.getPath('userData'), this.INDEX_PATH);
            try {
                await this.index.readIndex(indexPath);
                await this.loadDocuments();
                logger_1.logger.info('Loaded existing vector store index');
            }
            catch (e) {
                logger_1.logger.info('No existing index found, creating new one');
            }
            this.isInitialized = true;
            this.emit('initialized');
        }
        catch (error) {
            logger_1.logger.error('Error initializing vector store:', error);
            throw error;
        }
    }
    async loadDocuments() {
        try {
            // TODO: Implement document loading from disk
            logger_1.logger.info('Loading documents from disk');
        }
        catch (error) {
            logger_1.logger.error('Error loading documents:', error);
            throw error;
        }
    }
    async saveIndex() {
        try {
            const indexPath = path_1.default.join(electron_1.app.getPath('userData'), this.INDEX_PATH);
            await this.index.writeIndex(indexPath);
            logger_1.logger.info('Saved vector store index');
        }
        catch (error) {
            logger_1.logger.error('Error saving vector store index:', error);
            throw error;
        }
    }
    chunkText(text) {
        const chunks = [];
        let start = 0;
        while (start < text.length) {
            const end = Math.min(start + this.CHUNK_SIZE, text.length);
            let chunk = text.slice(start, end);
            // If we're not at the end, try to find a good break point
            if (end < text.length) {
                const lastPeriod = chunk.lastIndexOf('.');
                const lastSpace = chunk.lastIndexOf(' ');
                if (lastPeriod > this.CHUNK_SIZE - this.CHUNK_OVERLAP) {
                    chunk = chunk.slice(0, lastPeriod + 1);
                    start = start + lastPeriod + 1;
                }
                else if (lastSpace > this.CHUNK_SIZE - this.CHUNK_OVERLAP) {
                    chunk = chunk.slice(0, lastSpace + 1);
                    start = start + lastSpace + 1;
                }
                else {
                    start = end;
                }
            }
            else {
                start = end;
            }
            chunks.push(chunk);
        }
        return chunks;
    }
    async addDocument(document) {
        if (!this.isInitialized) {
            throw new Error('Vector store not initialized');
        }
        try {
            const id = (0, uuid_1.v4)();
            const chunks = this.chunkText(document.content);
            for (const chunk of chunks) {
                const chunkId = (0, uuid_1.v4)();
                const chunkDoc = {
                    id: chunkId,
                    content: chunk,
                    metadata: {
                        ...document.metadata,
                        originalId: id,
                        chunkIndex: chunks.indexOf(chunk),
                        totalChunks: chunks.length,
                    },
                };
                // Generate embedding
                const embedding = await this.embeddingService.generateEmbedding(chunk);
                // Add to vector store
                await this.index.addPoint(embedding, this.nextId);
                this.vectorMap.set(this.nextId, chunkId);
                this.documents.set(chunkId, chunkDoc);
                this.nextId++;
                // Check if we need to resize the index
                if (this.nextId >= this.index.getMaxElements()) {
                    const newSize = Math.min(this.index.getMaxElements() * 2, this.MAX_ELEMENTS);
                    await this.index.resizeIndex(newSize);
                    logger_1.logger.info(`Resized vector store index to ${newSize} elements`);
                }
            }
            // Save index periodically
            if (this.nextId % 100 === 0) {
                await this.saveIndex();
            }
            this.emit('documentAdded', id);
        }
        catch (error) {
            logger_1.logger.error('Error adding document:', error);
            throw error;
        }
    }
    async searchSimilar(query, k = 5) {
        if (!this.isInitialized) {
            throw new Error('Vector store not initialized');
        }
        try {
            // Generate query embedding
            const queryEmbedding = await this.embeddingService.generateEmbedding(query);
            // Search for similar vectors
            const { neighbors } = await this.index.searchKnn(queryEmbedding, k);
            // Map vector IDs back to documents
            const results = [];
            for (const neighborId of neighbors) {
                const docId = this.vectorMap.get(neighborId);
                if (docId) {
                    const doc = this.documents.get(docId);
                    if (doc) {
                        results.push(doc);
                    }
                }
            }
            return results;
        }
        catch (error) {
            logger_1.logger.error('Error searching documents:', error);
            throw error;
        }
    }
    async deleteDocument(id) {
        if (!this.isInitialized) {
            throw new Error('Vector store not initialized');
        }
        try {
            // Delete all chunks associated with the document
            for (const [chunkId, doc] of this.documents.entries()) {
                if (doc.metadata.originalId === id) {
                    this.documents.delete(chunkId);
                    // Note: We can't remove from HNSW index, but we can mark as deleted
                    // in the vectorMap by setting to null
                    for (const [vectorId, docId] of this.vectorMap.entries()) {
                        if (docId === chunkId) {
                            this.vectorMap.set(vectorId, '');
                        }
                    }
                }
            }
            this.emit('documentDeleted', id);
        }
        catch (error) {
            logger_1.logger.error('Error deleting document:', error);
            throw error;
        }
    }
    async clear() {
        if (!this.isInitialized) {
            throw new Error('Vector store not initialized');
        }
        try {
            this.documents.clear();
            this.vectorMap.clear();
            await this.index.clearIndex();
            this.nextId = 0;
            this.emit('cleared');
        }
        catch (error) {
            logger_1.logger.error('Error clearing vector store:', error);
            throw error;
        }
    }
    async getStats() {
        if (!this.isInitialized) {
            throw new Error('Vector store not initialized');
        }
        return {
            totalDocuments: this.documents.size,
            totalVectors: this.nextId,
            indexSize: this.index.getCurrentCount(),
            maxElements: this.index.getMaxElements(),
        };
    }
    async cleanup() {
        if (!this.isInitialized)
            return;
        try {
            await this.saveIndex();
            this.isInitialized = false;
        }
        catch (error) {
            logger_1.logger.error('Error cleaning up vector store:', error);
            throw error;
        }
    }
}
exports.VectorStoreService = VectorStoreService;
//# sourceMappingURL=VectorStoreService.js.map
</file>

<file path="src/services/VectorStoreService.js.map">
{"version":3,"file":"VectorStoreService.js","sourceRoot":"","sources":["VectorStoreService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/VectorStoreService.ts">
import { logger } from '../utils/logger';
import type { Document } from '@shared/types/ipc';
import { v4 as uuidv4 } from 'uuid';
import hnswlib from 'hnswlib-node';
import path from 'path';
import { app } from 'electron';
import { EmbeddingService } from './EmbeddingService';
import { EventEmitter } from 'events';
// Type declaration for HierarchicalNSW
interface HierarchicalNSW {
  new (space: string, dim: number): any;
  initIndex(maxElements: number): Promise<void>;
  readIndex(path: string): Promise<void>;
  writeIndex(path: string): Promise<void>;
  addPoint(point: number[], label: number): Promise<void>;
  searchKnn(query: number[], k: number): Promise<{neighbors: number[]}>;
  clearIndex(): Promise<void>;
  getMaxElements(): number;
  getCurrentCount(): number;
  resizeIndex(newSize: number): Promise<void>;
}
interface VectorEntry {
  id: string;
  document: Document;
  vectorId: number;
}
export class VectorStoreService extends EventEmitter {
  private static instance: VectorStoreService;
  private readonly CHUNK_SIZE = 1000;
  private readonly CHUNK_OVERLAP = 200;
  private readonly VECTOR_SIZE = 1536; // OpenAI embedding dimension
  private readonly MAX_ELEMENTS = 100000; // Maximum number of vectors to store
  private readonly INDEX_PATH = 'vector-store';
  private readonly SIMILARITY_THRESHOLD = 0.7;
  private documents: Map<string, Document> = new Map();
  private vectorMap: Map<number, string> = new Map(); // Maps vector IDs to document IDs
  private index!: HierarchicalNSW;
  private embeddingService: EmbeddingService;
  private nextId: number = 0;
  private isInitialized = false;
  private constructor(embeddingService: EmbeddingService) {
    super();
    this.embeddingService = embeddingService;
  }
  public static getInstance(): VectorStoreService {
    if (!VectorStoreService.instance) {
      const embeddingService = EmbeddingService.getInstance();
      VectorStoreService.instance = new VectorStoreService(embeddingService);
    }
    return VectorStoreService.instance;
  }
  async initialize(): Promise<void> {
    if (this.isInitialized) return;
    try {
      logger.info('Initializing VectorStoreService');
      // Initialize HNSW index
      this.index = new (hnswlib as any).HierarchicalNSW('cosine', this.VECTOR_SIZE);
      await this.index.initIndex(this.MAX_ELEMENTS);
      // Load existing index if available
      const indexPath = path.join(app.getPath('userData'), this.INDEX_PATH);
      try {
        await this.index.readIndex(indexPath);
        await this.loadDocuments();
        logger.info('Loaded existing vector store index');
      } catch (e) {
        logger.info('No existing index found, creating new one');
      }
      this.isInitialized = true;
      this.emit('initialized');
    } catch (error) {
      logger.error('Error initializing vector store:', error);
      throw error;
    }
  }
  private async loadDocuments(): Promise<void> {
    try {
      // TODO: Implement document loading from disk
      logger.info('Loading documents from disk');
    } catch (error) {
      logger.error('Error loading documents:', error);
      throw error;
    }
  }
  private async saveIndex(): Promise<void> {
    try {
      const indexPath = path.join(app.getPath('userData'), this.INDEX_PATH);
      await this.index.writeIndex(indexPath);
      logger.info('Saved vector store index');
    } catch (error) {
      logger.error('Error saving vector store index:', error);
      throw error;
    }
  }
  private chunkText(text: string): string[] {
    const chunks: string[] = [];
    let start = 0;
    while (start < text.length) {
      const end = Math.min(start + this.CHUNK_SIZE, text.length);
      let chunk = text.slice(start, end);
      // If we're not at the end, try to find a good break point
      if (end < text.length) {
        const lastPeriod = chunk.lastIndexOf('.');
        const lastSpace = chunk.lastIndexOf(' ');
        if (lastPeriod > this.CHUNK_SIZE - this.CHUNK_OVERLAP) {
          chunk = chunk.slice(0, lastPeriod + 1);
          start = start + lastPeriod + 1;
        } else if (lastSpace > this.CHUNK_SIZE - this.CHUNK_OVERLAP) {
          chunk = chunk.slice(0, lastSpace + 1);
          start = start + lastSpace + 1;
        } else {
          start = end;
        }
      } else {
        start = end;
      }
      chunks.push(chunk);
    }
    return chunks;
  }
  async addDocument(document: Omit<Document, 'id'>): Promise<void> {
    if (!this.isInitialized) {
      throw new Error('Vector store not initialized');
    }
    try {
      const id = uuidv4();
      const chunks = this.chunkText(document.content);
      for (const chunk of chunks) {
        const chunkId = uuidv4();
        const chunkDoc: Document = {
          id: chunkId,
          content: chunk,
          metadata: {
            ...document.metadata,
            originalId: id,
            chunkIndex: chunks.indexOf(chunk),
            totalChunks: chunks.length,
          },
        };
        // Generate embedding
        const embedding = await this.embeddingService.generateEmbedding(chunk);
        // Add to vector store
        await this.index.addPoint(embedding, this.nextId);
        this.vectorMap.set(this.nextId, chunkId);
        this.documents.set(chunkId, chunkDoc);
        this.nextId++;
        // Check if we need to resize the index
        if (this.nextId >= this.index.getMaxElements()) {
          const newSize = Math.min(this.index.getMaxElements() * 2, this.MAX_ELEMENTS);
          await this.index.resizeIndex(newSize);
          logger.info(`Resized vector store index to ${newSize} elements`);
        }
      }
      // Save index periodically
      if (this.nextId % 100 === 0) {
        await this.saveIndex();
      }
      this.emit('documentAdded', id);
    } catch (error) {
      logger.error('Error adding document:', error);
      throw error;
    }
  }
  async searchSimilar(query: string, k: number = 5): Promise<Document[]> {
    if (!this.isInitialized) {
      throw new Error('Vector store not initialized');
    }
    try {
      // Generate query embedding
      const queryEmbedding = await this.embeddingService.generateEmbedding(query);
      // Search for similar vectors
      const { neighbors } = await this.index.searchKnn(queryEmbedding, k);
      // Map vector IDs back to documents
      const results: Document[] = [];
      for (const neighborId of neighbors) {
        const docId = this.vectorMap.get(neighborId);
        if (docId) {
          const doc = this.documents.get(docId);
          if (doc) {
            results.push(doc);
          }
        }
      }
      return results;
    } catch (error) {
      logger.error('Error searching documents:', error);
      throw error;
    }
  }
  async deleteDocument(id: string): Promise<void> {
    if (!this.isInitialized) {
      throw new Error('Vector store not initialized');
    }
    try {
      // Delete all chunks associated with the document
      for (const [chunkId, doc] of this.documents.entries()) {
        if (doc.metadata.originalId === id) {
          this.documents.delete(chunkId);
          // Note: We can't remove from HNSW index, but we can mark as deleted
          // in the vectorMap by setting to null
          for (const [vectorId, docId] of this.vectorMap.entries()) {
            if (docId === chunkId) {
              this.vectorMap.set(vectorId, '');
            }
          }
        }
      }
      this.emit('documentDeleted', id);
    } catch (error) {
      logger.error('Error deleting document:', error);
      throw error;
    }
  }
  async clear(): Promise<void> {
    if (!this.isInitialized) {
      throw new Error('Vector store not initialized');
    }
    try {
      this.documents.clear();
      this.vectorMap.clear();
      await this.index.clearIndex();
      this.nextId = 0;
      this.emit('cleared');
    } catch (error) {
      logger.error('Error clearing vector store:', error);
      throw error;
    }
  }
  async getStats(): Promise<{
    totalDocuments: number;
    totalVectors: number;
    indexSize: number;
    maxElements: number;
  }> {
    if (!this.isInitialized) {
      throw new Error('Vector store not initialized');
    }
    return {
      totalDocuments: this.documents.size,
      totalVectors: this.nextId,
      indexSize: this.index.getCurrentCount(),
      maxElements: this.index.getMaxElements(),
    };
  }
  async cleanup(): Promise<void> {
    if (!this.isInitialized) return;
    try {
      await this.saveIndex();
      this.isInitialized = false;
    } catch (error) {
      logger.error('Error cleaning up vector store:', error);
      throw error;
    }
  }
}
</file>

<file path="src/services/WorkerService.d.ts">
import { BaseService, ServiceConfig } from './Service';
export interface Task {
    id: string;
    type: string;
    data: any;
    priority: number;
    retryCount?: number;
    workerId?: number;
}
export interface WorkerConfig extends ServiceConfig {
    maxWorkers: number;
    taskQueueSize: number;
    workerTimeout: number;
    retryAttempts: number;
    workerScript: string;
}
export declare class WorkerService extends BaseService {
    private workers;
    private taskQueue;
    private activeTasks;
    private config;
    constructor(config: WorkerConfig);
    protected initialize(): Promise<void>;
    protected cleanup(): Promise<void>;
    protected checkHealth(): Promise<boolean>;
    submitTask(task: Omit<Task, 'id'>): Promise<string>;
    private processNextTask;
    private handleWorkerMessage;
    private handleWorkerError;
    private handleWorkerExit;
    private handleTaskTimeout;
    getMetrics(): Promise<any>;
}
</file>

<file path="src/services/WorkerService.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerService = void 0;
const worker_threads_1 = require("worker_threads");
const Service_1 = require("./Service");
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
class WorkerService extends Service_1.BaseService {
    constructor(config) {
        super(config);
        this.workers = [];
        this.taskQueue = [];
        this.activeTasks = new Map();
        this.config = {
            maxWorkers: 4,
            taskQueueSize: 100,
            workerTimeout: 30000,
            retryAttempts: 3,
            ...config
        };
    }
    async initialize() {
        try {
            // Initialize worker pool
            for (let i = 0; i < this.config.maxWorkers; i++) {
                const worker = new worker_threads_1.Worker(path_1.default.join(__dirname, 'workers', this.config.workerScript), {
                    workerData: {
                        workerId: i,
                        config: this.config
                    }
                });
                worker.on('message', this.handleWorkerMessage.bind(this));
                worker.on('error', this.handleWorkerError.bind(this));
                worker.on('exit', this.handleWorkerExit.bind(this));
                this.workers.push(worker);
            }
            this.logger.info(`WorkerService initialized with ${this.config.maxWorkers} workers`);
        }
        catch (error) {
            this.logger.error('Failed to initialize WorkerService:', error);
            throw error;
        }
    }
    async cleanup() {
        try {
            // Terminate all workers
            await Promise.all(this.workers.map(worker => worker.terminate()));
            this.workers = [];
            this.taskQueue = [];
            this.activeTasks.clear();
        }
        catch (error) {
            this.logger.error('Error cleaning up WorkerService:', error);
            throw error;
        }
    }
    async checkHealth() {
        try {
            // Check if workers are responsive
            const healthChecks = this.workers.map(worker => new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(false), 5000);
                worker.postMessage({ type: 'health_check' });
                worker.once('message', (msg) => {
                    if (msg.type === 'health_check_response') {
                        clearTimeout(timeout);
                        resolve(true);
                    }
                });
            }));
            const results = await Promise.all(healthChecks);
            return results.every(healthy => healthy);
        }
        catch (error) {
            this.logger.error('Health check failed:', error);
            return false;
        }
    }
    async submitTask(task) {
        if (this.taskQueue.length >= this.config.taskQueueSize) {
            throw new Error('Task queue is full');
        }
        const taskWithId = {
            ...task,
            id: (0, uuid_1.v4)()
        };
        this.taskQueue.push(taskWithId);
        this.processNextTask();
        return taskWithId.id;
    }
    async processNextTask() {
        if (this.taskQueue.length === 0)
            return;
        const availableWorker = this.workers.find(worker => !Array.from(this.activeTasks.values()).some(task => task.workerId === worker.threadId));
        if (!availableWorker)
            return;
        const task = this.taskQueue.shift();
        this.activeTasks.set(task.id, { ...task, workerId: availableWorker.threadId });
        availableWorker.postMessage({
            type: 'task',
            task
        });
        // Set timeout for task
        setTimeout(() => {
            if (this.activeTasks.has(task.id)) {
                this.handleTaskTimeout(task.id);
            }
        }, this.config.workerTimeout);
    }
    handleWorkerMessage(message) {
        if (message.type === 'task_complete') {
            const task = this.activeTasks.get(message.taskId);
            if (task) {
                this.activeTasks.delete(message.taskId);
                this.emit('taskComplete', {
                    taskId: message.taskId,
                    result: message.result
                });
                this.processNextTask();
            }
        }
    }
    handleWorkerError(error) {
        this.logger.error('Worker error:', error);
        this.emit('workerError', error);
    }
    handleWorkerExit(code) {
        this.logger.warn(`Worker exited with code ${code}`);
        this.emit('workerExit', code);
    }
    handleTaskTimeout(taskId) {
        const task = this.activeTasks.get(taskId);
        if (task) {
            this.activeTasks.delete(taskId);
            this.emit('taskTimeout', taskId);
            if ((task.retryCount || 0) < this.config.retryAttempts) {
                this.taskQueue.push({
                    ...task,
                    retryCount: (task.retryCount || 0) + 1
                });
                this.processNextTask();
            }
        }
    }
    getMetrics() {
        return Promise.resolve({
            activeTasks: this.activeTasks.size,
            queuedTasks: this.taskQueue.length,
            workerCount: this.workers.length
        });
    }
}
exports.WorkerService = WorkerService;
//# sourceMappingURL=WorkerService.js.map
</file>

<file path="src/services/WorkerService.js.map">
{"version":3,"file":"WorkerService.js","sourceRoot":"","sources":["WorkerService.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/services/WorkerService.ts">
import { Worker } from 'worker_threads';
import { BaseService, ServiceConfig } from './Service';
import { logger } from '../utils/logger';
import path from 'path';
import { app } from 'electron';
import { v4 as uuidv4 } from 'uuid';
export interface Task {
  id: string;
  type: string;
  data: any;
  priority: number;
  retryCount?: number;
  workerId?: number;
}
export interface WorkerConfig extends ServiceConfig {
  maxWorkers: number;
  taskQueueSize: number;
  workerTimeout: number;
  retryAttempts: number;
  workerScript: string;
}
export class WorkerService extends BaseService {
  private workers: Worker[] = [];
  private taskQueue: Task[] = [];
  private activeTasks: Map<string, Task> = new Map();
  private config: WorkerConfig;
  constructor(config: WorkerConfig) {
    super(config);
    this.config = {
      maxWorkers: 4,
      taskQueueSize: 100,
      workerTimeout: 30000,
      retryAttempts: 3,
      ...config
    };
  }
  protected async initialize(): Promise<void> {
    try {
      // Initialize worker pool
      for (let i = 0; i < this.config.maxWorkers; i++) {
        const worker = new Worker(
          path.join(__dirname, 'workers', this.config.workerScript),
          {
            workerData: {
              workerId: i,
              config: this.config
            }
          }
        );
        worker.on('message', this.handleWorkerMessage.bind(this));
        worker.on('error', this.handleWorkerError.bind(this));
        worker.on('exit', this.handleWorkerExit.bind(this));
        this.workers.push(worker);
      }
      this.logger.info(`WorkerService initialized with ${this.config.maxWorkers} workers`);
    } catch (error) {
      this.logger.error('Failed to initialize WorkerService:', error);
      throw error;
    }
  }
  protected async cleanup(): Promise<void> {
    try {
      // Terminate all workers
      await Promise.all(
        this.workers.map(worker => worker.terminate())
      );
      this.workers = [];
      this.taskQueue = [];
      this.activeTasks.clear();
    } catch (error) {
      this.logger.error('Error cleaning up WorkerService:', error);
      throw error;
    }
  }
  protected async checkHealth(): Promise<boolean> {
    try {
      // Check if workers are responsive
      const healthChecks = this.workers.map(worker => 
        new Promise<boolean>((resolve) => {
          const timeout = setTimeout(() => resolve(false), 5000);
          worker.postMessage({ type: 'health_check' });
          worker.once('message', (msg) => {
            if (msg.type === 'health_check_response') {
              clearTimeout(timeout);
              resolve(true);
            }
          });
        })
      );
      const results = await Promise.all(healthChecks);
      return results.every(healthy => healthy);
    } catch (error) {
      this.logger.error('Health check failed:', error);
      return false;
    }
  }
  public async submitTask(task: Omit<Task, 'id'>): Promise<string> {
    if (this.taskQueue.length >= this.config.taskQueueSize) {
      throw new Error('Task queue is full');
    }
    const taskWithId = {
      ...task,
      id: uuidv4()
    };
    this.taskQueue.push(taskWithId);
    this.processNextTask();
    return taskWithId.id;
  }
  private async processNextTask(): Promise<void> {
    if (this.taskQueue.length === 0) return;
    const availableWorker = this.workers.find(worker => 
      !Array.from(this.activeTasks.values()).some(task => 
        task.workerId === worker.threadId
      )
    );
    if (!availableWorker) return;
    const task = this.taskQueue.shift()!;
    this.activeTasks.set(task.id, { ...task, workerId: availableWorker.threadId });
    availableWorker.postMessage({
      type: 'task',
      task
    });
    // Set timeout for task
    setTimeout(() => {
      if (this.activeTasks.has(task.id)) {
        this.handleTaskTimeout(task.id);
      }
    }, this.config.workerTimeout);
  }
  private handleWorkerMessage(message: any): void {
    if (message.type === 'task_complete') {
      const task = this.activeTasks.get(message.taskId);
      if (task) {
        this.activeTasks.delete(message.taskId);
        this.emit('taskComplete', {
          taskId: message.taskId,
          result: message.result
        });
        this.processNextTask();
      }
    }
  }
  private handleWorkerError(error: Error): void {
    this.logger.error('Worker error:', error);
    this.emit('workerError', error);
  }
  private handleWorkerExit(code: number): void {
    this.logger.warn(`Worker exited with code ${code}`);
    this.emit('workerExit', code);
  }
  private handleTaskTimeout(taskId: string): void {
    const task = this.activeTasks.get(taskId);
    if (task) {
      this.activeTasks.delete(taskId);
      this.emit('taskTimeout', taskId);
      if ((task.retryCount || 0) < this.config.retryAttempts) {
        this.taskQueue.push({
          ...task,
          retryCount: (task.retryCount || 0) + 1
        });
        this.processNextTask();
      }
    }
  }
  public getMetrics(): Promise<any> {
    return Promise.resolve({
      activeTasks: this.activeTasks.size,
      queuedTasks: this.taskQueue.length,
      workerCount: this.workers.length
    });
  }
}
</file>

<file path="src/utils/errors.d.ts">
export declare enum ErrorSeverity {
    LOW = "low",
    MEDIUM = "medium",
    HIGH = "high",
    CRITICAL = "critical"
}
export declare enum ErrorCategory {
    WINDOW = "window",
    SERVICE = "service",
    IPC = "ipc",
    RENDERER = "renderer",
    SYSTEM = "system",
    NETWORK = "network",
    DATABASE = "database"
}
export interface ErrorContext {
    category: ErrorCategory;
    severity: ErrorSeverity;
    recoverable: boolean;
    timestamp: string;
    details?: Record<string, any>;
}
export declare class AppError extends Error {
    readonly context: ErrorContext;
    constructor(message: string, category: ErrorCategory, severity?: ErrorSeverity, recoverable?: boolean, details?: Record<string, any>);
}
export declare class WindowError extends AppError {
    constructor(message: string, severity?: ErrorSeverity, details?: Record<string, any>);
}
export declare class ServiceError extends AppError {
    constructor(message: string, severity?: ErrorSeverity, details?: Record<string, any>);
}
export declare class IPCError extends AppError {
    constructor(message: string, severity?: ErrorSeverity, details?: Record<string, any>);
}
export declare class ErrorHandler {
    private static instance;
    private errorCount;
    private readonly MAX_RETRIES;
    private readonly RETRY_DELAY;
    private constructor();
    static getInstance(): ErrorHandler;
    private initializeErrorCounts;
    handleError(error: Error | AppError): void;
    private normalizeError;
    private logError;
    private updateErrorCount;
    private attemptRecovery;
    private recoverWindow;
    private recoverService;
    private recoverIPC;
    private recoverRenderer;
    resetErrorCount(category: ErrorCategory): void;
    getErrorCount(category: ErrorCategory): number;
}
</file>

<file path="src/utils/errors.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorHandler = exports.IPCError = exports.ServiceError = exports.WindowError = exports.AppError = exports.ErrorCategory = exports.ErrorSeverity = void 0;
const logger_1 = require("./logger");
var ErrorSeverity;
(function (ErrorSeverity) {
    ErrorSeverity["LOW"] = "low";
    ErrorSeverity["MEDIUM"] = "medium";
    ErrorSeverity["HIGH"] = "high";
    ErrorSeverity["CRITICAL"] = "critical";
})(ErrorSeverity || (exports.ErrorSeverity = ErrorSeverity = {}));
var ErrorCategory;
(function (ErrorCategory) {
    ErrorCategory["WINDOW"] = "window";
    ErrorCategory["SERVICE"] = "service";
    ErrorCategory["IPC"] = "ipc";
    ErrorCategory["RENDERER"] = "renderer";
    ErrorCategory["SYSTEM"] = "system";
    ErrorCategory["NETWORK"] = "network";
    ErrorCategory["DATABASE"] = "database";
})(ErrorCategory || (exports.ErrorCategory = ErrorCategory = {}));
class AppError extends Error {
    constructor(message, category, severity = ErrorSeverity.MEDIUM, recoverable = true, details) {
        super(message);
        this.name = 'AppError';
        this.context = {
            category,
            severity,
            recoverable,
            timestamp: new Date().toISOString(),
            details
        };
    }
}
exports.AppError = AppError;
class WindowError extends AppError {
    constructor(message, severity = ErrorSeverity.MEDIUM, details) {
        super(message, ErrorCategory.WINDOW, severity, true, details);
        this.name = 'WindowError';
    }
}
exports.WindowError = WindowError;
class ServiceError extends AppError {
    constructor(message, severity = ErrorSeverity.MEDIUM, details) {
        super(message, ErrorCategory.SERVICE, severity, true, details);
        this.name = 'ServiceError';
    }
}
exports.ServiceError = ServiceError;
class IPCError extends AppError {
    constructor(message, severity = ErrorSeverity.MEDIUM, details) {
        super(message, ErrorCategory.IPC, severity, true, details);
        this.name = 'IPCError';
    }
}
exports.IPCError = IPCError;
class ErrorHandler {
    constructor() {
        this.errorCount = new Map();
        this.MAX_RETRIES = 3;
        this.RETRY_DELAY = 5000; // 5 seconds
        this.initializeErrorCounts();
    }
    static getInstance() {
        if (!ErrorHandler.instance) {
            ErrorHandler.instance = new ErrorHandler();
        }
        return ErrorHandler.instance;
    }
    initializeErrorCounts() {
        Object.values(ErrorCategory).forEach(category => {
            this.errorCount.set(category, 0);
        });
    }
    handleError(error) {
        const appError = this.normalizeError(error);
        this.logError(appError);
        this.updateErrorCount(appError.context.category);
        this.attemptRecovery(appError);
    }
    normalizeError(error) {
        if (error instanceof AppError) {
            return error;
        }
        // Convert generic errors to AppError
        return new AppError(error.message, ErrorCategory.SYSTEM, ErrorSeverity.MEDIUM, true, { originalError: error });
    }
    logError(error) {
        const { category, severity, timestamp, details } = error.context;
        const errorCount = this.errorCount.get(category) || 0;
        logger_1.logger.error(`[${severity.toUpperCase()}] ${error.name}: ${error.message}`, {
            category,
            timestamp,
            errorCount,
            details,
            stack: error.stack
        });
    }
    updateErrorCount(category) {
        const currentCount = this.errorCount.get(category) || 0;
        this.errorCount.set(category, currentCount + 1);
    }
    async attemptRecovery(error) {
        if (!error.context.recoverable) {
            logger_1.logger.error('Non-recoverable error encountered:', error);
            return;
        }
        const errorCount = this.errorCount.get(error.context.category) || 0;
        if (errorCount > this.MAX_RETRIES) {
            logger_1.logger.error(`Maximum retry attempts (${this.MAX_RETRIES}) exceeded for ${error.context.category}`);
            return;
        }
        try {
            switch (error.context.category) {
                case ErrorCategory.WINDOW:
                    await this.recoverWindow();
                    break;
                case ErrorCategory.SERVICE:
                    await this.recoverService(error);
                    break;
                case ErrorCategory.IPC:
                    await this.recoverIPC();
                    break;
                case ErrorCategory.RENDERER:
                    await this.recoverRenderer();
                    break;
                default:
                    logger_1.logger.warn(`No specific recovery strategy for ${error.context.category}`);
            }
        }
        catch (recoveryError) {
            logger_1.logger.error('Recovery attempt failed:', recoveryError);
        }
    }
    async recoverWindow() {
        logger_1.logger.info('Attempting window recovery...');
        // Window recovery logic will be implemented in WindowManager
    }
    async recoverService(error) {
        logger_1.logger.info('Attempting service recovery...');
        // Service recovery logic will be implemented in ServiceManager
    }
    async recoverIPC() {
        logger_1.logger.info('Attempting IPC recovery...');
        // IPC recovery logic will be implemented in IPC handlers
    }
    async recoverRenderer() {
        logger_1.logger.info('Attempting renderer recovery...');
        // Renderer recovery logic will be implemented in WindowManager
    }
    resetErrorCount(category) {
        this.errorCount.set(category, 0);
    }
    getErrorCount(category) {
        return this.errorCount.get(category) || 0;
    }
}
exports.ErrorHandler = ErrorHandler;
//# sourceMappingURL=errors.js.map
</file>

<file path="src/utils/errors.js.map">
{"version":3,"file":"errors.js","sourceRoot":"","sources":["errors.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/utils/errors.ts">
import { logger } from './logger';
export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}
export enum ErrorCategory {
  WINDOW = 'window',
  SERVICE = 'service',
  IPC = 'ipc',
  RENDERER = 'renderer',
  SYSTEM = 'system',
  NETWORK = 'network',
  DATABASE = 'database'
}
export interface ErrorContext {
  category: ErrorCategory;
  severity: ErrorSeverity;
  recoverable: boolean;
  timestamp: string;
  details?: Record<string, any>;
}
export class AppError extends Error {
  public readonly context: ErrorContext;
  constructor(
    message: string,
    category: ErrorCategory,
    severity: ErrorSeverity = ErrorSeverity.MEDIUM,
    recoverable: boolean = true,
    details?: Record<string, any>
  ) {
    super(message);
    this.name = 'AppError';
    this.context = {
      category,
      severity,
      recoverable,
      timestamp: new Date().toISOString(),
      details
    };
  }
}
export class WindowError extends AppError {
  constructor(message: string, severity: ErrorSeverity = ErrorSeverity.MEDIUM, details?: Record<string, any>) {
    super(message, ErrorCategory.WINDOW, severity, true, details);
    this.name = 'WindowError';
  }
}
export class ServiceError extends AppError {
  constructor(message: string, severity: ErrorSeverity = ErrorSeverity.MEDIUM, details?: Record<string, any>) {
    super(message, ErrorCategory.SERVICE, severity, true, details);
    this.name = 'ServiceError';
  }
}
export class IPCError extends AppError {
  constructor(message: string, severity: ErrorSeverity = ErrorSeverity.MEDIUM, details?: Record<string, any>) {
    super(message, ErrorCategory.IPC, severity, true, details);
    this.name = 'IPCError';
  }
}
export class ErrorHandler {
  private static instance: ErrorHandler;
  private errorCount: Map<ErrorCategory, number> = new Map();
  private readonly MAX_RETRIES = 3;
  private readonly RETRY_DELAY = 5000; // 5 seconds
  private constructor() {
    this.initializeErrorCounts();
  }
  public static getInstance(): ErrorHandler {
    if (!ErrorHandler.instance) {
      ErrorHandler.instance = new ErrorHandler();
    }
    return ErrorHandler.instance;
  }
  private initializeErrorCounts(): void {
    Object.values(ErrorCategory).forEach(category => {
      this.errorCount.set(category, 0);
    });
  }
  public handleError(error: Error | AppError): void {
    const appError = this.normalizeError(error);
    this.logError(appError);
    this.updateErrorCount(appError.context.category);
    this.attemptRecovery(appError);
  }
  private normalizeError(error: Error | AppError): AppError {
    if (error instanceof AppError) {
      return error;
    }
    // Convert generic errors to AppError
    return new AppError(
      error.message,
      ErrorCategory.SYSTEM,
      ErrorSeverity.MEDIUM,
      true,
      { originalError: error }
    );
  }
  private logError(error: AppError): void {
    const { category, severity, timestamp, details } = error.context;
    const errorCount = this.errorCount.get(category) || 0;
    logger.error(`[${severity.toUpperCase()}] ${error.name}: ${error.message}`, {
      category,
      timestamp,
      errorCount,
      details,
      stack: error.stack
    });
  }
  private updateErrorCount(category: ErrorCategory): void {
    const currentCount = this.errorCount.get(category) || 0;
    this.errorCount.set(category, currentCount + 1);
  }
  private async attemptRecovery(error: AppError): Promise<void> {
    if (!error.context.recoverable) {
      logger.error('Non-recoverable error encountered:', error);
      return;
    }
    const errorCount = this.errorCount.get(error.context.category) || 0;
    if (errorCount > this.MAX_RETRIES) {
      logger.error(`Maximum retry attempts (${this.MAX_RETRIES}) exceeded for ${error.context.category}`);
      return;
    }
    try {
      switch (error.context.category) {
        case ErrorCategory.WINDOW:
          await this.recoverWindow();
          break;
        case ErrorCategory.SERVICE:
          await this.recoverService(error);
          break;
        case ErrorCategory.IPC:
          await this.recoverIPC();
          break;
        case ErrorCategory.RENDERER:
          await this.recoverRenderer();
          break;
        default:
          logger.warn(`No specific recovery strategy for ${error.context.category}`);
      }
    } catch (recoveryError) {
      logger.error('Recovery attempt failed:', recoveryError);
    }
  }
  private async recoverWindow(): Promise<void> {
    logger.info('Attempting window recovery...');
    // Window recovery logic will be implemented in WindowManager
  }
  private async recoverService(error: AppError): Promise<void> {
    logger.info('Attempting service recovery...');
    // Service recovery logic will be implemented in ServiceManager
  }
  private async recoverIPC(): Promise<void> {
    logger.info('Attempting IPC recovery...');
    // IPC recovery logic will be implemented in IPC handlers
  }
  private async recoverRenderer(): Promise<void> {
    logger.info('Attempting renderer recovery...');
    // Renderer recovery logic will be implemented in WindowManager
  }
  public resetErrorCount(category: ErrorCategory): void {
    this.errorCount.set(category, 0);
  }
  public getErrorCount(category: ErrorCategory): number {
    return this.errorCount.get(category) || 0;
  }
}
</file>

<file path="src/utils/logger.d.ts">
export declare class Logger {
    logDir: string;
    logFile: string;
    constructor();
    formatMessage(level: string, message: string, error?: any): string;
    writeToFile(message: string): void;
    info(message: string): void;
    error(message: string, error?: any): void;
    warn(message: string, error?: any): void;
    debug(message: string, error?: any): void;
}
export declare const logger: Logger;
</file>

<file path="src/utils/logger.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = exports.Logger = void 0;
const electron_1 = require("electron");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const date_fns_1 = require("date-fns");
class Logger {
    constructor() {
        this.logDir = path_1.default.join(electron_1.app.getPath('userData'), 'logs');
        this.logFile = path_1.default.join(this.logDir, `app-${(0, date_fns_1.format)(new Date(), 'yyyy-MM-dd')}.log`);
        // Create logs directory if it doesn't exist
        if (!fs_1.default.existsSync(this.logDir)) {
            fs_1.default.mkdirSync(this.logDir, { recursive: true });
        }
    }
    formatMessage(level, message, error) {
        const timestamp = (0, date_fns_1.format)(new Date(), 'yyyy-MM-dd HH:mm:ss.SSS');
        const errorDetails = error ? `\nError: ${error instanceof Error ? error.stack : error}` : '';
        return `[${timestamp}] ${level}: ${message}${errorDetails}\n`;
    }
    writeToFile(message) {
        try {
            fs_1.default.appendFileSync(this.logFile, message);
        }
        catch (error) {
            console.error('Failed to write to log file:', error);
        }
    }
    info(message) {
        const formattedMessage = this.formatMessage('INFO', message);
        console.info(formattedMessage);
        this.writeToFile(formattedMessage);
    }
    error(message, error) {
        const formattedMessage = this.formatMessage('ERROR', message, error);
        console.error(formattedMessage);
        this.writeToFile(formattedMessage);
    }
    warn(message, error) {
        const formattedMessage = this.formatMessage('WARN', message, error);
        console.warn(formattedMessage);
        this.writeToFile(formattedMessage);
    }
    debug(message, error) {
        const formattedMessage = this.formatMessage('DEBUG', message, error);
        console.debug(formattedMessage);
        this.writeToFile(formattedMessage);
    }
}
exports.Logger = Logger;
exports.logger = new Logger();
//# sourceMappingURL=logger.js.map
</file>

<file path="src/utils/logger.js.map">
{"version":3,"file":"logger.js","sourceRoot":"","sources":["logger.ts"],"names":[],"mappings":";;;;;;AAAA,uCAA+B;AAC/B,gDAAwB;AACxB,4CAAoB;AACpB,uCAAkC;AAElC,MAAa,MAAM;IAIjB;QACE,IAAI,CAAC,MAAM,GAAG,cAAI,CAAC,IAAI,CAAC,cAAG,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,MAAM,CAAC,CAAC;QACzD,IAAI,CAAC,OAAO,GAAG,cAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,IAAA,iBAAM,EAAC,IAAI,IAAI,EAAE,EAAE,YAAY,CAAC,MAAM,CAAC,CAAC;QAErF,4CAA4C;QAC5C,IAAI,CAAC,YAAE,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;YAChC,YAAE,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QACjD,CAAC;IACH,CAAC;IAEM,aAAa,CAAC,KAAa,EAAE,OAAe,EAAE,KAAW;QAC9D,MAAM,SAAS,GAAG,IAAA,iBAAM,EAAC,IAAI,IAAI,EAAE,EAAE,yBAAyB,CAAC,CAAC;QAChE,MAAM,YAAY,GAAG,KAAK,CAAC,CAAC,CAAC,YAAY,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;QAC7F,OAAO,IAAI,SAAS,KAAK,KAAK,KAAK,OAAO,GAAG,YAAY,IAAI,CAAC;IAChE,CAAC;IAEM,WAAW,CAAC,OAAe;QAChC,IAAI,CAAC;YACH,YAAE,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAC3C,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,8BAA8B,EAAE,KAAK,CAAC,CAAC;QACvD,CAAC;IACH,CAAC;IAEM,IAAI,CAAC,OAAe;QACzB,MAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAC7D,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC/B,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC;IACrC,CAAC;IAEM,KAAK,CAAC,OAAe,EAAE,KAAW;QACvC,MAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QACrE,OAAO,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;QAChC,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC;IACrC,CAAC;IAEM,IAAI,CAAC,OAAe,EAAE,KAAW;QACtC,MAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QACpE,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC/B,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC;IACrC,CAAC;IAEM,KAAK,CAAC,OAAe,EAAE,KAAW;QACvC,MAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QACrE,OAAO,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;QAChC,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC;IACrC,CAAC;CACF;AAnDD,wBAmDC;AAEY,QAAA,MAAM,GAAG,IAAI,MAAM,EAAE,CAAC"}
</file>

<file path="src/utils/logger.ts">
import { app } from 'electron';
import path from 'path';
import fs from 'fs';
import { format } from 'date-fns';
export class Logger {
  public logDir: string;
  public logFile: string;
  constructor() {
    this.logDir = path.join(app.getPath('userData'), 'logs');
    this.logFile = path.join(this.logDir, `app-${format(new Date(), 'yyyy-MM-dd')}.log`);
    // Create logs directory if it doesn't exist
    if (!fs.existsSync(this.logDir)) {
      fs.mkdirSync(this.logDir, { recursive: true });
    }
  }
  public formatMessage(level: string, message: string, error?: any): string {
    const timestamp = format(new Date(), 'yyyy-MM-dd HH:mm:ss.SSS');
    const errorDetails = error ? `\nError: ${error instanceof Error ? error.stack : error}` : '';
    return `[${timestamp}] ${level}: ${message}${errorDetails}\n`;
  }
  public writeToFile(message: string): void {
    try {
      fs.appendFileSync(this.logFile, message);
    } catch (error) {
      console.error('Failed to write to log file:', error);
    }
  }
  public info(message: string): void {
    const formattedMessage = this.formatMessage('INFO', message);
    console.info(formattedMessage);
    this.writeToFile(formattedMessage);
  }
  public error(message: string, error?: any): void {
    const formattedMessage = this.formatMessage('ERROR', message, error);
    console.error(formattedMessage);
    this.writeToFile(formattedMessage);
  }
  public warn(message: string, error?: any): void {
    const formattedMessage = this.formatMessage('WARN', message, error);
    console.warn(formattedMessage);
    this.writeToFile(formattedMessage);
  }
  public debug(message: string, error?: any): void {
    const formattedMessage = this.formatMessage('DEBUG', message, error);
    console.debug(formattedMessage);
    this.writeToFile(formattedMessage);
  }
}
export const logger = new Logger();
</file>

<file path="src/utils/memoryManager.d.ts">
interface MemoryStats {
    heapTotal: number;
    heapUsed: number;
    external: number;
    rss: number;
    arrayBuffers: number;
    heapTotalMB: string;
    heapUsedMB: string;
    externalMB: string;
    rssMB: string;
    arrayBuffersMB: string;
    heapUsedPercentage: string;
}
export declare class MemoryManager {
    private static instance;
    private monitoringInterval;
    private gcInterval;
    private lastGcTime;
    private readonly gcCooldown;
    private readonly thresholds;
    private constructor();
    static getInstance(): MemoryManager;
    initialize(): Promise<void>;
    private startMonitoring;
    private startPeriodicGC;
    private getMemoryStats;
    private analyzeMemoryUsage;
    private shouldRunGC;
    private runGC;
    getCurrentStats(): MemoryStats;
    cleanup(): void;
}
export {};
</file>

<file path="src/utils/memoryManager.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryManager = void 0;
const electron_1 = require("electron");
const logger_1 = require("./logger");
class MemoryManager {
    constructor() {
        this.monitoringInterval = null;
        this.gcInterval = null;
        this.lastGcTime = 0;
        this.gcCooldown = 60000; // 1 minute between GC attempts
        this.thresholds = {
            warning: 75, // 75% heap usage triggers warning
            critical: 90, // 90% heap usage triggers critical
            maxHeapSize: 4096, // 4GB max heap size
        };
        // Private constructor for singleton
    }
    static getInstance() {
        if (!MemoryManager.instance) {
            MemoryManager.instance = new MemoryManager();
        }
        return MemoryManager.instance;
    }
    async initialize() {
        // Configure V8 heap limit
        const v8HeapLimit = this.thresholds.maxHeapSize;
        if (process.platform === 'darwin') {
            electron_1.app.commandLine.appendSwitch('js-flags', `--max-old-space-size=${v8HeapLimit}`);
        }
        else {
            process.env.NODE_OPTIONS = `--max-old-space-size=${v8HeapLimit}`;
        }
        logger_1.logger.info(`Memory Manager initialized with ${v8HeapLimit}MB heap limit`);
        // Start monitoring
        this.startMonitoring();
        // Start periodic GC
        this.startPeriodicGC();
    }
    startMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
        }
        this.monitoringInterval = setInterval(() => {
            const stats = this.getMemoryStats();
            this.analyzeMemoryUsage(stats);
        }, 30000); // Check every 30 seconds
    }
    startPeriodicGC() {
        if (this.gcInterval) {
            clearInterval(this.gcInterval);
        }
        this.gcInterval = setInterval(() => {
            const stats = this.getMemoryStats();
            if (this.shouldRunGC(stats)) {
                this.runGC();
            }
        }, 300000); // Check every 5 minutes
    }
    getMemoryStats() {
        const used = process.memoryUsage();
        const heapUsedPercentage = (used.heapUsed / used.heapTotal) * 100;
        return {
            heapTotal: used.heapTotal,
            heapUsed: used.heapUsed,
            external: used.external,
            rss: used.rss,
            arrayBuffers: used.arrayBuffers,
            heapTotalMB: `${Math.round(used.heapTotal / 1024 / 1024)}MB`,
            heapUsedMB: `${Math.round(used.heapUsed / 1024 / 1024)}MB`,
            externalMB: `${Math.round(used.external / 1024 / 1024)}MB`,
            rssMB: `${Math.round(used.rss / 1024 / 1024)}MB`,
            arrayBuffersMB: `${Math.round(used.arrayBuffers / 1024 / 1024)}MB`,
            heapUsedPercentage: `${heapUsedPercentage.toFixed(2)}%`,
        };
    }
    analyzeMemoryUsage(stats) {
        const heapUsedPercentage = (stats.heapUsed / stats.heapTotal) * 100;
        if (heapUsedPercentage >= this.thresholds.critical) {
            logger_1.logger.warn('CRITICAL: High memory usage detected', {
                ...stats,
                action: 'Triggering emergency garbage collection',
            });
            this.runGC();
        }
        else if (heapUsedPercentage >= this.thresholds.warning) {
            logger_1.logger.warn('WARNING: Elevated memory usage', stats);
        }
        else {
            logger_1.logger.debug('Memory usage normal', stats);
        }
    }
    shouldRunGC(stats) {
        const now = Date.now();
        const heapUsedPercentage = (stats.heapUsed / stats.heapTotal) * 100;
        return (now - this.lastGcTime > this.gcCooldown &&
            heapUsedPercentage > this.thresholds.warning);
    }
    runGC() {
        try {
            if (global.gc) {
                const beforeStats = this.getMemoryStats();
                global.gc();
                const afterStats = this.getMemoryStats();
                const freedMemory = beforeStats.heapUsed - afterStats.heapUsed;
                const freedMemoryMB = Math.round(freedMemory / 1024 / 1024);
                logger_1.logger.info('Garbage collection completed', {
                    freedMemory: `${freedMemoryMB}MB`,
                    before: beforeStats,
                    after: afterStats,
                });
                this.lastGcTime = Date.now();
            }
            else {
                logger_1.logger.warn('Garbage collection not available. Run with --expose-gc flag');
            }
        }
        catch (error) {
            logger_1.logger.error('Error during garbage collection:', error);
        }
    }
    getCurrentStats() {
        return this.getMemoryStats();
    }
    cleanup() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
        if (this.gcInterval) {
            clearInterval(this.gcInterval);
            this.gcInterval = null;
        }
    }
}
exports.MemoryManager = MemoryManager;
//# sourceMappingURL=memoryManager.js.map
</file>

<file path="src/utils/memoryManager.js.map">
{"version":3,"file":"memoryManager.js","sourceRoot":"","sources":["memoryManager.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/utils/memoryManager.ts">
import { app } from 'electron';
import { logger } from './logger';
interface MemoryStats {
  heapTotal: number;
  heapUsed: number;
  external: number;
  rss: number;
  arrayBuffers: number;
  heapTotalMB: string;
  heapUsedMB: string;
  externalMB: string;
  rssMB: string;
  arrayBuffersMB: string;
  heapUsedPercentage: string;
}
interface MemoryThresholds {
  warning: number;  // Percentage
  critical: number; // Percentage
  maxHeapSize: number; // MB
}
export class MemoryManager {
  private static instance: MemoryManager;
  private monitoringInterval: NodeJS.Timeout | null = null;
  private gcInterval: NodeJS.Timeout | null = null;
  private lastGcTime: number = 0;
  private readonly gcCooldown: number = 60000; // 1 minute between GC attempts
  private readonly thresholds: MemoryThresholds = {
    warning: 75,    // 75% heap usage triggers warning
    critical: 90,   // 90% heap usage triggers critical
    maxHeapSize: 4096, // 4GB max heap size
  };
  private constructor() {
    // Private constructor for singleton
  }
  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }
  async initialize(): Promise<void> {
    // Configure V8 heap limit
    const v8HeapLimit = this.thresholds.maxHeapSize;
    if (process.platform === 'darwin') {
      app.commandLine.appendSwitch('js-flags', `--max-old-space-size=${v8HeapLimit}`);
    } else {
      process.env.NODE_OPTIONS = `--max-old-space-size=${v8HeapLimit}`;
    }
    logger.info(`Memory Manager initialized with ${v8HeapLimit}MB heap limit`);
    // Start monitoring
    this.startMonitoring();
    // Start periodic GC
    this.startPeriodicGC();
  }
  private startMonitoring(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }
    this.monitoringInterval = setInterval(() => {
      const stats = this.getMemoryStats();
      this.analyzeMemoryUsage(stats);
    }, 30000); // Check every 30 seconds
  }
  private startPeriodicGC(): void {
    if (this.gcInterval) {
      clearInterval(this.gcInterval);
    }
    this.gcInterval = setInterval(() => {
      const stats = this.getMemoryStats();
      if (this.shouldRunGC(stats)) {
        this.runGC();
      }
    }, 300000); // Check every 5 minutes
  }
  private getMemoryStats(): MemoryStats {
    const used = process.memoryUsage();
    const heapUsedPercentage = (used.heapUsed / used.heapTotal) * 100;
    return {
      heapTotal: used.heapTotal,
      heapUsed: used.heapUsed,
      external: used.external,
      rss: used.rss,
      arrayBuffers: used.arrayBuffers,
      heapTotalMB: `${Math.round(used.heapTotal / 1024 / 1024)}MB`,
      heapUsedMB: `${Math.round(used.heapUsed / 1024 / 1024)}MB`,
      externalMB: `${Math.round(used.external / 1024 / 1024)}MB`,
      rssMB: `${Math.round(used.rss / 1024 / 1024)}MB`,
      arrayBuffersMB: `${Math.round(used.arrayBuffers / 1024 / 1024)}MB`,
      heapUsedPercentage: `${heapUsedPercentage.toFixed(2)}%`,
    };
  }
  private analyzeMemoryUsage(stats: MemoryStats): void {
    const heapUsedPercentage = (stats.heapUsed / stats.heapTotal) * 100;
    if (heapUsedPercentage >= this.thresholds.critical) {
      logger.warn('CRITICAL: High memory usage detected', {
        ...stats,
        action: 'Triggering emergency garbage collection',
      });
      this.runGC();
    } else if (heapUsedPercentage >= this.thresholds.warning) {
      logger.warn('WARNING: Elevated memory usage', stats);
    } else {
      logger.debug('Memory usage normal', stats);
    }
  }
  private shouldRunGC(stats: MemoryStats): boolean {
    const now = Date.now();
    const heapUsedPercentage = (stats.heapUsed / stats.heapTotal) * 100;
    return (
      now - this.lastGcTime > this.gcCooldown &&
      heapUsedPercentage > this.thresholds.warning
    );
  }
  private runGC(): void {
    try {
      if (global.gc) {
        const beforeStats = this.getMemoryStats();
        global.gc();
        const afterStats = this.getMemoryStats();
        const freedMemory = beforeStats.heapUsed - afterStats.heapUsed;
        const freedMemoryMB = Math.round(freedMemory / 1024 / 1024);
        logger.info('Garbage collection completed', {
          freedMemory: `${freedMemoryMB}MB`,
          before: beforeStats,
          after: afterStats,
        });
        this.lastGcTime = Date.now();
      } else {
        logger.warn('Garbage collection not available. Run with --expose-gc flag');
      }
    } catch (error) {
      logger.error('Error during garbage collection:', error);
    }
  }
  getCurrentStats(): MemoryStats {
    return this.getMemoryStats();
  }
  cleanup(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
    if (this.gcInterval) {
      clearInterval(this.gcInterval);
      this.gcInterval = null;
    }
  }
}
</file>

<file path="src/utils/RequestQueue.d.ts">
import type { RequestQueueItem } from '../types/ollama';
export declare class RequestQueue<T> {
    private delayFn;
    private queue;
    private isProcessing;
    constructor(delayFn: (ms: number) => Promise<void>);
    enqueue(requestItem: RequestQueueItem): void;
    private process;
    clear(): void;
    get length(): number;
    get isActive(): boolean;
}
</file>

<file path="src/utils/RequestQueue.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestQueue = void 0;
class RequestQueue {
    constructor(delayFn) {
        this.delayFn = delayFn;
        this.queue = [];
        this.isProcessing = false;
    }
    enqueue(requestItem) {
        this.queue.push(requestItem);
        this.process();
    }
    async process() {
        if (this.isProcessing || !this.queue.length)
            return;
        this.isProcessing = true;
        const item = this.queue[0];
        try {
            const result = await item.request();
            item.resolve(result);
        }
        catch (err) {
            if (item.retries < item.maxRetries) {
                item.retries++;
                await this.delayFn(2 ** item.retries * 1000);
                this.isProcessing = false;
                return this.process();
            }
            item.reject(err);
        }
        this.queue.shift();
        this.isProcessing = false;
        this.process();
    }
    clear() {
        this.queue = [];
        this.isProcessing = false;
    }
    get length() {
        return this.queue.length;
    }
    get isActive() {
        return this.isProcessing;
    }
}
exports.RequestQueue = RequestQueue;
//# sourceMappingURL=RequestQueue.js.map
</file>

<file path="src/utils/RequestQueue.js.map">
{"version":3,"file":"RequestQueue.js","sourceRoot":"","sources":["RequestQueue.ts"],"names":[],"mappings":";;;AAEA,MAAa,YAAY;IAIvB,YAAoB,OAAsC;QAAtC,YAAO,GAAP,OAAO,CAA+B;QAHlD,UAAK,GAAuB,EAAE,CAAC;QAC/B,iBAAY,GAAG,KAAK,CAAC;IAEgC,CAAC;IAEvD,OAAO,CAAC,WAA6B;QAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC7B,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAEO,KAAK,CAAC,OAAO;QACnB,IAAI,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM;YAAE,OAAO;QACpD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAEzB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,EAAE,CAAC;YACpC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACvB,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;gBACnC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,MAAM,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,CAAC;gBAC7C,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;gBAC1B,OAAO,IAAI,CAAC,OAAO,EAAE,CAAC;YACxB,CAAC;YACD,IAAI,CAAC,MAAM,CAAC,GAAY,CAAC,CAAC;QAC5B,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QACnB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAEM,KAAK;QACV,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;IAC5B,CAAC;IAED,IAAW,MAAM;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IAC3B,CAAC;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;CACF;AA9CD,oCA8CC"}
</file>

<file path="src/utils/RequestQueue.ts">
import type { RequestQueueItem } from '../types/ollama';
export class RequestQueue<T> {
  private queue: RequestQueueItem[] = [];
  private isProcessing = false;
  constructor(private delayFn: (ms: number) => Promise<void>) {}
  public enqueue(requestItem: RequestQueueItem): void {
    this.queue.push(requestItem);
    this.process();
  }
  private async process(): Promise<void> {
    if (this.isProcessing || !this.queue.length) return;
    this.isProcessing = true;
    const item = this.queue[0];
    try {
      const result = await item.request();
      item.resolve(result);
    } catch (err) {
      if (item.retries < item.maxRetries) {
        item.retries++;
        await this.delayFn(2 ** item.retries * 1000);
        this.isProcessing = false;
        return this.process();
      }
      item.reject(err as Error);
    }
    this.queue.shift();
    this.isProcessing = false;
    this.process();
  }
  public clear(): void {
    this.queue = [];
    this.isProcessing = false;
  }
  public get length(): number {
    return this.queue.length;
  }
  public get isActive(): boolean {
    return this.isProcessing;
  }
}
</file>

<file path="src/utils/responseMonitor.d.ts">
export interface ResponseMetrics {
    tokenCount: number;
    responseTime: number;
    confidence: number;
    coherence: number;
    contextMatch: number;
    isTruncated: boolean;
    potentialHallucinations: string[];
}
export interface ResponseThresholds {
    maxTokenCount: number;
    minConfidence: number;
    minCoherence: number;
    minContextMatch: number;
    maxResponseTime: number;
}
export declare class ResponseMonitor {
    private static instance;
    private thresholds;
    private constructor();
    static getInstance(): ResponseMonitor;
    analyzeResponse(response: string, context: string, startTime: number, tokenCount: number): Promise<ResponseMetrics>;
    private detectTruncation;
    private calculateConfidence;
    private calculateCoherence;
    private calculateContextMatch;
    private detectHallucinations;
    private checkThresholds;
}
</file>

<file path="src/utils/responseMonitor.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseMonitor = void 0;
const logger_1 = require("./logger");
class ResponseMonitor {
    constructor() {
        this.thresholds = {
            maxTokenCount: 4096,
            minConfidence: 0.7,
            minCoherence: 0.6,
            minContextMatch: 0.5,
            maxResponseTime: 30000 // 30 seconds
        };
    }
    static getInstance() {
        if (!ResponseMonitor.instance) {
            ResponseMonitor.instance = new ResponseMonitor();
        }
        return ResponseMonitor.instance;
    }
    async analyzeResponse(response, context, startTime, tokenCount) {
        const responseTime = Date.now() - startTime;
        const isTruncated = this.detectTruncation(response);
        const confidence = this.calculateConfidence(response);
        const coherence = this.calculateCoherence(response);
        const contextMatch = this.calculateContextMatch(response, context);
        const hallucinations = this.detectHallucinations(response, context);
        const metrics = {
            tokenCount,
            responseTime,
            confidence,
            coherence,
            contextMatch,
            isTruncated,
            potentialHallucinations: hallucinations
        };
        this.checkThresholds(metrics);
        return metrics;
    }
    detectTruncation(response) {
        // Check for common truncation indicators
        const truncationIndicators = [
            /\.\.\.$/,
            /$/,
            /\[truncated\]/i,
            /\[cut off\]/i,
            /\[incomplete\]/i
        ];
        return truncationIndicators.some(pattern => pattern.test(response));
    }
    calculateConfidence(response) {
        // Simple confidence calculation based on response characteristics
        let confidence = 1.0;
        // Reduce confidence for short responses
        if (response.length < 50) {
            confidence *= 0.8;
        }
        // Reduce confidence for responses with many uncertain phrases
        const uncertainPhrases = [
            /i think/i,
            /maybe/i,
            /perhaps/i,
            /possibly/i,
            /not sure/i,
            /i'm not certain/i
        ];
        const uncertainCount = uncertainPhrases.filter(phrase => phrase.test(response)).length;
        confidence *= Math.max(0.5, 1 - (uncertainCount * 0.1));
        return confidence;
    }
    calculateCoherence(response) {
        // Simple coherence calculation based on sentence structure
        const sentences = response.split(/[.!?]+/).filter(Boolean);
        if (sentences.length === 0)
            return 0;
        let coherence = 1.0;
        // Check for sentence length consistency
        const avgLength = sentences.reduce((sum, s) => sum + s.length, 0) / sentences.length;
        const lengthVariation = sentences.reduce((sum, s) => sum + Math.abs(s.length - avgLength), 0) / sentences.length;
        coherence *= Math.max(0.5, 1 - (lengthVariation / avgLength));
        // Check for transition words
        const transitionWords = [
            'however', 'therefore', 'furthermore', 'moreover',
            'consequently', 'thus', 'hence', 'accordingly'
        ];
        const hasTransitions = transitionWords.some(word => response.toLowerCase().includes(word));
        if (hasTransitions)
            coherence *= 1.1;
        return Math.min(1, coherence);
    }
    calculateContextMatch(response, context) {
        // Calculate how well the response matches the context
        const contextWords = new Set(context.toLowerCase().split(/\W+/));
        const responseWords = response.toLowerCase().split(/\W+/);
        const matchingWords = responseWords.filter(word => contextWords.has(word));
        return matchingWords.length / responseWords.length;
    }
    detectHallucinations(response, context) {
        const hallucinations = [];
        const contextWords = new Set(context.toLowerCase().split(/\W+/));
        // Split response into sentences
        const sentences = response.split(/[.!?]+/).filter(Boolean);
        sentences.forEach(sentence => {
            const words = sentence.toLowerCase().split(/\W+/);
            const contextMatchCount = words.filter(word => contextWords.has(word)).length;
            // If a sentence has very few context words, it might be a hallucination
            if (words.length > 5 && contextMatchCount / words.length < 0.2) {
                hallucinations.push(sentence.trim());
            }
        });
        return hallucinations;
    }
    checkThresholds(metrics) {
        if (metrics.tokenCount > this.thresholds.maxTokenCount) {
            logger_1.logger.warn(`Response exceeds maximum token count: ${metrics.tokenCount}`);
        }
        if (metrics.confidence < this.thresholds.minConfidence) {
            logger_1.logger.warn(`Response confidence below threshold: ${metrics.confidence}`);
        }
        if (metrics.coherence < this.thresholds.minCoherence) {
            logger_1.logger.warn(`Response coherence below threshold: ${metrics.coherence}`);
        }
        if (metrics.contextMatch < this.thresholds.minContextMatch) {
            logger_1.logger.warn(`Response context match below threshold: ${metrics.contextMatch}`);
        }
        if (metrics.responseTime > this.thresholds.maxResponseTime) {
            logger_1.logger.warn(`Response time exceeds threshold: ${metrics.responseTime}ms`);
        }
    }
}
exports.ResponseMonitor = ResponseMonitor;
//# sourceMappingURL=responseMonitor.js.map
</file>

<file path="src/utils/responseMonitor.js.map">
{"version":3,"file":"responseMonitor.js","sourceRoot":"","sources":["responseMonitor.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/utils/responseMonitor.ts">
import { logger } from './logger';
export interface ResponseMetrics {
  tokenCount: number;
  responseTime: number;
  confidence: number;
  coherence: number;
  contextMatch: number;
  isTruncated: boolean;
  potentialHallucinations: string[];
}
export interface ResponseThresholds {
  maxTokenCount: number;
  minConfidence: number;
  minCoherence: number;
  minContextMatch: number;
  maxResponseTime: number;
}
export class ResponseMonitor {
  private static instance: ResponseMonitor;
  private thresholds: ResponseThresholds;
  private constructor() {
    this.thresholds = {
      maxTokenCount: 4096,
      minConfidence: 0.7,
      minCoherence: 0.6,
      minContextMatch: 0.5,
      maxResponseTime: 30000 // 30 seconds
    };
  }
  public static getInstance(): ResponseMonitor {
    if (!ResponseMonitor.instance) {
      ResponseMonitor.instance = new ResponseMonitor();
    }
    return ResponseMonitor.instance;
  }
  public async analyzeResponse(
    response: string,
    context: string,
    startTime: number,
    tokenCount: number
  ): Promise<ResponseMetrics> {
    const responseTime = Date.now() - startTime;
    const isTruncated = this.detectTruncation(response);
    const confidence = this.calculateConfidence(response);
    const coherence = this.calculateCoherence(response);
    const contextMatch = this.calculateContextMatch(response, context);
    const hallucinations = this.detectHallucinations(response, context);
    const metrics: ResponseMetrics = {
      tokenCount,
      responseTime,
      confidence,
      coherence,
      contextMatch,
      isTruncated,
      potentialHallucinations: hallucinations
    };
    this.checkThresholds(metrics);
    return metrics;
  }
  private detectTruncation(response: string): boolean {
    // Check for common truncation indicators
    const truncationIndicators = [
      /\.\.\.$/,
      /$/,
      /\[truncated\]/i,
      /\[cut off\]/i,
      /\[incomplete\]/i
    ];
    return truncationIndicators.some(pattern => pattern.test(response));
  }
  private calculateConfidence(response: string): number {
    // Simple confidence calculation based on response characteristics
    let confidence = 1.0;
    // Reduce confidence for short responses
    if (response.length < 50) {
      confidence *= 0.8;
    }
    // Reduce confidence for responses with many uncertain phrases
    const uncertainPhrases = [
      /i think/i,
      /maybe/i,
      /perhaps/i,
      /possibly/i,
      /not sure/i,
      /i'm not certain/i
    ];
    const uncertainCount = uncertainPhrases.filter(phrase => phrase.test(response)).length;
    confidence *= Math.max(0.5, 1 - (uncertainCount * 0.1));
    return confidence;
  }
  private calculateCoherence(response: string): number {
    // Simple coherence calculation based on sentence structure
    const sentences = response.split(/[.!?]+/).filter(Boolean);
    if (sentences.length === 0) return 0;
    let coherence = 1.0;
    // Check for sentence length consistency
    const avgLength = sentences.reduce((sum, s) => sum + s.length, 0) / sentences.length;
    const lengthVariation = sentences.reduce((sum, s) => sum + Math.abs(s.length - avgLength), 0) / sentences.length;
    coherence *= Math.max(0.5, 1 - (lengthVariation / avgLength));
    // Check for transition words
    const transitionWords = [
      'however', 'therefore', 'furthermore', 'moreover',
      'consequently', 'thus', 'hence', 'accordingly'
    ];
    const hasTransitions = transitionWords.some(word => response.toLowerCase().includes(word));
    if (hasTransitions) coherence *= 1.1;
    return Math.min(1, coherence);
  }
  private calculateContextMatch(response: string, context: string): number {
    // Calculate how well the response matches the context
    const contextWords = new Set(context.toLowerCase().split(/\W+/));
    const responseWords = response.toLowerCase().split(/\W+/);
    const matchingWords = responseWords.filter(word => contextWords.has(word));
    return matchingWords.length / responseWords.length;
  }
  private detectHallucinations(response: string, context: string): string[] {
    const hallucinations: string[] = [];
    const contextWords = new Set(context.toLowerCase().split(/\W+/));
    // Split response into sentences
    const sentences = response.split(/[.!?]+/).filter(Boolean);
    sentences.forEach(sentence => {
      const words = sentence.toLowerCase().split(/\W+/);
      const contextMatchCount = words.filter(word => contextWords.has(word)).length;
      // If a sentence has very few context words, it might be a hallucination
      if (words.length > 5 && contextMatchCount / words.length < 0.2) {
        hallucinations.push(sentence.trim());
      }
    });
    return hallucinations;
  }
  private checkThresholds(metrics: ResponseMetrics): void {
    if (metrics.tokenCount > this.thresholds.maxTokenCount) {
      logger.warn(`Response exceeds maximum token count: ${metrics.tokenCount}`);
    }
    if (metrics.confidence < this.thresholds.minConfidence) {
      logger.warn(`Response confidence below threshold: ${metrics.confidence}`);
    }
    if (metrics.coherence < this.thresholds.minCoherence) {
      logger.warn(`Response coherence below threshold: ${metrics.coherence}`);
    }
    if (metrics.contextMatch < this.thresholds.minContextMatch) {
      logger.warn(`Response context match below threshold: ${metrics.contextMatch}`);
    }
    if (metrics.responseTime > this.thresholds.maxResponseTime) {
      logger.warn(`Response time exceeds threshold: ${metrics.responseTime}ms`);
    }
  }
}
</file>

<file path="src/main.d.ts">
import './ipc/app';
import './ipc/memory';
</file>

<file path="src/main.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
const handlers_1 = require("./ipc/handlers");
const logger_1 = require("./utils/logger");
const ServiceManager_1 = require("./services/ServiceManager");
const channels_1 = require("./ipc/channels");
require("./ipc/app");
require("./ipc/memory");
const memoryManager_1 = require("./utils/memoryManager");
const WindowManager_1 = require("./main/WindowManager");
const errors_1 = require("./utils/errors");
const ollama_1 = require("./ipc/ollama");
// Configure V8 heap limit
const v8HeapLimit = 1024; // Reduced to 1GB for optimization
if (process.platform === 'darwin') {
    // On macOS, we need to set this before app is ready
    electron_1.app.commandLine.appendSwitch('js-flags', `--max-old-space-size=${v8HeapLimit}`);
}
else {
    // On other platforms, we can set it directly
    process.env.NODE_OPTIONS = `--max-old-space-size=${v8HeapLimit}`;
}
// Log the heap limit configuration
logger_1.logger.info(`V8 heap limit set to ${v8HeapLimit}MB`);
// Debug: Log memory usage periodically and trigger GC
setInterval(() => {
    if (global.gc) {
        global.gc();
    }
    const used = process.memoryUsage();
    logger_1.logger.debug('Memory usage:', {
        heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)}MB`,
        heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)}MB`,
        external: `${Math.round(used.external / 1024 / 1024)}MB`,
        rss: `${Math.round(used.rss / 1024 / 1024)}MB`,
    });
}, 30000); // Log every 30 seconds
class Application {
    constructor() {
        this.isInitialized = false;
        this.isQuitting = false;
        this.windowManager = WindowManager_1.WindowManager.getInstance();
        this.serviceManager = ServiceManager_1.ServiceManager.getInstance();
        this.errorHandler = errors_1.ErrorHandler.getInstance();
        this.memoryManager = memoryManager_1.MemoryManager.getInstance();
    }
    async start() {
        try {
            // Prevent multiple instances
            const gotTheLock = electron_1.app.requestSingleInstanceLock();
            if (!gotTheLock) {
                electron_1.app.quit();
                return;
            }
            // Handle second instance
            electron_1.app.on('second-instance', () => {
                const window = this.windowManager.getMainWindow();
                if (window) {
                    if (window.isMinimized())
                        window.restore();
                    window.focus();
                }
            });
            // Setup app events
            this.setupAppEvents();
            // Wait for app to be ready
            await new Promise((resolve) => {
                if (electron_1.app.isReady()) {
                    resolve();
                }
                else {
                    electron_1.app.once('ready', () => resolve());
                }
            });
            // Initialize application
            await this.initialize();
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.AppError('Failed to start application', errors_1.ErrorCategory.SYSTEM, errors_1.ErrorSeverity.CRITICAL, true, { originalError: error }));
            electron_1.app.quit();
        }
    }
    setupAppEvents() {
        // Handle window management
        electron_1.app.on('window-all-closed', () => {
            if (process.platform !== 'darwin') {
                this.quit();
            }
        });
        electron_1.app.on('activate', () => {
            if (!this.windowManager.getMainWindow()) {
                this.initialize();
            }
        });
        // Handle theme changes
        electron_1.nativeTheme.on('updated', () => {
            const window = this.windowManager.getMainWindow();
            if (window) {
                window.webContents.send(channels_1.IPC_CHANNELS.APP.THEME_UPDATED, {
                    theme: electron_1.nativeTheme.shouldUseDarkColors ? 'dark' : 'light',
                    shouldUseDarkColors: electron_1.nativeTheme.shouldUseDarkColors
                });
            }
        });
        // Handle app quit
        electron_1.app.on('before-quit', async (event) => {
            if (!this.isQuitting) {
                event.preventDefault();
                await this.quit();
            }
        });
        // Handle uncaught exceptions
        process.on('uncaughtException', (error) => {
            this.errorHandler.handleError(new errors_1.AppError('Uncaught exception', errors_1.ErrorCategory.SYSTEM, errors_1.ErrorSeverity.HIGH, true, { originalError: error }));
        });
        // Handle unhandled rejections
        process.on('unhandledRejection', (reason) => {
            this.errorHandler.handleError(new errors_1.AppError('Unhandled rejection', errors_1.ErrorCategory.SYSTEM, errors_1.ErrorSeverity.HIGH, true, { originalError: reason }));
        });
    }
    async initialize() {
        if (this.isInitialized)
            return;
        try {
            logger_1.logger.info('Initializing application...');
            // Initialize services first
            await this.serviceManager.initialize();
            // Create main window
            const mainWindow = await this.windowManager.createMainWindow();
            // Setup IPC handlers
            await (0, handlers_1.setupIpcHandlers)();
            const ollamaService = this.serviceManager.getService('ollama');
            if (ollamaService) {
                (0, ollama_1.registerOllamaHandlers)(ollamaService);
            }
            // Handle service status changes
            this.serviceManager.on('serviceStatusChanged', ({ serviceName, status, error }) => {
                if (mainWindow && !mainWindow.isDestroyed()) {
                    mainWindow.webContents.send(channels_1.IPC_CHANNELS.APP.SERVICE_STATUS_CHANGED, {
                        serviceName,
                        status,
                        error,
                    });
                }
            });
            this.isInitialized = true;
            logger_1.logger.info('Application initialized successfully');
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.AppError('Failed to initialize application', errors_1.ErrorCategory.SYSTEM, errors_1.ErrorSeverity.CRITICAL, true, { originalError: error }));
            // Attempt to recover by recreating the window
            setTimeout(() => {
                if (!this.windowManager.getMainWindow()) {
                    this.initialize();
                }
            }, 5000);
        }
    }
    async quit() {
        if (this.isQuitting)
            return;
        this.isQuitting = true;
        try {
            logger_1.logger.info('Quitting application...');
            // Cleanup resources
            await this.serviceManager.cleanup();
            await this.memoryManager.cleanup();
            // Close all windows
            const windows = electron_1.BrowserWindow.getAllWindows();
            for (const window of windows) {
                if (!window.isDestroyed()) {
                    window.destroy();
                }
            }
            // Quit the app
            electron_1.app.exit(0);
        }
        catch (error) {
            this.errorHandler.handleError(new errors_1.AppError('Failed to quit application gracefully', errors_1.ErrorCategory.SYSTEM, errors_1.ErrorSeverity.HIGH, true, { originalError: error }));
            // Force quit after error
            electron_1.app.exit(1);
        }
    }
}
// Start the application
const application = new Application();
application.start().catch((error) => {
    logger_1.logger.error('Failed to start application:', error);
    electron_1.app.exit(1);
});
//# sourceMappingURL=main.js.map
</file>

<file path="src/main.js.map">
{"version":3,"file":"main.js","sourceRoot":"","sources":["main.ts"],"names":[],"mappings":"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"}
</file>

<file path="src/main.ts">
import { app, BrowserWindow, ipcMain, nativeTheme } from 'electron';
import { setupIpcHandlers } from './ipc/handlers';
import { logger } from './utils/logger';
import * as path from 'path';
import { ServiceManager } from './services/ServiceManager';
import { IPC_CHANNELS } from './ipc/channels';
import './ipc/app';
import './ipc/memory';
import { OllamaService } from './services/OllamaService';
import * as fs from 'fs';
import { nativeImage } from 'electron';
import { MemoryManager } from './utils/memoryManager';
import { WindowManager } from './main/WindowManager';
import { ErrorHandler, AppError, ErrorSeverity, ErrorCategory } from './utils/errors';
import { registerOllamaHandlers } from './ipc/ollama';
// Configure V8 heap limit
const v8HeapLimit = 1024; // Reduced to 1GB for optimization
if (process.platform === 'darwin') {
  // On macOS, we need to set this before app is ready
  app.commandLine.appendSwitch('js-flags', `--max-old-space-size=${v8HeapLimit}`);
} else {
  // On other platforms, we can set it directly
  process.env.NODE_OPTIONS = `--max-old-space-size=${v8HeapLimit}`;
}
// Log the heap limit configuration
logger.info(`V8 heap limit set to ${v8HeapLimit}MB`);
// Debug: Log memory usage periodically and trigger GC
setInterval(() => {
  if (global.gc) {
    global.gc();
  }
  const used = process.memoryUsage();
  logger.debug('Memory usage:', {
    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)}MB`,
    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)}MB`,
    external: `${Math.round(used.external / 1024 / 1024)}MB`,
    rss: `${Math.round(used.rss / 1024 / 1024)}MB`,
  });
}, 30000); // Log every 30 seconds
class Application {
  private windowManager: WindowManager;
  private serviceManager: ServiceManager;
  private errorHandler: ErrorHandler;
  private memoryManager: MemoryManager;
  private isInitialized = false;
  private isQuitting = false;
  constructor() {
    this.windowManager = WindowManager.getInstance();
    this.serviceManager = ServiceManager.getInstance();
    this.errorHandler = ErrorHandler.getInstance();
    this.memoryManager = MemoryManager.getInstance();
  }
  public async start(): Promise<void> {
    try {
      // Prevent multiple instances
      const gotTheLock = app.requestSingleInstanceLock();
      if (!gotTheLock) {
        app.quit();
        return;
      }
      // Handle second instance
      app.on('second-instance', () => {
        const window = this.windowManager.getMainWindow();
        if (window) {
          if (window.isMinimized()) window.restore();
          window.focus();
        }
      });
      // Setup app events
      this.setupAppEvents();
      // Wait for app to be ready
      await new Promise<void>((resolve) => {
        if (app.isReady()) {
          resolve();
        } else {
          app.once('ready', () => resolve());
        }
      });
      // Initialize application
      await this.initialize();
    } catch (error) {
      this.errorHandler.handleError(
        new AppError(
          'Failed to start application',
          ErrorCategory.SYSTEM,
          ErrorSeverity.CRITICAL,
          true,
          { originalError: error }
        )
      );
      app.quit();
    }
  }
  private setupAppEvents(): void {
    // Handle window management
    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        this.quit();
      }
    });
    app.on('activate', () => {
      if (!this.windowManager.getMainWindow()) {
        this.initialize();
      }
    });
    // Handle theme changes
    nativeTheme.on('updated', () => {
      const window = this.windowManager.getMainWindow();
      if (window) {
        window.webContents.send(IPC_CHANNELS.APP.THEME_UPDATED, {
          theme: nativeTheme.shouldUseDarkColors ? 'dark' : 'light',
          shouldUseDarkColors: nativeTheme.shouldUseDarkColors
        });
      }
    });
    // Handle app quit
    app.on('before-quit', async (event) => {
      if (!this.isQuitting) {
        event.preventDefault();
        await this.quit();
      }
    });
    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
      this.errorHandler.handleError(
        new AppError(
          'Uncaught exception',
          ErrorCategory.SYSTEM,
          ErrorSeverity.HIGH,
          true,
          { originalError: error }
        )
      );
    });
    // Handle unhandled rejections
    process.on('unhandledRejection', (reason) => {
      this.errorHandler.handleError(
        new AppError(
          'Unhandled rejection',
          ErrorCategory.SYSTEM,
          ErrorSeverity.HIGH,
          true,
          { originalError: reason }
        )
      );
    });
  }
  private async initialize(): Promise<void> {
    if (this.isInitialized) return;
    try {
      logger.info('Initializing application...');
      // Initialize services first
      await this.serviceManager.initialize();
      // Create main window
      const mainWindow = await this.windowManager.createMainWindow();
      // Setup IPC handlers
      await setupIpcHandlers();
      const ollamaService = this.serviceManager.getService<OllamaService>('ollama');
      if (ollamaService) {
        registerOllamaHandlers(ollamaService);
      }
      // Handle service status changes
      this.serviceManager.on('serviceStatusChanged', ({ serviceName, status, error }) => {
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send(IPC_CHANNELS.APP.SERVICE_STATUS_CHANGED, {
            serviceName,
            status,
            error,
          });
        }
      });
      this.isInitialized = true;
      logger.info('Application initialized successfully');
    } catch (error) {
      this.errorHandler.handleError(
        new AppError(
          'Failed to initialize application',
          ErrorCategory.SYSTEM,
          ErrorSeverity.CRITICAL,
          true,
          { originalError: error }
        )
      );
      // Attempt to recover by recreating the window
      setTimeout(() => {
        if (!this.windowManager.getMainWindow()) {
          this.initialize();
        }
      }, 5000);
    }
  }
  private async quit(): Promise<void> {
    if (this.isQuitting) return;
    this.isQuitting = true;
    try {
      logger.info('Quitting application...');
      // Cleanup resources
      await this.serviceManager.cleanup();
      await this.memoryManager.cleanup();
      // Close all windows
      const windows = BrowserWindow.getAllWindows();
      for (const window of windows) {
        if (!window.isDestroyed()) {
          window.destroy();
        }
      }
      // Quit the app
      app.exit(0);
    } catch (error) {
      this.errorHandler.handleError(
        new AppError(
          'Failed to quit application gracefully',
          ErrorCategory.SYSTEM,
          ErrorSeverity.HIGH,
          true,
          { originalError: error }
        )
      );
      // Force quit after error
      app.exit(1);
    }
  }
}
// Start the application
const application = new Application();
application.start().catch((error) => {
  logger.error('Failed to start application:', error);
  app.exit(1);
});
</file>

<file path="src/preload.d.ts">
import { ServiceStatus, ServiceStatusInfo } from './config/services';
interface ElectronAPI {
    getServiceStatus: (service: string) => Promise<ServiceStatusInfo | undefined>;
    getAllServiceStatus: () => Promise<Map<string, ServiceStatusInfo>>;
    restartService: (service: string) => Promise<void>;
    stopService: (service: string) => Promise<void>;
    onServiceStatusChange: (callback: (event: {
        serviceName: string;
        status: ServiceStatus;
        error?: string;
        details?: Record<string, any>;
    }) => void) => () => void;
    minimize: () => Promise<void>;
    maximize: () => Promise<void>;
    close: () => Promise<void>;
    isMaximized: () => Promise<boolean>;
    getTheme: () => Promise<'light' | 'dark' | 'system'>;
    setTheme: (theme: 'light' | 'dark' | 'system') => Promise<void>;
}
declare global {
    interface Window {
        electronAPI: ElectronAPI;
    }
}
export {};
</file>

<file path="src/preload.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const electron_1 = require("electron");
console.log('[PRELOAD] Preload script started');
// Validate channel names for security
const VALID_CHANNELS = [
    'service:getStatus',
    'service:getAllStatus',
    'service:restart',
    'service:stop',
    'service:statusChanged',
    'window:minimize',
    'window:maximize',
    'window:close',
    'window:isMaximized',
    'theme:get',
    'theme:set',
    'app:get-theme',
    'app:set-theme',
    'app:theme-updated',
];
// Helper function to validate channel names
function isValidChannel(channel) {
    return VALID_CHANNELS.includes(channel);
}
// Helper function for safe IPC calls
async function safeInvoke(channel, ...args) {
    if (!isValidChannel(channel)) {
        throw new Error(`Invalid IPC channel: ${channel}`);
    }
    return electron_1.ipcRenderer.invoke(channel, ...args);
}
// Helper function for safe event listener registration
function safeOn(channel, callback) {
    if (!isValidChannel(channel)) {
        throw new Error(`Invalid IPC channel: ${channel}`);
    }
    electron_1.ipcRenderer.on(channel, (_event, ...args) => callback(...args));
    return () => {
        electron_1.ipcRenderer.removeListener(channel, callback);
    };
}
// Expose protected methods to the renderer process
electron_1.contextBridge.exposeInMainWorld('electronAPI', {
    // Service management
    getServiceStatus: (service) => safeInvoke('service:getStatus', service),
    getAllServiceStatus: () => safeInvoke('service:getAllStatus'),
    restartService: (service) => safeInvoke('service:restart', service),
    stopService: (service) => safeInvoke('service:stop', service),
    // Event handling
    onServiceStatusChange: (callback) => safeOn('service:statusChanged', callback),
    // Window management
    minimize: () => safeInvoke('window:minimize'),
    maximize: () => safeInvoke('window:maximize'),
    close: () => safeInvoke('window:close'),
    isMaximized: () => safeInvoke('window:isMaximized'),
    // Theme management
    getTheme: () => safeInvoke('app:get-theme'),
    setTheme: (theme) => safeInvoke('app:set-theme', theme),
    onThemeUpdated: (callback) => safeOn('app:theme-updated', callback),
});
// Log successful preload
console.log('Preload script executed successfully');
//# sourceMappingURL=preload.js.map
</file>

<file path="src/preload.js.map">
{"version":3,"file":"preload.js","sourceRoot":"","sources":["preload.ts"],"names":[],"mappings":";;AAAA,uCAAsD;AAUtD,OAAO,CAAC,GAAG,CAAC,kCAAkC,CAAC,CAAC;AAwBhD,sCAAsC;AACtC,MAAM,cAAc,GAAG;IACrB,mBAAmB;IACnB,sBAAsB;IACtB,iBAAiB;IACjB,cAAc;IACd,uBAAuB;IACvB,iBAAiB;IACjB,iBAAiB;IACjB,cAAc;IACd,oBAAoB;IACpB,WAAW;IACX,WAAW;IACX,eAAe;IACf,eAAe;IACf,mBAAmB;CACX,CAAC;AAIX,4CAA4C;AAC5C,SAAS,cAAc,CAAC,OAAe;IACrC,OAAO,cAAc,CAAC,QAAQ,CAAC,OAAuB,CAAC,CAAC;AAC1D,CAAC;AAED,qCAAqC;AACrC,KAAK,UAAU,UAAU,CAAC,OAAe,EAAE,GAAG,IAAW;IACvD,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC;QAC7B,MAAM,IAAI,KAAK,CAAC,wBAAwB,OAAO,EAAE,CAAC,CAAC;IACrD,CAAC;IACD,OAAO,sBAAW,CAAC,MAAM,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,CAAC;AAC9C,CAAC;AAED,uDAAuD;AACvD,SAAS,MAAM,CAAC,OAAe,EAAE,QAAkC;IACjE,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC;QAC7B,MAAM,IAAI,KAAK,CAAC,wBAAwB,OAAO,EAAE,CAAC,CAAC;IACrD,CAAC;IACD,sBAAW,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,MAAM,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IAChE,OAAO,GAAG,EAAE;QACV,sBAAW,CAAC,cAAc,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAChD,CAAC,CAAC;AACJ,CAAC;AAED,mDAAmD;AACnD,wBAAa,CAAC,iBAAiB,CAAC,aAAa,EAAE;IAC7C,qBAAqB;IACrB,gBAAgB,EAAE,CAAC,OAAe,EAAE,EAAE,CAAC,UAAU,CAAC,mBAAmB,EAAE,OAAO,CAAC;IAC/E,mBAAmB,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,sBAAsB,CAAC;IAC7D,cAAc,EAAE,CAAC,OAAe,EAAE,EAAE,CAAC,UAAU,CAAC,iBAAiB,EAAE,OAAO,CAAC;IAC3E,WAAW,EAAE,CAAC,OAAe,EAAE,EAAE,CAAC,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC;IAErE,iBAAiB;IACjB,qBAAqB,EAAE,CAAC,QAAwH,EAAE,EAAE,CAClJ,MAAM,CAAC,uBAAuB,EAAE,QAAQ,CAAC;IAE3C,oBAAoB;IACpB,QAAQ,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,iBAAiB,CAAC;IAC7C,QAAQ,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,iBAAiB,CAAC;IAC7C,KAAK,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC;IACvC,WAAW,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,oBAAoB,CAAC;IAEnD,mBAAmB;IACnB,QAAQ,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC,eAAe,CAAC;IAC3C,QAAQ,EAAE,CAAC,KAAkC,EAAE,EAAE,CAAC,UAAU,CAAC,eAAe,EAAE,KAAK,CAAC;IACpF,cAAc,EAAE,CAAC,QAAmG,EAAE,EAAE,CACtH,MAAM,CAAC,mBAAmB,EAAE,QAAQ,CAAC;CACzB,CAAC,CAAC;AAElB,yBAAyB;AACzB,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC"}
</file>

<file path="src/preload.ts">
import { contextBridge, ipcRenderer } from 'electron';
import type { 
  OllamaModel, 
  OllamaConnectionStatus,
  ModelLoadingState,
  OllamaRequestOptions,
  OllamaResponse
} from './types/ollama';
import { ServiceStatus, ServiceStatusInfo } from './config/services';
console.log('[PRELOAD] Preload script started');
// Define the API that will be exposed to the renderer
interface ElectronAPI {
  // Service management
  getServiceStatus: (service: string) => Promise<ServiceStatusInfo | undefined>;
  getAllServiceStatus: () => Promise<Map<string, ServiceStatusInfo>>;
  restartService: (service: string) => Promise<void>;
  stopService: (service: string) => Promise<void>;
  // Event handling
  onServiceStatusChange: (callback: (event: { serviceName: string; status: ServiceStatus; error?: string; details?: Record<string, any> }) => void) => () => void;
  // Window management
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
  isMaximized: () => Promise<boolean>;
  // Theme management
  getTheme: () => Promise<'light' | 'dark' | 'system'>;
  setTheme: (theme: 'light' | 'dark' | 'system') => Promise<void>;
}
// Validate channel names for security
const VALID_CHANNELS = [
  'service:getStatus',
  'service:getAllStatus',
  'service:restart',
  'service:stop',
  'service:statusChanged',
  'window:minimize',
  'window:maximize',
  'window:close',
  'window:isMaximized',
  'theme:get',
  'theme:set',
  'app:get-theme',
  'app:set-theme',
  'app:theme-updated',
] as const;
type ValidChannel = typeof VALID_CHANNELS[number];
// Helper function to validate channel names
function isValidChannel(channel: string): channel is ValidChannel {
  return VALID_CHANNELS.includes(channel as ValidChannel);
}
// Helper function for safe IPC calls
async function safeInvoke(channel: string, ...args: any[]): Promise<any> {
  if (!isValidChannel(channel)) {
    throw new Error(`Invalid IPC channel: ${channel}`);
  }
  return ipcRenderer.invoke(channel, ...args);
}
// Helper function for safe event listener registration
function safeOn(channel: string, callback: (...args: any[]) => void): () => void {
  if (!isValidChannel(channel)) {
    throw new Error(`Invalid IPC channel: ${channel}`);
  }
  ipcRenderer.on(channel, (_event, ...args) => callback(...args));
  return () => {
    ipcRenderer.removeListener(channel, callback);
  };
}
// Expose protected methods to the renderer process
contextBridge.exposeInMainWorld('electronAPI', {
  // Service management
  getServiceStatus: (service: string) => safeInvoke('service:getStatus', service),
  getAllServiceStatus: () => safeInvoke('service:getAllStatus'),
  restartService: (service: string) => safeInvoke('service:restart', service),
  stopService: (service: string) => safeInvoke('service:stop', service),
  // Event handling
  onServiceStatusChange: (callback: (event: { serviceName: string; status: ServiceStatus; error?: string; details?: Record<string, any> }) => void) => 
    safeOn('service:statusChanged', callback),
  // Window management
  minimize: () => safeInvoke('window:minimize'),
  maximize: () => safeInvoke('window:maximize'),
  close: () => safeInvoke('window:close'),
  isMaximized: () => safeInvoke('window:isMaximized'),
  // Theme management
  getTheme: () => safeInvoke('app:get-theme'),
  setTheme: (theme: 'light' | 'dark' | 'system') => safeInvoke('app:set-theme', theme),
  onThemeUpdated: (callback: (themeData: { theme: 'light' | 'dark' | 'system', shouldUseDarkColors: boolean }) => void) =>
    safeOn('app:theme-updated', callback),
} as ElectronAPI);
// Log successful preload
console.log('Preload script executed successfully');
// Optional: Expose type definitions for renderer process
declare global {
  interface Window {
    electronAPI: ElectronAPI;
  }
}
</file>

<file path="test-results/.last-run.json">
{
  "status": "failed",
  "failedTests": []
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 100
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": { "recommended": true }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double"
    }
  }
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024-2025 Once UI

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  sassOptions: {
    compiler: "modern",
    silenceDeprecations: ["legacy-js-api"],
  },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "@once-ui-system/nextjs-starter",
  "version": "0.7",
  "scripts": {
    "dev": "next dev --turbopack",
    "export": "next export",
    "build": "next build",
    "start": "next start",
    "biome-write": "npx @biomejs/biome format --write .",
    "lint": "next lint",
    "check-imports": "tsc --noEmit && eslint . --ext .ts,.tsx,.js,.jsx"
  },
  "dependencies": {
    "@floating-ui/react-dom": "^2.1.1",
    "classnames": "^2.5.1",
    "compressorjs": "^1.2.1",
    "date-fns": "^4.1.0",
    "next": "15.2.3",
    "postcss": "^8.4.39",
    "postcss-preset-env": "^9.5.15",
    "prismjs": "^1.30.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-icons": "^5.2.1",
    "recharts": "^2.15.1",
    "sass": "^1.77.6",
    "sharp": "^0.33.4"
  },
  "devDependencies": {
    "@biomejs/biome": "1.9.4",
    "@csstools/postcss-global-data": "^2.1.1",
    "@types/express": "^5.0.2",
    "@types/node": "20.17.23",
    "@types/react": "19.0.1",
    "@types/react-dom": "19.0.2",
    "eslint": "^8.57.0",
    "eslint-plugin-import": "^2.29.1",
    "postcss-custom-media": "^10.0.7",
    "postcss-flexbugs-fixes": "^5.0.2",
    "typescript": "5.8.2",
    "vitest": "^3.2.2",
    "zod": "^3.25.56"
  },
  "overrides": {
    "@types/react": "19.0.1",
    "@types/react-dom": "19.0.2"
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: [
    [
      "@csstools/postcss-global-data",
      {
        files: ["src/once-ui/styles/breakpoints.scss"],
      },
    ],
    "postcss-custom-media",
    "postcss-flexbugs-fixes",
    [
      "postcss-preset-env",
      {
        autoprefixer: {
          flexbox: "no-2009",
        },
        stage: 3,
        features: {
          "custom-properties": false,
        },
      },
    ],
  ],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "typeRoots": ["./types", "./node_modules/@types"],
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    },
    "target": "ES2017"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="vibe-tools.config.json">
{
  "web": {
    "provider": "perplexity",
    "model": "sonar-pro"
  },
  "plan": {
    "fileProvider": "gemini",
    "thinkingProvider": "gemini",
    "fileModel": "gemini-2.5-pro-preview-05-06",
    "thinkingModel": "gemini-2.5-pro-preview-05-06"
  },
  "repo": {
    "provider": "anthropic",
    "model": "claude-sonnet-4-20250514"
  },
  "doc": {
    "provider": "gemini",
    "model": "gemini-2.5-pro-preview-05-06"
  },
  "ide": "cursor"
}
</file>

<file path="WORKSPACE_ISSUE.md">
# Workspace Protocol Issue in HelloGPT

## Problem

When running `npm install` or `./dev-start.sh`, you might encounter the following error:

```
npm error code EUNSUPPORTEDPROTOCOL
npm error Unsupported URL Type "workspace:": workspace:*
```

This happens because the project uses the `workspace:*` protocol in some package.json files, which is not supported by all npm versions.

## Solutions

### Option 1: Run the Fix Script

We've created a script to automatically fix workspace dependencies:

```bash
# Make the script executable
chmod +x fix-workspace-deps.sh

# Run the script
./fix-workspace-deps.sh
```

This script will replace `workspace:*` references with `file:` paths, which are supported by all npm versions.

### Option 2: Update npm

Ensure you're using a recent version of npm that supports workspace protocol:

```bash
npm install -g npm@latest
```

### Option 3: Use Yarn or pnpm

Both Yarn and pnpm have better workspace support out of the box:

For Yarn:
```bash
npm install -g yarn
yarn install
```

For pnpm:
```bash
npm install -g pnpm
pnpm install
```

### Option 4: Manual Fix

If the automatic fix doesn't work, you can manually edit the package.json files to replace `workspace:*` with the appropriate `file:` paths:

1. In `renderer/package.json`:
   - Replace `"@electron-app/types": "workspace:*"` with `"@electron-app/types": "file:../electron-app/src/types"`

2. In other package.json files:
   - Replace `"@app/shared": "workspace:*"` with `"@app/shared": "file:../packages/shared"`

## After Fixing

After applying one of these solutions, you should be able to run:

```bash
./dev-start.sh
```

And the application should start without workspace protocol errors.

## Technical Details

The workspace protocol (`workspace:*`) is a feature used in monorepos to reference local packages. It's supported by Yarn and pnpm by default, but npm requires specific configuration and a recent version.

The fix script replaces these references with `file:` paths, which point directly to the local package directories and are supported by all package managers.
</file>

<file path="src/app/layout.tsx">
import "@/once-ui/styles/index.scss";
import "@/once-ui/tokens/index.scss";
import classNames from "classnames";
import { baseURL, style, meta, font, effects } from "@/app/resources/once-ui.config";
import { Background, Column, Flex, ToastProvider, ThemeProvider } from "@/once-ui/components";
import { opacity, SpacingToken } from "@/once-ui/types";
import { Meta, Schema } from "@/once-ui/modules";
import { chart } from "./resources/data.config";
export async function generateMetadata() {
  return Meta.generate({
    title: meta.home.title,
    description: meta.home.description,
    baseURL: baseURL,
    path: meta.home.path,
    canonical: meta.home.canonical,
    image: meta.home.image,
    robots: meta.home.robots,
    alternates: meta.home.alternates,
  });
}
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <Flex
      suppressHydrationWarning
      as="html"
      lang="en"
      fillHeight
      background="page"
      data-neutral={style.neutral}
      data-brand={style.brand}
      data-accent={style.accent}
      data-border={style.border}
      data-solid={style.solid}
      data-solid-style={style.solidStyle}
      data-surface={style.surface}
      data-transition={style.transition}
      data-scaling={style.scaling}
      data-viz={chart.mode}
      className={classNames(
        font.primary.variable,
        font.secondary.variable,
        font.tertiary.variable,
        font.code.variable,
      )}
    >
      <Schema
        as="webPage"
        baseURL={baseURL}
        title={meta.home.title}
        description={meta.home.description}
        path={meta.home.path}
      />
      <head>
        <script
          // biome-ignore lint/security/noDangerouslySetInnerHtml: <It's not dynamic nor a security issue.>
          dangerouslySetInnerHTML={{
            __html: `
              (function() {
                try {
                  const theme = localStorage.getItem('theme') || 'system';
                  const root = document.documentElement;
                  if (theme === 'system') {
                    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    root.setAttribute('data-theme', isDark ? 'dark' : 'light');
                  } else {
                    root.setAttribute('data-theme', theme);
                  }
                } catch (e) {
                  document.documentElement.setAttribute('data-theme', 'dark');
                }
              })();
            `,
          }}
        />
      </head>
      <ThemeProvider>
        <ToastProvider>
          <Column as="body" fillWidth margin="0" padding="0">
            <Background
              position="absolute"
              mask={{
                x: effects.mask.x,
                y: effects.mask.y,
                radius: effects.mask.radius,
                cursor: effects.mask.cursor,
              }}
              gradient={{
                display: effects.gradient.display,
                opacity: effects.gradient.opacity as opacity,
                x: effects.gradient.x,
                y: effects.gradient.y,
                width: effects.gradient.width,
                height: effects.gradient.height,
                tilt: effects.gradient.tilt,
                colorStart: effects.gradient.colorStart,
                colorEnd: effects.gradient.colorEnd,
              }}
              dots={{
                display: effects.dots.display,
                opacity: effects.dots.opacity as opacity,
                size: effects.dots.size as SpacingToken,
                color: effects.dots.color,
              }}
              grid={{
                display: effects.grid.display,
                opacity: effects.grid.opacity as opacity,
                color: effects.grid.color,
                width: effects.grid.width,
                height: effects.grid.height,
              }}
              lines={{
                display: effects.lines.display,
                opacity: effects.lines.opacity as opacity,
                size: effects.lines.size as SpacingToken,
                thickness: effects.lines.thickness,
                angle: effects.lines.angle,
                color: effects.lines.color,
              }}
            />
            {children}
          </Column>
        </ToastProvider>
      </ThemeProvider>
    </Flex>
  );
}
</file>

<file path="src/once-ui/components/AutoScroll.tsx">
"use client";
import { Row } from "@/once-ui/components";
import styles from "./AutoScroll.module.scss";
import React, { forwardRef } from "react";
interface AutoScrollProps extends React.ComponentProps<typeof Row> {
  children: React.ReactNode;
  speed?: "slow" | "medium" | "fast";
  pause?: boolean;
  className?: string;
  style?: React.CSSProperties;
}
const AutoScroll = forwardRef<HTMLDivElement, AutoScrollProps>(
  ({ children, speed = "medium", pause = false, className, style, ...flex }, ref) => {
    return (
      <Row overflow="hidden" fillWidth ref={ref} className={className} style={style} {...flex}>
        <Row
          fillWidth
          className={`${styles.marqueeWrapper} ${styles[speed]} ${pause ? styles.paused : ""}`}
        >
          <Row fillWidth horizontal="space-around" className={styles.marqueeContent}>
            {children}
          </Row>
          <Row fillWidth horizontal="space-around" className={styles.marqueeContent}>
            {children}
          </Row>
        </Row>
      </Row>
    );
  },
);
AutoScroll.displayName = "AutoScroll";
export { AutoScroll };
</file>

<file path="src/once-ui/components/Banner.tsx">
import { forwardRef } from "react";
import { Row } from "./Row";
interface BannerProps extends React.ComponentProps<typeof Row> {}
const Banner = forwardRef<HTMLDivElement, BannerProps>(({ children, ...flex }, ref) => (
  <Row
    fillWidth
    paddingX="16"
    paddingY="8"
    solid="brand-medium"
    onSolid="brand-strong"
    textVariant="label-default-s"
    align="center"
    center
    gap="12"
    ref={ref}
    {...flex}
  >
    {children}
  </Row>
));
Banner.displayName = "Banner";
export { Banner };
</file>

<file path="src/once-ui/components/Button.module.scss">
.button {
    display: flex;
    align-items: center;
    position: relative;
    user-select: none;
    padding: 0;
    white-space: nowrap;
    text-decoration: none;
    -webkit-tap-highlight-color: transparent;
    transition: var(--transition-micro-medium);
    &:hover, &:focus {
        z-index: 1;
    }
    &:disabled {
        box-shadow: none;
        background: var(--neutral-solid-weak);
        color: var(--neutral-on-solid-weak);
        border: none;
        pointer-events: none;
        cursor: not-allowed;
    }
}
.primary {
    box-shadow: inset 0 var(--solid-inset-distance) var(--solid-inset-size) var(--solid-inset-color-brand);
    background: var(--brand-solid-medium);
    border-style: solid;
    border-width: var(--solid-border-width);
    border-color: var(--solid-border-color-brand);
    color: var(--brand-on-solid-strong);
    &:hover, &:focus {
        background: var(--brand-solid-strong);
    }
}
.secondary {
    box-shadow: inset 0 var(--solid-inset-distance) var(--solid-inset-size) var(--solid-inset-color-neutral);
    border-style: solid;
    border: 1px solid var(--neutral-alpha-weak);
    background: var(--static-transparent);
    color: var(--neutral-on-background-strong);
    &:hover, &:focus {
        background: var(--neutral-alpha-weak);
        border-color: var(--neutral-alpha-weak);
    }
}
.tertiary {
    background: var(--static-transparent);
    color: var(--neutral-on-background-strong);
    border: 1px solid var(--static-transparent);
    &:hover, &:focus {
        border: 1px solid var(--neutral-border-medium);
    }
    &:disabled {
        background: var(--static-transparent);
        color: var(--neutral-on-background-weak);
    }
}
.ghost {
    border: none;
    background: var(--static-transparent);
    color: var(--neutral-on-background-medium);
    &:hover, &:focus {
        color: var(--neutral-on-background-strong);
    }
}
.danger {
    box-shadow: inset 0 var(--solid-inset-distance) var(--solid-inset-size) var(--solid-inset-color-danger);
    background: var(--danger-solid-medium);
    border-style: solid;
    border-width: var(--solid-border-width);
    border-color: var(--solid-border-color-danger);
    color: var(--danger-on-solid-strong);
    &:hover, &:focus {
        background: var(--danger-solid-strong);
    }
}
.s {
    padding: var(--static-space-4) var(--static-space-8);
    min-height: var(--static-space-32);
    height: var(--static-space-32);
    gap: var(--static-space-4);
}
.m {
    padding: var(--static-space-8) var(--static-space-12);
    min-height: var(--static-space-40);
    height: var(--static-space-40);
    gap: var(--static-space-4);
}
.l {
    padding: var(--static-space-12) var(--static-space-20);
    min-height: var(--static-space-48);
    height: var(--static-space-48);
    gap: var(--static-space-8);
}
</file>

<file path="src/once-ui/components/Card.tsx">
"use client";
import React, { forwardRef } from "react";
import { Flex } from ".";
import styles from "./Card.module.scss";
import { ElementType } from "./ElementType";
import classNames from "classnames";
interface CardProps extends React.ComponentProps<typeof Flex> {
  children?: React.ReactNode;
  href?: string;
  onClick?: () => void;
}
const Card = forwardRef<HTMLDivElement, CardProps>(
  ({ children, href, onClick, style, className, ...rest }, ref) => {
    return (
      <ElementType
        tabIndex={0}
        className={classNames(
          "reset-button-styles",
          "display-flex",
          "fill-width",
          "min-width-0",
          (onClick || href) && "focus-ring",
          (onClick || href) && "radius-l",
        )}
        href={href}
        onClick={onClick ? onClick : () => {}}
        role="button"
        ref={ref}
      >
        <Flex
          background="surface"
          onBackground="neutral-strong"
          transition="macro-medium"
          border="neutral-medium"
          cursor="interactive"
          align="left"
          className={styles.card}
          onClick={onClick}
          {...rest}
          style={{
            ...style,
          }}
        >
          {children}
        </Flex>
      </ElementType>
    );
  },
);
Card.displayName = "Card";
export { Card };
</file>

<file path="src/once-ui/components/DateRangeInput.tsx">
"use client";
import React, { useState, useCallback, useEffect } from "react";
import { Input, DropdownWrapper, Flex, DateRange, DateRangePicker, Row } from ".";
interface DateRangeInputProps
  extends Omit<React.ComponentProps<typeof Input>, "onChange" | "value" | "label"> {
  id: string;
  startLabel: string;
  endLabel: string;
  value?: DateRange;
  onChange?: (range: DateRange) => void;
  minHeight?: number;
  className?: string;
  style?: React.CSSProperties;
}
interface LocalizedDateRange {
  startDate: string | null;
  endDate: string | null;
}
const formatDateRange = (range: DateRange): LocalizedDateRange => {
  const options: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "short",
    day: "numeric",
  };
  return {
    startDate: range.startDate?.toLocaleDateString("en-US", options) || null,
    endDate: range.endDate?.toLocaleDateString("en-US", options) || null,
  };
};
export const DateRangeInput: React.FC<DateRangeInputProps> = ({
  id,
  startLabel = "Start",
  endLabel = "End",
  value,
  onChange,
  error,
  minHeight,
  className,
  style,
  ...rest
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState(
    value ? formatDateRange(value) : { startDate: "", endDate: "" },
  );
  useEffect(() => {
    if (value) {
      setInputValue(formatDateRange(value));
    }
  }, [value]);
  const handleDateChange = useCallback(
    (range: DateRange) => {
      setInputValue(formatDateRange(range));
      onChange?.(range);
      if (range.endDate != undefined) {
        setIsOpen(false);
      }
    },
    [onChange],
  );
  const handleInputClick = useCallback(() => {
    setIsOpen(true);
  }, []);
  const trigger = (
    <Row fillWidth horizontal="center" gap="-1">
      <Input
        className="cursor-interactive"
        style={{
          textOverflow: "ellipsis",
        }}
        radius={"left"}
        id={id}
        label={startLabel}
        value={inputValue.startDate ?? ""}
        error={error}
        readOnly
        onClick={handleInputClick}
        {...rest}
      />
      <Input
        className="cursor-interactive"
        style={{
          textOverflow: "ellipsis",
        }}
        radius={"right"}
        id={id}
        label={endLabel}
        value={inputValue.endDate ?? ""}
        error={error}
        readOnly
        onClick={handleInputClick}
        {...rest}
      />
    </Row>
  );
  const dropdown = (
    <Flex padding="20" center={true}>
      <DateRangePicker value={value} onChange={handleDateChange} />
    </Flex>
  );
  return (
    <DropdownWrapper
      fillWidth
      trigger={trigger}
      minHeight={minHeight}
      dropdown={dropdown}
      isOpen={isOpen}
      closeAfterClick={false}
      className={className}
      style={{ ...style }}
      onOpenChange={setIsOpen}
    />
  );
};
</file>

<file path="src/once-ui/components/DropdownWrapper.tsx">
"use client";
import React, {
  useState,
  useRef,
  useEffect,
  ReactNode,
  forwardRef,
  useImperativeHandle,
  useCallback,
  KeyboardEvent,
} from "react";
import {
  useFloating,
  shift,
  offset,
  flip,
  size,
  autoUpdate,
  Placement,
} from "@floating-ui/react-dom";
import { Flex, Dropdown } from ".";
import styles from "./DropdownWrapper.module.scss";
export interface DropdownWrapperProps {
  fillWidth?: boolean;
  minWidth?: number;
  maxWidth?: number;
  minHeight?: number;
  placement?: Placement;
  trigger: ReactNode;
  dropdown: ReactNode;
  selectedOption?: string;
  style?: React.CSSProperties;
  className?: string;
  onSelect?: (value: string) => void;
  closeAfterClick?: boolean;
  isOpen?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
}
const DropdownWrapper = forwardRef<HTMLDivElement, DropdownWrapperProps>(
  (
    {
      trigger,
      dropdown,
      selectedOption,
      minHeight,
      onSelect,
      closeAfterClick = true,
      isOpen: controlledIsOpen,
      onOpenChange,
      minWidth,
      maxWidth,
      fillWidth = false,
      placement = "bottom-start",
      className,
      style,
    },
    ref,
  ) => {
    const wrapperRef = useRef<HTMLDivElement>(null);
    const dropdownRef = useRef<HTMLDivElement | null>(null);
    const [mounted, setMounted] = useState(false);
    const [internalIsOpen, setInternalIsOpen] = useState(false);
    const [focusedIndex, setFocusedIndex] = useState(-1);
    const isControlled = controlledIsOpen !== undefined;
    const isOpen = isControlled ? controlledIsOpen : internalIsOpen;
    const handleOpenChange = useCallback(
      (newIsOpen: boolean) => {
        if (!isControlled) {
          setInternalIsOpen(newIsOpen);
        }
        onOpenChange?.(newIsOpen);
      },
      [onOpenChange, isControlled],
    );
    const { x, y, strategy, refs, update } = useFloating({
      placement: placement,
      open: isOpen,
      middleware: [
        offset(4),
        minHeight ? undefined : flip(),
        shift(),
        size({
          apply({ availableWidth, availableHeight, elements }) {
            Object.assign(elements.floating.style, {
              width: fillWidth ? "100%" : "auto",
              minWidth: minWidth ? `${minWidth}rem` : undefined,
              maxWidth: maxWidth ? `${maxWidth}rem` : `${availableWidth}px`,
              minHeight: `${Math.min(minHeight || 0)}px`,
              maxHeight: `${availableHeight}px`,
            });
          },
        }),
      ],
      whileElementsMounted: autoUpdate,
    });
    useImperativeHandle(ref, () => wrapperRef.current as HTMLDivElement);
    useEffect(() => {
      if (wrapperRef.current) {
        refs.setReference(wrapperRef.current);
      }
    }, [refs, mounted]);
    useEffect(() => {
      if (!mounted) {
        setMounted(true);
      }
    }, [mounted]);
    useEffect(() => {
      if (isOpen && mounted) {
        requestAnimationFrame(() => {
          if (dropdownRef.current) {
            refs.setFloating(dropdownRef.current);
            update();
            // Reset focus index when opening
            setFocusedIndex(-1);
            // Set up initial keyboard navigation
            const optionElements = dropdownRef.current
              ? Array.from(
                  dropdownRef.current.querySelectorAll('.option, [role="option"], [data-value]'),
                )
              : [];
            // If we have options, highlight the first one
            if (optionElements.length > 0) {
              setFocusedIndex(0);
              optionElements.forEach((el, i) => {
                if (i === 0) {
                  (el as HTMLElement).classList.add("highlighted");
                } else {
                  (el as HTMLElement).classList.remove("highlighted");
                }
              });
            }
          }
        });
      }
    }, [isOpen, mounted, refs, update]);
    const handleClickOutside = useCallback(
      (event: MouseEvent) => {
        if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) {
          handleOpenChange(false);
          setFocusedIndex(-1);
        }
      },
      [handleOpenChange, wrapperRef],
    );
    const handleFocusOut = useCallback(
      (event: FocusEvent) => {
        if (wrapperRef.current && !wrapperRef.current.contains(event.relatedTarget as Node)) {
          handleOpenChange(false);
          setFocusedIndex(-1);
        }
      },
      [handleOpenChange, wrapperRef],
    );
    useEffect(() => {
      const currentWrapperRef = wrapperRef.current;
      document.addEventListener("mousedown", handleClickOutside);
      currentWrapperRef?.addEventListener("focusout", handleFocusOut);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
        currentWrapperRef?.removeEventListener("focusout", handleFocusOut);
      };
    }, [handleClickOutside, handleFocusOut]);
    // Handle keyboard navigation
    const handleKeyDown = useCallback(
      (e: KeyboardEvent<HTMLDivElement>) => {
        if (!isOpen) {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            handleOpenChange(true);
          }
          return;
        }
        if (e.key === "Escape") {
          e.preventDefault();
          handleOpenChange(false);
          setFocusedIndex(-1);
          return;
        }
        if (e.key === "ArrowDown" || e.key === "ArrowUp") {
          e.preventDefault();
          // Find all Option components in the dropdown
          // We need to look for the actual clickable elements inside the dropdown
          const optionElements = dropdownRef.current
            ? Array.from(
                dropdownRef.current.querySelectorAll('.option, [role="option"], [data-value]'),
              )
            : [];
          if (optionElements.length === 0) return;
          let newIndex = focusedIndex;
          if (e.key === "ArrowDown") {
            newIndex = focusedIndex < optionElements.length - 1 ? focusedIndex + 1 : 0;
          } else {
            newIndex = focusedIndex > 0 ? focusedIndex - 1 : optionElements.length - 1;
          }
          setFocusedIndex(newIndex);
          // Highlight the element visually
          optionElements.forEach((el, i) => {
            if (i === newIndex) {
              (el as HTMLElement).classList.add("highlighted");
              // Scroll into view if needed
              (el as HTMLElement).scrollIntoView({ block: "nearest" });
            } else {
              (el as HTMLElement).classList.remove("highlighted");
            }
          });
        } else if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          // Find all Option components
          const optionElements = dropdownRef.current
            ? Array.from(
                dropdownRef.current.querySelectorAll('.option, [role="option"], [data-value]'),
              )
            : [];
          // Click the focused option
          if (focusedIndex >= 0 && focusedIndex < optionElements.length) {
            (optionElements[focusedIndex] as HTMLElement).click();
            if (closeAfterClick) {
              handleOpenChange(false);
              setFocusedIndex(-1);
            }
          }
        }
      },
      [isOpen, focusedIndex, handleOpenChange, closeAfterClick],
    );
    return (
      <Flex
        fillWidth={fillWidth}
        direction="column"
        transition="macro-medium"
        style={{
          ...(minHeight && isOpen
            ? {
                marginBottom: `${minHeight + 8}px`,
              }
            : {}),
          ...style,
        }}
        className={className}
        ref={wrapperRef}
        onClick={(e) => {
          if (!isOpen) {
            handleOpenChange(true);
            return;
          }
          if (
            closeAfterClick &&
            dropdownRef.current &&
            !dropdownRef.current.contains(e.target as Node)
          ) {
            handleOpenChange(false);
            setFocusedIndex(-1);
          }
        }}
        onKeyDown={handleKeyDown}
        tabIndex={-1}
        role="button"
        aria-haspopup="listbox"
        aria-expanded={isOpen}
      >
        {trigger}
        {isOpen && dropdown && (
          <Flex
            zIndex={1}
            className={styles.fadeIn}
            minWidth={minWidth}
            ref={dropdownRef}
            style={{
              position: strategy,
              top: y ?? 0,
              left: x ?? 0,
            }}
            role="listbox"
          >
            <Dropdown
              minWidth={minWidth}
              radius="l"
              selectedOption={selectedOption}
              onSelect={onSelect}
            >
              {dropdown}
            </Dropdown>
          </Flex>
        )}
      </Flex>
    );
  },
);
DropdownWrapper.displayName = "DropdownWrapper";
export { DropdownWrapper };
</file>

<file path="src/once-ui/components/FlipFx.tsx">
"use client";
import React, {
  useState,
  useEffect,
  useRef,
  useLayoutEffect,
  useCallback,
  forwardRef,
} from "react";
import { Flex } from "@/once-ui/components";
export interface FlipFxProps extends React.ComponentProps<typeof Flex> {
  flipDirection?: "horizontal" | "vertical";
  timing?: number;
  flipped?: boolean;
  onFlip?: (flipped: boolean) => void;
  disableClickFlip?: boolean;
  autoFlipInterval?: number;
  front: React.ReactNode;
  back: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
const FlipFx = forwardRef<HTMLDivElement, FlipFxProps>((props, ref) => {
  const {
    flipDirection = "horizontal",
    timing = 2000,
    flipped,
    onFlip,
    disableClickFlip = false,
    autoFlipInterval,
    front,
    back,
    className,
    style,
    ...flex
  } = props;
  const [internalFlipped, setInternalFlipped] = useState(false);
  const flippedState = flipped ?? internalFlipped;
  const cardRef = useRef<HTMLDivElement>(null);
  const frontRef = useRef<HTMLDivElement>(null);
  const backRef = useRef<HTMLDivElement>(null);
  useLayoutEffect(() => {
    const updateHeight = () => {
      if (cardRef.current && frontRef.current && backRef.current) {
        const frontH = frontRef.current.scrollHeight;
        const backH = backRef.current.scrollHeight;
        cardRef.current.style.height = `${Math.max(frontH, backH)}px`;
      }
    };
    updateHeight();
    const observer = new ResizeObserver(updateHeight);
    if (frontRef.current) observer.observe(frontRef.current);
    if (backRef.current) observer.observe(backRef.current);
    return () => observer.disconnect();
  }, [flippedState, front, back]);
  useEffect(() => {
    if (autoFlipInterval) {
      const interval = setInterval(() => {
        setInternalFlipped((prev) => !prev);
        onFlip?.(!flippedState);
      }, autoFlipInterval * 1000);
      return () => clearInterval(interval);
    }
  }, [autoFlipInterval, flippedState, onFlip]);
  const handleFlip = useCallback(() => {
    if (disableClickFlip || autoFlipInterval) return;
    setInternalFlipped((v) => !v);
    onFlip?.(!flippedState);
  }, [disableClickFlip, autoFlipInterval, flippedState, onFlip]);
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleFlip();
    }
  }, [handleFlip]);
  return (
    <Flex
      ref={(node) => {
        cardRef.current = node as HTMLDivElement;
        if (typeof ref === "function") ref(node as HTMLDivElement);
        else if (ref) (ref as React.RefObject<HTMLDivElement | null>).current = node;
      }}
      className={className}
      style={{
        transformStyle: "preserve-3d",
        transition: `transform ${timing}ms cubic-bezier(0.22, 1, 0.36, 1)`,
        transform: flippedState
          ? flipDirection === "vertical"
            ? "rotateX(180deg)"
            : "rotateY(180deg)"
          : "none",
        perspective: "1000px",
        ...style,
      }}
      onClick={handleFlip}
      onKeyDown={handleKeyDown}
      role="button"
      aria-pressed={flippedState}
      tabIndex={0}
      {...flex}
    >
      <Flex
        ref={frontRef}
        fill
        position="absolute"
        overflow="hidden"
        aria-hidden={flippedState}
        style={{
          backfaceVisibility: "hidden",
        }}
      >
        {front}
      </Flex>
      <Flex
        ref={backRef}
        fill
        position="absolute"
        overflow="hidden"
        aria-hidden={!flippedState}
        style={{
          backfaceVisibility: "hidden",
          transform: "rotateY(180deg)",
        }}
      >
        <Flex
          fill
          style={{
            transform: flipDirection === "vertical" ? "rotateY(-180deg) rotateX(180deg)" : undefined,
          }}
        >
          {back}
        </Flex>
      </Flex>
    </Flex>
  );
});
FlipFx.displayName = "FlipFx";
export { FlipFx };
</file>

<file path="src/once-ui/components/Heading.tsx">
"use client";
import React, { ElementType, ComponentPropsWithoutRef } from "react";
import classNames from "classnames";
import { TextProps, CommonProps, SpacingProps } from "../interfaces";
import { ColorScheme, ColorWeight, TextVariant, SpacingToken } from "../types";
type HeadingProps<T extends ElementType> = TextProps<T> &
  CommonProps &
  SpacingProps &
  ComponentPropsWithoutRef<T>;
const Heading = <T extends ElementType = "h1">({
  as,
  variant,
  size,
  weight,
  onBackground,
  onSolid,
  align,
  wrap = "balance",
  padding,
  paddingLeft,
  paddingRight,
  paddingTop,
  paddingBottom,
  paddingX,
  paddingY,
  margin,
  marginLeft,
  marginRight,
  marginTop,
  marginBottom,
  marginX,
  marginY,
  children,
  style,
  truncate,
  className,
  ...props
}: HeadingProps<T>) => {
  const Component = as || "h1";
  if (variant && (size || weight)) {
    console.warn("When 'variant' is set, 'size' and 'weight' are ignored.");
  }
  if (onBackground && onSolid) {
    console.warn(
      "You cannot use both 'onBackground' and 'onSolid' props simultaneously. Only one will be applied.",
    );
  }
  const getVariantClasses = (variant: TextVariant) => {
    const [fontType, weight, size] = variant.split("-");
    return [`font-${fontType}`, `font-${weight}`, `font-${size}`];
  };
  const sizeClass = size ? `font-${size}` : "font-m";
  const weightClass = weight ? `font-${weight}` : "font-strong";
  const classes = variant ? getVariantClasses(variant) : [sizeClass, weightClass];
  let colorClass = "neutral-on-background-strong";
  if (onBackground) {
    const [scheme, weight] = onBackground.split("-") as [ColorScheme, ColorWeight];
    colorClass = `${scheme}-on-background-${weight}`;
  } else if (onSolid) {
    const [scheme, weight] = onSolid.split("-") as [ColorScheme, ColorWeight];
    colorClass = `${scheme}-on-solid-${weight}`;
  }
  const generateClassName = (prefix: string, token: SpacingToken | undefined) => {
    return token ? `${prefix}-${token}` : undefined;
  };
  const combinedClasses = classNames(
    ...classes,
    colorClass,
    className,
    generateClassName("p", padding),
    generateClassName("pl", paddingLeft),
    generateClassName("pr", paddingRight),
    generateClassName("pt", paddingTop),
    generateClassName("pb", paddingBottom),
    generateClassName("px", paddingX),
    generateClassName("py", paddingY),
    generateClassName("m", margin),
    generateClassName("ml", marginLeft),
    generateClassName("mr", marginRight),
    generateClassName("mt", marginTop),
    generateClassName("mb", marginBottom),
    generateClassName("mx", marginX),
    generateClassName("my", marginY),
    truncate && "truncate",
  );
  return (
    <Component
      className={combinedClasses}
      style={{
        textAlign: align,
        textWrap: wrap,
        ...style,
      }}
      {...props}
    >
      {children}
    </Component>
  );
};
Heading.displayName = "Heading";
export { Heading };
</file>

<file path="src/once-ui/components/InfiniteScroll.tsx">
"use client";
import React, { ReactNode, useEffect, useRef, useState } from "react";
import { Spinner } from "./Spinner";
import { Column } from "./Column";
import { Row } from "./Row";
export interface InfiniteScrollProps<T> extends React.ComponentProps<typeof Row> {
  items: T[];
  renderItem: (item: T, index: number) => ReactNode;
  loadMore: () => Promise<boolean>;
  loading?: boolean;
  threshold?: number;
  className?: string;
}
function InfiniteScroll<T>({
  items,
  renderItem,
  loadMore,
  loading = false,
  threshold = 200,
  ...flex
}: InfiniteScrollProps<T>) {
  const [hasMore, setHasMore] = useState(true);
  const [isLoading, setIsLoading] = useState(loading);
  const observerRef = useRef<IntersectionObserver | null>(null);
  const lastItemRef = useRef<HTMLDivElement | null>(null);
  const handleLoadMore = async () => {
    if (isLoading || !hasMore) return;
    setIsLoading(true);
    try {
      const hasMoreItems = await loadMore();
      setHasMore(hasMoreItems);
    } catch (error) {
      console.error("Error loading more items:", error);
      setHasMore(false);
    } finally {
      setIsLoading(false);
    }
  };
  useEffect(() => {
    if (!hasMore || isLoading) return;
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
    observerRef.current = new IntersectionObserver(
      (entries) => {
        const [entry] = entries;
        if (entry.isIntersecting) {
          handleLoadMore();
        }
      },
      {
        root: null,
        rootMargin: `0px 0px ${threshold}px 0px`,
        threshold: 0.1,
      },
    );
    if (lastItemRef.current) {
      observerRef.current.observe(lastItemRef.current);
    }
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [items, hasMore, isLoading]);
  return (
    <>
      {items.map((item, index) => {
        // If this is the last item, attach the ref
        if (index === items.length - 1) {
          return (
            <Row key={index} ref={lastItemRef} {...flex}>
              {renderItem(item, index)}
            </Row>
          );
        }
        return <React.Fragment key={index}>{renderItem(item, index)}</React.Fragment>;
      })}
      {isLoading && (
        <Column fillWidth horizontal="center" padding="24">
          <Spinner size="m" />
        </Column>
      )}
    </>
  );
}
export { InfiniteScroll };
</file>

<file path="src/once-ui/components/Mask.tsx">
"use client";
import React, { CSSProperties, forwardRef, useEffect, useRef, useState } from "react";
import { Flex } from ".";
import styles from "./Mask.module.scss";
import classNames from "classnames";
export interface MaskProps extends Omit<React.ComponentProps<typeof Flex>, "radius" | "cursor"> {
  cursor?: boolean;
  x?: number;
  y?: number;
  radius?: number;
  className?: string;
  style?: React.CSSProperties;
  children?: React.ReactNode;
}
const Mask = forwardRef<HTMLDivElement, MaskProps>(
  ({ cursor = false, x, y, radius = 50, children, className, style, ...rest }, forwardedRef) => {
    const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 });
    const [smoothPosition, setSmoothPosition] = useState({ x: 0, y: 0 });
    const maskRef = useRef<HTMLDivElement>(null);
    useEffect(() => {
      if (forwardedRef) {
        if (typeof forwardedRef === "function") {
          forwardedRef(maskRef.current);
        } else if (forwardedRef && "current" in forwardedRef) {
          (forwardedRef as React.RefObject<HTMLDivElement | null>).current = maskRef.current;
        }
      }
    }, [forwardedRef]);
    useEffect(() => {
      if (!cursor) return;
      const handleMouseMove = (event: MouseEvent) => {
        if (maskRef.current) {
          const rect = maskRef.current.getBoundingClientRect();
          setCursorPosition({
            x: event.clientX - rect.left,
            y: event.clientY - rect.top,
          });
        }
      };
      document.addEventListener("mousemove", handleMouseMove);
      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
      };
    }, [cursor]);
    useEffect(() => {
      if (!cursor) return;
      let animationFrameId: number;
      const updateSmoothPosition = () => {
        setSmoothPosition((prev) => {
          const dx = cursorPosition.x - prev.x;
          const dy = cursorPosition.y - prev.y;
          const easingFactor = 0.05;
          return {
            x: Math.round(prev.x + dx * easingFactor),
            y: Math.round(prev.y + dy * easingFactor),
          };
        });
        animationFrameId = requestAnimationFrame(updateSmoothPosition);
      };
      animationFrameId = requestAnimationFrame(updateSmoothPosition);
      return () => {
        cancelAnimationFrame(animationFrameId);
      };
    }, [cursorPosition, cursor]);
    const maskStyle = (): CSSProperties => {
      if (cursor) {
        return {
          "--mask-position-x": `${smoothPosition.x}px`,
          "--mask-position-y": `${smoothPosition.y}px`,
          "--mask-radius": `${radius}vh`,
        } as CSSProperties;
      }
      if (x != null && y != null) {
        return {
          "--mask-position-x": `${x}%`,
          "--mask-position-y": `${y}%`,
          "--mask-radius": `${radius}vh`,
        } as CSSProperties;
      }
      return {};
    };
    return (
      <Flex
        ref={maskRef}
        fill
        className={classNames(styles.mask, className)}
        top="0"
        left="0"
        zIndex={0}
        overflow="hidden"
        style={{
          ...maskStyle(),
          ...style,
        }}
        {...rest}
      >
        {children}
      </Flex>
    );
  },
);
Mask.displayName = "Mask";
export { Mask };
</file>

<file path="src/once-ui/components/Option.tsx">
import classNames from "classnames";
import { Flex, Text, ElementType } from ".";
import styles from "./Option.module.scss";
import React, { forwardRef, KeyboardEvent } from "react";
export interface OptionProps {
  label?: React.ReactNode;
  href?: string;
  value: string;
  hasPrefix?: React.ReactNode;
  hasSuffix?: React.ReactNode;
  description?: React.ReactNode;
  danger?: boolean;
  selected?: boolean;
  highlighted?: boolean;
  tabIndex?: number;
  children?: React.ReactNode;
  onClick?: (value: string) => void;
  onLinkClick?: () => void;
}
const Option = forwardRef<HTMLDivElement, OptionProps>(
  (
    {
      label,
      value,
      href,
      hasPrefix,
      hasSuffix,
      description,
      danger,
      selected,
      highlighted,
      tabIndex,
      onClick,
      onLinkClick,
      children,
      ...props
    },
    ref,
  ) => {
    if (href && onClick) {
      console.warn("Option should not have both `href` and `onClick` props.");
    }
    return (
      <ElementType
        tabIndex={tabIndex}
        ref={ref}
        href={href}
        className="reset-button-styles fill-width"
        onLinkClick={onLinkClick}
        onKeyDown={(e: KeyboardEvent<HTMLElement>) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            onClick?.(value);
          }
        }}
      >
        <Flex
          {...props}
          fillWidth
          vertical="center"
          paddingX="12"
          paddingY="8"
          gap="12"
          radius="m"
          role="option"
          aria-selected={selected}
          tabIndex={-1}
          borderWidth={1}
          borderStyle="solid"
          cursor="interactive"
          transition="micro-medium"
          onClick={() => onClick?.(value)}
          className={classNames(styles.option, {
            [styles.danger]: danger,
            [styles.selected]: selected,
            [styles.highlighted]: highlighted,
          })}
          data-value={value}
        >
          {hasPrefix && <Flex className={styles.prefix}>{hasPrefix}</Flex>}
          {children}
          <Flex
            horizontal="start"
            style={{
              whiteSpace: "nowrap",
            }}
            fillWidth
            direction="column"
          >
            <Text onBackground="neutral-strong" variant="label-default-s">
              {label}
            </Text>
            {description && (
              <Text variant="body-default-xs" onBackground="neutral-weak">
                {description}
              </Text>
            )}
          </Flex>
          {hasSuffix && <Flex className={styles.suffix}>{hasSuffix}</Flex>}
        </Flex>
      </ElementType>
    );
  },
);
Option.displayName = "Option";
export { Option };
</file>

<file path="src/once-ui/components/Particle.tsx">
"use client";
import React, { useEffect, useRef } from "react";
import { SpacingToken } from "../types";
import { DisplayProps } from "../interfaces";
import { Flex } from ".";
interface ParticleProps extends React.ComponentProps<typeof Flex> {
  display?: boolean;
  density?: number;
  color?: string;
  size?: SpacingToken;
  speed?: number;
  interactive?: boolean;
  interactionRadius?: number;
  opacity?: DisplayProps["opacity"];
  className?: string;
  style?: React.CSSProperties;
  children?: React.ReactNode;
}
export const Particle = React.forwardRef<HTMLDivElement, ParticleProps>(
  (
    {
      display = true,
      density = 100,
      color = "brand-on-background-weak",
      size = "2",
      speed = 0.3,
      interactive = false,
      interactionRadius = 20,
      opacity = 100,
      children,
      className,
      style,
      ...rest
    },
    forwardedRef,
  ) => {
    const containerRef = useRef<HTMLDivElement>(null);
    useEffect(() => {
      if (forwardedRef && "current" in forwardedRef) {
        forwardedRef.current = containerRef.current;
      } else if (typeof forwardedRef === "function") {
        forwardedRef(containerRef.current);
      }
    }, [forwardedRef]);
    useEffect(() => {
      if (!display || !containerRef.current) return;
      const container = containerRef.current;
      const particles: HTMLElement[] = [];
      const particleTargets = new Map<HTMLElement, { x: number; y: number }>();
      const initialPositions = new Map<HTMLElement, { x: number; y: number }>();
      let mousePosition = { x: -1000, y: -1000 };
      let animationFrameId: number;
      const parsedSize = `var(--static-space-${size})`;
      const parsedOpacity = `${opacity}%`;
      const movementSpeed = speed * 0.08;
      const repulsionStrength = 0.15 * (speed || 1);
      const handleMouseMove = (e: MouseEvent) => {
        const rect = container.getBoundingClientRect();
        mousePosition = {
          x: ((e.clientX - rect.left) / rect.width) * 100,
          y: ((e.clientY - rect.top) / rect.height) * 100,
        };
      };
      const createParticle = () => {
        const particleEl = document.createElement("div");
        particleEl.style.position = "absolute";
        particleEl.style.width = parsedSize;
        particleEl.style.height = parsedSize;
        particleEl.style.background = `var(--${color})`;
        particleEl.style.borderRadius = "50%";
        particleEl.style.pointerEvents = "none";
        particleEl.style.opacity = parsedOpacity;
        particleEl.style.transition = "transform 0.4s ease-out, opacity 0.6s ease-out";
        const initialX = 10 + Math.random() * 80;
        const initialY = 10 + Math.random() * 80;
        particleEl.style.left = `${initialX}%`;
        particleEl.style.top = `${initialY}%`;
        initialPositions.set(particleEl, { x: initialX, y: initialY });
        particleTargets.set(particleEl, { x: initialX, y: initialY });
        container.appendChild(particleEl);
        particles.push(particleEl);
        return particleEl;
      };
      const updateParticles = () => {
        particles.forEach((particleEl, index) => {
          const currentTarget = particleTargets.get(particleEl);
          const initial = initialPositions.get(particleEl);
          if (!currentTarget || !initial) return;
          const currentX = parseFloat(particleEl.style.left);
          const currentY = parseFloat(particleEl.style.top);
          const time = Date.now() * 0.001 * speed;
          const baseNoiseX = Math.sin(time + index) * 0.5;
          const baseNoiseY = Math.cos(time + index * 1.2) * 0.5;
          let targetX = initial.x + baseNoiseX;
          let targetY = initial.y + baseNoiseY;
          if (interactive) {
            const dx = mousePosition.x - currentX;
            const dy = mousePosition.y - currentY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < interactionRadius) {
              const force = (interactionRadius - distance) * repulsionStrength;
              const angle = Math.atan2(dy, dx);
              targetX -= Math.cos(angle) * force;
              targetY -= Math.sin(angle) * force;
            }
          }
          targetX = Math.max(5, Math.min(95, targetX));
          targetY = Math.max(5, Math.min(95, targetY));
          particleTargets.set(particleEl, {
            x: targetX,
            y: targetY,
          });
          particleEl.style.left = `${currentX + (targetX - currentX) * movementSpeed}%`;
          particleEl.style.top = `${currentY + (targetY - currentY) * movementSpeed}%`;
        });
        animationFrameId = requestAnimationFrame(updateParticles);
      };
      if (interactive) {
        document.addEventListener("mousemove", handleMouseMove);
      }
      for (let i = 0; i < density; i++) {
        createParticle();
      }
      updateParticles();
      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        cancelAnimationFrame(animationFrameId);
        particles.forEach((particleEl) => {
          particleEl.remove();
          particleTargets.delete(particleEl);
          initialPositions.delete(particleEl);
        });
      };
    }, [
      display,
      color,
      size,
      speed,
      interactive,
      interactionRadius,
      opacity,
      density,
      containerRef,
    ]);
    return (
      <Flex
        ref={containerRef}
        position="absolute"
        top="0"
        left="0"
        fill
        pointerEvents="none"
        className={className}
        style={style}
        {...rest}
      >
        {children}
      </Flex>
    );
  },
);
Particle.displayName = "Particle";
</file>

<file path="src/once-ui/components/RevealFx.tsx">
"use client";
import React, { useState, useEffect, forwardRef, useRef } from "react";
import { SpacingToken } from "../types";
import styles from "./RevealFx.module.scss";
import { Flex } from ".";
interface RevealFxProps extends React.ComponentProps<typeof Flex> {
  children: React.ReactNode;
  speed?: "slow" | "medium" | "fast";
  delay?: number;
  revealedByDefault?: boolean;
  translateY?: number | SpacingToken;
  trigger?: boolean;
  style?: React.CSSProperties;
  className?: string;
}
const RevealFx = forwardRef<HTMLDivElement, RevealFxProps>(
  (
    {
      children,
      speed = "medium",
      delay = 0,
      revealedByDefault = false,
      translateY,
      trigger,
      style,
      className,
      ...rest
    },
    ref,
  ) => {
    const [isRevealed, setIsRevealed] = useState(revealedByDefault);
    const [maskRemoved, setMaskRemoved] = useState(false);
    const transitionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const getSpeedDurationMs = () => {
      switch (speed) {
        case "fast":
          return 1000;
        case "medium":
          return 2000;
        case "slow":
          return 3000;
        default:
          return 2000;
      }
    };
    const getSpeedDuration = () => {
      const ms = getSpeedDurationMs();
      return `${ms / 1000}s`;
    };
    useEffect(() => {
      const timer = setTimeout(() => {
        setIsRevealed(true);
        // Always set a timeout to remove the mask after transition completes
        transitionTimeoutRef.current = setTimeout(() => {
          setMaskRemoved(true);
        }, getSpeedDurationMs());
      }, delay * 1000);
      return () => {
        clearTimeout(timer);
        if (transitionTimeoutRef.current) {
          clearTimeout(transitionTimeoutRef.current);
        }
      };
    }, [delay]);
    useEffect(() => {
      if (trigger !== undefined) {
        setIsRevealed(trigger);
        // Reset mask removal state when trigger changes
        setMaskRemoved(false);
        // If trigger is true, set timeout to remove mask after transition
        if (trigger) {
          if (transitionTimeoutRef.current) {
            clearTimeout(transitionTimeoutRef.current);
          }
          transitionTimeoutRef.current = setTimeout(() => {
            setMaskRemoved(true);
          }, getSpeedDurationMs());
        }
      }
    }, [trigger]);
    const getTranslateYValue = () => {
      if (typeof translateY === "number") {
        return `${translateY}rem`;
      } else if (typeof translateY === "string") {
        return `var(--static-space-${translateY})`;
      }
      return undefined;
    };
    const translateValue = getTranslateYValue();
    const revealStyle: React.CSSProperties = {
      transitionDuration: getSpeedDuration(),
      transform: isRevealed ? "translateY(0)" : `translateY(${translateValue})`,
      ...style,
    };
    // If mask is removed after transition, use the no-mask classes
    if (maskRemoved) {
      return (
        <Flex
          fillWidth
          ref={ref}
          style={revealStyle}
          className={`${styles.revealedNoMask} ${className || ""}`}
          {...rest}
        >
          {children}
        </Flex>
      );
    }
    return (
      <Flex
        fillWidth
        ref={ref}
        style={revealStyle}
        className={`${styles.revealFx} ${isRevealed ? styles.revealed : styles.hidden} ${className || ""}`}
        {...rest}
      >
        {children}
      </Flex>
    );
  },
);
RevealFx.displayName = "RevealFx";
export { RevealFx };
</file>

<file path="src/once-ui/components/Select.tsx">
"use client";
import React, { useState, useRef, useEffect, forwardRef, ReactNode } from "react";
import classNames from "classnames";
import {
  DropdownWrapper,
  Flex,
  Icon,
  IconButton,
  Input,
  InputProps,
  Option,
  OptionProps,
  DropdownWrapperProps,
} from ".";
import inputStyles from "./Input.module.scss";
import { Placement } from "@floating-ui/react-dom";
type SelectOptionType = Omit<OptionProps, "selected">;
interface SelectProps
  extends Omit<InputProps, "onSelect" | "value">,
    Pick<DropdownWrapperProps, "minHeight" | "minWidth" | "maxWidth"> {
  options: SelectOptionType[];
  value?: string;
  emptyState?: ReactNode;
  onSelect?: (value: string) => void;
  placement?: Placement;
  searchable?: boolean;
  className?: string;
  style?: React.CSSProperties;
}
const Select = forwardRef<HTMLDivElement, SelectProps>(
  (
    {
      options,
      value = "",
      onSelect,
      searchable = false,
      emptyState = "No results",
      minHeight,
      minWidth,
      maxWidth,
      placement,
      className,
      style,
      ...rest
    },
    ref,
  ) => {
    const [isFocused, setIsFocused] = useState(false);
    const [isFilled, setIsFilled] = useState(!!value);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [highlightedIndex, setHighlightedIndex] = useState<number | null>(() => {
      if (!options?.length || !value) return null;
      return options.findIndex((option) => option.value === value);
    });
    const [searchQuery, setSearchQuery] = useState("");
    const selectRef = useRef<HTMLDivElement | null>(null);
    const clearButtonRef = useRef<HTMLButtonElement>(null);
    const handleFocus = () => {
      setIsFocused(true);
    };
    const handleBlur = (event: React.FocusEvent<HTMLInputElement>) => {
      if (selectRef.current && !selectRef.current.contains(event.relatedTarget as Node)) {
        setIsFocused(false);
        setIsDropdownOpen(false);
      }
    };
    const handleSelect = (value: string) => {
      if (onSelect) onSelect(value);
      setIsDropdownOpen(false);
      setIsFilled(true);
    };
    const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {
      if (!isFocused && event.key !== "Enter") return;
      switch (event.key) {
        case "Escape":
          setIsDropdownOpen(false);
          break;
        case "ArrowDown":
          if (!isDropdownOpen) {
            setIsDropdownOpen(true);
            break;
          }
          event.preventDefault();
          setHighlightedIndex((prevIndex) => {
            const newIndex =
              prevIndex === null || prevIndex === options.length - 1 ? 0 : prevIndex + 1;
            return newIndex;
          });
          break;
        case "ArrowUp":
          event.preventDefault();
          setHighlightedIndex((prevIndex) => {
            const newIndex =
              prevIndex === null || prevIndex === 0 ? options.length - 1 : prevIndex - 1;
            return newIndex;
          });
          break;
        case "Enter":
          event.preventDefault();
          if (highlightedIndex !== null && isDropdownOpen) {
            handleSelect(options[highlightedIndex].value);
          } else {
            setIsDropdownOpen(true);
          }
          break;
        default:
          break;
      }
    };
    const handleClearSearch = (e: React.MouseEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setSearchQuery("");
      // Force focus back to the input after clearing
      const input = selectRef.current?.querySelector("input");
      if (input) {
        input.focus();
      }
    };
    const selectedOption = options.find((opt) => opt.value === value);
    useEffect(() => {
      const handleClickOutside = (event: MouseEvent) => {
        if (
          selectRef.current &&
          !selectRef.current.contains(event.target as Node) &&
          !clearButtonRef.current?.contains(event.target as Node)
        ) {
          setIsDropdownOpen(false);
        }
      };
      const handleFocusOut = (event: FocusEvent) => {
        if (event.target instanceof HTMLInputElement) {
          handleBlur(event as unknown as React.FocusEvent<HTMLInputElement>);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      document.addEventListener("focusout", handleFocusOut);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
        document.removeEventListener("focusout", handleFocusOut);
      };
    }, []);
    return (
      <DropdownWrapper
        fillWidth
        ref={(node) => {
          selectRef.current = node;
          if (typeof ref === "function") ref(node);
          else if (ref) ref.current = node;
        }}
        isOpen={isDropdownOpen}
        onOpenChange={setIsDropdownOpen}
        placement={placement}
        minHeight={minHeight}
        trigger={
          <Input
            {...rest}
            style={{
              textOverflow: "ellipsis",
              ...style,
            }}
            cursor="interactive"
            value={typeof selectedOption?.label === "string" ? selectedOption.label : ""}
            onFocus={handleFocus}
            onKeyDown={handleKeyDown}
            readOnly
            className={classNames("fill-width", {
              [inputStyles.filled]: isFilled,
              [inputStyles.focused]: isFocused,
              className,
            })}
            aria-haspopup="listbox"
            aria-expanded={isDropdownOpen}
          />
        }
        dropdown={
          <>
            {searchable && (
              <Flex fillWidth>
                <Input
                  data-scaling="90"
                  style={{
                    marginTop: "-1px",
                    marginLeft: "-1px",
                    width: "calc(100% + 2px)",
                  }}
                  id="search"
                  placeholder="Search"
                  height="s"
                  radius="none"
                  hasSuffix={
                    searchQuery ? (
                      <IconButton
                        tooltip="Clear"
                        tooltipPosition="left"
                        icon="close"
                        variant="ghost"
                        size="s"
                        onClick={handleClearSearch}
                      />
                    ) : undefined
                  }
                  hasPrefix={<Icon name="search" size="xs" />}
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                  onBlur={handleBlur}
                />
              </Flex>
            )}
            <Flex fillWidth padding="4" direction="column" gap="2">
              {options
                .filter((option) =>
                  option.label?.toString().toLowerCase().includes(searchQuery.toLowerCase()),
                )
                .map((option, index) => (
                  <Option
                    key={option.value}
                    {...option}
                    onClick={() => {
                      option.onClick?.(option.value);
                      handleSelect(option.value);
                    }}
                    selected={option.value === value}
                    highlighted={index === highlightedIndex}
                    tabIndex={-1}
                  />
                ))}
              {searchQuery &&
                options.filter((option) =>
                  option.label?.toString().toLowerCase().includes(searchQuery.toLowerCase()),
                ).length === 0 && (
                  <Flex fillWidth vertical="center" horizontal="center" paddingX="16" paddingY="32">
                    {emptyState}
                  </Flex>
                )}
            </Flex>
          </>
        }
      />
    );
  },
);
Select.displayName = "Select";
export { Select };
</file>

<file path="src/once-ui/components/SmartLink.tsx">
"use client";
import React, { forwardRef, ReactNode } from "react";
import classNames from "classnames";
import { Icon, ElementType } from ".";
import { IconName } from "../icons";
interface CommonProps {
  prefixIcon?: IconName;
  suffixIcon?: IconName;
  fillWidth?: boolean;
  iconSize?: "xs" | "s" | "m" | "l" | "xl";
  selected?: boolean;
  unstyled?: boolean;
  children: ReactNode;
  href?: string;
  style?: React.CSSProperties;
  className?: string;
}
export type SmartLinkProps = CommonProps & React.AnchorHTMLAttributes<HTMLAnchorElement>;
const SmartLink = forwardRef<HTMLAnchorElement, SmartLinkProps>(
  (
    {
      href,
      prefixIcon,
      suffixIcon,
      fillWidth = false,
      iconSize = "xs",
      style,
      className,
      selected,
      unstyled = false,
      children,
      ...props
    },
    ref,
  ) => {
    const content = (
      <>
        {prefixIcon && <Icon name={prefixIcon} size={iconSize} />}
        {children}
        {suffixIcon && <Icon name={suffixIcon} size={iconSize} />}
      </>
    );
    const commonProps = {
      ref,
      className: classNames(
        className,
        "reset-button-styles focus-ring align-center display-inline-flex g-8 radius-s",
        {
          "fill-width": fillWidth,
          "fit-width": !fillWidth,
          "min-width-0": fillWidth,
          "px-2 mx-2": !unstyled,
        },
      ),
      style: !unstyled
        ? {
            ...(selected && {
              textDecoration: "underline",
              textUnderlineOffset: "0.3em",
              textUnderlineThickness: "var(--static-space-1)",
              color: "var(--neutral-on-background-strong)",
            }),
            ...style,
          }
        : {
            textDecoration: "none",
            ...style,
          },
      ...props,
    };
    return (
      <ElementType href={href} {...commonProps}>
        {content}
      </ElementType>
    );
  },
);
SmartLink.displayName = "SmartLink";
export { SmartLink };
</file>

<file path="src/once-ui/components/Text.tsx">
"use client";
import React, { ElementType, ComponentPropsWithoutRef } from "react";
import classNames from "classnames";
import { TextProps, CommonProps, SpacingProps } from "../interfaces";
import { ColorScheme, ColorWeight, TextVariant, SpacingToken } from "../types";
type TypeProps<T extends ElementType> = TextProps<T> &
  CommonProps &
  SpacingProps &
  ComponentPropsWithoutRef<T>;
const Text = <T extends ElementType = "span">({
  as,
  variant,
  size,
  weight,
  onBackground,
  onSolid,
  align,
  wrap,
  padding,
  paddingLeft,
  paddingRight,
  paddingTop,
  paddingBottom,
  paddingX,
  paddingY,
  margin,
  marginLeft,
  marginRight,
  marginTop,
  marginBottom,
  marginX,
  marginY,
  children,
  style,
  className,
  truncate,
  ...props
}: TypeProps<T>) => {
  const Component = as || "span";
  if (variant && (size || weight)) {
    console.warn("When 'variant' is set, 'size' and 'weight' are ignored.");
  }
  if (onBackground && onSolid) {
    console.warn(
      "You cannot use both 'onBackground' and 'onSolid' props simultaneously. Only one will be applied.",
    );
  }
  const getVariantClasses = (variant: TextVariant) => {
    const [fontType, weight, size] = variant.split("-");
    return [`font-${fontType}`, `font-${weight}`, `font-${size}`];
  };
  const sizeClass = size ? `font-${size}` : "";
  const weightClass = weight ? `font-${weight}` : "";
  const classes = variant ? getVariantClasses(variant) : [sizeClass, weightClass];
  let colorClass = "";
  if (onBackground) {
    const [scheme, weight] = onBackground.split("-") as [ColorScheme, ColorWeight];
    colorClass = `${scheme}-on-background-${weight}`;
  } else if (onSolid) {
    const [scheme, weight] = onSolid.split("-") as [ColorScheme, ColorWeight];
    colorClass = `${scheme}-on-solid-${weight}`;
  }
  const generateClassName = (prefix: string, token: SpacingToken | undefined) => {
    return token ? `${prefix}-${token}` : undefined;
  };
  const combinedClasses = classNames(
    ...classes,
    colorClass,
    className,
    generateClassName("p", padding),
    generateClassName("pl", paddingLeft),
    generateClassName("pr", paddingRight),
    generateClassName("pt", paddingTop),
    generateClassName("pb", paddingBottom),
    generateClassName("px", paddingX),
    generateClassName("py", paddingY),
    generateClassName("m", margin),
    generateClassName("ml", marginLeft),
    generateClassName("mr", marginRight),
    generateClassName("mt", marginTop),
    generateClassName("mb", marginBottom),
    generateClassName("mx", marginX),
    generateClassName("my", marginY),
    truncate && "truncate",
  );
  return (
    <Component
      className={combinedClasses}
      style={{
        textAlign: align,
        textWrap: wrap,
        ...style,
      }}
      {...props}
    >
      {children}
    </Component>
  );
};
Text.displayName = "Text";
export { Text };
</file>

<file path="src/once-ui/components/UserMenu.tsx">
"use client";
import React from "react";
import classNames from "classnames";
import { Flex, DropdownWrapper, User, UserProps, DropdownWrapperProps } from ".";
import styles from "./UserMenu.module.scss";
import { Placement } from "@floating-ui/react-dom";
interface UserMenuProps
  extends UserProps,
    Pick<DropdownWrapperProps, "minHeight" | "minWidth" | "maxWidth"> {
  selected?: boolean;
  placement?: Placement;
  dropdown?: React.ReactNode;
  className?: string;
  style?: React.CSSProperties;
}
const UserMenu: React.FC<UserMenuProps> = ({
  selected = false,
  dropdown,
  minWidth,
  maxWidth,
  minHeight,
  placement,
  className,
  style,
  ...userProps
}) => {
  return (
    <DropdownWrapper
      minWidth={minWidth}
      maxWidth={maxWidth}
      minHeight={minHeight}
      placement={placement}
      style={{
        borderRadius: "var(--radius-full)",
      }}
      trigger={
        <Flex
          tabIndex={0}
          direction="column"
          padding="4"
          radius="full"
          cursor="interactive"
          border={selected ? "neutral-medium" : "transparent"}
          background={selected ? "neutral-strong" : "transparent"}
          className={classNames(className || "", selected ? styles.selected : "", styles.wrapper)}
          style={style}
        >
          <User {...userProps} />
        </Flex>
      }
      dropdown={dropdown}
    />
  );
};
UserMenu.displayName = "UserMenu";
export { UserMenu };
</file>

<file path="src/once-ui/modules/data/ChartHeader.tsx">
"use client";
import React, { useState, useEffect } from "react";
import {
  startOfYear,
  endOfYear,
  startOfMonth,
  endOfMonth,
  startOfWeek,
  endOfWeek,
  subYears,
  subMonths,
  subWeeks,
  isSameDay,
} from "date-fns";
import {
  Column,
  Text,
  Row,
  DateRange,
  DateRangePicker,
  DropdownWrapper,
  IconButton,
  ToggleButton,
} from "../../components";
import { DateConfig, PresetsConfig } from "./interfaces";
interface ChartHeaderProps
  extends Omit<React.ComponentProps<typeof Column>, "title" | "description"> {
  title?: React.ReactNode;
  description?: React.ReactNode;
  dateRange?: DateRange;
  date?: DateConfig;
  onDateRangeChange?: (range: DateRange) => void;
  presets?: PresetsConfig;
}
export const ChartHeader: React.FC<ChartHeaderProps> = ({
  title,
  description,
  dateRange,
  date,
  onDateRangeChange,
  presets = { display: true, granularity: "week" },
  ...flex
}) => {
  if (!title && !description && !dateRange && !date) {
    return null;
  }
  const [dateRangeOpen, setDateRangeOpen] = useState(false);
  const [selectedPreset, setSelectedPreset] = useState<string | null>(null);
  type DateRangePreset = {
    getRange: () => DateRange;
  };
  type PresetName =
    | "This year"
    | "This month"
    | "This week"
    | "Last year"
    | "Last month"
    | "Last week";
  const dateRangePresets: Record<PresetName, DateRangePreset> = {
    "This year": {
      getRange: () => ({
        startDate: startOfYear(new Date()),
        endDate: endOfYear(new Date()),
      }),
    },
    "This month": {
      getRange: () => ({
        startDate: startOfMonth(new Date()),
        endDate: endOfMonth(new Date()),
      }),
    },
    "This week": {
      getRange: () => ({
        startDate: startOfWeek(new Date()),
        endDate: endOfWeek(new Date()),
      }),
    },
    "Last year": {
      getRange: () => {
        const lastYear = subYears(new Date(), 1);
        return {
          startDate: startOfYear(lastYear),
          endDate: endOfYear(lastYear),
        };
      },
    },
    "Last month": {
      getRange: () => {
        const lastMonth = subMonths(new Date(), 1);
        return {
          startDate: startOfMonth(lastMonth),
          endDate: endOfMonth(lastMonth),
        };
      },
    },
    "Last week": {
      getRange: () => {
        const lastWeek = subWeeks(new Date(), 1);
        return {
          startDate: startOfWeek(lastWeek),
          endDate: endOfWeek(lastWeek),
        };
      },
    },
  };
  useEffect(() => {
    if (dateRange) {
      const matchingPreset = Object.entries(dateRangePresets).find(([name, preset]) => {
        const presetRange = preset.getRange();
        return (
          dateRange.startDate &&
          presetRange.startDate &&
          isSameDay(dateRange.startDate, presetRange.startDate) &&
          dateRange.endDate &&
          presetRange.endDate &&
          isSameDay(dateRange.endDate, presetRange.endDate)
        );
      });
      setSelectedPreset(matchingPreset ? matchingPreset[0] : null);
    } else {
      setSelectedPreset(null);
    }
  }, [dateRange]);
  useEffect(() => {
    const handleEscapeKey = (event: KeyboardEvent) => {
      if (event.key === "Escape" && dateRangeOpen) {
        setDateRangeOpen(false);
      }
    };
    if (dateRangeOpen) {
      document.addEventListener("keydown", handleEscapeKey);
    }
    return () => {
      document.removeEventListener("keydown", handleEscapeKey);
    };
  }, [dateRangeOpen]);
  const handleDateRangeChange = (newRange: DateRange) => {
    if (onDateRangeChange) {
      onDateRangeChange(newRange);
    }
  };
  const handlePresetClick = (presetName: PresetName) => {
    const newRange = dateRangePresets[presetName].getRange();
    setSelectedPreset(presetName);
    handleDateRangeChange(newRange);
  };
  if (!title && !description && !date?.selector) {
    return null;
  }
  return (
    <Column fillWidth paddingX="20" paddingY="12" gap="4" {...flex}>
      <Row fillWidth vertical="center">
        <Column fillWidth gap="4">
          {title && <Text variant="heading-strong-xs">{title}</Text>}
          {description && (
            <Text variant="label-default-s" onBackground="neutral-weak">
              {description}
            </Text>
          )}
        </Column>
        {dateRange && date?.selector && (
          <DropdownWrapper
            isOpen={dateRangeOpen}
            onOpenChange={(isOpen) => setDateRangeOpen(isOpen)}
            placement="bottom-end"
            trigger={
              <IconButton
                icon="calendar"
                onClick={() => setDateRangeOpen(!dateRangeOpen)}
                variant="secondary"
                size="m"
              />
            }
            dropdown={
              <Row padding="4" mobileDirection="column">
                {presets.display && (
                  <Column
                    mobileDirection="row"
                    padding="4"
                    gap="2"
                    minWidth={8}
                    border="neutral-alpha-weak"
                    radius="m"
                    overflowX="scroll"
                  >
                    {(Object.keys(dateRangePresets) as PresetName[])
                      .filter((presetName) => {
                        if (presets.granularity === "year") {
                          return presetName.includes("year");
                        } else if (presets.granularity === "month") {
                          return presetName.includes("year") || presetName.includes("month");
                        } else {
                          return true;
                        }
                      })
                      .map((presetName) => (
                        <ToggleButton
                          key={presetName}
                          style={{ paddingLeft: "0.25rem" }}
                          fillWidth
                          horizontal="start"
                          selected={selectedPreset === presetName}
                          onClick={() => handlePresetClick(presetName)}
                        >
                          {presetName}
                        </ToggleButton>
                      ))}
                  </Column>
                )}
                <DateRangePicker
                  size="s"
                  padding="16"
                  gap="24"
                  id="chart-date-range"
                  maxDate={date?.max}
                  minDate={date?.min}
                  dual={date?.dual}
                  value={dateRange}
                  onChange={handleDateRangeChange}
                />
              </Row>
            }
          />
        )}
      </Row>
    </Column>
  );
};
export type { ChartHeaderProps };
</file>

<file path="src/once-ui/modules/navigation/HeadingNav.tsx">
"use client";
import React, { forwardRef, useEffect, useState, useRef, useCallback } from "react";
import { Column, Flex, Row, SmartLink, Text } from "@/once-ui/components";
import { useHeadingLinks } from "@/once-ui/hooks/generateHeadingLinks";
interface props extends React.ComponentProps<typeof Flex> {}
const HeadingNav = forwardRef<HTMLDivElement, props>(({ className, style, ...rest }, ref) => {
  const [activeHeadingId, setActiveHeadingId] = useState<string | null>(null);
  const [activeIndex, setActiveIndex] = useState(0);
  const indicatorRef = useRef<HTMLDivElement>(null);
  const headings = useHeadingLinks();
  const observerRef = useRef<IntersectionObserver | null>(null);
  const lastUpdateTimeRef = useRef<number>(0);
  const pendingUpdateRef = useRef<string | null>(null);
  const scrollTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const isUpdatingRef = useRef<boolean>(false);
  const updateActiveHeadingInternal = useCallback(
    (id: string) => {
      const index = headings.findIndex((h) => h.id === id);
      if (index !== -1) {
        setActiveHeadingId(id);
        setActiveIndex(index);
        if (indicatorRef.current) {
          indicatorRef.current.style.top = `calc(${index} * var(--static-space-32))`;
        }
        lastUpdateTimeRef.current = Date.now();
        isUpdatingRef.current = false;
      }
    },
    [headings],
  );
  useEffect(() => {
    if (headings.length === 0) return;
    setActiveHeadingId(headings[0]?.id || null);
    const headingElements = headings
      .map((heading) => document.getElementById(heading.id))
      .filter(Boolean) as HTMLElement[];
    const headingPositions = new Map<string, number>();
    const calculateHeadingPositions = () => {
      headingElements.forEach((el) => {
        if (el) {
          headingPositions.set(el.id, el.getBoundingClientRect().top + window.scrollY - 150);
        }
      });
    };
    calculateHeadingPositions();
    const debouncedUpdateActiveHeading = (id: string) => {
      const now = Date.now();
      if (isUpdatingRef.current) {
        pendingUpdateRef.current = id;
        return;
      }
      if (now - lastUpdateTimeRef.current < 200) {
        pendingUpdateRef.current = id;
        if (scrollTimeoutRef.current) {
          clearTimeout(scrollTimeoutRef.current);
        }
        scrollTimeoutRef.current = setTimeout(() => {
          if (pendingUpdateRef.current) {
            isUpdatingRef.current = true;
            updateActiveHeadingInternal(pendingUpdateRef.current);
            pendingUpdateRef.current = null;
          }
        }, 200);
        return;
      }
      isUpdatingRef.current = true;
      updateActiveHeadingInternal(id);
    };
    const findActiveHeading = () => {
      const scrollPosition = window.scrollY;
      let activeId = headings[0]?.id;
      let closestPosition = -Infinity;
      headingPositions.forEach((position, id) => {
        if (position <= scrollPosition && position > closestPosition) {
          closestPosition = position;
          activeId = id;
        }
      });
      if (activeId) {
        debouncedUpdateActiveHeading(activeId);
      }
    };
    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          findActiveHeading();
          ticking = false;
        });
        ticking = true;
      }
    };
    window.addEventListener("scroll", handleScroll, { passive: true });
    observerRef.current = new IntersectionObserver(
      (entries) => {
        if (Date.now() - lastUpdateTimeRef.current > 400) {
          const enteringEntries = entries.filter((entry) => entry.isIntersecting);
          if (enteringEntries.length > 0) {
            enteringEntries.sort((a, b) => {
              const aRect = a.boundingClientRect;
              const bRect = b.boundingClientRect;
              return aRect.top - bRect.top;
            });
            debouncedUpdateActiveHeading(enteringEntries[0].target.id);
          }
        }
      },
      {
        rootMargin: "-150px 0px -30% 0px",
        threshold: [0, 0.1, 0.5, 1],
      },
    );
    headingElements.forEach((element) => {
      if (element && observerRef.current) {
        observerRef.current.observe(element);
      }
    });
    window.addEventListener("resize", calculateHeadingPositions);
    findActiveHeading();
    return () => {
      if (observerRef.current) {
        headingElements.forEach((element) => {
          if (element) observerRef.current?.unobserve(element);
        });
      }
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", calculateHeadingPositions);
      if (scrollTimeoutRef.current) {
        clearTimeout(scrollTimeoutRef.current);
      }
    };
  }, [headings, updateActiveHeadingInternal]);
  const handleHeadingClick = (id: string, index: number) => {
    setActiveHeadingId(id);
    setActiveIndex(index);
    if (indicatorRef.current) {
      indicatorRef.current.style.top = `calc(${index} * var(--static-space-32))`;
    }
    lastUpdateTimeRef.current = Date.now();
  };
  return (
    <Row paddingLeft="8" gap="12" className={className} style={style} ref={ref} {...rest}>
      <Row width="2" background="neutral-alpha-medium" radius="full" overflow="hidden">
        <Row
          ref={indicatorRef}
          height="32"
          paddingY="4"
          fillWidth
          position="absolute"
          style={{
            top: `calc(${activeIndex} * var(--static-space-32))`,
            transition: "top 0.3s ease",
          }}
        >
          <Row fillWidth solid="brand-strong" radius="full" />
        </Row>
      </Row>
      <Column fillWidth>
        {headings.map((heading, index) => {
          const indent = heading.level - 2;
          const isActive = heading.id === activeHeadingId;
          return (
            <Flex key={heading.id} fillWidth height="32" paddingX="4">
              <SmartLink
                fillWidth
                href={"#" + heading.id}
                onClick={(e) => {
                  e.preventDefault();
                  const target = document.getElementById(heading.id);
                  if (target) {
                    const targetPosition =
                      target.getBoundingClientRect().top + window.scrollY - 150;
                    window.scrollTo({
                      top: targetPosition,
                      behavior: "smooth",
                    });
                    handleHeadingClick(heading.id, index);
                  }
                }}
                style={{
                  paddingLeft: `calc(${indent} * var(--static-space-8))`,
                  color: isActive
                    ? "var(--neutral-on-background-strong)"
                    : "var(--neutral-on-background-weak)",
                  transition: "color 0.2s ease",
                }}
              >
                <Text
                  variant={isActive ? "body-strong-s" : "body-default-s"}
                  truncate
                  style={{
                    transition: "font-weight 0.2s ease",
                  }}
                >
                  {heading.text}
                </Text>
              </SmartLink>
            </Flex>
          );
        })}
      </Column>
    </Row>
  );
});
HeadingNav.displayName = "HeadingNav";
export { HeadingNav };
</file>

<file path="src/once-ui/modules/index.ts">
export { CodeBlock } from "./code/CodeBlock";
export { MediaUpload } from "./media/MediaUpload";
export { Meta } from "./seo/Meta";
export { Schema } from "./seo/Schema";
export { HeadingNav } from "./navigation/HeadingNav";
export { HeadingLink } from "./navigation/HeadingLink";
export { MegaMenu } from "./navigation/MegaMenu";
export { MobileMegaMenu } from "./navigation/MobileMegaMenu";
export { Kbar } from "./navigation/Kbar";
export { BarChart } from "./data/BarChart";
export { LineChart } from "./data/LineChart";
export { PieChart } from "./data/PieChart";
export { LineBarChart } from "./data/LineBarChart";
export { Tooltip } from "./data/Tooltip";
export { Legend } from "./data/Legend";
</file>

<file path="src/once-ui/interfaces.ts">
import { CSSProperties, ElementType, HTMLAttributes, ReactNode } from "react";
import {
  ColorScheme,
  ColorWeight,
  flex,
  gridColumns,
  opacity,
  RadiusNest,
  RadiusSize,
  ShadowSize,
  SpacingToken,
  TextSize,
  TextType,
  TextVariant,
  TextWeight,
} from "./types";
export interface GridProps extends HTMLAttributes<HTMLDivElement> {
  columns?: gridColumns;
  rows?: gridColumns;
  tabletColumns?: gridColumns;
  mobileColumns?: gridColumns;
  tabletRows?: gridColumns;
  mobileRows?: gridColumns;
}
export interface FlexProps extends HTMLAttributes<HTMLDivElement> {
  direction?: "row" | "column" | "row-reverse" | "column-reverse";
  tabletDirection?: "row" | "column" | "row-reverse" | "column-reverse";
  mobileDirection?: "row" | "column" | "row-reverse" | "column-reverse";
  horizontal?:
    | "start"
    | "center"
    | "end"
    | "space-between"
    | "space-around"
    | "space-evenly"
    | "stretch";
  vertical?:
    | "start"
    | "center"
    | "end"
    | "space-between"
    | "space-around"
    | "space-evenly"
    | "stretch";
  center?: boolean;
  wrap?: boolean;
  flex?: flex;
}
export interface TextProps<T extends ElementType = "span"> extends HTMLAttributes<T> {
  as?: T;
  variant?: TextVariant;
  wrap?: CSSProperties["textWrap"];
  size?: TextSize;
  weight?: TextWeight;
  truncate?: boolean;
}
export interface SizeProps extends HTMLAttributes<HTMLDivElement> {
  width?: number | SpacingToken;
  height?: number | SpacingToken;
  maxWidth?: number | SpacingToken;
  minWidth?: number | SpacingToken;
  minHeight?: number | SpacingToken;
  maxHeight?: number | SpacingToken;
  fit?: boolean;
  fitWidth?: boolean;
  fitHeight?: boolean;
  fill?: boolean;
  fillWidth?: boolean;
  fillHeight?: boolean;
  aspectRatio?: CSSProperties["aspectRatio"];
}
export interface SpacingProps extends HTMLAttributes<HTMLDivElement> {
  padding?: SpacingToken;
  paddingLeft?: SpacingToken;
  paddingRight?: SpacingToken;
  paddingTop?: SpacingToken;
  paddingBottom?: SpacingToken;
  paddingX?: SpacingToken;
  paddingY?: SpacingToken;
  margin?: SpacingToken;
  marginLeft?: SpacingToken;
  marginRight?: SpacingToken;
  marginTop?: SpacingToken;
  marginBottom?: SpacingToken;
  marginX?: SpacingToken;
  marginY?: SpacingToken;
  gap?: SpacingToken | "-1";
  top?: SpacingToken;
  right?: SpacingToken;
  bottom?: SpacingToken;
  left?: SpacingToken;
}
export interface StyleProps extends HTMLAttributes<HTMLDivElement> {
  textVariant?: TextVariant;
  textSize?: TextSize;
  textType?: TextType;
  textWeight?: TextWeight;
  background?:
    | `${ColorScheme}-${ColorWeight}`
    | `${ColorScheme}-alpha-${ColorWeight}`
    | "surface"
    | "overlay"
    | "page"
    | "transparent";
  solid?: `${ColorScheme}-${ColorWeight}`;
  borderTop?:
    | `${ColorScheme}-${ColorWeight}`
    | `${ColorScheme}-alpha-${ColorWeight}`
    | "surface"
    | "transparent";
  borderRight?:
    | `${ColorScheme}-${ColorWeight}`
    | `${ColorScheme}-alpha-${ColorWeight}`
    | "surface"
    | "transparent";
  borderBottom?:
    | `${ColorScheme}-${ColorWeight}`
    | `${ColorScheme}-alpha-${ColorWeight}`
    | "surface"
    | "transparent";
  borderLeft?:
    | `${ColorScheme}-${ColorWeight}`
    | `${ColorScheme}-alpha-${ColorWeight}`
    | "surface"
    | "transparent";
  border?:
    | `${ColorScheme}-${ColorWeight}`
    | `${ColorScheme}-alpha-${ColorWeight}`
    | "surface"
    | "transparent";
  borderStyle?: "solid" | "dashed";
  borderWidth?: 1 | 2;
  topRadius?: RadiusSize;
  rightRadius?: RadiusSize;
  bottomRadius?: RadiusSize;
  leftRadius?: RadiusSize;
  topLeftRadius?: RadiusSize;
  topRightRadius?: RadiusSize;
  bottomLeftRadius?: RadiusSize;
  bottomRightRadius?: RadiusSize;
  radius?: RadiusSize | `${RadiusSize}-${RadiusNest}`;
  shadow?: ShadowSize;
  cursor?: CSSProperties["cursor"] | "interactive";
}
export interface ConditionalProps extends HTMLAttributes<HTMLDivElement> {
  hide?: "s" | "m" | "l";
  show?: "s" | "m" | "l";
}
export interface DisplayProps extends HTMLAttributes<HTMLDivElement> {
  as?: ElementType;
  inline?: boolean;
  pointerEvents?: "none" | "all" | "auto";
  position?: CSSProperties["position"];
  overflow?: CSSProperties["overflow"];
  overflowX?: CSSProperties["overflowX"];
  overflowY?: CSSProperties["overflowY"];
  transition?:
    | "micro-short"
    | "micro-medium"
    | "micro-long"
    | "macro-short"
    | "macro-medium"
    | "macro-long";
  opacity?: opacity;
  zIndex?: -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
  dark?: boolean;
  light?: boolean;
}
export interface CommonProps extends HTMLAttributes<HTMLDivElement> {
  onBackground?: `${ColorScheme}-${ColorWeight}`;
  onSolid?: `${ColorScheme}-${ColorWeight}`;
  align?: CSSProperties["textAlign"];
  className?: string;
  children?: ReactNode;
  style?: React.CSSProperties;
}
</file>

<file path="README.md">
# Once UI for Next.js

A design system for indie builders who move fast and break limits without neglecting quality. Once UI combines the simplicity of low-code with the power of code: write 70% less compared to shadcn + tailwind.


![Once UI](public/images/og/home.jpg)

## Features

Start building your Next.js app in minutes.

* **Customization**: Manage design config in a single file.
* **Components**: Access advanced components with simple APIs.
* **Data-viz**: Add responsive charts with a few lines of code.
* **SEO**: Use our SEO components to simplify meta and schema setup.
* **PRO**: Launch ready-made apps without minimal coding with Once UI Pro.

[Get Once UI Pro](https://once-ui.com/pricing)

## Demo

Check the [starter demo app](https://demo.once-ui.com).

![Once UI](public/images/demo.jpg)

## Documentation

Learn how to build with Once UI at [docs.once-ui.com](https://docs.once-ui.com/once-ui/quick-start).

## Quick start

[Magic Portfolio](https://once-ui.com/products/magic-portfolio): Our free portfolio starter used and loved by thousands of creatives. Simple, customizable, responsive.

[Magic Store](https://once-ui.com/products/magic-store) (PRO): Our premium ecommerce storefront that lets you launch your merch store in minutes. Payment, production and shipping managed by Fourthwall.

[Magic Docs](https://once-ui.com/products/magic-docs) (PRO): Our premium documentation generator. Just add your MDX files and let Magic Docs handle the rest.

[Magic Bio](https://once-ui.com/products/magic-bio) (PRO): Our premium link-in-bio template that automatically fetches open-graph data. Just add your links and deploy.

[Once UI Blocks](https://once-ui.com/blocks) (PRO): Copy-paste pre-designed blocks and deploy fully-functional sites with lightning speed.

[Once UI for Figma](https://once-ui.com/figma) (PRO): Design and prototype entire products from scratch in hours.

## Get started

Clone the starter template from GitHub:
```bash
git clone https://github.com/once-ui-system/nextjs-starter.git
```

Deploy to Vercel with a single click:
[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fonce-ui-system%2Fnextjs-starter&redirect-url=https%3A%2F%2Fonce-ui.com%2F)

## Creators

Connect with us!

**Lorant One**: [Site](https://lorant.one) / [Threads](https://www.threads.net/@lorant.one) / [LinkedIn](https://www.linkedin.com/in/lorant-one/)

**Zsofia Komaromi**: [Site](https://zsofia.pro) / [Threads](https://www.threads.net/@zsofia_kom) / [LinkedIn](https://www.linkedin.com/in/zsofiakomaromi/)

## Become a Oncer

![Design Engineers Club](https://docs.once-ui.com/images/docs/vibe-coding-dark.jpg)

Join the [Design Engineers Club](https://discord.com/invite/5EyAQ4eNdS) on Discord to connect with us and share your projects.

Found a bug? Report it [here](https://github.com/once-ui-system/nextjs-starter/issues/new?labels=bug&template=bug_report.md). Got a feature request? Submit it [here](https://github.com/once-ui-system/nextjs-starter/issues/new?labels=feature%20request&template=feature_request.md).

## Sponsors

Once UI is an indie project. [Sponsor us](https://github.com/sponsors/once-ui-system) and get featured on our site!

## License

Distributed under the MIT License. See `LICENSE.txt` for more information.
</file>

<file path="src/once-ui/components/Background.tsx">
"use client";
import React, { forwardRef, useEffect, useRef } from "react";
import { Flex, Mask, MaskProps } from ".";
import styles from "./Background.module.scss";
import classNames from "classnames";
import { DisplayProps } from "../interfaces";
import { SpacingToken } from "../types";
function setRef<T>(ref: React.Ref<T> | undefined, value: T | null) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref && "current" in ref) {
    (ref as React.RefObject<T | null>).current = value;
  }
}
interface GradientProps {
  display?: boolean;
  opacity?: DisplayProps["opacity"];
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  tilt?: number;
  colorStart?: string;
  colorEnd?: string;
}
interface DotsProps {
  display?: boolean;
  opacity?: DisplayProps["opacity"];
  color?: string;
  size?: SpacingToken;
}
interface GridProps {
  display?: boolean;
  opacity?: DisplayProps["opacity"];
  color?: string;
  width?: string;
  height?: string;
}
interface LinesProps {
  display?: boolean;
  opacity?: DisplayProps["opacity"];
  size?: SpacingToken;
  thickness?: number;
  angle?: number;
  color?: string;
}
interface BackgroundProps extends React.ComponentProps<typeof Flex> {
  gradient?: GradientProps;
  dots?: DotsProps;
  grid?: GridProps;
  lines?: LinesProps;
  mask?: MaskProps;
  className?: string;
  style?: React.CSSProperties;
  children?: React.ReactNode;
}
const Background = forwardRef<HTMLDivElement, BackgroundProps>(
  (
    { gradient = {}, dots = {}, grid = {}, lines = {}, mask, children, className, style, ...rest },
    forwardedRef,
  ) => {
    const dotsColor = dots.color ?? "brand-on-background-weak";
    const dotsSize = "var(--static-space-" + (dots.size ?? "24") + ")";
    const backgroundRef = useRef<HTMLDivElement>(null);
    useEffect(() => {
      setRef(forwardedRef, backgroundRef.current);
    }, [forwardedRef]);
    const remap = (
      value: number,
      inputMin: number,
      inputMax: number,
      outputMin: number,
      outputMax: number,
    ) => {
      return ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;
    };
    const adjustedX = gradient.x != null ? remap(gradient.x, 0, 100, 37.5, 62.5) : 50;
    const adjustedY = gradient.y != null ? remap(gradient.y, 0, 100, 37.5, 62.5) : 50;
    const renderContent = () => (
      <>
        {gradient.display && (
          <Flex
            position="absolute"
            className={styles.gradient}
            opacity={gradient.opacity}
            pointerEvents="none"
            style={{
              ["--gradient-position-x" as string]: `${adjustedX}%`,
              ["--gradient-position-y" as string]: `${adjustedY}%`,
              ["--gradient-width" as string]:
                gradient.width != null ? `${gradient.width / 4}%` : "25%",
              ["--gradient-height" as string]:
                gradient.height != null ? `${gradient.height / 4}%` : "25%",
              ["--gradient-tilt" as string]: gradient.tilt != null ? `${gradient.tilt}deg` : "0deg",
              ["--gradient-color-start" as string]: gradient.colorStart
                ? `var(--${gradient.colorStart})`
                : "var(--brand-solid-strong)",
              ["--gradient-color-end" as string]: gradient.colorEnd
                ? `var(--${gradient.colorEnd})`
                : "var(--brand-solid-weak)",
            }}
          />
        )}
        {dots.display && (
          <Flex
            position="absolute"
            top="0"
            left="0"
            fill
            pointerEvents="none"
            className={styles.dots}
            opacity={dots.opacity}
            style={
              {
                "--dots-color": `var(--${dotsColor})`,
                "--dots-size": dotsSize,
              } as React.CSSProperties
            }
          />
        )}
        {lines.display && (
          <Flex
            position="absolute"
            top="0"
            left="0"
            fill
            pointerEvents="none"
            className={styles.lines}
            opacity={lines.opacity}
            style={
              {
                "--lines-angle": `${lines.angle ?? -45}deg`,
                "--lines-color": `var(--${lines.color ?? "brand-on-background-weak"})`,
                "--lines-thickness": `${lines.thickness ?? 1}px`,
                "--lines-spacing": `var(--static-space-${lines.size ?? "8"})`,
                background: `
                repeating-linear-gradient(
                  var(--lines-angle),
                  var(--static-transparent),
                  var(--static-transparent) calc(var(--lines-spacing) - var(--lines-thickness)),
                  var(--lines-color) calc(var(--lines-spacing) - var(--lines-thickness)),
                  var(--lines-color) var(--lines-spacing)
                )
              `,
              } as React.CSSProperties
            }
          />
        )}
        {grid.display && (
          <Flex
            position="absolute"
            top="0"
            left="0"
            fill
            pointerEvents="none"
            opacity={grid.opacity}
            style={{
              backgroundImage: `linear-gradient(to right, var(--${grid.color ?? "brand-on-background-weak"}) 1px, transparent 1px), linear-gradient(to bottom, var(--${grid.color ?? "brand-on-background-weak"}) 1px, transparent 1px)`,
              backgroundSize: `${grid.width ?? "80px"} ${grid.height ?? "80px"}`,
            }}
          />
        )}
        {children}
      </>
    );
    return (
      <Flex
        ref={backgroundRef}
        fill
        className={classNames(className)}
        zIndex={0}
        overflow="hidden"
        style={style}
        {...rest}
      >
        {mask ? (
          <Mask
            fill
            position="absolute"
            cursor={mask.cursor}
            radius={mask.radius}
            x={mask.x}
            y={mask.y}
          >
            {renderContent()}
          </Mask>
        ) : (
          renderContent()
        )}
      </Flex>
    );
  },
);
Background.displayName = "Background";
export { Background };
</file>

<file path="src/once-ui/components/index.ts">
export * from "./Accordion";
export * from "./AccordionGroup";
export * from "./Arrow";
export * from "./AutoScroll";
export * from "./Avatar";
export * from "./AvatarGroup";
export * from "./Badge";
export * from "./Banner";
export * from "./Background";
export * from "./Button";
export * from "./Carousel";
export * from "./Card";
export * from "./CursorCard";
export * from "./Column";
export * from "./Checkbox";
export * from "./Chip";
export * from "./ColorInput";
export * from "./CompareImage";
export * from "./DateInput";
export * from "./DatePicker";
export * from "./DateRangeInput";
export * from "./DateRangePicker";
export * from "./Dialog";
export * from "./Dropdown";
export * from "./DropdownWrapper";
export * from "./ElementType";
export * from "./Fade";
export * from "./Feedback";
export * from "./Flex";
export * from "./FlipFx";
export * from "./GlitchFx";
export * from "./Grid";
export * from "./Heading";
export * from "./HoloFx";
export * from "./Icon";
export * from "./IconButton";
export * from "./InfiniteScroll";
export * from "./InlineCode";
export * from "./Input";
export * from "./InteractiveDetails";
export * from "./Kbd";
export * from "./LetterFx";
export * from "./Line";
export * from "./Logo";
export * from "./LogoCloud";
export * from "./Mask";
export * from "./Media";
export * from "./NavIcon";
export * from "./NumberInput";
export * from "./OgCard";
export * from "./Option";
export * from "./OTPInput";
export * from "./Particle";
export * from "./PasswordInput";
export * from "./RadioButton";
export * from "./RevealFx";
export * from "./Row";
export * from "./Scroller";
export * from "./ScrollToTop";
export * from "./SegmentedControl";
export * from "./Select";
export * from "./Skeleton";
export * from "./SmartLink";
export * from "./Spinner";
export * from "./StatusIndicator";
export * from "./StylePanel";
export * from "./StyleOverlay";
export * from "./Switch";
export * from "./Table";
export * from "./Tag";
export * from "./TagInput";
export * from "./Text";
export * from "./Textarea";
export * from "./TiltFx";
export * from "./Toast";
export * from "./Toaster";
export * from "./ToastProvider";
export * from "./ToggleButton";
export * from "./Tooltip";
export * from "./ThemeSwitcher";
export * from "./ThemeProvider";
export * from "./User";
export * from "./UserMenu";
</file>

<file path="src/once-ui/modules/code/CodeBlock.tsx">
"use client";
import React, { useState, useEffect, useRef, ReactNode } from "react";
import "./CodeHighlight.css";
import "./LineNumber.css";
import styles from "./CodeBlock.module.scss";
import { Flex, Button, IconButton, Scroller, Row, StyleOverlay } from "@/once-ui/components";
import Prism from "prismjs";
import "prismjs/plugins/line-highlight/prism-line-highlight";
import "prismjs/plugins/line-numbers/prism-line-numbers";
import "prismjs/components/prism-jsx";
import "prismjs/components/prism-css";
import "prismjs/components/prism-typescript";
import "prismjs/components/prism-tsx";
import classNames from "classnames";
import { SpacingToken } from "@/once-ui/types";
type CodeInstance = {
  code: string | { content: string; error: string | null };
  language: string;
  label: string;
};
interface CodeBlockProps extends React.ComponentProps<typeof Flex> {
  highlight?: string;
  codeHeight?: number;
  fillHeight?: boolean;
  previewPadding?: SpacingToken;
  codes?: CodeInstance[];
  preview?: ReactNode;
  copyButton?: boolean;
  styleButton?: boolean;
  reloadButton?: boolean;
  fullscreenButton?: boolean;
  compact?: boolean;
  className?: string;
  style?: React.CSSProperties;
  onInstanceChange?: (index: number) => void;
  lineNumbers?: boolean;
}
const CodeBlock: React.FC<CodeBlockProps> = ({
  highlight,
  codeHeight,
  fillHeight,
  previewPadding = "l",
  codes = [],
  preview,
  copyButton = true,
  styleButton = false,
  reloadButton = false,
  fullscreenButton = false,
  lineNumbers = false,
  compact = false,
  className,
  style,
  onInstanceChange,
  ...rest
}) => {
  const codeRef = useRef<HTMLElement>(null);
  const preRef = useRef<HTMLPreElement>(null);
  const [selectedInstance, setSelectedInstance] = useState(0);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const { code, language, label } = codes[selectedInstance] || {
    code: "",
    language: "",
    label: "Select code",
  };
  useEffect(() => {
    if (codeRef.current && codes.length > 0) {
      Prism.highlightAll();
    }
  }, [code, codes.length]);
  useEffect(() => {
    if (isFullscreen) {
      document.body.style.overflow = "hidden";
      const handleEscKey = (event: KeyboardEvent) => {
        if (event.key === "Escape") {
          setIsFullscreen(false);
        }
      };
      document.addEventListener("keydown", handleEscKey);
      return () => {
        document.body.style.overflow = "";
        document.removeEventListener("keydown", handleEscKey);
      };
    } else {
      document.body.style.overflow = "";
    }
    return () => {
      document.body.style.overflow = "";
    };
  }, [isFullscreen]);
  const [copyIcon, setCopyIcon] = useState<string>("clipboard");
  const handleCopy = () => {
    if (codes.length > 0 && code) {
      navigator.clipboard
        .writeText(typeof code === "string" ? code : code.content)
        .then(() => {
          setCopyIcon("check");
          setTimeout(() => {
            setCopyIcon("clipboard");
          }, 5000);
        })
        .catch((err) => {
          console.error("Failed to copy code: ", err);
        });
    }
  };
  const [refreshKey, setRefreshKey] = useState(0);
  const handleRefresh = () => {
    setRefreshKey((prev) => prev + 1);
  };
  const handleContent = (selectedLabel: string) => {
    const index = codes.findIndex((instance) => instance.label === selectedLabel);
    if (index !== -1) {
      setSelectedInstance(index);
    }
  };
  const toggleFullscreen = () => {
    setIsFullscreen((prev) => !prev);
  };
  return (
    <Flex
      position={isFullscreen ? "fixed" : "relative"}
      zIndex={0}
      background="surface"
      radius="l"
      overflow="hidden"
      border="neutral-medium"
      direction="column"
      vertical="center"
      fillWidth
      minHeight={3}
      className={classNames(className, {
        [styles.fullscreen]: isFullscreen,
      })}
      style={style}
      {...rest}
    >
      {(codes.length > 1 || (copyButton && !compact)) && (
        <Flex
          borderBottom="neutral-medium"
          zIndex={2}
          position="static"
          fillWidth
          horizontal="space-between"
          gap="16"
        >
          {codes.length > 1 ? (
            <Scroller paddingX="4">
              {codes.map((instance, index) => (
                <Row paddingY="4" paddingRight="2" key={index}>
                  <Button
                    className="mr-2"
                    weight="default"
                    size="s"
                    variant={selectedInstance === index ? "secondary" : "tertiary"}
                    label={instance.label}
                    onClick={() => {
                      setSelectedInstance(index);
                      onInstanceChange?.(index);
                      handleContent(instance.label);
                    }}
                  />
                </Row>
              ))}
            </Scroller>
          ) : (
            <Row
              paddingY="12"
              paddingX="16"
              textVariant="label-default-s"
              onBackground="neutral-strong"
            >
              {codes[0].label}
            </Row>
          )}
          {!compact && (
            <Flex padding="4" gap="2" position="static">
              {reloadButton && (
                <IconButton
                  size="m"
                  tooltip="Reload"
                  tooltipPosition="left"
                  variant="tertiary"
                  onClick={handleRefresh}
                  icon="refresh"
                />
              )}
              {fullscreenButton && (
                <IconButton
                  size="m"
                  tooltip={isFullscreen ? "Exit fullscreen" : "Fullscreen"}
                  tooltipPosition="left"
                  variant="tertiary"
                  icon={isFullscreen ? "minimize" : "maximize"}
                  onClick={toggleFullscreen}
                />
              )}
              {styleButton && (
                <StyleOverlay>
                  <IconButton variant="tertiary" icon="sparkle" />
                </StyleOverlay>
              )}
              {copyButton && (
                <IconButton
                  size="m"
                  tooltip="Copy"
                  tooltipPosition="left"
                  variant="tertiary"
                  onClick={handleCopy}
                  icon={copyIcon}
                />
              )}
            </Flex>
          )}
        </Flex>
      )}
      {preview && (
        <Flex
          style={{
            isolation: "isolate",
          }}
          key={refreshKey}
          padding={previewPadding}
          fillHeight
          horizontal="center"
          overflowY="auto"
        >
          {Array.isArray(preview)
            ? preview.map((item, index) => <React.Fragment key={index}>{item}</React.Fragment>)
            : preview}
        </Flex>
      )}
      {codes.length > 0 && code && (
        <Flex
          borderTop={!compact && preview ? "neutral-medium" : undefined}
          fillWidth
          fillHeight={fillHeight}
        >
          <Flex overflowX="auto" fillWidth>
            <pre
              style={{ maxHeight: `${codeHeight}rem` }}
              data-line={highlight}
              ref={preRef}
              className={classNames(
                lineNumbers ? styles.lineNumberPadding : styles.padding,
                styles.pre,
                `language-${language}`,
                {
                  "line-numbers": lineNumbers,
                },
              )}
              tabIndex={-1}
            >
              <code ref={codeRef} className={classNames(styles.code, `language-${language}`)}>
                {typeof code === "string" ? code : code.content}
              </code>
            </pre>
          </Flex>
          {compact && copyButton && (
            <Flex position="absolute" right="8" top="8" className={styles.compactCopy} zIndex={1}>
              <IconButton
                tooltip="Copy"
                tooltipPosition="left"
                aria-label="Copy code"
                onClick={handleCopy}
                icon={copyIcon}
                size="m"
                variant="tertiary"
              />
            </Flex>
          )}
        </Flex>
      )}
    </Flex>
  );
};
CodeBlock.displayName = "CodeBlock";
export { CodeBlock };
</file>

<file path="src/app/page.tsx">
import {
  Heading,
  Text,
  Button,
  Column,
  Badge,
  Logo,
  Line,
  LetterFx,
} from "@/once-ui/components";
export default function Home() {
  return (
    <Column fill center padding="l">
      <Column maxWidth="s" horizontal="center" gap="l" align="center">
        <Badge
          textVariant="code-default-s"
          border="neutral-alpha-medium"
          onBackground="neutral-medium"
          vertical="center"
          gap="16"
        >
          <Logo icon={false} href="https://once-ui.com" size="xs" />
          <Line vert background="neutral-alpha-strong" />
          <Text marginX="4">
            <LetterFx trigger="instant">An ecosystem, not a UI kit</LetterFx>
          </Text>
        </Badge>
        <Heading variant="display-strong-xl" marginTop="24">
          Presence that doesn't beg for attention
        </Heading>
        <Text
          variant="heading-default-xl"
          onBackground="neutral-weak"
          wrap="balance"
          marginBottom="16"
        >
          Build with clarity, speed, and quiet confidence
        </Text>
        <Button
          id="docs"
          href="https://docs.once-ui.com/once-ui/quick-start"
          data-border="rounded"
          weight="default"
          prefixIcon="copy"
          arrowIcon
        >
          Explore docs
        </Button>
      </Column>
    </Column>
  );
}
</file>

</files>
